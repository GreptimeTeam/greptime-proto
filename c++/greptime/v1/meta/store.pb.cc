// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/store.proto

#include "greptime/v1/meta/store.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace greptime {
namespace v1 {
namespace meta {
PROTOBUF_CONSTEXPR RangeRequest::RangeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.range_end_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.limit_)*/int64_t{0}
  , /*decltype(_impl_.keys_only_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RangeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeRequestDefaultTypeInternal() {}
  union {
    RangeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeRequestDefaultTypeInternal _RangeRequest_default_instance_;
PROTOBUF_CONSTEXPR RangeResponse::RangeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.more_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RangeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeResponseDefaultTypeInternal() {}
  union {
    RangeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeResponseDefaultTypeInternal _RangeResponse_default_instance_;
PROTOBUF_CONSTEXPR PutRequest::PutRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PutRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PutRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PutRequestDefaultTypeInternal() {}
  union {
    PutRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PutRequestDefaultTypeInternal _PutRequest_default_instance_;
PROTOBUF_CONSTEXPR PutResponse::PutResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PutResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PutResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PutResponseDefaultTypeInternal() {}
  union {
    PutResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PutResponseDefaultTypeInternal _PutResponse_default_instance_;
PROTOBUF_CONSTEXPR BatchGetRequest::BatchGetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchGetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchGetRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchGetRequestDefaultTypeInternal() {}
  union {
    BatchGetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchGetRequestDefaultTypeInternal _BatchGetRequest_default_instance_;
PROTOBUF_CONSTEXPR BatchGetResponse::BatchGetResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchGetResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchGetResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchGetResponseDefaultTypeInternal() {}
  union {
    BatchGetResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchGetResponseDefaultTypeInternal _BatchGetResponse_default_instance_;
PROTOBUF_CONSTEXPR BatchPutRequest::BatchPutRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchPutRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchPutRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchPutRequestDefaultTypeInternal() {}
  union {
    BatchPutRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchPutRequestDefaultTypeInternal _BatchPutRequest_default_instance_;
PROTOBUF_CONSTEXPR BatchPutResponse::BatchPutResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prev_kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchPutResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchPutResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchPutResponseDefaultTypeInternal() {}
  union {
    BatchPutResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchPutResponseDefaultTypeInternal _BatchPutResponse_default_instance_;
PROTOBUF_CONSTEXPR BatchDeleteRequest::BatchDeleteRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchDeleteRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchDeleteRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchDeleteRequestDefaultTypeInternal() {}
  union {
    BatchDeleteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchDeleteRequestDefaultTypeInternal _BatchDeleteRequest_default_instance_;
PROTOBUF_CONSTEXPR BatchDeleteResponse::BatchDeleteResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prev_kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BatchDeleteResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BatchDeleteResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BatchDeleteResponseDefaultTypeInternal() {}
  union {
    BatchDeleteResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatchDeleteResponseDefaultTypeInternal _BatchDeleteResponse_default_instance_;
PROTOBUF_CONSTEXPR CompareAndPutRequest::CompareAndPutRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expect_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CompareAndPutRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompareAndPutRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompareAndPutRequestDefaultTypeInternal() {}
  union {
    CompareAndPutRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompareAndPutRequestDefaultTypeInternal _CompareAndPutRequest_default_instance_;
PROTOBUF_CONSTEXPR CompareAndPutResponse::CompareAndPutResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/nullptr
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CompareAndPutResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompareAndPutResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompareAndPutResponseDefaultTypeInternal() {}
  union {
    CompareAndPutResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompareAndPutResponseDefaultTypeInternal _CompareAndPutResponse_default_instance_;
PROTOBUF_CONSTEXPR DeleteRangeRequest::DeleteRangeRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.range_end_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.prev_kv_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteRangeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteRangeRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteRangeRequestDefaultTypeInternal() {}
  union {
    DeleteRangeRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteRangeResponse::DeleteRangeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.prev_kvs_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.deleted_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteRangeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteRangeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteRangeResponseDefaultTypeInternal() {}
  union {
    DeleteRangeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
PROTOBUF_CONSTEXPR MoveValueRequest::MoveValueRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.to_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveValueRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveValueRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveValueRequestDefaultTypeInternal() {}
  union {
    MoveValueRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveValueRequestDefaultTypeInternal _MoveValueRequest_default_instance_;
PROTOBUF_CONSTEXPR MoveValueResponse::MoveValueResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.kv_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveValueResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveValueResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveValueResponseDefaultTypeInternal() {}
  union {
    MoveValueResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveValueResponseDefaultTypeInternal _MoveValueResponse_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
static ::_pb::Metadata file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[16];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_greptime_2fv1_2fmeta_2fstore_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_greptime_2fv1_2fmeta_2fstore_2eproto = nullptr;

const uint32_t TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeRequest, _impl_.range_end_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeRequest, _impl_.limit_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeRequest, _impl_.keys_only_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeResponse, _impl_.kvs_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::RangeResponse, _impl_.more_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutRequest, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutRequest, _impl_.prev_kv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::PutResponse, _impl_.prev_kv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchGetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchGetRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchGetRequest, _impl_.keys_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchGetResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchGetResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchGetResponse, _impl_.kvs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutRequest, _impl_.kvs_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutRequest, _impl_.prev_kv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchPutResponse, _impl_.prev_kvs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteRequest, _impl_.keys_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteRequest, _impl_.prev_kv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::BatchDeleteResponse, _impl_.prev_kvs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutRequest, _impl_.expect_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutRequest, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutResponse, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::CompareAndPutResponse, _impl_.prev_kv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeRequest, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeRequest, _impl_.range_end_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeRequest, _impl_.prev_kv_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeResponse, _impl_.deleted_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::DeleteRangeResponse, _impl_.prev_kvs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueRequest, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueRequest, _impl_.from_key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueRequest, _impl_.to_key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::meta::MoveValueResponse, _impl_.kv_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::greptime::v1::meta::RangeRequest)},
  { 11, -1, -1, sizeof(::greptime::v1::meta::RangeResponse)},
  { 20, -1, -1, sizeof(::greptime::v1::meta::PutRequest)},
  { 30, -1, -1, sizeof(::greptime::v1::meta::PutResponse)},
  { 38, -1, -1, sizeof(::greptime::v1::meta::BatchGetRequest)},
  { 46, -1, -1, sizeof(::greptime::v1::meta::BatchGetResponse)},
  { 54, -1, -1, sizeof(::greptime::v1::meta::BatchPutRequest)},
  { 63, -1, -1, sizeof(::greptime::v1::meta::BatchPutResponse)},
  { 71, -1, -1, sizeof(::greptime::v1::meta::BatchDeleteRequest)},
  { 80, -1, -1, sizeof(::greptime::v1::meta::BatchDeleteResponse)},
  { 88, -1, -1, sizeof(::greptime::v1::meta::CompareAndPutRequest)},
  { 98, -1, -1, sizeof(::greptime::v1::meta::CompareAndPutResponse)},
  { 107, -1, -1, sizeof(::greptime::v1::meta::DeleteRangeRequest)},
  { 117, -1, -1, sizeof(::greptime::v1::meta::DeleteRangeResponse)},
  { 126, -1, -1, sizeof(::greptime::v1::meta::MoveValueRequest)},
  { 135, -1, -1, sizeof(::greptime::v1::meta::MoveValueResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::greptime::v1::meta::_RangeRequest_default_instance_._instance,
  &::greptime::v1::meta::_RangeResponse_default_instance_._instance,
  &::greptime::v1::meta::_PutRequest_default_instance_._instance,
  &::greptime::v1::meta::_PutResponse_default_instance_._instance,
  &::greptime::v1::meta::_BatchGetRequest_default_instance_._instance,
  &::greptime::v1::meta::_BatchGetResponse_default_instance_._instance,
  &::greptime::v1::meta::_BatchPutRequest_default_instance_._instance,
  &::greptime::v1::meta::_BatchPutResponse_default_instance_._instance,
  &::greptime::v1::meta::_BatchDeleteRequest_default_instance_._instance,
  &::greptime::v1::meta::_BatchDeleteResponse_default_instance_._instance,
  &::greptime::v1::meta::_CompareAndPutRequest_default_instance_._instance,
  &::greptime::v1::meta::_CompareAndPutResponse_default_instance_._instance,
  &::greptime::v1::meta::_DeleteRangeRequest_default_instance_._instance,
  &::greptime::v1::meta::_DeleteRangeResponse_default_instance_._instance,
  &::greptime::v1::meta::_MoveValueRequest_default_instance_._instance,
  &::greptime::v1::meta::_MoveValueResponse_default_instance_._instance,
};

const char descriptor_table_protodef_greptime_2fv1_2fmeta_2fstore_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\034greptime/v1/meta/store.proto\022\020greptime"
  ".v1.meta\032\035greptime/v1/meta/common.proto\""
  "\201\001\n\014RangeRequest\022/\n\006header\030\001 \001(\0132\037.grept"
  "ime.v1.meta.RequestHeader\022\013\n\003key\030\002 \001(\014\022\021"
  "\n\trange_end\030\003 \001(\014\022\r\n\005limit\030\004 \001(\003\022\021\n\tkeys"
  "_only\030\005 \001(\010\"x\n\rRangeResponse\0220\n\006header\030\001"
  " \001(\0132 .greptime.v1.meta.ResponseHeader\022\'"
  "\n\003kvs\030\002 \003(\0132\032.greptime.v1.meta.KeyValue\022"
  "\014\n\004more\030\003 \001(\010\"j\n\nPutRequest\022/\n\006header\030\001 "
  "\001(\0132\037.greptime.v1.meta.RequestHeader\022\013\n\003"
  "key\030\002 \001(\014\022\r\n\005value\030\003 \001(\014\022\017\n\007prev_kv\030\004 \001("
  "\010\"l\n\013PutResponse\0220\n\006header\030\001 \001(\0132 .grept"
  "ime.v1.meta.ResponseHeader\022+\n\007prev_kv\030\002 "
  "\001(\0132\032.greptime.v1.meta.KeyValue\"P\n\017Batch"
  "GetRequest\022/\n\006header\030\001 \001(\0132\037.greptime.v1"
  ".meta.RequestHeader\022\014\n\004keys\030\002 \003(\014\"m\n\020Bat"
  "chGetResponse\0220\n\006header\030\001 \001(\0132 .greptime"
  ".v1.meta.ResponseHeader\022\'\n\003kvs\030\002 \003(\0132\032.g"
  "reptime.v1.meta.KeyValue\"|\n\017BatchPutRequ"
  "est\022/\n\006header\030\001 \001(\0132\037.greptime.v1.meta.R"
  "equestHeader\022\'\n\003kvs\030\002 \003(\0132\032.greptime.v1."
  "meta.KeyValue\022\017\n\007prev_kv\030\003 \001(\010\"r\n\020BatchP"
  "utResponse\0220\n\006header\030\001 \001(\0132 .greptime.v1"
  ".meta.ResponseHeader\022,\n\010prev_kvs\030\002 \003(\0132\032"
  ".greptime.v1.meta.KeyValue\"d\n\022BatchDelet"
  "eRequest\022/\n\006header\030\001 \001(\0132\037.greptime.v1.m"
  "eta.RequestHeader\022\014\n\004keys\030\002 \003(\014\022\017\n\007prev_"
  "kv\030\003 \001(\010\"u\n\023BatchDeleteResponse\0220\n\006heade"
  "r\030\001 \001(\0132 .greptime.v1.meta.ResponseHeade"
  "r\022,\n\010prev_kvs\030\002 \003(\0132\032.greptime.v1.meta.K"
  "eyValue\"s\n\024CompareAndPutRequest\022/\n\006heade"
  "r\030\001 \001(\0132\037.greptime.v1.meta.RequestHeader"
  "\022\013\n\003key\030\002 \001(\014\022\016\n\006expect\030\003 \001(\014\022\r\n\005value\030\004"
  " \001(\014\"\207\001\n\025CompareAndPutResponse\0220\n\006header"
  "\030\001 \001(\0132 .greptime.v1.meta.ResponseHeader"
  "\022\017\n\007success\030\002 \001(\010\022+\n\007prev_kv\030\003 \001(\0132\032.gre"
  "ptime.v1.meta.KeyValue\"v\n\022DeleteRangeReq"
  "uest\022/\n\006header\030\001 \001(\0132\037.greptime.v1.meta."
  "RequestHeader\022\013\n\003key\030\002 \001(\014\022\021\n\trange_end\030"
  "\003 \001(\014\022\017\n\007prev_kv\030\004 \001(\010\"\206\001\n\023DeleteRangeRe"
  "sponse\0220\n\006header\030\001 \001(\0132 .greptime.v1.met"
  "a.ResponseHeader\022\017\n\007deleted\030\002 \001(\003\022,\n\010pre"
  "v_kvs\030\003 \003(\0132\032.greptime.v1.meta.KeyValue\""
  "e\n\020MoveValueRequest\022/\n\006header\030\001 \001(\0132\037.gr"
  "eptime.v1.meta.RequestHeader\022\020\n\010from_key"
  "\030\002 \001(\014\022\016\n\006to_key\030\003 \001(\014\"m\n\021MoveValueRespo"
  "nse\0220\n\006header\030\001 \001(\0132 .greptime.v1.meta.R"
  "esponseHeader\022&\n\002kv\030\002 \001(\0132\032.greptime.v1."
  "meta.KeyValue2\253\005\n\005Store\022H\n\005Range\022\036.grept"
  "ime.v1.meta.RangeRequest\032\037.greptime.v1.m"
  "eta.RangeResponse\022B\n\003Put\022\034.greptime.v1.m"
  "eta.PutRequest\032\035.greptime.v1.meta.PutRes"
  "ponse\022Q\n\010BatchGet\022!.greptime.v1.meta.Bat"
  "chGetRequest\032\".greptime.v1.meta.BatchGet"
  "Response\022Q\n\010BatchPut\022!.greptime.v1.meta."
  "BatchPutRequest\032\".greptime.v1.meta.Batch"
  "PutResponse\022Z\n\013BatchDelete\022$.greptime.v1"
  ".meta.BatchDeleteRequest\032%.greptime.v1.m"
  "eta.BatchDeleteResponse\022`\n\rCompareAndPut"
  "\022&.greptime.v1.meta.CompareAndPutRequest"
  "\032\'.greptime.v1.meta.CompareAndPutRespons"
  "e\022Z\n\013DeleteRange\022$.greptime.v1.meta.Dele"
  "teRangeRequest\032%.greptime.v1.meta.Delete"
  "RangeResponse\022T\n\tMoveValue\022\".greptime.v1"
  ".meta.MoveValueRequest\032#.greptime.v1.met"
  "a.MoveValueResponseB<Z:github.com/Grepti"
  "meTeam/greptime-proto/go/greptime/v1/met"
  "ab\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_deps[1] = {
  &::descriptor_table_greptime_2fv1_2fmeta_2fcommon_2eproto,
};
static ::_pbi::once_flag descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto = {
    false, false, 2689, descriptor_table_protodef_greptime_2fv1_2fmeta_2fstore_2eproto,
    "greptime/v1/meta/store.proto",
    &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once, descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_deps, 1, 16,
    schemas, file_default_instances, TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto::offsets,
    file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto, file_level_enum_descriptors_greptime_2fv1_2fmeta_2fstore_2eproto,
    file_level_service_descriptors_greptime_2fv1_2fmeta_2fstore_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter() {
  return &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_greptime_2fv1_2fmeta_2fstore_2eproto(&descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto);
namespace greptime {
namespace v1 {
namespace meta {

// ===================================================================

class RangeRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const RangeRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
RangeRequest::_Internal::header(const RangeRequest* msg) {
  return *msg->_impl_.header_;
}
void RangeRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
RangeRequest::RangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.RangeRequest)
}
RangeRequest::RangeRequest(const RangeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.range_end_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.limit_){}
    , decltype(_impl_.keys_only_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  ::memcpy(&_impl_.limit_, &from._impl_.limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.keys_only_) -
    reinterpret_cast<char*>(&_impl_.limit_)) + sizeof(_impl_.keys_only_));
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.RangeRequest)
}

inline void RangeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.range_end_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.limit_){int64_t{0}}
    , decltype(_impl_.keys_only_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RangeRequest::~RangeRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.RangeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RangeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.RangeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  ::memset(&_impl_.limit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.keys_only_) -
      reinterpret_cast<char*>(&_impl_.limit_)) + sizeof(_impl_.keys_only_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes range_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 limit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool keys_only = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.keys_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.RangeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // bytes range_end = 3;
  if (!this->_internal_range_end().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_range_end(), target);
  }

  // int64 limit = 4;
  if (this->_internal_limit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_limit(), target);
  }

  // bool keys_only = 5;
  if (this->_internal_keys_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_keys_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.RangeRequest)
  return target;
}

size_t RangeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.RangeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // bytes range_end = 3;
  if (!this->_internal_range_end().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_range_end());
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 limit = 4;
  if (this->_internal_limit() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_limit());
  }

  // bool keys_only = 5;
  if (this->_internal_keys_only() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeRequest::GetClassData() const { return &_class_data_; }


void RangeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangeRequest*>(&to_msg);
  auto& from = static_cast<const RangeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.RangeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_limit() != 0) {
    _this->_internal_set_limit(from._internal_limit());
  }
  if (from._internal_keys_only() != 0) {
    _this->_internal_set_keys_only(from._internal_keys_only());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeRequest::CopyFrom(const RangeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.RangeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeRequest::IsInitialized() const {
  return true;
}

void RangeRequest::InternalSwap(RangeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.range_end_, lhs_arena,
      &other->_impl_.range_end_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeRequest, _impl_.keys_only_)
      + sizeof(RangeRequest::_impl_.keys_only_)
      - PROTOBUF_FIELD_OFFSET(RangeRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[0]);
}

// ===================================================================

class RangeResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const RangeResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
RangeResponse::_Internal::header(const RangeResponse* msg) {
  return *msg->_impl_.header_;
}
void RangeResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void RangeResponse::clear_kvs() {
  _impl_.kvs_.Clear();
}
RangeResponse::RangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.RangeResponse)
}
RangeResponse::RangeResponse(const RangeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.kvs_){from._impl_.kvs_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.more_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.more_ = from._impl_.more_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.RangeResponse)
}

inline void RangeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.more_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RangeResponse::~RangeResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.RangeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.kvs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void RangeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.RangeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.kvs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.more_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.meta.KeyValue kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool more = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.more_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.RangeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool more = 3;
  if (this->_internal_more() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_more(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.RangeResponse)
  return target;
}

size_t RangeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.RangeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  total_size += 1UL * this->_internal_kvs_size();
  for (const auto& msg : this->_impl_.kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool more = 3;
  if (this->_internal_more() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeResponse::GetClassData() const { return &_class_data_; }


void RangeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangeResponse*>(&to_msg);
  auto& from = static_cast<const RangeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.RangeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.kvs_.MergeFrom(from._impl_.kvs_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_more() != 0) {
    _this->_internal_set_more(from._internal_more());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeResponse::CopyFrom(const RangeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.RangeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeResponse::IsInitialized() const {
  return true;
}

void RangeResponse::InternalSwap(RangeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.kvs_.InternalSwap(&other->_impl_.kvs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RangeResponse, _impl_.more_)
      + sizeof(RangeResponse::_impl_.more_)
      - PROTOBUF_FIELD_OFFSET(RangeResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[1]);
}

// ===================================================================

class PutRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const PutRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
PutRequest::_Internal::header(const PutRequest* msg) {
  return *msg->_impl_.header_;
}
void PutRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
PutRequest::PutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.PutRequest)
}
PutRequest::PutRequest(const PutRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PutRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  _this->_impl_.prev_kv_ = from._impl_.prev_kv_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.PutRequest)
}

inline void PutRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PutRequest::~PutRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.PutRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PutRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void PutRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PutRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.PutRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.prev_kv_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PutRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool prev_kv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PutRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.PutRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // bytes value = 3;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_value(), target);
  }

  // bool prev_kv = 4;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_prev_kv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.PutRequest)
  return target;
}

size_t PutRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.PutRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // bytes value = 3;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool prev_kv = 4;
  if (this->_internal_prev_kv() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PutRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PutRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PutRequest::GetClassData() const { return &_class_data_; }


void PutRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PutRequest*>(&to_msg);
  auto& from = static_cast<const PutRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.PutRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PutRequest::CopyFrom(const PutRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.PutRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutRequest::IsInitialized() const {
  return true;
}

void PutRequest::InternalSwap(PutRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PutRequest, _impl_.prev_kv_)
      + sizeof(PutRequest::_impl_.prev_kv_)
      - PROTOBUF_FIELD_OFFSET(PutRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PutRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[2]);
}

// ===================================================================

class PutResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const PutResponse* msg);
  static const ::greptime::v1::meta::KeyValue& prev_kv(const PutResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
PutResponse::_Internal::header(const PutResponse* msg) {
  return *msg->_impl_.header_;
}
const ::greptime::v1::meta::KeyValue&
PutResponse::_Internal::prev_kv(const PutResponse* msg) {
  return *msg->_impl_.prev_kv_;
}
void PutResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void PutResponse::clear_prev_kv() {
  if (GetArenaForAllocation() == nullptr && _impl_.prev_kv_ != nullptr) {
    delete _impl_.prev_kv_;
  }
  _impl_.prev_kv_ = nullptr;
}
PutResponse::PutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.PutResponse)
}
PutResponse::PutResponse(const PutResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PutResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_prev_kv()) {
    _this->_impl_.prev_kv_ = new ::greptime::v1::meta::KeyValue(*from._impl_.prev_kv_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.PutResponse)
}

inline void PutResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PutResponse::~PutResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.PutResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PutResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.prev_kv_;
}

void PutResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PutResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.PutResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.prev_kv_ != nullptr) {
    delete _impl_.prev_kv_;
  }
  _impl_.prev_kv_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PutResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.meta.KeyValue prev_kv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prev_kv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PutResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.PutResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.meta.KeyValue prev_kv = 2;
  if (this->_internal_has_prev_kv()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::prev_kv(this),
        _Internal::prev_kv(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.PutResponse)
  return target;
}

size_t PutResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.PutResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .greptime.v1.meta.KeyValue prev_kv = 2;
  if (this->_internal_has_prev_kv()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.prev_kv_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PutResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PutResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PutResponse::GetClassData() const { return &_class_data_; }


void PutResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PutResponse*>(&to_msg);
  auto& from = static_cast<const PutResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.PutResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_prev_kv()) {
    _this->_internal_mutable_prev_kv()->::greptime::v1::meta::KeyValue::MergeFrom(
        from._internal_prev_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PutResponse::CopyFrom(const PutResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.PutResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutResponse::IsInitialized() const {
  return true;
}

void PutResponse::InternalSwap(PutResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PutResponse, _impl_.prev_kv_)
      + sizeof(PutResponse::_impl_.prev_kv_)
      - PROTOBUF_FIELD_OFFSET(PutResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PutResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[3]);
}

// ===================================================================

class BatchGetRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const BatchGetRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
BatchGetRequest::_Internal::header(const BatchGetRequest* msg) {
  return *msg->_impl_.header_;
}
void BatchGetRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
BatchGetRequest::BatchGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.BatchGetRequest)
}
BatchGetRequest::BatchGetRequest(const BatchGetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchGetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.BatchGetRequest)
}

inline void BatchGetRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchGetRequest::~BatchGetRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.BatchGetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchGetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void BatchGetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchGetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.BatchGetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchGetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchGetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.BatchGetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated bytes keys = 2;
  for (int i = 0, n = this->_internal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_keys(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.BatchGetRequest)
  return target;
}

size_t BatchGetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.BatchGetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes keys = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keys_.size());
  for (int i = 0, n = _impl_.keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.keys_.Get(i));
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchGetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchGetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchGetRequest::GetClassData() const { return &_class_data_; }


void BatchGetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchGetRequest*>(&to_msg);
  auto& from = static_cast<const BatchGetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.BatchGetRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchGetRequest::CopyFrom(const BatchGetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.BatchGetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchGetRequest::IsInitialized() const {
  return true;
}

void BatchGetRequest::InternalSwap(BatchGetRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchGetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[4]);
}

// ===================================================================

class BatchGetResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const BatchGetResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
BatchGetResponse::_Internal::header(const BatchGetResponse* msg) {
  return *msg->_impl_.header_;
}
void BatchGetResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void BatchGetResponse::clear_kvs() {
  _impl_.kvs_.Clear();
}
BatchGetResponse::BatchGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.BatchGetResponse)
}
BatchGetResponse::BatchGetResponse(const BatchGetResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchGetResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.kvs_){from._impl_.kvs_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.BatchGetResponse)
}

inline void BatchGetResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchGetResponse::~BatchGetResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.BatchGetResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchGetResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.kvs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void BatchGetResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchGetResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.BatchGetResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.kvs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchGetResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.meta.KeyValue kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchGetResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.BatchGetResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.BatchGetResponse)
  return target;
}

size_t BatchGetResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.BatchGetResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  total_size += 1UL * this->_internal_kvs_size();
  for (const auto& msg : this->_impl_.kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchGetResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchGetResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchGetResponse::GetClassData() const { return &_class_data_; }


void BatchGetResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchGetResponse*>(&to_msg);
  auto& from = static_cast<const BatchGetResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.BatchGetResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.kvs_.MergeFrom(from._impl_.kvs_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchGetResponse::CopyFrom(const BatchGetResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.BatchGetResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchGetResponse::IsInitialized() const {
  return true;
}

void BatchGetResponse::InternalSwap(BatchGetResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.kvs_.InternalSwap(&other->_impl_.kvs_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchGetResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[5]);
}

// ===================================================================

class BatchPutRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const BatchPutRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
BatchPutRequest::_Internal::header(const BatchPutRequest* msg) {
  return *msg->_impl_.header_;
}
void BatchPutRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void BatchPutRequest::clear_kvs() {
  _impl_.kvs_.Clear();
}
BatchPutRequest::BatchPutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.BatchPutRequest)
}
BatchPutRequest::BatchPutRequest(const BatchPutRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchPutRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.kvs_){from._impl_.kvs_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  _this->_impl_.prev_kv_ = from._impl_.prev_kv_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.BatchPutRequest)
}

inline void BatchPutRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchPutRequest::~BatchPutRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.BatchPutRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchPutRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.kvs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void BatchPutRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchPutRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.BatchPutRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.kvs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.prev_kv_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchPutRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.meta.KeyValue kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool prev_kv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchPutRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.BatchPutRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool prev_kv = 3;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_prev_kv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.BatchPutRequest)
  return target;
}

size_t BatchPutRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.BatchPutRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  total_size += 1UL * this->_internal_kvs_size();
  for (const auto& msg : this->_impl_.kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool prev_kv = 3;
  if (this->_internal_prev_kv() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchPutRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchPutRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchPutRequest::GetClassData() const { return &_class_data_; }


void BatchPutRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchPutRequest*>(&to_msg);
  auto& from = static_cast<const BatchPutRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.BatchPutRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.kvs_.MergeFrom(from._impl_.kvs_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchPutRequest::CopyFrom(const BatchPutRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.BatchPutRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchPutRequest::IsInitialized() const {
  return true;
}

void BatchPutRequest::InternalSwap(BatchPutRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.kvs_.InternalSwap(&other->_impl_.kvs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchPutRequest, _impl_.prev_kv_)
      + sizeof(BatchPutRequest::_impl_.prev_kv_)
      - PROTOBUF_FIELD_OFFSET(BatchPutRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchPutRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[6]);
}

// ===================================================================

class BatchPutResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const BatchPutResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
BatchPutResponse::_Internal::header(const BatchPutResponse* msg) {
  return *msg->_impl_.header_;
}
void BatchPutResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void BatchPutResponse::clear_prev_kvs() {
  _impl_.prev_kvs_.Clear();
}
BatchPutResponse::BatchPutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.BatchPutResponse)
}
BatchPutResponse::BatchPutResponse(const BatchPutResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchPutResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prev_kvs_){from._impl_.prev_kvs_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.BatchPutResponse)
}

inline void BatchPutResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.prev_kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchPutResponse::~BatchPutResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.BatchPutResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchPutResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prev_kvs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void BatchPutResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchPutResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.BatchPutResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prev_kvs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchPutResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prev_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchPutResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.BatchPutResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prev_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_prev_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.BatchPutResponse)
  return target;
}

size_t BatchPutResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.BatchPutResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
  total_size += 1UL * this->_internal_prev_kvs_size();
  for (const auto& msg : this->_impl_.prev_kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchPutResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchPutResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchPutResponse::GetClassData() const { return &_class_data_; }


void BatchPutResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchPutResponse*>(&to_msg);
  auto& from = static_cast<const BatchPutResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.BatchPutResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prev_kvs_.MergeFrom(from._impl_.prev_kvs_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchPutResponse::CopyFrom(const BatchPutResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.BatchPutResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchPutResponse::IsInitialized() const {
  return true;
}

void BatchPutResponse::InternalSwap(BatchPutResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.prev_kvs_.InternalSwap(&other->_impl_.prev_kvs_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchPutResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[7]);
}

// ===================================================================

class BatchDeleteRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const BatchDeleteRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
BatchDeleteRequest::_Internal::header(const BatchDeleteRequest* msg) {
  return *msg->_impl_.header_;
}
void BatchDeleteRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
BatchDeleteRequest::BatchDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.BatchDeleteRequest)
}
BatchDeleteRequest::BatchDeleteRequest(const BatchDeleteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchDeleteRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  _this->_impl_.prev_kv_ = from._impl_.prev_kv_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.BatchDeleteRequest)
}

inline void BatchDeleteRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keys_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchDeleteRequest::~BatchDeleteRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.BatchDeleteRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchDeleteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void BatchDeleteRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchDeleteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.BatchDeleteRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.prev_kv_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchDeleteRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool prev_kv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchDeleteRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.BatchDeleteRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated bytes keys = 2;
  for (int i = 0, n = this->_internal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_keys(i);
    target = stream->WriteBytes(2, s, target);
  }

  // bool prev_kv = 3;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_prev_kv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.BatchDeleteRequest)
  return target;
}

size_t BatchDeleteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.BatchDeleteRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes keys = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keys_.size());
  for (int i = 0, n = _impl_.keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.keys_.Get(i));
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool prev_kv = 3;
  if (this->_internal_prev_kv() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchDeleteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchDeleteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchDeleteRequest::GetClassData() const { return &_class_data_; }


void BatchDeleteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchDeleteRequest*>(&to_msg);
  auto& from = static_cast<const BatchDeleteRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.BatchDeleteRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchDeleteRequest::CopyFrom(const BatchDeleteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.BatchDeleteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchDeleteRequest::IsInitialized() const {
  return true;
}

void BatchDeleteRequest::InternalSwap(BatchDeleteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchDeleteRequest, _impl_.prev_kv_)
      + sizeof(BatchDeleteRequest::_impl_.prev_kv_)
      - PROTOBUF_FIELD_OFFSET(BatchDeleteRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchDeleteRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[8]);
}

// ===================================================================

class BatchDeleteResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const BatchDeleteResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
BatchDeleteResponse::_Internal::header(const BatchDeleteResponse* msg) {
  return *msg->_impl_.header_;
}
void BatchDeleteResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void BatchDeleteResponse::clear_prev_kvs() {
  _impl_.prev_kvs_.Clear();
}
BatchDeleteResponse::BatchDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.BatchDeleteResponse)
}
BatchDeleteResponse::BatchDeleteResponse(const BatchDeleteResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BatchDeleteResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prev_kvs_){from._impl_.prev_kvs_}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.BatchDeleteResponse)
}

inline void BatchDeleteResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.prev_kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BatchDeleteResponse::~BatchDeleteResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.BatchDeleteResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BatchDeleteResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prev_kvs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void BatchDeleteResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BatchDeleteResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.BatchDeleteResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prev_kvs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchDeleteResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prev_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BatchDeleteResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.BatchDeleteResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prev_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_prev_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.BatchDeleteResponse)
  return target;
}

size_t BatchDeleteResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.BatchDeleteResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
  total_size += 1UL * this->_internal_prev_kvs_size();
  for (const auto& msg : this->_impl_.prev_kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchDeleteResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BatchDeleteResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchDeleteResponse::GetClassData() const { return &_class_data_; }


void BatchDeleteResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BatchDeleteResponse*>(&to_msg);
  auto& from = static_cast<const BatchDeleteResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.BatchDeleteResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prev_kvs_.MergeFrom(from._impl_.prev_kvs_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchDeleteResponse::CopyFrom(const BatchDeleteResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.BatchDeleteResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchDeleteResponse::IsInitialized() const {
  return true;
}

void BatchDeleteResponse::InternalSwap(BatchDeleteResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.prev_kvs_.InternalSwap(&other->_impl_.prev_kvs_);
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchDeleteResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[9]);
}

// ===================================================================

class CompareAndPutRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const CompareAndPutRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
CompareAndPutRequest::_Internal::header(const CompareAndPutRequest* msg) {
  return *msg->_impl_.header_;
}
void CompareAndPutRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
CompareAndPutRequest::CompareAndPutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.CompareAndPutRequest)
}
CompareAndPutRequest::CompareAndPutRequest(const CompareAndPutRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompareAndPutRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.expect_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.expect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expect().empty()) {
    _this->_impl_.expect_.Set(from._internal_expect(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.CompareAndPutRequest)
}

inline void CompareAndPutRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.expect_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.expect_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expect_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CompareAndPutRequest::~CompareAndPutRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.CompareAndPutRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompareAndPutRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.expect_.Destroy();
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void CompareAndPutRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompareAndPutRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.CompareAndPutRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.expect_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompareAndPutRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes expect = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_expect();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompareAndPutRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.CompareAndPutRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // bytes expect = 3;
  if (!this->_internal_expect().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_expect(), target);
  }

  // bytes value = 4;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.CompareAndPutRequest)
  return target;
}

size_t CompareAndPutRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.CompareAndPutRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // bytes expect = 3;
  if (!this->_internal_expect().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_expect());
  }

  // bytes value = 4;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompareAndPutRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompareAndPutRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompareAndPutRequest::GetClassData() const { return &_class_data_; }


void CompareAndPutRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompareAndPutRequest*>(&to_msg);
  auto& from = static_cast<const CompareAndPutRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.CompareAndPutRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_expect().empty()) {
    _this->_internal_set_expect(from._internal_expect());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompareAndPutRequest::CopyFrom(const CompareAndPutRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.CompareAndPutRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompareAndPutRequest::IsInitialized() const {
  return true;
}

void CompareAndPutRequest::InternalSwap(CompareAndPutRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.expect_, lhs_arena,
      &other->_impl_.expect_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompareAndPutRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[10]);
}

// ===================================================================

class CompareAndPutResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const CompareAndPutResponse* msg);
  static const ::greptime::v1::meta::KeyValue& prev_kv(const CompareAndPutResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
CompareAndPutResponse::_Internal::header(const CompareAndPutResponse* msg) {
  return *msg->_impl_.header_;
}
const ::greptime::v1::meta::KeyValue&
CompareAndPutResponse::_Internal::prev_kv(const CompareAndPutResponse* msg) {
  return *msg->_impl_.prev_kv_;
}
void CompareAndPutResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void CompareAndPutResponse::clear_prev_kv() {
  if (GetArenaForAllocation() == nullptr && _impl_.prev_kv_ != nullptr) {
    delete _impl_.prev_kv_;
  }
  _impl_.prev_kv_ = nullptr;
}
CompareAndPutResponse::CompareAndPutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.CompareAndPutResponse)
}
CompareAndPutResponse::CompareAndPutResponse(const CompareAndPutResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompareAndPutResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){nullptr}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_prev_kv()) {
    _this->_impl_.prev_kv_ = new ::greptime::v1::meta::KeyValue(*from._impl_.prev_kv_);
  }
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.CompareAndPutResponse)
}

inline void CompareAndPutResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){nullptr}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CompareAndPutResponse::~CompareAndPutResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.CompareAndPutResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompareAndPutResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.prev_kv_;
}

void CompareAndPutResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompareAndPutResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.CompareAndPutResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.prev_kv_ != nullptr) {
    delete _impl_.prev_kv_;
  }
  _impl_.prev_kv_ = nullptr;
  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompareAndPutResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool success = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.meta.KeyValue prev_kv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_prev_kv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompareAndPutResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.CompareAndPutResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bool success = 2;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_success(), target);
  }

  // .greptime.v1.meta.KeyValue prev_kv = 3;
  if (this->_internal_has_prev_kv()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::prev_kv(this),
        _Internal::prev_kv(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.CompareAndPutResponse)
  return target;
}

size_t CompareAndPutResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.CompareAndPutResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .greptime.v1.meta.KeyValue prev_kv = 3;
  if (this->_internal_has_prev_kv()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.prev_kv_);
  }

  // bool success = 2;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompareAndPutResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompareAndPutResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompareAndPutResponse::GetClassData() const { return &_class_data_; }


void CompareAndPutResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompareAndPutResponse*>(&to_msg);
  auto& from = static_cast<const CompareAndPutResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.CompareAndPutResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_prev_kv()) {
    _this->_internal_mutable_prev_kv()->::greptime::v1::meta::KeyValue::MergeFrom(
        from._internal_prev_kv());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompareAndPutResponse::CopyFrom(const CompareAndPutResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.CompareAndPutResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompareAndPutResponse::IsInitialized() const {
  return true;
}

void CompareAndPutResponse::InternalSwap(CompareAndPutResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompareAndPutResponse, _impl_.success_)
      + sizeof(CompareAndPutResponse::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(CompareAndPutResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CompareAndPutResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[11]);
}

// ===================================================================

class DeleteRangeRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const DeleteRangeRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
DeleteRangeRequest::_Internal::header(const DeleteRangeRequest* msg) {
  return *msg->_impl_.header_;
}
void DeleteRangeRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
DeleteRangeRequest::DeleteRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.DeleteRangeRequest)
}
DeleteRangeRequest::DeleteRangeRequest(const DeleteRangeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteRangeRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.range_end_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_range_end().empty()) {
    _this->_impl_.range_end_.Set(from._internal_range_end(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  _this->_impl_.prev_kv_ = from._impl_.prev_kv_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.DeleteRangeRequest)
}

inline void DeleteRangeRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.range_end_){}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.prev_kv_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.range_end_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.range_end_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteRangeRequest::~DeleteRangeRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.DeleteRangeRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteRangeRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.range_end_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void DeleteRangeRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteRangeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.DeleteRangeRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.range_end_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.prev_kv_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteRangeRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes range_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_range_end();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool prev_kv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.prev_kv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteRangeRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.DeleteRangeRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // bytes range_end = 3;
  if (!this->_internal_range_end().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_range_end(), target);
  }

  // bool prev_kv = 4;
  if (this->_internal_prev_kv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_prev_kv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.DeleteRangeRequest)
  return target;
}

size_t DeleteRangeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.DeleteRangeRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  // bytes range_end = 3;
  if (!this->_internal_range_end().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_range_end());
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // bool prev_kv = 4;
  if (this->_internal_prev_kv() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteRangeRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteRangeRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteRangeRequest::GetClassData() const { return &_class_data_; }


void DeleteRangeRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteRangeRequest*>(&to_msg);
  auto& from = static_cast<const DeleteRangeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.DeleteRangeRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_range_end().empty()) {
    _this->_internal_set_range_end(from._internal_range_end());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_prev_kv() != 0) {
    _this->_internal_set_prev_kv(from._internal_prev_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteRangeRequest::CopyFrom(const DeleteRangeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.DeleteRangeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeRequest::IsInitialized() const {
  return true;
}

void DeleteRangeRequest::InternalSwap(DeleteRangeRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.range_end_, lhs_arena,
      &other->_impl_.range_end_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeleteRangeRequest, _impl_.prev_kv_)
      + sizeof(DeleteRangeRequest::_impl_.prev_kv_)
      - PROTOBUF_FIELD_OFFSET(DeleteRangeRequest, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteRangeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[12]);
}

// ===================================================================

class DeleteRangeResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const DeleteRangeResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
DeleteRangeResponse::_Internal::header(const DeleteRangeResponse* msg) {
  return *msg->_impl_.header_;
}
void DeleteRangeResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void DeleteRangeResponse::clear_prev_kvs() {
  _impl_.prev_kvs_.Clear();
}
DeleteRangeResponse::DeleteRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.DeleteRangeResponse)
}
DeleteRangeResponse::DeleteRangeResponse(const DeleteRangeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteRangeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.prev_kvs_){from._impl_.prev_kvs_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.deleted_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.deleted_ = from._impl_.deleted_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.DeleteRangeResponse)
}

inline void DeleteRangeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.prev_kvs_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.deleted_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeleteRangeResponse::~DeleteRangeResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.DeleteRangeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteRangeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.prev_kvs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void DeleteRangeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteRangeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.DeleteRangeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.prev_kvs_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.deleted_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteRangeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 deleted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.meta.KeyValue prev_kvs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_prev_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteRangeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.DeleteRangeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // int64 deleted = 2;
  if (this->_internal_deleted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_deleted(), target);
  }

  // repeated .greptime.v1.meta.KeyValue prev_kvs = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_prev_kvs_size()); i < n; i++) {
    const auto& repfield = this->_internal_prev_kvs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.DeleteRangeResponse)
  return target;
}

size_t DeleteRangeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.DeleteRangeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.meta.KeyValue prev_kvs = 3;
  total_size += 1UL * this->_internal_prev_kvs_size();
  for (const auto& msg : this->_impl_.prev_kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // int64 deleted = 2;
  if (this->_internal_deleted() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_deleted());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteRangeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteRangeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteRangeResponse::GetClassData() const { return &_class_data_; }


void DeleteRangeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteRangeResponse*>(&to_msg);
  auto& from = static_cast<const DeleteRangeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.DeleteRangeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.prev_kvs_.MergeFrom(from._impl_.prev_kvs_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_deleted() != 0) {
    _this->_internal_set_deleted(from._internal_deleted());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteRangeResponse::CopyFrom(const DeleteRangeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.DeleteRangeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeResponse::IsInitialized() const {
  return true;
}

void DeleteRangeResponse::InternalSwap(DeleteRangeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.prev_kvs_.InternalSwap(&other->_impl_.prev_kvs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeleteRangeResponse, _impl_.deleted_)
      + sizeof(DeleteRangeResponse::_impl_.deleted_)
      - PROTOBUF_FIELD_OFFSET(DeleteRangeResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteRangeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[13]);
}

// ===================================================================

class MoveValueRequest::_Internal {
 public:
  static const ::greptime::v1::meta::RequestHeader& header(const MoveValueRequest* msg);
};

const ::greptime::v1::meta::RequestHeader&
MoveValueRequest::_Internal::header(const MoveValueRequest* msg) {
  return *msg->_impl_.header_;
}
void MoveValueRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
MoveValueRequest::MoveValueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.MoveValueRequest)
}
MoveValueRequest::MoveValueRequest(const MoveValueRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveValueRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_key_){}
    , decltype(_impl_.to_key_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.from_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_from_key().empty()) {
    _this->_impl_.from_key_.Set(from._internal_from_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.to_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_to_key().empty()) {
    _this->_impl_.to_key_.Set(from._internal_to_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::RequestHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.MoveValueRequest)
}

inline void MoveValueRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_key_){}
    , decltype(_impl_.to_key_){}
    , decltype(_impl_.header_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.from_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.to_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoveValueRequest::~MoveValueRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.MoveValueRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveValueRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.from_key_.Destroy();
  _impl_.to_key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void MoveValueRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveValueRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.MoveValueRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.from_key_.ClearToEmpty();
  _impl_.to_key_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveValueRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes from_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_from_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes to_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_to_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveValueRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.MoveValueRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // bytes from_key = 2;
  if (!this->_internal_from_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_from_key(), target);
  }

  // bytes to_key = 3;
  if (!this->_internal_to_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_to_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.MoveValueRequest)
  return target;
}

size_t MoveValueRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.MoveValueRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes from_key = 2;
  if (!this->_internal_from_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_from_key());
  }

  // bytes to_key = 3;
  if (!this->_internal_to_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_to_key());
  }

  // .greptime.v1.meta.RequestHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveValueRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveValueRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveValueRequest::GetClassData() const { return &_class_data_; }


void MoveValueRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveValueRequest*>(&to_msg);
  auto& from = static_cast<const MoveValueRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.MoveValueRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_from_key().empty()) {
    _this->_internal_set_from_key(from._internal_from_key());
  }
  if (!from._internal_to_key().empty()) {
    _this->_internal_set_to_key(from._internal_to_key());
  }
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::RequestHeader::MergeFrom(
        from._internal_header());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveValueRequest::CopyFrom(const MoveValueRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.MoveValueRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveValueRequest::IsInitialized() const {
  return true;
}

void MoveValueRequest::InternalSwap(MoveValueRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_key_, lhs_arena,
      &other->_impl_.from_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.to_key_, lhs_arena,
      &other->_impl_.to_key_, rhs_arena
  );
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveValueRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[14]);
}

// ===================================================================

class MoveValueResponse::_Internal {
 public:
  static const ::greptime::v1::meta::ResponseHeader& header(const MoveValueResponse* msg);
  static const ::greptime::v1::meta::KeyValue& kv(const MoveValueResponse* msg);
};

const ::greptime::v1::meta::ResponseHeader&
MoveValueResponse::_Internal::header(const MoveValueResponse* msg) {
  return *msg->_impl_.header_;
}
const ::greptime::v1::meta::KeyValue&
MoveValueResponse::_Internal::kv(const MoveValueResponse* msg) {
  return *msg->_impl_.kv_;
}
void MoveValueResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void MoveValueResponse::clear_kv() {
  if (GetArenaForAllocation() == nullptr && _impl_.kv_ != nullptr) {
    delete _impl_.kv_;
  }
  _impl_.kv_ = nullptr;
}
MoveValueResponse::MoveValueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.meta.MoveValueResponse)
}
MoveValueResponse::MoveValueResponse(const MoveValueResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveValueResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.kv_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::meta::ResponseHeader(*from._impl_.header_);
  }
  if (from._internal_has_kv()) {
    _this->_impl_.kv_ = new ::greptime::v1::meta::KeyValue(*from._impl_.kv_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.meta.MoveValueResponse)
}

inline void MoveValueResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.kv_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MoveValueResponse::~MoveValueResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.meta.MoveValueResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveValueResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (this != internal_default_instance()) delete _impl_.kv_;
}

void MoveValueResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveValueResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.meta.MoveValueResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.kv_ != nullptr) {
    delete _impl_.kv_;
  }
  _impl_.kv_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveValueResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.meta.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.meta.KeyValue kv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_kv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveValueResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.meta.MoveValueResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.meta.KeyValue kv = 2;
  if (this->_internal_has_kv()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::kv(this),
        _Internal::kv(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.meta.MoveValueResponse)
  return target;
}

size_t MoveValueResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.meta.MoveValueResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.meta.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // .greptime.v1.meta.KeyValue kv = 2;
  if (this->_internal_has_kv()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.kv_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveValueResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveValueResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveValueResponse::GetClassData() const { return &_class_data_; }


void MoveValueResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveValueResponse*>(&to_msg);
  auto& from = static_cast<const MoveValueResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.meta.MoveValueResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::meta::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_has_kv()) {
    _this->_internal_mutable_kv()->::greptime::v1::meta::KeyValue::MergeFrom(
        from._internal_kv());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveValueResponse::CopyFrom(const MoveValueResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.meta.MoveValueResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveValueResponse::IsInitialized() const {
  return true;
}

void MoveValueResponse::InternalSwap(MoveValueResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveValueResponse, _impl_.kv_)
      + sizeof(MoveValueResponse::_impl_.kv_)
      - PROTOBUF_FIELD_OFFSET(MoveValueResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveValueResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_getter, &descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto_once,
      file_level_metadata_greptime_2fv1_2fmeta_2fstore_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::RangeRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::RangeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::RangeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::RangeResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::RangeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::RangeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::PutRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::PutRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::PutRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::PutResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::PutResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::PutResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::BatchGetRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::BatchGetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::BatchGetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::BatchGetResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::BatchGetResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::BatchGetResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::BatchPutRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::BatchPutRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::BatchPutRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::BatchPutResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::BatchPutResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::BatchPutResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::BatchDeleteRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::BatchDeleteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::BatchDeleteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::BatchDeleteResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::BatchDeleteResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::BatchDeleteResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::CompareAndPutRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::CompareAndPutRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::CompareAndPutRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::CompareAndPutResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::CompareAndPutResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::CompareAndPutResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::DeleteRangeRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::DeleteRangeRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::DeleteRangeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::DeleteRangeResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::DeleteRangeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::DeleteRangeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::MoveValueRequest*
Arena::CreateMaybeMessage< ::greptime::v1::meta::MoveValueRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::MoveValueRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::meta::MoveValueResponse*
Arena::CreateMaybeMessage< ::greptime::v1::meta::MoveValueResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::meta::MoveValueResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
