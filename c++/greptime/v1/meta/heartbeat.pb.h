// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/heartbeat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/meta/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fmeta_2fheartbeat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
namespace greptime {
namespace v1 {
namespace meta {
class AskLeaderRequest;
struct AskLeaderRequestDefaultTypeInternal;
extern AskLeaderRequestDefaultTypeInternal _AskLeaderRequest_default_instance_;
class AskLeaderResponse;
struct AskLeaderResponseDefaultTypeInternal;
extern AskLeaderResponseDefaultTypeInternal _AskLeaderResponse_default_instance_;
class GrantedRegion;
struct GrantedRegionDefaultTypeInternal;
extern GrantedRegionDefaultTypeInternal _GrantedRegion_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class MailboxMessage;
struct MailboxMessageDefaultTypeInternal;
extern MailboxMessageDefaultTypeInternal _MailboxMessage_default_instance_;
class RegionLease;
struct RegionLeaseDefaultTypeInternal;
extern RegionLeaseDefaultTypeInternal _RegionLease_default_instance_;
class RegionStat;
struct RegionStatDefaultTypeInternal;
extern RegionStatDefaultTypeInternal _RegionStat_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::meta::AskLeaderRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::AskLeaderRequest>(Arena*);
template<> ::greptime::v1::meta::AskLeaderResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::AskLeaderResponse>(Arena*);
template<> ::greptime::v1::meta::GrantedRegion* Arena::CreateMaybeMessage<::greptime::v1::meta::GrantedRegion>(Arena*);
template<> ::greptime::v1::meta::HeartbeatRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::HeartbeatRequest>(Arena*);
template<> ::greptime::v1::meta::HeartbeatResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::HeartbeatResponse>(Arena*);
template<> ::greptime::v1::meta::MailboxMessage* Arena::CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(Arena*);
template<> ::greptime::v1::meta::RegionLease* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionLease>(Arena*);
template<> ::greptime::v1::meta::RegionStat* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionStat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace meta {

enum RegionRole : int {
  Leader = 0,
  Follower = 1,
  RegionRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegionRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegionRole_IsValid(int value);
constexpr RegionRole RegionRole_MIN = Leader;
constexpr RegionRole RegionRole_MAX = Follower;
constexpr int RegionRole_ARRAYSIZE = RegionRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegionRole_descriptor();
template<typename T>
inline const std::string& RegionRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegionRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegionRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegionRole_descriptor(), enum_t_value);
}
inline bool RegionRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegionRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegionRole>(
    RegionRole_descriptor(), name, value);
}
// ===================================================================

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatRequest& from) {
    HeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionStatsFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kPeerFieldNumber = 2,
    kReportIntervalFieldNumber = 3,
    kMailboxMessageFieldNumber = 5,
    kDurationSinceEpochFieldNumber = 6,
    kNodeEpochFieldNumber = 7,
  };
  // repeated .greptime.v1.meta.RegionStat region_stats = 4;
  int region_stats_size() const;
  private:
  int _internal_region_stats_size() const;
  public:
  void clear_region_stats();
  ::greptime::v1::meta::RegionStat* mutable_region_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >*
      mutable_region_stats();
  private:
  const ::greptime::v1::meta::RegionStat& _internal_region_stats(int index) const;
  ::greptime::v1::meta::RegionStat* _internal_add_region_stats();
  public:
  const ::greptime::v1::meta::RegionStat& region_stats(int index) const;
  ::greptime::v1::meta::RegionStat* add_region_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >&
      region_stats() const;

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.Peer peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::greptime::v1::meta::Peer& peer() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Peer* release_peer();
  ::greptime::v1::meta::Peer* mutable_peer();
  void set_allocated_peer(::greptime::v1::meta::Peer* peer);
  private:
  const ::greptime::v1::meta::Peer& _internal_peer() const;
  ::greptime::v1::meta::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::greptime::v1::meta::Peer* peer);
  ::greptime::v1::meta::Peer* unsafe_arena_release_peer();

  // .greptime.v1.meta.TimeInterval report_interval = 3;
  bool has_report_interval() const;
  private:
  bool _internal_has_report_interval() const;
  public:
  void clear_report_interval();
  const ::greptime::v1::meta::TimeInterval& report_interval() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TimeInterval* release_report_interval();
  ::greptime::v1::meta::TimeInterval* mutable_report_interval();
  void set_allocated_report_interval(::greptime::v1::meta::TimeInterval* report_interval);
  private:
  const ::greptime::v1::meta::TimeInterval& _internal_report_interval() const;
  ::greptime::v1::meta::TimeInterval* _internal_mutable_report_interval();
  public:
  void unsafe_arena_set_allocated_report_interval(
      ::greptime::v1::meta::TimeInterval* report_interval);
  ::greptime::v1::meta::TimeInterval* unsafe_arena_release_report_interval();

  // .greptime.v1.meta.MailboxMessage mailbox_message = 5;
  bool has_mailbox_message() const;
  private:
  bool _internal_has_mailbox_message() const;
  public:
  void clear_mailbox_message();
  const ::greptime::v1::meta::MailboxMessage& mailbox_message() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::MailboxMessage* release_mailbox_message();
  ::greptime::v1::meta::MailboxMessage* mutable_mailbox_message();
  void set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message);
  private:
  const ::greptime::v1::meta::MailboxMessage& _internal_mailbox_message() const;
  ::greptime::v1::meta::MailboxMessage* _internal_mutable_mailbox_message();
  public:
  void unsafe_arena_set_allocated_mailbox_message(
      ::greptime::v1::meta::MailboxMessage* mailbox_message);
  ::greptime::v1::meta::MailboxMessage* unsafe_arena_release_mailbox_message();

  // uint64 duration_since_epoch = 6;
  void clear_duration_since_epoch();
  uint64_t duration_since_epoch() const;
  void set_duration_since_epoch(uint64_t value);
  private:
  uint64_t _internal_duration_since_epoch() const;
  void _internal_set_duration_since_epoch(uint64_t value);
  public:

  // uint64 node_epoch = 7;
  void clear_node_epoch();
  uint64_t node_epoch() const;
  void set_node_epoch(uint64_t value);
  private:
  uint64_t _internal_node_epoch() const;
  void _internal_set_node_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat > region_stats_;
    ::greptime::v1::meta::RequestHeader* header_;
    ::greptime::v1::meta::Peer* peer_;
    ::greptime::v1::meta::TimeInterval* report_interval_;
    ::greptime::v1::meta::MailboxMessage* mailbox_message_;
    uint64_t duration_since_epoch_;
    uint64_t node_epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class RegionStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionStat) */ {
 public:
  inline RegionStat() : RegionStat(nullptr) {}
  ~RegionStat() override;
  explicit PROTOBUF_CONSTEXPR RegionStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionStat(const RegionStat& from);
  RegionStat(RegionStat&& from) noexcept
    : RegionStat() {
    *this = ::std::move(from);
  }

  inline RegionStat& operator=(const RegionStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionStat& operator=(RegionStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionStat* internal_default_instance() {
    return reinterpret_cast<const RegionStat*>(
               &_RegionStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegionStat& a, RegionStat& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionStat& from) {
    RegionStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionStat";
  }
  protected:
  explicit RegionStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEngineFieldNumber = 6,
    kRegionIdFieldNumber = 1,
    kRcusFieldNumber = 2,
    kWcusFieldNumber = 3,
    kApproximateBytesFieldNumber = 4,
    kApproximateRowsFieldNumber = 5,
    kRoleFieldNumber = 7,
  };
  // string engine = 6;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // int64 rcus = 2;
  void clear_rcus();
  int64_t rcus() const;
  void set_rcus(int64_t value);
  private:
  int64_t _internal_rcus() const;
  void _internal_set_rcus(int64_t value);
  public:

  // int64 wcus = 3;
  void clear_wcus();
  int64_t wcus() const;
  void set_wcus(int64_t value);
  private:
  int64_t _internal_wcus() const;
  void _internal_set_wcus(int64_t value);
  public:

  // int64 approximate_bytes = 4;
  void clear_approximate_bytes();
  int64_t approximate_bytes() const;
  void set_approximate_bytes(int64_t value);
  private:
  int64_t _internal_approximate_bytes() const;
  void _internal_set_approximate_bytes(int64_t value);
  public:

  // int64 approximate_rows = 5;
  void clear_approximate_rows();
  int64_t approximate_rows() const;
  void set_approximate_rows(int64_t value);
  private:
  int64_t _internal_approximate_rows() const;
  void _internal_set_approximate_rows(int64_t value);
  public:

  // .greptime.v1.meta.RegionRole role = 7;
  void clear_role();
  ::greptime::v1::meta::RegionRole role() const;
  void set_role(::greptime::v1::meta::RegionRole value);
  private:
  ::greptime::v1::meta::RegionRole _internal_role() const;
  void _internal_set_role(::greptime::v1::meta::RegionRole value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    uint64_t region_id_;
    int64_t rcus_;
    int64_t wcus_;
    int64_t approximate_bytes_;
    int64_t approximate_rows_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatResponse& from) {
    HeartbeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMailboxMessageFieldNumber = 2,
    kRegionLeaseFieldNumber = 3,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.MailboxMessage mailbox_message = 2;
  bool has_mailbox_message() const;
  private:
  bool _internal_has_mailbox_message() const;
  public:
  void clear_mailbox_message();
  const ::greptime::v1::meta::MailboxMessage& mailbox_message() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::MailboxMessage* release_mailbox_message();
  ::greptime::v1::meta::MailboxMessage* mutable_mailbox_message();
  void set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message);
  private:
  const ::greptime::v1::meta::MailboxMessage& _internal_mailbox_message() const;
  ::greptime::v1::meta::MailboxMessage* _internal_mutable_mailbox_message();
  public:
  void unsafe_arena_set_allocated_mailbox_message(
      ::greptime::v1::meta::MailboxMessage* mailbox_message);
  ::greptime::v1::meta::MailboxMessage* unsafe_arena_release_mailbox_message();

  // .greptime.v1.meta.RegionLease region_lease = 3;
  bool has_region_lease() const;
  private:
  bool _internal_has_region_lease() const;
  public:
  void clear_region_lease();
  const ::greptime::v1::meta::RegionLease& region_lease() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RegionLease* release_region_lease();
  ::greptime::v1::meta::RegionLease* mutable_region_lease();
  void set_allocated_region_lease(::greptime::v1::meta::RegionLease* region_lease);
  private:
  const ::greptime::v1::meta::RegionLease& _internal_region_lease() const;
  ::greptime::v1::meta::RegionLease* _internal_mutable_region_lease();
  public:
  void unsafe_arena_set_allocated_region_lease(
      ::greptime::v1::meta::RegionLease* region_lease);
  ::greptime::v1::meta::RegionLease* unsafe_arena_release_region_lease();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::MailboxMessage* mailbox_message_;
    ::greptime::v1::meta::RegionLease* region_lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class GrantedRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.GrantedRegion) */ {
 public:
  inline GrantedRegion() : GrantedRegion(nullptr) {}
  ~GrantedRegion() override;
  explicit PROTOBUF_CONSTEXPR GrantedRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrantedRegion(const GrantedRegion& from);
  GrantedRegion(GrantedRegion&& from) noexcept
    : GrantedRegion() {
    *this = ::std::move(from);
  }

  inline GrantedRegion& operator=(const GrantedRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrantedRegion& operator=(GrantedRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrantedRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrantedRegion* internal_default_instance() {
    return reinterpret_cast<const GrantedRegion*>(
               &_GrantedRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GrantedRegion& a, GrantedRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(GrantedRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrantedRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrantedRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrantedRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrantedRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrantedRegion& from) {
    GrantedRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrantedRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.GrantedRegion";
  }
  protected:
  explicit GrantedRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // .greptime.v1.meta.RegionRole role = 2;
  void clear_role();
  ::greptime::v1::meta::RegionRole role() const;
  void set_role(::greptime::v1::meta::RegionRole value);
  private:
  ::greptime::v1::meta::RegionRole _internal_role() const;
  void _internal_set_role(::greptime::v1::meta::RegionRole value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.GrantedRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class RegionLease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionLease) */ {
 public:
  inline RegionLease() : RegionLease(nullptr) {}
  ~RegionLease() override;
  explicit PROTOBUF_CONSTEXPR RegionLease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionLease(const RegionLease& from);
  RegionLease(RegionLease&& from) noexcept
    : RegionLease() {
    *this = ::std::move(from);
  }

  inline RegionLease& operator=(const RegionLease& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionLease& operator=(RegionLease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionLease& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionLease* internal_default_instance() {
    return reinterpret_cast<const RegionLease*>(
               &_RegionLease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegionLease& a, RegionLease& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionLease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionLease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionLease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionLease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionLease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionLease& from) {
    RegionLease::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionLease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionLease";
  }
  protected:
  explicit RegionLease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
    kDurationSinceEpochFieldNumber = 2,
    kLeaseSecondsFieldNumber = 3,
  };
  // repeated .greptime.v1.meta.GrantedRegion regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::greptime::v1::meta::GrantedRegion* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >*
      mutable_regions();
  private:
  const ::greptime::v1::meta::GrantedRegion& _internal_regions(int index) const;
  ::greptime::v1::meta::GrantedRegion* _internal_add_regions();
  public:
  const ::greptime::v1::meta::GrantedRegion& regions(int index) const;
  ::greptime::v1::meta::GrantedRegion* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >&
      regions() const;

  // uint64 duration_since_epoch = 2;
  void clear_duration_since_epoch();
  uint64_t duration_since_epoch() const;
  void set_duration_since_epoch(uint64_t value);
  private:
  uint64_t _internal_duration_since_epoch() const;
  void _internal_set_duration_since_epoch(uint64_t value);
  public:

  // uint64 lease_seconds = 3;
  void clear_lease_seconds();
  uint64_t lease_seconds() const;
  void set_lease_seconds(uint64_t value);
  private:
  uint64_t _internal_lease_seconds() const;
  void _internal_set_lease_seconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionLease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion > regions_;
    uint64_t duration_since_epoch_;
    uint64_t lease_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class AskLeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.AskLeaderRequest) */ {
 public:
  inline AskLeaderRequest() : AskLeaderRequest(nullptr) {}
  ~AskLeaderRequest() override;
  explicit PROTOBUF_CONSTEXPR AskLeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskLeaderRequest(const AskLeaderRequest& from);
  AskLeaderRequest(AskLeaderRequest&& from) noexcept
    : AskLeaderRequest() {
    *this = ::std::move(from);
  }

  inline AskLeaderRequest& operator=(const AskLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaderRequest& operator=(AskLeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const AskLeaderRequest*>(
               &_AskLeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AskLeaderRequest& a, AskLeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AskLeaderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskLeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AskLeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AskLeaderRequest& from) {
    AskLeaderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskLeaderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.AskLeaderRequest";
  }
  protected:
  explicit AskLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.AskLeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class AskLeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.AskLeaderResponse) */ {
 public:
  inline AskLeaderResponse() : AskLeaderResponse(nullptr) {}
  ~AskLeaderResponse() override;
  explicit PROTOBUF_CONSTEXPR AskLeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskLeaderResponse(const AskLeaderResponse& from);
  AskLeaderResponse(AskLeaderResponse&& from) noexcept
    : AskLeaderResponse() {
    *this = ::std::move(from);
  }

  inline AskLeaderResponse& operator=(const AskLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaderResponse& operator=(AskLeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const AskLeaderResponse*>(
               &_AskLeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AskLeaderResponse& a, AskLeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AskLeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskLeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AskLeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AskLeaderResponse& from) {
    AskLeaderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskLeaderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.AskLeaderResponse";
  }
  protected:
  explicit AskLeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaderFieldNumber = 2,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.Peer leader = 2;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::greptime::v1::meta::Peer& leader() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Peer* release_leader();
  ::greptime::v1::meta::Peer* mutable_leader();
  void set_allocated_leader(::greptime::v1::meta::Peer* leader);
  private:
  const ::greptime::v1::meta::Peer& _internal_leader() const;
  ::greptime::v1::meta::Peer* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::greptime::v1::meta::Peer* leader);
  ::greptime::v1::meta::Peer* unsafe_arena_release_leader();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.AskLeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::Peer* leader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class MailboxMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.MailboxMessage) */ {
 public:
  inline MailboxMessage() : MailboxMessage(nullptr) {}
  ~MailboxMessage() override;
  explicit PROTOBUF_CONSTEXPR MailboxMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailboxMessage(const MailboxMessage& from);
  MailboxMessage(MailboxMessage&& from) noexcept
    : MailboxMessage() {
    *this = ::std::move(from);
  }

  inline MailboxMessage& operator=(const MailboxMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailboxMessage& operator=(MailboxMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailboxMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kJson = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MailboxMessage* internal_default_instance() {
    return reinterpret_cast<const MailboxMessage*>(
               &_MailboxMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MailboxMessage& a, MailboxMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MailboxMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailboxMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailboxMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailboxMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailboxMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailboxMessage& from) {
    MailboxMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailboxMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.MailboxMessage";
  }
  protected:
  explicit MailboxMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kIdFieldNumber = 1,
    kTimestampMillisFieldNumber = 5,
    kJsonFieldNumber = 6,
  };
  // string subject = 2;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string from = 3;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 4;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // int64 timestamp_millis = 5;
  void clear_timestamp_millis();
  int64_t timestamp_millis() const;
  void set_timestamp_millis(int64_t value);
  private:
  int64_t _internal_timestamp_millis() const;
  void _internal_set_timestamp_millis(int64_t value);
  public:

  // string json = 6;
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.meta.MailboxMessage)
 private:
  class _Internal;
  void set_has_json();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
    uint64_t id_;
    int64_t timestamp_millis_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool HeartbeatRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& HeartbeatRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& HeartbeatRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.header)
  return _internal_header();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.header)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.header)
}

// .greptime.v1.meta.Peer peer = 2;
inline bool HeartbeatRequest::_internal_has_peer() const {
  return this != internal_default_instance() && _impl_.peer_ != nullptr;
}
inline bool HeartbeatRequest::has_peer() const {
  return _internal_has_peer();
}
inline const ::greptime::v1::meta::Peer& HeartbeatRequest::_internal_peer() const {
  const ::greptime::v1::meta::Peer* p = _impl_.peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Peer&>(
      ::greptime::v1::meta::_Peer_default_instance_);
}
inline const ::greptime::v1::meta::Peer& HeartbeatRequest::peer() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.peer)
  return _internal_peer();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_peer(
    ::greptime::v1::meta::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  _impl_.peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.peer)
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::release_peer() {
  
  ::greptime::v1::meta::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.peer)
  
  ::greptime::v1::meta::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::_internal_mutable_peer() {
  
  if (_impl_.peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Peer>(GetArenaForAllocation());
    _impl_.peer_ = p;
  }
  return _impl_.peer_;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::mutable_peer() {
  ::greptime::v1::meta::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.peer)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_peer(::greptime::v1::meta::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.peer)
}

// .greptime.v1.meta.TimeInterval report_interval = 3;
inline bool HeartbeatRequest::_internal_has_report_interval() const {
  return this != internal_default_instance() && _impl_.report_interval_ != nullptr;
}
inline bool HeartbeatRequest::has_report_interval() const {
  return _internal_has_report_interval();
}
inline const ::greptime::v1::meta::TimeInterval& HeartbeatRequest::_internal_report_interval() const {
  const ::greptime::v1::meta::TimeInterval* p = _impl_.report_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TimeInterval&>(
      ::greptime::v1::meta::_TimeInterval_default_instance_);
}
inline const ::greptime::v1::meta::TimeInterval& HeartbeatRequest::report_interval() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.report_interval)
  return _internal_report_interval();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_report_interval(
    ::greptime::v1::meta::TimeInterval* report_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_interval_);
  }
  _impl_.report_interval_ = report_interval;
  if (report_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.report_interval)
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::release_report_interval() {
  
  ::greptime::v1::meta::TimeInterval* temp = _impl_.report_interval_;
  _impl_.report_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::unsafe_arena_release_report_interval() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.report_interval)
  
  ::greptime::v1::meta::TimeInterval* temp = _impl_.report_interval_;
  _impl_.report_interval_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::_internal_mutable_report_interval() {
  
  if (_impl_.report_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TimeInterval>(GetArenaForAllocation());
    _impl_.report_interval_ = p;
  }
  return _impl_.report_interval_;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::mutable_report_interval() {
  ::greptime::v1::meta::TimeInterval* _msg = _internal_mutable_report_interval();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.report_interval)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_report_interval(::greptime::v1::meta::TimeInterval* report_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_interval_);
  }
  if (report_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_interval));
    if (message_arena != submessage_arena) {
      report_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report_interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.report_interval_ = report_interval;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.report_interval)
}

// repeated .greptime.v1.meta.RegionStat region_stats = 4;
inline int HeartbeatRequest::_internal_region_stats_size() const {
  return _impl_.region_stats_.size();
}
inline int HeartbeatRequest::region_stats_size() const {
  return _internal_region_stats_size();
}
inline void HeartbeatRequest::clear_region_stats() {
  _impl_.region_stats_.Clear();
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::mutable_region_stats(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _impl_.region_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >*
HeartbeatRequest::mutable_region_stats() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.HeartbeatRequest.region_stats)
  return &_impl_.region_stats_;
}
inline const ::greptime::v1::meta::RegionStat& HeartbeatRequest::_internal_region_stats(int index) const {
  return _impl_.region_stats_.Get(index);
}
inline const ::greptime::v1::meta::RegionStat& HeartbeatRequest::region_stats(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _internal_region_stats(index);
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::_internal_add_region_stats() {
  return _impl_.region_stats_.Add();
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::add_region_stats() {
  ::greptime::v1::meta::RegionStat* _add = _internal_add_region_stats();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >&
HeartbeatRequest::region_stats() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _impl_.region_stats_;
}

// .greptime.v1.meta.MailboxMessage mailbox_message = 5;
inline bool HeartbeatRequest::_internal_has_mailbox_message() const {
  return this != internal_default_instance() && _impl_.mailbox_message_ != nullptr;
}
inline bool HeartbeatRequest::has_mailbox_message() const {
  return _internal_has_mailbox_message();
}
inline void HeartbeatRequest::clear_mailbox_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.mailbox_message_ != nullptr) {
    delete _impl_.mailbox_message_;
  }
  _impl_.mailbox_message_ = nullptr;
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatRequest::_internal_mailbox_message() const {
  const ::greptime::v1::meta::MailboxMessage* p = _impl_.mailbox_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::MailboxMessage&>(
      ::greptime::v1::meta::_MailboxMessage_default_instance_);
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatRequest::mailbox_message() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  return _internal_mailbox_message();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_mailbox_message(
    ::greptime::v1::meta::MailboxMessage* mailbox_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_message_);
  }
  _impl_.mailbox_message_ = mailbox_message;
  if (mailbox_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.mailbox_message)
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::release_mailbox_message() {
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::unsafe_arena_release_mailbox_message() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::_internal_mutable_mailbox_message() {
  
  if (_impl_.mailbox_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(GetArenaForAllocation());
    _impl_.mailbox_message_ = p;
  }
  return _impl_.mailbox_message_;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::mutable_mailbox_message() {
  ::greptime::v1::meta::MailboxMessage* _msg = _internal_mutable_mailbox_message();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mailbox_message_;
  }
  if (mailbox_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mailbox_message);
    if (message_arena != submessage_arena) {
      mailbox_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_message_ = mailbox_message;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.mailbox_message)
}

// uint64 duration_since_epoch = 6;
inline void HeartbeatRequest::clear_duration_since_epoch() {
  _impl_.duration_since_epoch_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_duration_since_epoch() const {
  return _impl_.duration_since_epoch_;
}
inline uint64_t HeartbeatRequest::duration_since_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.duration_since_epoch)
  return _internal_duration_since_epoch();
}
inline void HeartbeatRequest::_internal_set_duration_since_epoch(uint64_t value) {
  
  _impl_.duration_since_epoch_ = value;
}
inline void HeartbeatRequest::set_duration_since_epoch(uint64_t value) {
  _internal_set_duration_since_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.HeartbeatRequest.duration_since_epoch)
}

// uint64 node_epoch = 7;
inline void HeartbeatRequest::clear_node_epoch() {
  _impl_.node_epoch_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_node_epoch() const {
  return _impl_.node_epoch_;
}
inline uint64_t HeartbeatRequest::node_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.node_epoch)
  return _internal_node_epoch();
}
inline void HeartbeatRequest::_internal_set_node_epoch(uint64_t value) {
  
  _impl_.node_epoch_ = value;
}
inline void HeartbeatRequest::set_node_epoch(uint64_t value) {
  _internal_set_node_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.HeartbeatRequest.node_epoch)
}

// -------------------------------------------------------------------

// RegionStat

// uint64 region_id = 1;
inline void RegionStat::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t RegionStat::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t RegionStat::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.region_id)
  return _internal_region_id();
}
inline void RegionStat::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void RegionStat::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.region_id)
}

// int64 rcus = 2;
inline void RegionStat::clear_rcus() {
  _impl_.rcus_ = int64_t{0};
}
inline int64_t RegionStat::_internal_rcus() const {
  return _impl_.rcus_;
}
inline int64_t RegionStat::rcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.rcus)
  return _internal_rcus();
}
inline void RegionStat::_internal_set_rcus(int64_t value) {
  
  _impl_.rcus_ = value;
}
inline void RegionStat::set_rcus(int64_t value) {
  _internal_set_rcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.rcus)
}

// int64 wcus = 3;
inline void RegionStat::clear_wcus() {
  _impl_.wcus_ = int64_t{0};
}
inline int64_t RegionStat::_internal_wcus() const {
  return _impl_.wcus_;
}
inline int64_t RegionStat::wcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.wcus)
  return _internal_wcus();
}
inline void RegionStat::_internal_set_wcus(int64_t value) {
  
  _impl_.wcus_ = value;
}
inline void RegionStat::set_wcus(int64_t value) {
  _internal_set_wcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.wcus)
}

// int64 approximate_bytes = 4;
inline void RegionStat::clear_approximate_bytes() {
  _impl_.approximate_bytes_ = int64_t{0};
}
inline int64_t RegionStat::_internal_approximate_bytes() const {
  return _impl_.approximate_bytes_;
}
inline int64_t RegionStat::approximate_bytes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.approximate_bytes)
  return _internal_approximate_bytes();
}
inline void RegionStat::_internal_set_approximate_bytes(int64_t value) {
  
  _impl_.approximate_bytes_ = value;
}
inline void RegionStat::set_approximate_bytes(int64_t value) {
  _internal_set_approximate_bytes(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.approximate_bytes)
}

// int64 approximate_rows = 5;
inline void RegionStat::clear_approximate_rows() {
  _impl_.approximate_rows_ = int64_t{0};
}
inline int64_t RegionStat::_internal_approximate_rows() const {
  return _impl_.approximate_rows_;
}
inline int64_t RegionStat::approximate_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.approximate_rows)
  return _internal_approximate_rows();
}
inline void RegionStat::_internal_set_approximate_rows(int64_t value) {
  
  _impl_.approximate_rows_ = value;
}
inline void RegionStat::set_approximate_rows(int64_t value) {
  _internal_set_approximate_rows(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.approximate_rows)
}

// string engine = 6;
inline void RegionStat::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& RegionStat::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionStat::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.engine)
}
inline std::string* RegionStat::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionStat.engine)
  return _s;
}
inline const std::string& RegionStat::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void RegionStat::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionStat::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionStat::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RegionStat.engine)
  return _impl_.engine_.Release();
}
inline void RegionStat::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RegionStat.engine)
}

// .greptime.v1.meta.RegionRole role = 7;
inline void RegionStat::clear_role() {
  _impl_.role_ = 0;
}
inline ::greptime::v1::meta::RegionRole RegionStat::_internal_role() const {
  return static_cast< ::greptime::v1::meta::RegionRole >(_impl_.role_);
}
inline ::greptime::v1::meta::RegionRole RegionStat::role() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.role)
  return _internal_role();
}
inline void RegionStat::_internal_set_role(::greptime::v1::meta::RegionRole value) {
  
  _impl_.role_ = value;
}
inline void RegionStat::set_role(::greptime::v1::meta::RegionRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.role)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool HeartbeatResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& HeartbeatResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& HeartbeatResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.header)
  return _internal_header();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.header)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.header)
}

// .greptime.v1.meta.MailboxMessage mailbox_message = 2;
inline bool HeartbeatResponse::_internal_has_mailbox_message() const {
  return this != internal_default_instance() && _impl_.mailbox_message_ != nullptr;
}
inline bool HeartbeatResponse::has_mailbox_message() const {
  return _internal_has_mailbox_message();
}
inline void HeartbeatResponse::clear_mailbox_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.mailbox_message_ != nullptr) {
    delete _impl_.mailbox_message_;
  }
  _impl_.mailbox_message_ = nullptr;
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatResponse::_internal_mailbox_message() const {
  const ::greptime::v1::meta::MailboxMessage* p = _impl_.mailbox_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::MailboxMessage&>(
      ::greptime::v1::meta::_MailboxMessage_default_instance_);
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatResponse::mailbox_message() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  return _internal_mailbox_message();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_mailbox_message(
    ::greptime::v1::meta::MailboxMessage* mailbox_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_message_);
  }
  _impl_.mailbox_message_ = mailbox_message;
  if (mailbox_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.mailbox_message)
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::release_mailbox_message() {
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::unsafe_arena_release_mailbox_message() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::_internal_mutable_mailbox_message() {
  
  if (_impl_.mailbox_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(GetArenaForAllocation());
    _impl_.mailbox_message_ = p;
  }
  return _impl_.mailbox_message_;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::mutable_mailbox_message() {
  ::greptime::v1::meta::MailboxMessage* _msg = _internal_mutable_mailbox_message();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mailbox_message_;
  }
  if (mailbox_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mailbox_message);
    if (message_arena != submessage_arena) {
      mailbox_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_message_ = mailbox_message;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.mailbox_message)
}

// .greptime.v1.meta.RegionLease region_lease = 3;
inline bool HeartbeatResponse::_internal_has_region_lease() const {
  return this != internal_default_instance() && _impl_.region_lease_ != nullptr;
}
inline bool HeartbeatResponse::has_region_lease() const {
  return _internal_has_region_lease();
}
inline void HeartbeatResponse::clear_region_lease() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_lease_ != nullptr) {
    delete _impl_.region_lease_;
  }
  _impl_.region_lease_ = nullptr;
}
inline const ::greptime::v1::meta::RegionLease& HeartbeatResponse::_internal_region_lease() const {
  const ::greptime::v1::meta::RegionLease* p = _impl_.region_lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RegionLease&>(
      ::greptime::v1::meta::_RegionLease_default_instance_);
}
inline const ::greptime::v1::meta::RegionLease& HeartbeatResponse::region_lease() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.region_lease)
  return _internal_region_lease();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_region_lease(
    ::greptime::v1::meta::RegionLease* region_lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_lease_);
  }
  _impl_.region_lease_ = region_lease;
  if (region_lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.region_lease)
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::release_region_lease() {
  
  ::greptime::v1::meta::RegionLease* temp = _impl_.region_lease_;
  _impl_.region_lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::unsafe_arena_release_region_lease() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.region_lease)
  
  ::greptime::v1::meta::RegionLease* temp = _impl_.region_lease_;
  _impl_.region_lease_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::_internal_mutable_region_lease() {
  
  if (_impl_.region_lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RegionLease>(GetArenaForAllocation());
    _impl_.region_lease_ = p;
  }
  return _impl_.region_lease_;
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::mutable_region_lease() {
  ::greptime::v1::meta::RegionLease* _msg = _internal_mutable_region_lease();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.region_lease)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_region_lease(::greptime::v1::meta::RegionLease* region_lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_lease_;
  }
  if (region_lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region_lease);
    if (message_arena != submessage_arena) {
      region_lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_lease_ = region_lease;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.region_lease)
}

// -------------------------------------------------------------------

// GrantedRegion

// uint64 region_id = 1;
inline void GrantedRegion::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t GrantedRegion::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t GrantedRegion::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.GrantedRegion.region_id)
  return _internal_region_id();
}
inline void GrantedRegion::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void GrantedRegion::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.GrantedRegion.region_id)
}

// .greptime.v1.meta.RegionRole role = 2;
inline void GrantedRegion::clear_role() {
  _impl_.role_ = 0;
}
inline ::greptime::v1::meta::RegionRole GrantedRegion::_internal_role() const {
  return static_cast< ::greptime::v1::meta::RegionRole >(_impl_.role_);
}
inline ::greptime::v1::meta::RegionRole GrantedRegion::role() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.GrantedRegion.role)
  return _internal_role();
}
inline void GrantedRegion::_internal_set_role(::greptime::v1::meta::RegionRole value) {
  
  _impl_.role_ = value;
}
inline void GrantedRegion::set_role(::greptime::v1::meta::RegionRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.GrantedRegion.role)
}

// -------------------------------------------------------------------

// RegionLease

// repeated .greptime.v1.meta.GrantedRegion regions = 1;
inline int RegionLease::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int RegionLease::regions_size() const {
  return _internal_regions_size();
}
inline void RegionLease::clear_regions() {
  _impl_.regions_.Clear();
}
inline ::greptime::v1::meta::GrantedRegion* RegionLease::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionLease.regions)
  return _impl_.regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >*
RegionLease::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RegionLease.regions)
  return &_impl_.regions_;
}
inline const ::greptime::v1::meta::GrantedRegion& RegionLease::_internal_regions(int index) const {
  return _impl_.regions_.Get(index);
}
inline const ::greptime::v1::meta::GrantedRegion& RegionLease::regions(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.regions)
  return _internal_regions(index);
}
inline ::greptime::v1::meta::GrantedRegion* RegionLease::_internal_add_regions() {
  return _impl_.regions_.Add();
}
inline ::greptime::v1::meta::GrantedRegion* RegionLease::add_regions() {
  ::greptime::v1::meta::GrantedRegion* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RegionLease.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >&
RegionLease::regions() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RegionLease.regions)
  return _impl_.regions_;
}

// uint64 duration_since_epoch = 2;
inline void RegionLease::clear_duration_since_epoch() {
  _impl_.duration_since_epoch_ = uint64_t{0u};
}
inline uint64_t RegionLease::_internal_duration_since_epoch() const {
  return _impl_.duration_since_epoch_;
}
inline uint64_t RegionLease::duration_since_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.duration_since_epoch)
  return _internal_duration_since_epoch();
}
inline void RegionLease::_internal_set_duration_since_epoch(uint64_t value) {
  
  _impl_.duration_since_epoch_ = value;
}
inline void RegionLease::set_duration_since_epoch(uint64_t value) {
  _internal_set_duration_since_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.duration_since_epoch)
}

// uint64 lease_seconds = 3;
inline void RegionLease::clear_lease_seconds() {
  _impl_.lease_seconds_ = uint64_t{0u};
}
inline uint64_t RegionLease::_internal_lease_seconds() const {
  return _impl_.lease_seconds_;
}
inline uint64_t RegionLease::lease_seconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.lease_seconds)
  return _internal_lease_seconds();
}
inline void RegionLease::_internal_set_lease_seconds(uint64_t value) {
  
  _impl_.lease_seconds_ = value;
}
inline void RegionLease::set_lease_seconds(uint64_t value) {
  _internal_set_lease_seconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.lease_seconds)
}

// -------------------------------------------------------------------

// AskLeaderRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool AskLeaderRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AskLeaderRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& AskLeaderRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& AskLeaderRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderRequest.header)
  return _internal_header();
}
inline void AskLeaderRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderRequest.header)
  return _msg;
}
inline void AskLeaderRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderRequest.header)
}

// -------------------------------------------------------------------

// AskLeaderResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool AskLeaderResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AskLeaderResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& AskLeaderResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& AskLeaderResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderResponse.header)
  return _internal_header();
}
inline void AskLeaderResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderResponse.header)
  return _msg;
}
inline void AskLeaderResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderResponse.header)
}

// .greptime.v1.meta.Peer leader = 2;
inline bool AskLeaderResponse::_internal_has_leader() const {
  return this != internal_default_instance() && _impl_.leader_ != nullptr;
}
inline bool AskLeaderResponse::has_leader() const {
  return _internal_has_leader();
}
inline const ::greptime::v1::meta::Peer& AskLeaderResponse::_internal_leader() const {
  const ::greptime::v1::meta::Peer* p = _impl_.leader_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Peer&>(
      ::greptime::v1::meta::_Peer_default_instance_);
}
inline const ::greptime::v1::meta::Peer& AskLeaderResponse::leader() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderResponse.leader)
  return _internal_leader();
}
inline void AskLeaderResponse::unsafe_arena_set_allocated_leader(
    ::greptime::v1::meta::Peer* leader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  _impl_.leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderResponse.leader)
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::release_leader() {
  
  ::greptime::v1::meta::Peer* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderResponse.leader)
  
  ::greptime::v1::meta::Peer* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::_internal_mutable_leader() {
  
  if (_impl_.leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Peer>(GetArenaForAllocation());
    _impl_.leader_ = p;
  }
  return _impl_.leader_;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::mutable_leader() {
  ::greptime::v1::meta::Peer* _msg = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderResponse.leader)
  return _msg;
}
inline void AskLeaderResponse::set_allocated_leader(::greptime::v1::meta::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader));
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderResponse.leader)
}

// -------------------------------------------------------------------

// MailboxMessage

// uint64 id = 1;
inline void MailboxMessage::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t MailboxMessage::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t MailboxMessage::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.id)
  return _internal_id();
}
inline void MailboxMessage::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void MailboxMessage::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.id)
}

// string subject = 2;
inline void MailboxMessage::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& MailboxMessage::subject() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.subject)
}
inline std::string* MailboxMessage::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.subject)
  return _s;
}
inline const std::string& MailboxMessage::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void MailboxMessage::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_subject() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.subject)
  return _impl_.subject_.Release();
}
inline void MailboxMessage::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.subject)
}

// string from = 3;
inline void MailboxMessage::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& MailboxMessage::from() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.from)
}
inline std::string* MailboxMessage::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.from)
  return _s;
}
inline const std::string& MailboxMessage::_internal_from() const {
  return _impl_.from_.Get();
}
inline void MailboxMessage::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_from() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.from)
  return _impl_.from_.Release();
}
inline void MailboxMessage::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.from)
}

// string to = 4;
inline void MailboxMessage::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& MailboxMessage::to() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.to)
}
inline std::string* MailboxMessage::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.to)
  return _s;
}
inline const std::string& MailboxMessage::_internal_to() const {
  return _impl_.to_.Get();
}
inline void MailboxMessage::_internal_set_to(const std::string& value) {
  
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_to() {
  
  return _impl_.to_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_to() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.to)
  return _impl_.to_.Release();
}
inline void MailboxMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  _impl_.to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.to)
}

// int64 timestamp_millis = 5;
inline void MailboxMessage::clear_timestamp_millis() {
  _impl_.timestamp_millis_ = int64_t{0};
}
inline int64_t MailboxMessage::_internal_timestamp_millis() const {
  return _impl_.timestamp_millis_;
}
inline int64_t MailboxMessage::timestamp_millis() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.timestamp_millis)
  return _internal_timestamp_millis();
}
inline void MailboxMessage::_internal_set_timestamp_millis(int64_t value) {
  
  _impl_.timestamp_millis_ = value;
}
inline void MailboxMessage::set_timestamp_millis(int64_t value) {
  _internal_set_timestamp_millis(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.timestamp_millis)
}

// string json = 6;
inline bool MailboxMessage::_internal_has_json() const {
  return payload_case() == kJson;
}
inline bool MailboxMessage::has_json() const {
  return _internal_has_json();
}
inline void MailboxMessage::set_has_json() {
  _impl_._oneof_case_[0] = kJson;
}
inline void MailboxMessage::clear_json() {
  if (_internal_has_json()) {
    _impl_.payload_.json_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& MailboxMessage::json() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline void MailboxMessage::set_json(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  _impl_.payload_.json_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.json)
}
inline std::string* MailboxMessage::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.json)
  return _s;
}
inline const std::string& MailboxMessage::_internal_json() const {
  if (_internal_has_json()) {
    return _impl_.payload_.json_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MailboxMessage::_internal_set_json(const std::string& value) {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  _impl_.payload_.json_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  return _impl_.payload_.json_.Mutable(      GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_json() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.json)
  if (_internal_has_json()) {
    clear_has_payload();
    return _impl_.payload_.json_.Release();
  } else {
    return nullptr;
  }
}
inline void MailboxMessage::set_allocated_json(std::string* json) {
  if (has_payload()) {
    clear_payload();
  }
  if (json != nullptr) {
    set_has_json();
    _impl_.payload_.json_.InitAllocated(json, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.json)
}

inline bool MailboxMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MailboxMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MailboxMessage::PayloadCase MailboxMessage::payload_case() const {
  return MailboxMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::meta::RegionRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::meta::RegionRole>() {
  return ::greptime::v1::meta::RegionRole_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto
