// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/heartbeat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/meta/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fmeta_2fheartbeat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
namespace greptime {
namespace v1 {
namespace meta {
class AskLeaderRequest;
struct AskLeaderRequestDefaultTypeInternal;
extern AskLeaderRequestDefaultTypeInternal _AskLeaderRequest_default_instance_;
class AskLeaderResponse;
struct AskLeaderResponseDefaultTypeInternal;
extern AskLeaderResponseDefaultTypeInternal _AskLeaderResponse_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class MailboxMessage;
struct MailboxMessageDefaultTypeInternal;
extern MailboxMessageDefaultTypeInternal _MailboxMessage_default_instance_;
class NodeStat;
struct NodeStatDefaultTypeInternal;
extern NodeStatDefaultTypeInternal _NodeStat_default_instance_;
class NodeStat_AttrsEntry_DoNotUse;
struct NodeStat_AttrsEntry_DoNotUseDefaultTypeInternal;
extern NodeStat_AttrsEntry_DoNotUseDefaultTypeInternal _NodeStat_AttrsEntry_DoNotUse_default_instance_;
class RegionLease;
struct RegionLeaseDefaultTypeInternal;
extern RegionLeaseDefaultTypeInternal _RegionLease_default_instance_;
class RegionStat;
struct RegionStatDefaultTypeInternal;
extern RegionStatDefaultTypeInternal _RegionStat_default_instance_;
class RegionStat_AttrsEntry_DoNotUse;
struct RegionStat_AttrsEntry_DoNotUseDefaultTypeInternal;
extern RegionStat_AttrsEntry_DoNotUseDefaultTypeInternal _RegionStat_AttrsEntry_DoNotUse_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::meta::AskLeaderRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::AskLeaderRequest>(Arena*);
template<> ::greptime::v1::meta::AskLeaderResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::AskLeaderResponse>(Arena*);
template<> ::greptime::v1::meta::HeartbeatRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::HeartbeatRequest>(Arena*);
template<> ::greptime::v1::meta::HeartbeatResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::HeartbeatResponse>(Arena*);
template<> ::greptime::v1::meta::MailboxMessage* Arena::CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(Arena*);
template<> ::greptime::v1::meta::NodeStat* Arena::CreateMaybeMessage<::greptime::v1::meta::NodeStat>(Arena*);
template<> ::greptime::v1::meta::NodeStat_AttrsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::NodeStat_AttrsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::RegionLease* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionLease>(Arena*);
template<> ::greptime::v1::meta::RegionStat* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionStat>(Arena*);
template<> ::greptime::v1::meta::RegionStat_AttrsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionStat_AttrsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace meta {

// ===================================================================

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatRequest& from) {
    HeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionStatsFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kPeerFieldNumber = 2,
    kReportIntervalFieldNumber = 3,
    kNodeStatFieldNumber = 4,
    kMailboxMessageFieldNumber = 6,
    kDurationSinceEpochFieldNumber = 7,
    kNodeEpochFieldNumber = 8,
  };
  // repeated .greptime.v1.meta.RegionStat region_stats = 5;
  int region_stats_size() const;
  private:
  int _internal_region_stats_size() const;
  public:
  void clear_region_stats();
  ::greptime::v1::meta::RegionStat* mutable_region_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >*
      mutable_region_stats();
  private:
  const ::greptime::v1::meta::RegionStat& _internal_region_stats(int index) const;
  ::greptime::v1::meta::RegionStat* _internal_add_region_stats();
  public:
  const ::greptime::v1::meta::RegionStat& region_stats(int index) const;
  ::greptime::v1::meta::RegionStat* add_region_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >&
      region_stats() const;

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.Peer peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::greptime::v1::meta::Peer& peer() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Peer* release_peer();
  ::greptime::v1::meta::Peer* mutable_peer();
  void set_allocated_peer(::greptime::v1::meta::Peer* peer);
  private:
  const ::greptime::v1::meta::Peer& _internal_peer() const;
  ::greptime::v1::meta::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::greptime::v1::meta::Peer* peer);
  ::greptime::v1::meta::Peer* unsafe_arena_release_peer();

  // .greptime.v1.meta.TimeInterval report_interval = 3;
  bool has_report_interval() const;
  private:
  bool _internal_has_report_interval() const;
  public:
  void clear_report_interval();
  const ::greptime::v1::meta::TimeInterval& report_interval() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TimeInterval* release_report_interval();
  ::greptime::v1::meta::TimeInterval* mutable_report_interval();
  void set_allocated_report_interval(::greptime::v1::meta::TimeInterval* report_interval);
  private:
  const ::greptime::v1::meta::TimeInterval& _internal_report_interval() const;
  ::greptime::v1::meta::TimeInterval* _internal_mutable_report_interval();
  public:
  void unsafe_arena_set_allocated_report_interval(
      ::greptime::v1::meta::TimeInterval* report_interval);
  ::greptime::v1::meta::TimeInterval* unsafe_arena_release_report_interval();

  // .greptime.v1.meta.NodeStat node_stat = 4;
  bool has_node_stat() const;
  private:
  bool _internal_has_node_stat() const;
  public:
  void clear_node_stat();
  const ::greptime::v1::meta::NodeStat& node_stat() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::NodeStat* release_node_stat();
  ::greptime::v1::meta::NodeStat* mutable_node_stat();
  void set_allocated_node_stat(::greptime::v1::meta::NodeStat* node_stat);
  private:
  const ::greptime::v1::meta::NodeStat& _internal_node_stat() const;
  ::greptime::v1::meta::NodeStat* _internal_mutable_node_stat();
  public:
  void unsafe_arena_set_allocated_node_stat(
      ::greptime::v1::meta::NodeStat* node_stat);
  ::greptime::v1::meta::NodeStat* unsafe_arena_release_node_stat();

  // .greptime.v1.meta.MailboxMessage mailbox_message = 6;
  bool has_mailbox_message() const;
  private:
  bool _internal_has_mailbox_message() const;
  public:
  void clear_mailbox_message();
  const ::greptime::v1::meta::MailboxMessage& mailbox_message() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::MailboxMessage* release_mailbox_message();
  ::greptime::v1::meta::MailboxMessage* mutable_mailbox_message();
  void set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message);
  private:
  const ::greptime::v1::meta::MailboxMessage& _internal_mailbox_message() const;
  ::greptime::v1::meta::MailboxMessage* _internal_mutable_mailbox_message();
  public:
  void unsafe_arena_set_allocated_mailbox_message(
      ::greptime::v1::meta::MailboxMessage* mailbox_message);
  ::greptime::v1::meta::MailboxMessage* unsafe_arena_release_mailbox_message();

  // uint64 duration_since_epoch = 7;
  void clear_duration_since_epoch();
  uint64_t duration_since_epoch() const;
  void set_duration_since_epoch(uint64_t value);
  private:
  uint64_t _internal_duration_since_epoch() const;
  void _internal_set_duration_since_epoch(uint64_t value);
  public:

  // uint64 node_epoch = 8;
  void clear_node_epoch();
  uint64_t node_epoch() const;
  void set_node_epoch(uint64_t value);
  private:
  uint64_t _internal_node_epoch() const;
  void _internal_set_node_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat > region_stats_;
    ::greptime::v1::meta::RequestHeader* header_;
    ::greptime::v1::meta::Peer* peer_;
    ::greptime::v1::meta::TimeInterval* report_interval_;
    ::greptime::v1::meta::NodeStat* node_stat_;
    ::greptime::v1::meta::MailboxMessage* mailbox_message_;
    uint64_t duration_since_epoch_;
    uint64_t node_epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class NodeStat_AttrsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStat_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStat_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  NodeStat_AttrsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR NodeStat_AttrsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit NodeStat_AttrsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeStat_AttrsEntry_DoNotUse& other);
  static const NodeStat_AttrsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeStat_AttrsEntry_DoNotUse*>(&_NodeStat_AttrsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.NodeStat.AttrsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.NodeStat.AttrsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};

// -------------------------------------------------------------------

class NodeStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.NodeStat) */ {
 public:
  inline NodeStat() : NodeStat(nullptr) {}
  ~NodeStat() override;
  explicit PROTOBUF_CONSTEXPR NodeStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeStat(const NodeStat& from);
  NodeStat(NodeStat&& from) noexcept
    : NodeStat() {
    *this = ::std::move(from);
  }

  inline NodeStat& operator=(const NodeStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStat& operator=(NodeStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeStat* internal_default_instance() {
    return reinterpret_cast<const NodeStat*>(
               &_NodeStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeStat& a, NodeStat& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeStat& from) {
    NodeStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.NodeStat";
  }
  protected:
  explicit NodeStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 100,
    kRcusFieldNumber = 1,
    kWcusFieldNumber = 2,
    kTableNumFieldNumber = 3,
    kRegionNumFieldNumber = 4,
  };
  // map<string, string> attrs = 100;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attrs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attrs();

  // int64 rcus = 1;
  void clear_rcus();
  int64_t rcus() const;
  void set_rcus(int64_t value);
  private:
  int64_t _internal_rcus() const;
  void _internal_set_rcus(int64_t value);
  public:

  // int64 wcus = 2;
  void clear_wcus();
  int64_t wcus() const;
  void set_wcus(int64_t value);
  private:
  int64_t _internal_wcus() const;
  void _internal_set_wcus(int64_t value);
  public:

  // int64 table_num = 3;
  void clear_table_num();
  int64_t table_num() const;
  void set_table_num(int64_t value);
  private:
  int64_t _internal_table_num() const;
  void _internal_set_table_num(int64_t value);
  public:

  // int64 region_num = 4;
  void clear_region_num();
  int64_t region_num() const;
  void set_region_num(int64_t value);
  private:
  int64_t _internal_region_num() const;
  void _internal_set_region_num(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.NodeStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        NodeStat_AttrsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attrs_;
    int64_t rcus_;
    int64_t wcus_;
    int64_t table_num_;
    int64_t region_num_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class RegionStat_AttrsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionStat_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionStat_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RegionStat_AttrsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RegionStat_AttrsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RegionStat_AttrsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RegionStat_AttrsEntry_DoNotUse& other);
  static const RegionStat_AttrsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RegionStat_AttrsEntry_DoNotUse*>(&_RegionStat_AttrsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.RegionStat.AttrsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.RegionStat.AttrsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};

// -------------------------------------------------------------------

class RegionStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionStat) */ {
 public:
  inline RegionStat() : RegionStat(nullptr) {}
  ~RegionStat() override;
  explicit PROTOBUF_CONSTEXPR RegionStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionStat(const RegionStat& from);
  RegionStat(RegionStat&& from) noexcept
    : RegionStat() {
    *this = ::std::move(from);
  }

  inline RegionStat& operator=(const RegionStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionStat& operator=(RegionStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionStat* internal_default_instance() {
    return reinterpret_cast<const RegionStat*>(
               &_RegionStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegionStat& a, RegionStat& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionStat& from) {
    RegionStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionStat";
  }
  protected:
  explicit RegionStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 100,
    kTableIdentFieldNumber = 2,
    kRegionIdFieldNumber = 1,
    kRcusFieldNumber = 3,
    kWcusFieldNumber = 4,
    kApproximateBytesFieldNumber = 5,
    kApproximateRowsFieldNumber = 6,
  };
  // map<string, string> attrs = 100;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attrs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attrs();

  // .greptime.v1.meta.TableIdent table_ident = 2;
  bool has_table_ident() const;
  private:
  bool _internal_has_table_ident() const;
  public:
  void clear_table_ident();
  const ::greptime::v1::meta::TableIdent& table_ident() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableIdent* release_table_ident();
  ::greptime::v1::meta::TableIdent* mutable_table_ident();
  void set_allocated_table_ident(::greptime::v1::meta::TableIdent* table_ident);
  private:
  const ::greptime::v1::meta::TableIdent& _internal_table_ident() const;
  ::greptime::v1::meta::TableIdent* _internal_mutable_table_ident();
  public:
  void unsafe_arena_set_allocated_table_ident(
      ::greptime::v1::meta::TableIdent* table_ident);
  ::greptime::v1::meta::TableIdent* unsafe_arena_release_table_ident();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // int64 rcus = 3;
  void clear_rcus();
  int64_t rcus() const;
  void set_rcus(int64_t value);
  private:
  int64_t _internal_rcus() const;
  void _internal_set_rcus(int64_t value);
  public:

  // int64 wcus = 4;
  void clear_wcus();
  int64_t wcus() const;
  void set_wcus(int64_t value);
  private:
  int64_t _internal_wcus() const;
  void _internal_set_wcus(int64_t value);
  public:

  // int64 approximate_bytes = 5;
  void clear_approximate_bytes();
  int64_t approximate_bytes() const;
  void set_approximate_bytes(int64_t value);
  private:
  int64_t _internal_approximate_bytes() const;
  void _internal_set_approximate_bytes(int64_t value);
  public:

  // int64 approximate_rows = 6;
  void clear_approximate_rows();
  int64_t approximate_rows() const;
  void set_approximate_rows(int64_t value);
  private:
  int64_t _internal_approximate_rows() const;
  void _internal_set_approximate_rows(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RegionStat_AttrsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attrs_;
    ::greptime::v1::meta::TableIdent* table_ident_;
    uint64_t region_id_;
    int64_t rcus_;
    int64_t wcus_;
    int64_t approximate_bytes_;
    int64_t approximate_rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatResponse& from) {
    HeartbeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionLeasesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kMailboxMessageFieldNumber = 2,
  };
  // repeated .greptime.v1.meta.RegionLease region_leases = 3;
  int region_leases_size() const;
  private:
  int _internal_region_leases_size() const;
  public:
  void clear_region_leases();
  ::greptime::v1::meta::RegionLease* mutable_region_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionLease >*
      mutable_region_leases();
  private:
  const ::greptime::v1::meta::RegionLease& _internal_region_leases(int index) const;
  ::greptime::v1::meta::RegionLease* _internal_add_region_leases();
  public:
  const ::greptime::v1::meta::RegionLease& region_leases(int index) const;
  ::greptime::v1::meta::RegionLease* add_region_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionLease >&
      region_leases() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.MailboxMessage mailbox_message = 2;
  bool has_mailbox_message() const;
  private:
  bool _internal_has_mailbox_message() const;
  public:
  void clear_mailbox_message();
  const ::greptime::v1::meta::MailboxMessage& mailbox_message() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::MailboxMessage* release_mailbox_message();
  ::greptime::v1::meta::MailboxMessage* mutable_mailbox_message();
  void set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message);
  private:
  const ::greptime::v1::meta::MailboxMessage& _internal_mailbox_message() const;
  ::greptime::v1::meta::MailboxMessage* _internal_mutable_mailbox_message();
  public:
  void unsafe_arena_set_allocated_mailbox_message(
      ::greptime::v1::meta::MailboxMessage* mailbox_message);
  ::greptime::v1::meta::MailboxMessage* unsafe_arena_release_mailbox_message();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionLease > region_leases_;
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::MailboxMessage* mailbox_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class RegionLease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionLease) */ {
 public:
  inline RegionLease() : RegionLease(nullptr) {}
  ~RegionLease() override;
  explicit PROTOBUF_CONSTEXPR RegionLease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionLease(const RegionLease& from);
  RegionLease(RegionLease&& from) noexcept
    : RegionLease() {
    *this = ::std::move(from);
  }

  inline RegionLease& operator=(const RegionLease& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionLease& operator=(RegionLease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionLease& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionLease* internal_default_instance() {
    return reinterpret_cast<const RegionLease*>(
               &_RegionLease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegionLease& a, RegionLease& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionLease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionLease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionLease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionLease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionLease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionLease& from) {
    RegionLease::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionLease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionLease";
  }
  protected:
  explicit RegionLease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 2,
    kTableIdentFieldNumber = 1,
    kDurationSinceEpochFieldNumber = 3,
    kLeaseSecondsFieldNumber = 4,
  };
  // repeated uint32 regions = 2;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  private:
  uint32_t _internal_regions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_regions() const;
  void _internal_add_regions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_regions();
  public:
  uint32_t regions(int index) const;
  void set_regions(int index, uint32_t value);
  void add_regions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      regions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_regions();

  // .greptime.v1.meta.TableIdent table_ident = 1;
  bool has_table_ident() const;
  private:
  bool _internal_has_table_ident() const;
  public:
  void clear_table_ident();
  const ::greptime::v1::meta::TableIdent& table_ident() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableIdent* release_table_ident();
  ::greptime::v1::meta::TableIdent* mutable_table_ident();
  void set_allocated_table_ident(::greptime::v1::meta::TableIdent* table_ident);
  private:
  const ::greptime::v1::meta::TableIdent& _internal_table_ident() const;
  ::greptime::v1::meta::TableIdent* _internal_mutable_table_ident();
  public:
  void unsafe_arena_set_allocated_table_ident(
      ::greptime::v1::meta::TableIdent* table_ident);
  ::greptime::v1::meta::TableIdent* unsafe_arena_release_table_ident();

  // uint64 duration_since_epoch = 3;
  void clear_duration_since_epoch();
  uint64_t duration_since_epoch() const;
  void set_duration_since_epoch(uint64_t value);
  private:
  uint64_t _internal_duration_since_epoch() const;
  void _internal_set_duration_since_epoch(uint64_t value);
  public:

  // uint64 lease_seconds = 4;
  void clear_lease_seconds();
  uint64_t lease_seconds() const;
  void set_lease_seconds(uint64_t value);
  private:
  uint64_t _internal_lease_seconds() const;
  void _internal_set_lease_seconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionLease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > regions_;
    mutable std::atomic<int> _regions_cached_byte_size_;
    ::greptime::v1::meta::TableIdent* table_ident_;
    uint64_t duration_since_epoch_;
    uint64_t lease_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class AskLeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.AskLeaderRequest) */ {
 public:
  inline AskLeaderRequest() : AskLeaderRequest(nullptr) {}
  ~AskLeaderRequest() override;
  explicit PROTOBUF_CONSTEXPR AskLeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskLeaderRequest(const AskLeaderRequest& from);
  AskLeaderRequest(AskLeaderRequest&& from) noexcept
    : AskLeaderRequest() {
    *this = ::std::move(from);
  }

  inline AskLeaderRequest& operator=(const AskLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaderRequest& operator=(AskLeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const AskLeaderRequest*>(
               &_AskLeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AskLeaderRequest& a, AskLeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AskLeaderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskLeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AskLeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AskLeaderRequest& from) {
    AskLeaderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskLeaderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.AskLeaderRequest";
  }
  protected:
  explicit AskLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.AskLeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class AskLeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.AskLeaderResponse) */ {
 public:
  inline AskLeaderResponse() : AskLeaderResponse(nullptr) {}
  ~AskLeaderResponse() override;
  explicit PROTOBUF_CONSTEXPR AskLeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskLeaderResponse(const AskLeaderResponse& from);
  AskLeaderResponse(AskLeaderResponse&& from) noexcept
    : AskLeaderResponse() {
    *this = ::std::move(from);
  }

  inline AskLeaderResponse& operator=(const AskLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaderResponse& operator=(AskLeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const AskLeaderResponse*>(
               &_AskLeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AskLeaderResponse& a, AskLeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AskLeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskLeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AskLeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AskLeaderResponse& from) {
    AskLeaderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskLeaderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.AskLeaderResponse";
  }
  protected:
  explicit AskLeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaderFieldNumber = 2,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.Peer leader = 2;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::greptime::v1::meta::Peer& leader() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Peer* release_leader();
  ::greptime::v1::meta::Peer* mutable_leader();
  void set_allocated_leader(::greptime::v1::meta::Peer* leader);
  private:
  const ::greptime::v1::meta::Peer& _internal_leader() const;
  ::greptime::v1::meta::Peer* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::greptime::v1::meta::Peer* leader);
  ::greptime::v1::meta::Peer* unsafe_arena_release_leader();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.AskLeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::Peer* leader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class MailboxMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.MailboxMessage) */ {
 public:
  inline MailboxMessage() : MailboxMessage(nullptr) {}
  ~MailboxMessage() override;
  explicit PROTOBUF_CONSTEXPR MailboxMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailboxMessage(const MailboxMessage& from);
  MailboxMessage(MailboxMessage&& from) noexcept
    : MailboxMessage() {
    *this = ::std::move(from);
  }

  inline MailboxMessage& operator=(const MailboxMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailboxMessage& operator=(MailboxMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailboxMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kJson = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MailboxMessage* internal_default_instance() {
    return reinterpret_cast<const MailboxMessage*>(
               &_MailboxMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MailboxMessage& a, MailboxMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MailboxMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailboxMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailboxMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailboxMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailboxMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailboxMessage& from) {
    MailboxMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailboxMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.MailboxMessage";
  }
  protected:
  explicit MailboxMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kIdFieldNumber = 1,
    kTimestampMillisFieldNumber = 5,
    kJsonFieldNumber = 6,
  };
  // string subject = 2;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string from = 3;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 4;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // int64 timestamp_millis = 5;
  void clear_timestamp_millis();
  int64_t timestamp_millis() const;
  void set_timestamp_millis(int64_t value);
  private:
  int64_t _internal_timestamp_millis() const;
  void _internal_set_timestamp_millis(int64_t value);
  public:

  // string json = 6;
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.meta.MailboxMessage)
 private:
  class _Internal;
  void set_has_json();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
    uint64_t id_;
    int64_t timestamp_millis_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool HeartbeatRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& HeartbeatRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& HeartbeatRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.header)
  return _internal_header();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.header)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.header)
}

// .greptime.v1.meta.Peer peer = 2;
inline bool HeartbeatRequest::_internal_has_peer() const {
  return this != internal_default_instance() && _impl_.peer_ != nullptr;
}
inline bool HeartbeatRequest::has_peer() const {
  return _internal_has_peer();
}
inline const ::greptime::v1::meta::Peer& HeartbeatRequest::_internal_peer() const {
  const ::greptime::v1::meta::Peer* p = _impl_.peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Peer&>(
      ::greptime::v1::meta::_Peer_default_instance_);
}
inline const ::greptime::v1::meta::Peer& HeartbeatRequest::peer() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.peer)
  return _internal_peer();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_peer(
    ::greptime::v1::meta::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  _impl_.peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.peer)
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::release_peer() {
  
  ::greptime::v1::meta::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.peer)
  
  ::greptime::v1::meta::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::_internal_mutable_peer() {
  
  if (_impl_.peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Peer>(GetArenaForAllocation());
    _impl_.peer_ = p;
  }
  return _impl_.peer_;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::mutable_peer() {
  ::greptime::v1::meta::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.peer)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_peer(::greptime::v1::meta::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.peer)
}

// .greptime.v1.meta.TimeInterval report_interval = 3;
inline bool HeartbeatRequest::_internal_has_report_interval() const {
  return this != internal_default_instance() && _impl_.report_interval_ != nullptr;
}
inline bool HeartbeatRequest::has_report_interval() const {
  return _internal_has_report_interval();
}
inline const ::greptime::v1::meta::TimeInterval& HeartbeatRequest::_internal_report_interval() const {
  const ::greptime::v1::meta::TimeInterval* p = _impl_.report_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TimeInterval&>(
      ::greptime::v1::meta::_TimeInterval_default_instance_);
}
inline const ::greptime::v1::meta::TimeInterval& HeartbeatRequest::report_interval() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.report_interval)
  return _internal_report_interval();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_report_interval(
    ::greptime::v1::meta::TimeInterval* report_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_interval_);
  }
  _impl_.report_interval_ = report_interval;
  if (report_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.report_interval)
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::release_report_interval() {
  
  ::greptime::v1::meta::TimeInterval* temp = _impl_.report_interval_;
  _impl_.report_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::unsafe_arena_release_report_interval() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.report_interval)
  
  ::greptime::v1::meta::TimeInterval* temp = _impl_.report_interval_;
  _impl_.report_interval_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::_internal_mutable_report_interval() {
  
  if (_impl_.report_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TimeInterval>(GetArenaForAllocation());
    _impl_.report_interval_ = p;
  }
  return _impl_.report_interval_;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::mutable_report_interval() {
  ::greptime::v1::meta::TimeInterval* _msg = _internal_mutable_report_interval();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.report_interval)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_report_interval(::greptime::v1::meta::TimeInterval* report_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_interval_);
  }
  if (report_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_interval));
    if (message_arena != submessage_arena) {
      report_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report_interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.report_interval_ = report_interval;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.report_interval)
}

// .greptime.v1.meta.NodeStat node_stat = 4;
inline bool HeartbeatRequest::_internal_has_node_stat() const {
  return this != internal_default_instance() && _impl_.node_stat_ != nullptr;
}
inline bool HeartbeatRequest::has_node_stat() const {
  return _internal_has_node_stat();
}
inline void HeartbeatRequest::clear_node_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.node_stat_ != nullptr) {
    delete _impl_.node_stat_;
  }
  _impl_.node_stat_ = nullptr;
}
inline const ::greptime::v1::meta::NodeStat& HeartbeatRequest::_internal_node_stat() const {
  const ::greptime::v1::meta::NodeStat* p = _impl_.node_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::NodeStat&>(
      ::greptime::v1::meta::_NodeStat_default_instance_);
}
inline const ::greptime::v1::meta::NodeStat& HeartbeatRequest::node_stat() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.node_stat)
  return _internal_node_stat();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_node_stat(
    ::greptime::v1::meta::NodeStat* node_stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.node_stat_);
  }
  _impl_.node_stat_ = node_stat;
  if (node_stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.node_stat)
}
inline ::greptime::v1::meta::NodeStat* HeartbeatRequest::release_node_stat() {
  
  ::greptime::v1::meta::NodeStat* temp = _impl_.node_stat_;
  _impl_.node_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::NodeStat* HeartbeatRequest::unsafe_arena_release_node_stat() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.node_stat)
  
  ::greptime::v1::meta::NodeStat* temp = _impl_.node_stat_;
  _impl_.node_stat_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::NodeStat* HeartbeatRequest::_internal_mutable_node_stat() {
  
  if (_impl_.node_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::NodeStat>(GetArenaForAllocation());
    _impl_.node_stat_ = p;
  }
  return _impl_.node_stat_;
}
inline ::greptime::v1::meta::NodeStat* HeartbeatRequest::mutable_node_stat() {
  ::greptime::v1::meta::NodeStat* _msg = _internal_mutable_node_stat();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.node_stat)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_node_stat(::greptime::v1::meta::NodeStat* node_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.node_stat_;
  }
  if (node_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node_stat);
    if (message_arena != submessage_arena) {
      node_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.node_stat_ = node_stat;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.node_stat)
}

// repeated .greptime.v1.meta.RegionStat region_stats = 5;
inline int HeartbeatRequest::_internal_region_stats_size() const {
  return _impl_.region_stats_.size();
}
inline int HeartbeatRequest::region_stats_size() const {
  return _internal_region_stats_size();
}
inline void HeartbeatRequest::clear_region_stats() {
  _impl_.region_stats_.Clear();
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::mutable_region_stats(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _impl_.region_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >*
HeartbeatRequest::mutable_region_stats() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.HeartbeatRequest.region_stats)
  return &_impl_.region_stats_;
}
inline const ::greptime::v1::meta::RegionStat& HeartbeatRequest::_internal_region_stats(int index) const {
  return _impl_.region_stats_.Get(index);
}
inline const ::greptime::v1::meta::RegionStat& HeartbeatRequest::region_stats(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _internal_region_stats(index);
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::_internal_add_region_stats() {
  return _impl_.region_stats_.Add();
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::add_region_stats() {
  ::greptime::v1::meta::RegionStat* _add = _internal_add_region_stats();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >&
HeartbeatRequest::region_stats() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _impl_.region_stats_;
}

// .greptime.v1.meta.MailboxMessage mailbox_message = 6;
inline bool HeartbeatRequest::_internal_has_mailbox_message() const {
  return this != internal_default_instance() && _impl_.mailbox_message_ != nullptr;
}
inline bool HeartbeatRequest::has_mailbox_message() const {
  return _internal_has_mailbox_message();
}
inline void HeartbeatRequest::clear_mailbox_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.mailbox_message_ != nullptr) {
    delete _impl_.mailbox_message_;
  }
  _impl_.mailbox_message_ = nullptr;
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatRequest::_internal_mailbox_message() const {
  const ::greptime::v1::meta::MailboxMessage* p = _impl_.mailbox_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::MailboxMessage&>(
      ::greptime::v1::meta::_MailboxMessage_default_instance_);
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatRequest::mailbox_message() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  return _internal_mailbox_message();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_mailbox_message(
    ::greptime::v1::meta::MailboxMessage* mailbox_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_message_);
  }
  _impl_.mailbox_message_ = mailbox_message;
  if (mailbox_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.mailbox_message)
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::release_mailbox_message() {
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::unsafe_arena_release_mailbox_message() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::_internal_mutable_mailbox_message() {
  
  if (_impl_.mailbox_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(GetArenaForAllocation());
    _impl_.mailbox_message_ = p;
  }
  return _impl_.mailbox_message_;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::mutable_mailbox_message() {
  ::greptime::v1::meta::MailboxMessage* _msg = _internal_mutable_mailbox_message();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mailbox_message_;
  }
  if (mailbox_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mailbox_message);
    if (message_arena != submessage_arena) {
      mailbox_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_message_ = mailbox_message;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.mailbox_message)
}

// uint64 duration_since_epoch = 7;
inline void HeartbeatRequest::clear_duration_since_epoch() {
  _impl_.duration_since_epoch_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_duration_since_epoch() const {
  return _impl_.duration_since_epoch_;
}
inline uint64_t HeartbeatRequest::duration_since_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.duration_since_epoch)
  return _internal_duration_since_epoch();
}
inline void HeartbeatRequest::_internal_set_duration_since_epoch(uint64_t value) {
  
  _impl_.duration_since_epoch_ = value;
}
inline void HeartbeatRequest::set_duration_since_epoch(uint64_t value) {
  _internal_set_duration_since_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.HeartbeatRequest.duration_since_epoch)
}

// uint64 node_epoch = 8;
inline void HeartbeatRequest::clear_node_epoch() {
  _impl_.node_epoch_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_node_epoch() const {
  return _impl_.node_epoch_;
}
inline uint64_t HeartbeatRequest::node_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.node_epoch)
  return _internal_node_epoch();
}
inline void HeartbeatRequest::_internal_set_node_epoch(uint64_t value) {
  
  _impl_.node_epoch_ = value;
}
inline void HeartbeatRequest::set_node_epoch(uint64_t value) {
  _internal_set_node_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.HeartbeatRequest.node_epoch)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeStat

// int64 rcus = 1;
inline void NodeStat::clear_rcus() {
  _impl_.rcus_ = int64_t{0};
}
inline int64_t NodeStat::_internal_rcus() const {
  return _impl_.rcus_;
}
inline int64_t NodeStat::rcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeStat.rcus)
  return _internal_rcus();
}
inline void NodeStat::_internal_set_rcus(int64_t value) {
  
  _impl_.rcus_ = value;
}
inline void NodeStat::set_rcus(int64_t value) {
  _internal_set_rcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeStat.rcus)
}

// int64 wcus = 2;
inline void NodeStat::clear_wcus() {
  _impl_.wcus_ = int64_t{0};
}
inline int64_t NodeStat::_internal_wcus() const {
  return _impl_.wcus_;
}
inline int64_t NodeStat::wcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeStat.wcus)
  return _internal_wcus();
}
inline void NodeStat::_internal_set_wcus(int64_t value) {
  
  _impl_.wcus_ = value;
}
inline void NodeStat::set_wcus(int64_t value) {
  _internal_set_wcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeStat.wcus)
}

// int64 table_num = 3;
inline void NodeStat::clear_table_num() {
  _impl_.table_num_ = int64_t{0};
}
inline int64_t NodeStat::_internal_table_num() const {
  return _impl_.table_num_;
}
inline int64_t NodeStat::table_num() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeStat.table_num)
  return _internal_table_num();
}
inline void NodeStat::_internal_set_table_num(int64_t value) {
  
  _impl_.table_num_ = value;
}
inline void NodeStat::set_table_num(int64_t value) {
  _internal_set_table_num(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeStat.table_num)
}

// int64 region_num = 4;
inline void NodeStat::clear_region_num() {
  _impl_.region_num_ = int64_t{0};
}
inline int64_t NodeStat::_internal_region_num() const {
  return _impl_.region_num_;
}
inline int64_t NodeStat::region_num() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeStat.region_num)
  return _internal_region_num();
}
inline void NodeStat::_internal_set_region_num(int64_t value) {
  
  _impl_.region_num_ = value;
}
inline void NodeStat::set_region_num(int64_t value) {
  _internal_set_region_num(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeStat.region_num)
}

// map<string, string> attrs = 100;
inline int NodeStat::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int NodeStat::attrs_size() const {
  return _internal_attrs_size();
}
inline void NodeStat::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStat::_internal_attrs() const {
  return _impl_.attrs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStat::attrs() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.NodeStat.attrs)
  return _internal_attrs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStat::_internal_mutable_attrs() {
  return _impl_.attrs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStat::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.NodeStat.attrs)
  return _internal_mutable_attrs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RegionStat

// uint64 region_id = 1;
inline void RegionStat::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t RegionStat::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t RegionStat::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.region_id)
  return _internal_region_id();
}
inline void RegionStat::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void RegionStat::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.region_id)
}

// .greptime.v1.meta.TableIdent table_ident = 2;
inline bool RegionStat::_internal_has_table_ident() const {
  return this != internal_default_instance() && _impl_.table_ident_ != nullptr;
}
inline bool RegionStat::has_table_ident() const {
  return _internal_has_table_ident();
}
inline const ::greptime::v1::meta::TableIdent& RegionStat::_internal_table_ident() const {
  const ::greptime::v1::meta::TableIdent* p = _impl_.table_ident_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableIdent&>(
      ::greptime::v1::meta::_TableIdent_default_instance_);
}
inline const ::greptime::v1::meta::TableIdent& RegionStat::table_ident() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.table_ident)
  return _internal_table_ident();
}
inline void RegionStat::unsafe_arena_set_allocated_table_ident(
    ::greptime::v1::meta::TableIdent* table_ident) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_ident_);
  }
  _impl_.table_ident_ = table_ident;
  if (table_ident) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RegionStat.table_ident)
}
inline ::greptime::v1::meta::TableIdent* RegionStat::release_table_ident() {
  
  ::greptime::v1::meta::TableIdent* temp = _impl_.table_ident_;
  _impl_.table_ident_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableIdent* RegionStat::unsafe_arena_release_table_ident() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RegionStat.table_ident)
  
  ::greptime::v1::meta::TableIdent* temp = _impl_.table_ident_;
  _impl_.table_ident_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableIdent* RegionStat::_internal_mutable_table_ident() {
  
  if (_impl_.table_ident_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableIdent>(GetArenaForAllocation());
    _impl_.table_ident_ = p;
  }
  return _impl_.table_ident_;
}
inline ::greptime::v1::meta::TableIdent* RegionStat::mutable_table_ident() {
  ::greptime::v1::meta::TableIdent* _msg = _internal_mutable_table_ident();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionStat.table_ident)
  return _msg;
}
inline void RegionStat::set_allocated_table_ident(::greptime::v1::meta::TableIdent* table_ident) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_ident_);
  }
  if (table_ident) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_ident));
    if (message_arena != submessage_arena) {
      table_ident = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_ident, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_ident_ = table_ident;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RegionStat.table_ident)
}

// int64 rcus = 3;
inline void RegionStat::clear_rcus() {
  _impl_.rcus_ = int64_t{0};
}
inline int64_t RegionStat::_internal_rcus() const {
  return _impl_.rcus_;
}
inline int64_t RegionStat::rcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.rcus)
  return _internal_rcus();
}
inline void RegionStat::_internal_set_rcus(int64_t value) {
  
  _impl_.rcus_ = value;
}
inline void RegionStat::set_rcus(int64_t value) {
  _internal_set_rcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.rcus)
}

// int64 wcus = 4;
inline void RegionStat::clear_wcus() {
  _impl_.wcus_ = int64_t{0};
}
inline int64_t RegionStat::_internal_wcus() const {
  return _impl_.wcus_;
}
inline int64_t RegionStat::wcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.wcus)
  return _internal_wcus();
}
inline void RegionStat::_internal_set_wcus(int64_t value) {
  
  _impl_.wcus_ = value;
}
inline void RegionStat::set_wcus(int64_t value) {
  _internal_set_wcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.wcus)
}

// int64 approximate_bytes = 5;
inline void RegionStat::clear_approximate_bytes() {
  _impl_.approximate_bytes_ = int64_t{0};
}
inline int64_t RegionStat::_internal_approximate_bytes() const {
  return _impl_.approximate_bytes_;
}
inline int64_t RegionStat::approximate_bytes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.approximate_bytes)
  return _internal_approximate_bytes();
}
inline void RegionStat::_internal_set_approximate_bytes(int64_t value) {
  
  _impl_.approximate_bytes_ = value;
}
inline void RegionStat::set_approximate_bytes(int64_t value) {
  _internal_set_approximate_bytes(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.approximate_bytes)
}

// int64 approximate_rows = 6;
inline void RegionStat::clear_approximate_rows() {
  _impl_.approximate_rows_ = int64_t{0};
}
inline int64_t RegionStat::_internal_approximate_rows() const {
  return _impl_.approximate_rows_;
}
inline int64_t RegionStat::approximate_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.approximate_rows)
  return _internal_approximate_rows();
}
inline void RegionStat::_internal_set_approximate_rows(int64_t value) {
  
  _impl_.approximate_rows_ = value;
}
inline void RegionStat::set_approximate_rows(int64_t value) {
  _internal_set_approximate_rows(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.approximate_rows)
}

// map<string, string> attrs = 100;
inline int RegionStat::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int RegionStat::attrs_size() const {
  return _internal_attrs_size();
}
inline void RegionStat::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionStat::_internal_attrs() const {
  return _impl_.attrs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionStat::attrs() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.RegionStat.attrs)
  return _internal_attrs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionStat::_internal_mutable_attrs() {
  return _impl_.attrs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionStat::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.RegionStat.attrs)
  return _internal_mutable_attrs();
}

// -------------------------------------------------------------------

// HeartbeatResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool HeartbeatResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& HeartbeatResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& HeartbeatResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.header)
  return _internal_header();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.header)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.header)
}

// .greptime.v1.meta.MailboxMessage mailbox_message = 2;
inline bool HeartbeatResponse::_internal_has_mailbox_message() const {
  return this != internal_default_instance() && _impl_.mailbox_message_ != nullptr;
}
inline bool HeartbeatResponse::has_mailbox_message() const {
  return _internal_has_mailbox_message();
}
inline void HeartbeatResponse::clear_mailbox_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.mailbox_message_ != nullptr) {
    delete _impl_.mailbox_message_;
  }
  _impl_.mailbox_message_ = nullptr;
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatResponse::_internal_mailbox_message() const {
  const ::greptime::v1::meta::MailboxMessage* p = _impl_.mailbox_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::MailboxMessage&>(
      ::greptime::v1::meta::_MailboxMessage_default_instance_);
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatResponse::mailbox_message() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  return _internal_mailbox_message();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_mailbox_message(
    ::greptime::v1::meta::MailboxMessage* mailbox_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_message_);
  }
  _impl_.mailbox_message_ = mailbox_message;
  if (mailbox_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.mailbox_message)
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::release_mailbox_message() {
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::unsafe_arena_release_mailbox_message() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::_internal_mutable_mailbox_message() {
  
  if (_impl_.mailbox_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(GetArenaForAllocation());
    _impl_.mailbox_message_ = p;
  }
  return _impl_.mailbox_message_;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::mutable_mailbox_message() {
  ::greptime::v1::meta::MailboxMessage* _msg = _internal_mutable_mailbox_message();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mailbox_message_;
  }
  if (mailbox_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mailbox_message);
    if (message_arena != submessage_arena) {
      mailbox_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_message_ = mailbox_message;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.mailbox_message)
}

// repeated .greptime.v1.meta.RegionLease region_leases = 3;
inline int HeartbeatResponse::_internal_region_leases_size() const {
  return _impl_.region_leases_.size();
}
inline int HeartbeatResponse::region_leases_size() const {
  return _internal_region_leases_size();
}
inline void HeartbeatResponse::clear_region_leases() {
  _impl_.region_leases_.Clear();
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::mutable_region_leases(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.region_leases)
  return _impl_.region_leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionLease >*
HeartbeatResponse::mutable_region_leases() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.HeartbeatResponse.region_leases)
  return &_impl_.region_leases_;
}
inline const ::greptime::v1::meta::RegionLease& HeartbeatResponse::_internal_region_leases(int index) const {
  return _impl_.region_leases_.Get(index);
}
inline const ::greptime::v1::meta::RegionLease& HeartbeatResponse::region_leases(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.region_leases)
  return _internal_region_leases(index);
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::_internal_add_region_leases() {
  return _impl_.region_leases_.Add();
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::add_region_leases() {
  ::greptime::v1::meta::RegionLease* _add = _internal_add_region_leases();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.HeartbeatResponse.region_leases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionLease >&
HeartbeatResponse::region_leases() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.HeartbeatResponse.region_leases)
  return _impl_.region_leases_;
}

// -------------------------------------------------------------------

// RegionLease

// .greptime.v1.meta.TableIdent table_ident = 1;
inline bool RegionLease::_internal_has_table_ident() const {
  return this != internal_default_instance() && _impl_.table_ident_ != nullptr;
}
inline bool RegionLease::has_table_ident() const {
  return _internal_has_table_ident();
}
inline const ::greptime::v1::meta::TableIdent& RegionLease::_internal_table_ident() const {
  const ::greptime::v1::meta::TableIdent* p = _impl_.table_ident_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableIdent&>(
      ::greptime::v1::meta::_TableIdent_default_instance_);
}
inline const ::greptime::v1::meta::TableIdent& RegionLease::table_ident() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.table_ident)
  return _internal_table_ident();
}
inline void RegionLease::unsafe_arena_set_allocated_table_ident(
    ::greptime::v1::meta::TableIdent* table_ident) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_ident_);
  }
  _impl_.table_ident_ = table_ident;
  if (table_ident) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RegionLease.table_ident)
}
inline ::greptime::v1::meta::TableIdent* RegionLease::release_table_ident() {
  
  ::greptime::v1::meta::TableIdent* temp = _impl_.table_ident_;
  _impl_.table_ident_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableIdent* RegionLease::unsafe_arena_release_table_ident() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RegionLease.table_ident)
  
  ::greptime::v1::meta::TableIdent* temp = _impl_.table_ident_;
  _impl_.table_ident_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableIdent* RegionLease::_internal_mutable_table_ident() {
  
  if (_impl_.table_ident_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableIdent>(GetArenaForAllocation());
    _impl_.table_ident_ = p;
  }
  return _impl_.table_ident_;
}
inline ::greptime::v1::meta::TableIdent* RegionLease::mutable_table_ident() {
  ::greptime::v1::meta::TableIdent* _msg = _internal_mutable_table_ident();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionLease.table_ident)
  return _msg;
}
inline void RegionLease::set_allocated_table_ident(::greptime::v1::meta::TableIdent* table_ident) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_ident_);
  }
  if (table_ident) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_ident));
    if (message_arena != submessage_arena) {
      table_ident = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_ident, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_ident_ = table_ident;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RegionLease.table_ident)
}

// repeated uint32 regions = 2;
inline int RegionLease::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int RegionLease::regions_size() const {
  return _internal_regions_size();
}
inline void RegionLease::clear_regions() {
  _impl_.regions_.Clear();
}
inline uint32_t RegionLease::_internal_regions(int index) const {
  return _impl_.regions_.Get(index);
}
inline uint32_t RegionLease::regions(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.regions)
  return _internal_regions(index);
}
inline void RegionLease::set_regions(int index, uint32_t value) {
  _impl_.regions_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.regions)
}
inline void RegionLease::_internal_add_regions(uint32_t value) {
  _impl_.regions_.Add(value);
}
inline void RegionLease::add_regions(uint32_t value) {
  _internal_add_regions(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RegionLease.regions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RegionLease::_internal_regions() const {
  return _impl_.regions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
RegionLease::regions() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RegionLease.regions)
  return _internal_regions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RegionLease::_internal_mutable_regions() {
  return &_impl_.regions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
RegionLease::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RegionLease.regions)
  return _internal_mutable_regions();
}

// uint64 duration_since_epoch = 3;
inline void RegionLease::clear_duration_since_epoch() {
  _impl_.duration_since_epoch_ = uint64_t{0u};
}
inline uint64_t RegionLease::_internal_duration_since_epoch() const {
  return _impl_.duration_since_epoch_;
}
inline uint64_t RegionLease::duration_since_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.duration_since_epoch)
  return _internal_duration_since_epoch();
}
inline void RegionLease::_internal_set_duration_since_epoch(uint64_t value) {
  
  _impl_.duration_since_epoch_ = value;
}
inline void RegionLease::set_duration_since_epoch(uint64_t value) {
  _internal_set_duration_since_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.duration_since_epoch)
}

// uint64 lease_seconds = 4;
inline void RegionLease::clear_lease_seconds() {
  _impl_.lease_seconds_ = uint64_t{0u};
}
inline uint64_t RegionLease::_internal_lease_seconds() const {
  return _impl_.lease_seconds_;
}
inline uint64_t RegionLease::lease_seconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.lease_seconds)
  return _internal_lease_seconds();
}
inline void RegionLease::_internal_set_lease_seconds(uint64_t value) {
  
  _impl_.lease_seconds_ = value;
}
inline void RegionLease::set_lease_seconds(uint64_t value) {
  _internal_set_lease_seconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.lease_seconds)
}

// -------------------------------------------------------------------

// AskLeaderRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool AskLeaderRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AskLeaderRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& AskLeaderRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& AskLeaderRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderRequest.header)
  return _internal_header();
}
inline void AskLeaderRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderRequest.header)
  return _msg;
}
inline void AskLeaderRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderRequest.header)
}

// -------------------------------------------------------------------

// AskLeaderResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool AskLeaderResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AskLeaderResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& AskLeaderResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& AskLeaderResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderResponse.header)
  return _internal_header();
}
inline void AskLeaderResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderResponse.header)
  return _msg;
}
inline void AskLeaderResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderResponse.header)
}

// .greptime.v1.meta.Peer leader = 2;
inline bool AskLeaderResponse::_internal_has_leader() const {
  return this != internal_default_instance() && _impl_.leader_ != nullptr;
}
inline bool AskLeaderResponse::has_leader() const {
  return _internal_has_leader();
}
inline const ::greptime::v1::meta::Peer& AskLeaderResponse::_internal_leader() const {
  const ::greptime::v1::meta::Peer* p = _impl_.leader_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Peer&>(
      ::greptime::v1::meta::_Peer_default_instance_);
}
inline const ::greptime::v1::meta::Peer& AskLeaderResponse::leader() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderResponse.leader)
  return _internal_leader();
}
inline void AskLeaderResponse::unsafe_arena_set_allocated_leader(
    ::greptime::v1::meta::Peer* leader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  _impl_.leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderResponse.leader)
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::release_leader() {
  
  ::greptime::v1::meta::Peer* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderResponse.leader)
  
  ::greptime::v1::meta::Peer* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::_internal_mutable_leader() {
  
  if (_impl_.leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Peer>(GetArenaForAllocation());
    _impl_.leader_ = p;
  }
  return _impl_.leader_;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::mutable_leader() {
  ::greptime::v1::meta::Peer* _msg = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderResponse.leader)
  return _msg;
}
inline void AskLeaderResponse::set_allocated_leader(::greptime::v1::meta::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader));
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderResponse.leader)
}

// -------------------------------------------------------------------

// MailboxMessage

// uint64 id = 1;
inline void MailboxMessage::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t MailboxMessage::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t MailboxMessage::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.id)
  return _internal_id();
}
inline void MailboxMessage::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void MailboxMessage::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.id)
}

// string subject = 2;
inline void MailboxMessage::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& MailboxMessage::subject() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.subject)
}
inline std::string* MailboxMessage::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.subject)
  return _s;
}
inline const std::string& MailboxMessage::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void MailboxMessage::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_subject() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.subject)
  return _impl_.subject_.Release();
}
inline void MailboxMessage::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.subject)
}

// string from = 3;
inline void MailboxMessage::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& MailboxMessage::from() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.from)
}
inline std::string* MailboxMessage::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.from)
  return _s;
}
inline const std::string& MailboxMessage::_internal_from() const {
  return _impl_.from_.Get();
}
inline void MailboxMessage::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_from() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.from)
  return _impl_.from_.Release();
}
inline void MailboxMessage::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.from)
}

// string to = 4;
inline void MailboxMessage::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& MailboxMessage::to() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.to)
}
inline std::string* MailboxMessage::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.to)
  return _s;
}
inline const std::string& MailboxMessage::_internal_to() const {
  return _impl_.to_.Get();
}
inline void MailboxMessage::_internal_set_to(const std::string& value) {
  
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_to() {
  
  return _impl_.to_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_to() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.to)
  return _impl_.to_.Release();
}
inline void MailboxMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  _impl_.to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.to)
}

// int64 timestamp_millis = 5;
inline void MailboxMessage::clear_timestamp_millis() {
  _impl_.timestamp_millis_ = int64_t{0};
}
inline int64_t MailboxMessage::_internal_timestamp_millis() const {
  return _impl_.timestamp_millis_;
}
inline int64_t MailboxMessage::timestamp_millis() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.timestamp_millis)
  return _internal_timestamp_millis();
}
inline void MailboxMessage::_internal_set_timestamp_millis(int64_t value) {
  
  _impl_.timestamp_millis_ = value;
}
inline void MailboxMessage::set_timestamp_millis(int64_t value) {
  _internal_set_timestamp_millis(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.timestamp_millis)
}

// string json = 6;
inline bool MailboxMessage::_internal_has_json() const {
  return payload_case() == kJson;
}
inline bool MailboxMessage::has_json() const {
  return _internal_has_json();
}
inline void MailboxMessage::set_has_json() {
  _impl_._oneof_case_[0] = kJson;
}
inline void MailboxMessage::clear_json() {
  if (_internal_has_json()) {
    _impl_.payload_.json_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& MailboxMessage::json() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline void MailboxMessage::set_json(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  _impl_.payload_.json_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.json)
}
inline std::string* MailboxMessage::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.json)
  return _s;
}
inline const std::string& MailboxMessage::_internal_json() const {
  if (_internal_has_json()) {
    return _impl_.payload_.json_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MailboxMessage::_internal_set_json(const std::string& value) {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  _impl_.payload_.json_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  return _impl_.payload_.json_.Mutable(      GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_json() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.json)
  if (_internal_has_json()) {
    clear_has_payload();
    return _impl_.payload_.json_.Release();
  } else {
    return nullptr;
  }
}
inline void MailboxMessage::set_allocated_json(std::string* json) {
  if (has_payload()) {
    clear_payload();
  }
  if (json != nullptr) {
    set_has_json();
    _impl_.payload_.json_.InitAllocated(json, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.json)
}

inline bool MailboxMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MailboxMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MailboxMessage::PayloadCase MailboxMessage::payload_case() const {
  return MailboxMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto
