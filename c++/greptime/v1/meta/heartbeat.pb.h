// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/heartbeat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/meta/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fmeta_2fheartbeat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
namespace greptime {
namespace v1 {
namespace meta {
class AskLeaderRequest;
struct AskLeaderRequestDefaultTypeInternal;
extern AskLeaderRequestDefaultTypeInternal _AskLeaderRequest_default_instance_;
class AskLeaderResponse;
struct AskLeaderResponseDefaultTypeInternal;
extern AskLeaderResponseDefaultTypeInternal _AskLeaderResponse_default_instance_;
class DatanodeWorkloads;
struct DatanodeWorkloadsDefaultTypeInternal;
extern DatanodeWorkloadsDefaultTypeInternal _DatanodeWorkloads_default_instance_;
class FlowStat;
struct FlowStatDefaultTypeInternal;
extern FlowStatDefaultTypeInternal _FlowStat_default_instance_;
class FlowStat_FlowLastExecTimeMapEntry_DoNotUse;
struct FlowStat_FlowLastExecTimeMapEntry_DoNotUseDefaultTypeInternal;
extern FlowStat_FlowLastExecTimeMapEntry_DoNotUseDefaultTypeInternal _FlowStat_FlowLastExecTimeMapEntry_DoNotUse_default_instance_;
class FlowStat_FlowStatSizeEntry_DoNotUse;
struct FlowStat_FlowStatSizeEntry_DoNotUseDefaultTypeInternal;
extern FlowStat_FlowStatSizeEntry_DoNotUseDefaultTypeInternal _FlowStat_FlowStatSizeEntry_DoNotUse_default_instance_;
class FlownodeWorkloads;
struct FlownodeWorkloadsDefaultTypeInternal;
extern FlownodeWorkloadsDefaultTypeInternal _FlownodeWorkloads_default_instance_;
class FrontendWorkloads;
struct FrontendWorkloadsDefaultTypeInternal;
extern FrontendWorkloadsDefaultTypeInternal _FrontendWorkloads_default_instance_;
class GrantedRegion;
struct GrantedRegionDefaultTypeInternal;
extern GrantedRegionDefaultTypeInternal _GrantedRegion_default_instance_;
class GrantedRegion_ExtensionsEntry_DoNotUse;
struct GrantedRegion_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern GrantedRegion_ExtensionsEntry_DoNotUseDefaultTypeInternal _GrantedRegion_ExtensionsEntry_DoNotUse_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class MailboxMessage;
struct MailboxMessageDefaultTypeInternal;
extern MailboxMessageDefaultTypeInternal _MailboxMessage_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class RegionLease;
struct RegionLeaseDefaultTypeInternal;
extern RegionLeaseDefaultTypeInternal _RegionLease_default_instance_;
class RegionStat;
struct RegionStatDefaultTypeInternal;
extern RegionStatDefaultTypeInternal _RegionStat_default_instance_;
class RegionStat_ExtensionsEntry_DoNotUse;
struct RegionStat_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern RegionStat_ExtensionsEntry_DoNotUseDefaultTypeInternal _RegionStat_ExtensionsEntry_DoNotUse_default_instance_;
class TopicStat;
struct TopicStatDefaultTypeInternal;
extern TopicStatDefaultTypeInternal _TopicStat_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::meta::AskLeaderRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::AskLeaderRequest>(Arena*);
template<> ::greptime::v1::meta::AskLeaderResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::AskLeaderResponse>(Arena*);
template<> ::greptime::v1::meta::DatanodeWorkloads* Arena::CreateMaybeMessage<::greptime::v1::meta::DatanodeWorkloads>(Arena*);
template<> ::greptime::v1::meta::FlowStat* Arena::CreateMaybeMessage<::greptime::v1::meta::FlowStat>(Arena*);
template<> ::greptime::v1::meta::FlowStat_FlowLastExecTimeMapEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::FlowStat_FlowLastExecTimeMapEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::FlowStat_FlowStatSizeEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::FlowStat_FlowStatSizeEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::FlownodeWorkloads* Arena::CreateMaybeMessage<::greptime::v1::meta::FlownodeWorkloads>(Arena*);
template<> ::greptime::v1::meta::FrontendWorkloads* Arena::CreateMaybeMessage<::greptime::v1::meta::FrontendWorkloads>(Arena*);
template<> ::greptime::v1::meta::GrantedRegion* Arena::CreateMaybeMessage<::greptime::v1::meta::GrantedRegion>(Arena*);
template<> ::greptime::v1::meta::GrantedRegion_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::GrantedRegion_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::HeartbeatRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::HeartbeatRequest>(Arena*);
template<> ::greptime::v1::meta::HeartbeatResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::HeartbeatResponse>(Arena*);
template<> ::greptime::v1::meta::MailboxMessage* Arena::CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(Arena*);
template<> ::greptime::v1::meta::NodeInfo* Arena::CreateMaybeMessage<::greptime::v1::meta::NodeInfo>(Arena*);
template<> ::greptime::v1::meta::RegionLease* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionLease>(Arena*);
template<> ::greptime::v1::meta::RegionStat* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionStat>(Arena*);
template<> ::greptime::v1::meta::RegionStat_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionStat_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::TopicStat* Arena::CreateMaybeMessage<::greptime::v1::meta::TopicStat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace meta {

enum RegionRole : int {
  Leader = 0,
  Follower = 1,
  DowngradingLeader = 2,
  RegionRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RegionRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RegionRole_IsValid(int value);
constexpr RegionRole RegionRole_MIN = Leader;
constexpr RegionRole RegionRole_MAX = DowngradingLeader;
constexpr int RegionRole_ARRAYSIZE = RegionRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegionRole_descriptor();
template<typename T>
inline const std::string& RegionRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegionRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegionRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegionRole_descriptor(), enum_t_value);
}
inline bool RegionRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegionRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegionRole>(
    RegionRole_descriptor(), name, value);
}
// ===================================================================

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  enum NodeWorkloadsCase {
    kDatanode = 10,
    kFrontend = 11,
    kFlownode = 12,
    NODE_WORKLOADS_NOT_SET = 0,
  };

  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatRequest& from) {
    HeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionStatsFieldNumber = 4,
    kTopicStatsFieldNumber = 13,
    kHeaderFieldNumber = 1,
    kPeerFieldNumber = 2,
    kReportIntervalFieldNumber = 3,
    kMailboxMessageFieldNumber = 5,
    kInfoFieldNumber = 8,
    kFlowStatFieldNumber = 9,
    kDurationSinceEpochFieldNumber = 6,
    kNodeEpochFieldNumber = 7,
    kDatanodeFieldNumber = 10,
    kFrontendFieldNumber = 11,
    kFlownodeFieldNumber = 12,
  };
  // repeated .greptime.v1.meta.RegionStat region_stats = 4;
  int region_stats_size() const;
  private:
  int _internal_region_stats_size() const;
  public:
  void clear_region_stats();
  ::greptime::v1::meta::RegionStat* mutable_region_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >*
      mutable_region_stats();
  private:
  const ::greptime::v1::meta::RegionStat& _internal_region_stats(int index) const;
  ::greptime::v1::meta::RegionStat* _internal_add_region_stats();
  public:
  const ::greptime::v1::meta::RegionStat& region_stats(int index) const;
  ::greptime::v1::meta::RegionStat* add_region_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >&
      region_stats() const;

  // repeated .greptime.v1.meta.TopicStat topic_stats = 13;
  int topic_stats_size() const;
  private:
  int _internal_topic_stats_size() const;
  public:
  void clear_topic_stats();
  ::greptime::v1::meta::TopicStat* mutable_topic_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TopicStat >*
      mutable_topic_stats();
  private:
  const ::greptime::v1::meta::TopicStat& _internal_topic_stats(int index) const;
  ::greptime::v1::meta::TopicStat* _internal_add_topic_stats();
  public:
  const ::greptime::v1::meta::TopicStat& topic_stats(int index) const;
  ::greptime::v1::meta::TopicStat* add_topic_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TopicStat >&
      topic_stats() const;

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.Peer peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::greptime::v1::meta::Peer& peer() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Peer* release_peer();
  ::greptime::v1::meta::Peer* mutable_peer();
  void set_allocated_peer(::greptime::v1::meta::Peer* peer);
  private:
  const ::greptime::v1::meta::Peer& _internal_peer() const;
  ::greptime::v1::meta::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::greptime::v1::meta::Peer* peer);
  ::greptime::v1::meta::Peer* unsafe_arena_release_peer();

  // .greptime.v1.meta.TimeInterval report_interval = 3;
  bool has_report_interval() const;
  private:
  bool _internal_has_report_interval() const;
  public:
  void clear_report_interval();
  const ::greptime::v1::meta::TimeInterval& report_interval() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TimeInterval* release_report_interval();
  ::greptime::v1::meta::TimeInterval* mutable_report_interval();
  void set_allocated_report_interval(::greptime::v1::meta::TimeInterval* report_interval);
  private:
  const ::greptime::v1::meta::TimeInterval& _internal_report_interval() const;
  ::greptime::v1::meta::TimeInterval* _internal_mutable_report_interval();
  public:
  void unsafe_arena_set_allocated_report_interval(
      ::greptime::v1::meta::TimeInterval* report_interval);
  ::greptime::v1::meta::TimeInterval* unsafe_arena_release_report_interval();

  // .greptime.v1.meta.MailboxMessage mailbox_message = 5;
  bool has_mailbox_message() const;
  private:
  bool _internal_has_mailbox_message() const;
  public:
  void clear_mailbox_message();
  const ::greptime::v1::meta::MailboxMessage& mailbox_message() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::MailboxMessage* release_mailbox_message();
  ::greptime::v1::meta::MailboxMessage* mutable_mailbox_message();
  void set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message);
  private:
  const ::greptime::v1::meta::MailboxMessage& _internal_mailbox_message() const;
  ::greptime::v1::meta::MailboxMessage* _internal_mutable_mailbox_message();
  public:
  void unsafe_arena_set_allocated_mailbox_message(
      ::greptime::v1::meta::MailboxMessage* mailbox_message);
  ::greptime::v1::meta::MailboxMessage* unsafe_arena_release_mailbox_message();

  // .greptime.v1.meta.NodeInfo info = 8;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::greptime::v1::meta::NodeInfo& info() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::NodeInfo* release_info();
  ::greptime::v1::meta::NodeInfo* mutable_info();
  void set_allocated_info(::greptime::v1::meta::NodeInfo* info);
  private:
  const ::greptime::v1::meta::NodeInfo& _internal_info() const;
  ::greptime::v1::meta::NodeInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::greptime::v1::meta::NodeInfo* info);
  ::greptime::v1::meta::NodeInfo* unsafe_arena_release_info();

  // .greptime.v1.meta.FlowStat flow_stat = 9;
  bool has_flow_stat() const;
  private:
  bool _internal_has_flow_stat() const;
  public:
  void clear_flow_stat();
  const ::greptime::v1::meta::FlowStat& flow_stat() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::FlowStat* release_flow_stat();
  ::greptime::v1::meta::FlowStat* mutable_flow_stat();
  void set_allocated_flow_stat(::greptime::v1::meta::FlowStat* flow_stat);
  private:
  const ::greptime::v1::meta::FlowStat& _internal_flow_stat() const;
  ::greptime::v1::meta::FlowStat* _internal_mutable_flow_stat();
  public:
  void unsafe_arena_set_allocated_flow_stat(
      ::greptime::v1::meta::FlowStat* flow_stat);
  ::greptime::v1::meta::FlowStat* unsafe_arena_release_flow_stat();

  // uint64 duration_since_epoch = 6;
  void clear_duration_since_epoch();
  uint64_t duration_since_epoch() const;
  void set_duration_since_epoch(uint64_t value);
  private:
  uint64_t _internal_duration_since_epoch() const;
  void _internal_set_duration_since_epoch(uint64_t value);
  public:

  // uint64 node_epoch = 7;
  void clear_node_epoch();
  uint64_t node_epoch() const;
  void set_node_epoch(uint64_t value);
  private:
  uint64_t _internal_node_epoch() const;
  void _internal_set_node_epoch(uint64_t value);
  public:

  // .greptime.v1.meta.DatanodeWorkloads datanode = 10;
  bool has_datanode() const;
  private:
  bool _internal_has_datanode() const;
  public:
  void clear_datanode();
  const ::greptime::v1::meta::DatanodeWorkloads& datanode() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::DatanodeWorkloads* release_datanode();
  ::greptime::v1::meta::DatanodeWorkloads* mutable_datanode();
  void set_allocated_datanode(::greptime::v1::meta::DatanodeWorkloads* datanode);
  private:
  const ::greptime::v1::meta::DatanodeWorkloads& _internal_datanode() const;
  ::greptime::v1::meta::DatanodeWorkloads* _internal_mutable_datanode();
  public:
  void unsafe_arena_set_allocated_datanode(
      ::greptime::v1::meta::DatanodeWorkloads* datanode);
  ::greptime::v1::meta::DatanodeWorkloads* unsafe_arena_release_datanode();

  // .greptime.v1.meta.FrontendWorkloads frontend = 11;
  bool has_frontend() const;
  private:
  bool _internal_has_frontend() const;
  public:
  void clear_frontend();
  const ::greptime::v1::meta::FrontendWorkloads& frontend() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::FrontendWorkloads* release_frontend();
  ::greptime::v1::meta::FrontendWorkloads* mutable_frontend();
  void set_allocated_frontend(::greptime::v1::meta::FrontendWorkloads* frontend);
  private:
  const ::greptime::v1::meta::FrontendWorkloads& _internal_frontend() const;
  ::greptime::v1::meta::FrontendWorkloads* _internal_mutable_frontend();
  public:
  void unsafe_arena_set_allocated_frontend(
      ::greptime::v1::meta::FrontendWorkloads* frontend);
  ::greptime::v1::meta::FrontendWorkloads* unsafe_arena_release_frontend();

  // .greptime.v1.meta.FlownodeWorkloads flownode = 12;
  bool has_flownode() const;
  private:
  bool _internal_has_flownode() const;
  public:
  void clear_flownode();
  const ::greptime::v1::meta::FlownodeWorkloads& flownode() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::FlownodeWorkloads* release_flownode();
  ::greptime::v1::meta::FlownodeWorkloads* mutable_flownode();
  void set_allocated_flownode(::greptime::v1::meta::FlownodeWorkloads* flownode);
  private:
  const ::greptime::v1::meta::FlownodeWorkloads& _internal_flownode() const;
  ::greptime::v1::meta::FlownodeWorkloads* _internal_mutable_flownode();
  public:
  void unsafe_arena_set_allocated_flownode(
      ::greptime::v1::meta::FlownodeWorkloads* flownode);
  ::greptime::v1::meta::FlownodeWorkloads* unsafe_arena_release_flownode();

  void clear_node_workloads();
  NodeWorkloadsCase node_workloads_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.meta.HeartbeatRequest)
 private:
  class _Internal;
  void set_has_datanode();
  void set_has_frontend();
  void set_has_flownode();

  inline bool has_node_workloads() const;
  inline void clear_has_node_workloads();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat > region_stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TopicStat > topic_stats_;
    ::greptime::v1::meta::RequestHeader* header_;
    ::greptime::v1::meta::Peer* peer_;
    ::greptime::v1::meta::TimeInterval* report_interval_;
    ::greptime::v1::meta::MailboxMessage* mailbox_message_;
    ::greptime::v1::meta::NodeInfo* info_;
    ::greptime::v1::meta::FlowStat* flow_stat_;
    uint64_t duration_since_epoch_;
    uint64_t node_epoch_;
    union NodeWorkloadsUnion {
      constexpr NodeWorkloadsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::meta::DatanodeWorkloads* datanode_;
      ::greptime::v1::meta::FrontendWorkloads* frontend_;
      ::greptime::v1::meta::FlownodeWorkloads* flownode_;
    } node_workloads_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class DatanodeWorkloads final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.DatanodeWorkloads) */ {
 public:
  inline DatanodeWorkloads() : DatanodeWorkloads(nullptr) {}
  ~DatanodeWorkloads() override;
  explicit PROTOBUF_CONSTEXPR DatanodeWorkloads(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatanodeWorkloads(const DatanodeWorkloads& from);
  DatanodeWorkloads(DatanodeWorkloads&& from) noexcept
    : DatanodeWorkloads() {
    *this = ::std::move(from);
  }

  inline DatanodeWorkloads& operator=(const DatanodeWorkloads& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatanodeWorkloads& operator=(DatanodeWorkloads&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatanodeWorkloads& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatanodeWorkloads* internal_default_instance() {
    return reinterpret_cast<const DatanodeWorkloads*>(
               &_DatanodeWorkloads_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DatanodeWorkloads& a, DatanodeWorkloads& b) {
    a.Swap(&b);
  }
  inline void Swap(DatanodeWorkloads* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatanodeWorkloads* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatanodeWorkloads* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatanodeWorkloads>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatanodeWorkloads& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatanodeWorkloads& from) {
    DatanodeWorkloads::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatanodeWorkloads* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.DatanodeWorkloads";
  }
  protected:
  explicit DatanodeWorkloads(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated int32 types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  int32_t _internal_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_types() const;
  void _internal_add_types(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_types();
  public:
  int32_t types(int index) const;
  void set_types(int index, int32_t value);
  void add_types(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.DatanodeWorkloads)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > types_;
    mutable std::atomic<int> _types_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class FrontendWorkloads final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.FrontendWorkloads) */ {
 public:
  inline FrontendWorkloads() : FrontendWorkloads(nullptr) {}
  ~FrontendWorkloads() override;
  explicit PROTOBUF_CONSTEXPR FrontendWorkloads(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrontendWorkloads(const FrontendWorkloads& from);
  FrontendWorkloads(FrontendWorkloads&& from) noexcept
    : FrontendWorkloads() {
    *this = ::std::move(from);
  }

  inline FrontendWorkloads& operator=(const FrontendWorkloads& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrontendWorkloads& operator=(FrontendWorkloads&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrontendWorkloads& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrontendWorkloads* internal_default_instance() {
    return reinterpret_cast<const FrontendWorkloads*>(
               &_FrontendWorkloads_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FrontendWorkloads& a, FrontendWorkloads& b) {
    a.Swap(&b);
  }
  inline void Swap(FrontendWorkloads* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrontendWorkloads* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrontendWorkloads* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrontendWorkloads>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrontendWorkloads& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrontendWorkloads& from) {
    FrontendWorkloads::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrontendWorkloads* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.FrontendWorkloads";
  }
  protected:
  explicit FrontendWorkloads(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated int32 types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  int32_t _internal_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_types() const;
  void _internal_add_types(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_types();
  public:
  int32_t types(int index) const;
  void set_types(int index, int32_t value);
  void add_types(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.FrontendWorkloads)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > types_;
    mutable std::atomic<int> _types_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class FlownodeWorkloads final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.FlownodeWorkloads) */ {
 public:
  inline FlownodeWorkloads() : FlownodeWorkloads(nullptr) {}
  ~FlownodeWorkloads() override;
  explicit PROTOBUF_CONSTEXPR FlownodeWorkloads(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlownodeWorkloads(const FlownodeWorkloads& from);
  FlownodeWorkloads(FlownodeWorkloads&& from) noexcept
    : FlownodeWorkloads() {
    *this = ::std::move(from);
  }

  inline FlownodeWorkloads& operator=(const FlownodeWorkloads& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlownodeWorkloads& operator=(FlownodeWorkloads&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlownodeWorkloads& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlownodeWorkloads* internal_default_instance() {
    return reinterpret_cast<const FlownodeWorkloads*>(
               &_FlownodeWorkloads_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FlownodeWorkloads& a, FlownodeWorkloads& b) {
    a.Swap(&b);
  }
  inline void Swap(FlownodeWorkloads* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlownodeWorkloads* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlownodeWorkloads* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlownodeWorkloads>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlownodeWorkloads& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlownodeWorkloads& from) {
    FlownodeWorkloads::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlownodeWorkloads* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.FlownodeWorkloads";
  }
  protected:
  explicit FlownodeWorkloads(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
  };
  // repeated int32 types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  private:
  int32_t _internal_types(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_types() const;
  void _internal_add_types(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_types();
  public:
  int32_t types(int index) const;
  void set_types(int index, int32_t value);
  void add_types(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.FlownodeWorkloads)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > types_;
    mutable std::atomic<int> _types_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() override;
  explicit PROTOBUF_CONSTEXPR NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInfo& from) {
    NodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kGitCommitFieldNumber = 2,
    kStartTimeMsFieldNumber = 3,
    kMemoryBytesFieldNumber = 5,
    kCpusFieldNumber = 4,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string git_commit = 2;
  void clear_git_commit();
  const std::string& git_commit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_git_commit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_git_commit();
  PROTOBUF_NODISCARD std::string* release_git_commit();
  void set_allocated_git_commit(std::string* git_commit);
  private:
  const std::string& _internal_git_commit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_git_commit(const std::string& value);
  std::string* _internal_mutable_git_commit();
  public:

  // uint64 start_time_ms = 3;
  void clear_start_time_ms();
  uint64_t start_time_ms() const;
  void set_start_time_ms(uint64_t value);
  private:
  uint64_t _internal_start_time_ms() const;
  void _internal_set_start_time_ms(uint64_t value);
  public:

  // uint64 memory_bytes = 5;
  void clear_memory_bytes();
  uint64_t memory_bytes() const;
  void set_memory_bytes(uint64_t value);
  private:
  uint64_t _internal_memory_bytes() const;
  void _internal_set_memory_bytes(uint64_t value);
  public:

  // uint32 cpus = 4;
  void clear_cpus();
  uint32_t cpus() const;
  void set_cpus(uint32_t value);
  private:
  uint32_t _internal_cpus() const;
  void _internal_set_cpus(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr git_commit_;
    uint64_t start_time_ms_;
    uint64_t memory_bytes_;
    uint32_t cpus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class RegionStat_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionStat_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionStat_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  RegionStat_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RegionStat_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RegionStat_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RegionStat_ExtensionsEntry_DoNotUse& other);
  static const RegionStat_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RegionStat_ExtensionsEntry_DoNotUse*>(&_RegionStat_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.RegionStat.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};

// -------------------------------------------------------------------

class RegionStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionStat) */ {
 public:
  inline RegionStat() : RegionStat(nullptr) {}
  ~RegionStat() override;
  explicit PROTOBUF_CONSTEXPR RegionStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionStat(const RegionStat& from);
  RegionStat(RegionStat&& from) noexcept
    : RegionStat() {
    *this = ::std::move(from);
  }

  inline RegionStat& operator=(const RegionStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionStat& operator=(RegionStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionStat* internal_default_instance() {
    return reinterpret_cast<const RegionStat*>(
               &_RegionStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegionStat& a, RegionStat& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionStat& from) {
    RegionStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionStat";
  }
  protected:
  explicit RegionStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 99,
    kEngineFieldNumber = 6,
    kRegionIdFieldNumber = 1,
    kRcusFieldNumber = 2,
    kWcusFieldNumber = 3,
    kApproximateBytesFieldNumber = 4,
    kRoleFieldNumber = 7,
  };
  // map<string, bytes> extensions = 99;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extensions();

  // string engine = 6;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // int64 rcus = 2;
  void clear_rcus();
  int64_t rcus() const;
  void set_rcus(int64_t value);
  private:
  int64_t _internal_rcus() const;
  void _internal_set_rcus(int64_t value);
  public:

  // int64 wcus = 3;
  void clear_wcus();
  int64_t wcus() const;
  void set_wcus(int64_t value);
  private:
  int64_t _internal_wcus() const;
  void _internal_set_wcus(int64_t value);
  public:

  // int64 approximate_bytes = 4;
  void clear_approximate_bytes();
  int64_t approximate_bytes() const;
  void set_approximate_bytes(int64_t value);
  private:
  int64_t _internal_approximate_bytes() const;
  void _internal_set_approximate_bytes(int64_t value);
  public:

  // .greptime.v1.meta.RegionRole role = 7;
  void clear_role();
  ::greptime::v1::meta::RegionRole role() const;
  void set_role(::greptime::v1::meta::RegionRole value);
  private:
  ::greptime::v1::meta::RegionRole _internal_role() const;
  void _internal_set_role(::greptime::v1::meta::RegionRole value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RegionStat_ExtensionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    uint64_t region_id_;
    int64_t rcus_;
    int64_t wcus_;
    int64_t approximate_bytes_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class TopicStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.TopicStat) */ {
 public:
  inline TopicStat() : TopicStat(nullptr) {}
  ~TopicStat() override;
  explicit PROTOBUF_CONSTEXPR TopicStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TopicStat(const TopicStat& from);
  TopicStat(TopicStat&& from) noexcept
    : TopicStat() {
    *this = ::std::move(from);
  }

  inline TopicStat& operator=(const TopicStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicStat& operator=(TopicStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopicStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopicStat* internal_default_instance() {
    return reinterpret_cast<const TopicStat*>(
               &_TopicStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TopicStat& a, TopicStat& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopicStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopicStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopicStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TopicStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TopicStat& from) {
    TopicStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.TopicStat";
  }
  protected:
  explicit TopicStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kRecordSizeFieldNumber = 2,
    kRecordNumFieldNumber = 3,
    kLatestEntryIdFieldNumber = 4,
  };
  // string topic_name = 1;
  void clear_topic_name();
  const std::string& topic_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic_name();
  PROTOBUF_NODISCARD std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // uint64 record_size = 2;
  void clear_record_size();
  uint64_t record_size() const;
  void set_record_size(uint64_t value);
  private:
  uint64_t _internal_record_size() const;
  void _internal_set_record_size(uint64_t value);
  public:

  // uint64 record_num = 3;
  void clear_record_num();
  uint64_t record_num() const;
  void set_record_num(uint64_t value);
  private:
  uint64_t _internal_record_num() const;
  void _internal_set_record_num(uint64_t value);
  public:

  // uint64 latest_entry_id = 4;
  void clear_latest_entry_id();
  uint64_t latest_entry_id() const;
  void set_latest_entry_id(uint64_t value);
  private:
  uint64_t _internal_latest_entry_id() const;
  void _internal_set_latest_entry_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.TopicStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
    uint64_t record_size_;
    uint64_t record_num_;
    uint64_t latest_entry_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class FlowStat_FlowStatSizeEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowStat_FlowStatSizeEntry_DoNotUse, 
    uint32_t, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowStat_FlowStatSizeEntry_DoNotUse, 
    uint32_t, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  FlowStat_FlowStatSizeEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FlowStat_FlowStatSizeEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FlowStat_FlowStatSizeEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FlowStat_FlowStatSizeEntry_DoNotUse& other);
  static const FlowStat_FlowStatSizeEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FlowStat_FlowStatSizeEntry_DoNotUse*>(&_FlowStat_FlowStatSizeEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};

// -------------------------------------------------------------------

class FlowStat_FlowLastExecTimeMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowStat_FlowLastExecTimeMapEntry_DoNotUse, 
    uint32_t, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowStat_FlowLastExecTimeMapEntry_DoNotUse, 
    uint32_t, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  FlowStat_FlowLastExecTimeMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FlowStat_FlowLastExecTimeMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FlowStat_FlowLastExecTimeMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FlowStat_FlowLastExecTimeMapEntry_DoNotUse& other);
  static const FlowStat_FlowLastExecTimeMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FlowStat_FlowLastExecTimeMapEntry_DoNotUse*>(&_FlowStat_FlowLastExecTimeMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};

// -------------------------------------------------------------------

class FlowStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.FlowStat) */ {
 public:
  inline FlowStat() : FlowStat(nullptr) {}
  ~FlowStat() override;
  explicit PROTOBUF_CONSTEXPR FlowStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowStat(const FlowStat& from);
  FlowStat(FlowStat&& from) noexcept
    : FlowStat() {
    *this = ::std::move(from);
  }

  inline FlowStat& operator=(const FlowStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowStat& operator=(FlowStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowStat* internal_default_instance() {
    return reinterpret_cast<const FlowStat*>(
               &_FlowStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FlowStat& a, FlowStat& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowStat& from) {
    FlowStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.FlowStat";
  }
  protected:
  explicit FlowStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFlowStatSizeFieldNumber = 1,
    kFlowLastExecTimeMapFieldNumber = 2,
  };
  // map<uint32, uint64> flow_stat_size = 1;
  int flow_stat_size_size() const;
  private:
  int _internal_flow_stat_size_size() const;
  public:
  void clear_flow_stat_size();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >&
      _internal_flow_stat_size() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >*
      _internal_mutable_flow_stat_size();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >&
      flow_stat_size() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >*
      mutable_flow_stat_size();

  // map<uint32, int64> flow_last_exec_time_map = 2;
  int flow_last_exec_time_map_size() const;
  private:
  int _internal_flow_last_exec_time_map_size() const;
  public:
  void clear_flow_last_exec_time_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >&
      _internal_flow_last_exec_time_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >*
      _internal_mutable_flow_last_exec_time_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >&
      flow_last_exec_time_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >*
      mutable_flow_last_exec_time_map();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.FlowStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FlowStat_FlowStatSizeEntry_DoNotUse,
        uint32_t, uint64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> flow_stat_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FlowStat_FlowLastExecTimeMapEntry_DoNotUse,
        uint32_t, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> flow_last_exec_time_map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatResponse(const HeartbeatResponse& from);
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatResponse& from) {
    HeartbeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.HeartbeatResponse";
  }
  protected:
  explicit HeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMailboxMessageFieldNumber = 2,
    kRegionLeaseFieldNumber = 3,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.MailboxMessage mailbox_message = 2;
  bool has_mailbox_message() const;
  private:
  bool _internal_has_mailbox_message() const;
  public:
  void clear_mailbox_message();
  const ::greptime::v1::meta::MailboxMessage& mailbox_message() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::MailboxMessage* release_mailbox_message();
  ::greptime::v1::meta::MailboxMessage* mutable_mailbox_message();
  void set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message);
  private:
  const ::greptime::v1::meta::MailboxMessage& _internal_mailbox_message() const;
  ::greptime::v1::meta::MailboxMessage* _internal_mutable_mailbox_message();
  public:
  void unsafe_arena_set_allocated_mailbox_message(
      ::greptime::v1::meta::MailboxMessage* mailbox_message);
  ::greptime::v1::meta::MailboxMessage* unsafe_arena_release_mailbox_message();

  // .greptime.v1.meta.RegionLease region_lease = 3;
  bool has_region_lease() const;
  private:
  bool _internal_has_region_lease() const;
  public:
  void clear_region_lease();
  const ::greptime::v1::meta::RegionLease& region_lease() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RegionLease* release_region_lease();
  ::greptime::v1::meta::RegionLease* mutable_region_lease();
  void set_allocated_region_lease(::greptime::v1::meta::RegionLease* region_lease);
  private:
  const ::greptime::v1::meta::RegionLease& _internal_region_lease() const;
  ::greptime::v1::meta::RegionLease* _internal_mutable_region_lease();
  public:
  void unsafe_arena_set_allocated_region_lease(
      ::greptime::v1::meta::RegionLease* region_lease);
  ::greptime::v1::meta::RegionLease* unsafe_arena_release_region_lease();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.HeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::MailboxMessage* mailbox_message_;
    ::greptime::v1::meta::RegionLease* region_lease_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class GrantedRegion_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GrantedRegion_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GrantedRegion_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  GrantedRegion_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR GrantedRegion_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GrantedRegion_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GrantedRegion_ExtensionsEntry_DoNotUse& other);
  static const GrantedRegion_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GrantedRegion_ExtensionsEntry_DoNotUse*>(&_GrantedRegion_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.GrantedRegion.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};

// -------------------------------------------------------------------

class GrantedRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.GrantedRegion) */ {
 public:
  inline GrantedRegion() : GrantedRegion(nullptr) {}
  ~GrantedRegion() override;
  explicit PROTOBUF_CONSTEXPR GrantedRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrantedRegion(const GrantedRegion& from);
  GrantedRegion(GrantedRegion&& from) noexcept
    : GrantedRegion() {
    *this = ::std::move(from);
  }

  inline GrantedRegion& operator=(const GrantedRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrantedRegion& operator=(GrantedRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrantedRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrantedRegion* internal_default_instance() {
    return reinterpret_cast<const GrantedRegion*>(
               &_GrantedRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GrantedRegion& a, GrantedRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(GrantedRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrantedRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrantedRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrantedRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrantedRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrantedRegion& from) {
    GrantedRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrantedRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.GrantedRegion";
  }
  protected:
  explicit GrantedRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 99,
    kRegionIdFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // map<string, bytes> extensions = 99;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extensions();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // .greptime.v1.meta.RegionRole role = 2;
  void clear_role();
  ::greptime::v1::meta::RegionRole role() const;
  void set_role(::greptime::v1::meta::RegionRole value);
  private:
  ::greptime::v1::meta::RegionRole _internal_role() const;
  void _internal_set_role(::greptime::v1::meta::RegionRole value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.GrantedRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GrantedRegion_ExtensionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extensions_;
    uint64_t region_id_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class RegionLease final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionLease) */ {
 public:
  inline RegionLease() : RegionLease(nullptr) {}
  ~RegionLease() override;
  explicit PROTOBUF_CONSTEXPR RegionLease(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionLease(const RegionLease& from);
  RegionLease(RegionLease&& from) noexcept
    : RegionLease() {
    *this = ::std::move(from);
  }

  inline RegionLease& operator=(const RegionLease& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionLease& operator=(RegionLease&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionLease& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionLease* internal_default_instance() {
    return reinterpret_cast<const RegionLease*>(
               &_RegionLease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RegionLease& a, RegionLease& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionLease* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionLease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionLease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionLease>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionLease& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionLease& from) {
    RegionLease::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionLease* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionLease";
  }
  protected:
  explicit RegionLease(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 1,
    kCloseableRegionIdsFieldNumber = 4,
    kDurationSinceEpochFieldNumber = 2,
    kLeaseSecondsFieldNumber = 3,
  };
  // repeated .greptime.v1.meta.GrantedRegion regions = 1;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::greptime::v1::meta::GrantedRegion* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >*
      mutable_regions();
  private:
  const ::greptime::v1::meta::GrantedRegion& _internal_regions(int index) const;
  ::greptime::v1::meta::GrantedRegion* _internal_add_regions();
  public:
  const ::greptime::v1::meta::GrantedRegion& regions(int index) const;
  ::greptime::v1::meta::GrantedRegion* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >&
      regions() const;

  // repeated uint64 closeable_region_ids = 4;
  int closeable_region_ids_size() const;
  private:
  int _internal_closeable_region_ids_size() const;
  public:
  void clear_closeable_region_ids();
  private:
  uint64_t _internal_closeable_region_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_closeable_region_ids() const;
  void _internal_add_closeable_region_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_closeable_region_ids();
  public:
  uint64_t closeable_region_ids(int index) const;
  void set_closeable_region_ids(int index, uint64_t value);
  void add_closeable_region_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      closeable_region_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_closeable_region_ids();

  // uint64 duration_since_epoch = 2;
  void clear_duration_since_epoch();
  uint64_t duration_since_epoch() const;
  void set_duration_since_epoch(uint64_t value);
  private:
  uint64_t _internal_duration_since_epoch() const;
  void _internal_set_duration_since_epoch(uint64_t value);
  public:

  // uint64 lease_seconds = 3;
  void clear_lease_seconds();
  uint64_t lease_seconds() const;
  void set_lease_seconds(uint64_t value);
  private:
  uint64_t _internal_lease_seconds() const;
  void _internal_set_lease_seconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionLease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion > regions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > closeable_region_ids_;
    mutable std::atomic<int> _closeable_region_ids_cached_byte_size_;
    uint64_t duration_since_epoch_;
    uint64_t lease_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class AskLeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.AskLeaderRequest) */ {
 public:
  inline AskLeaderRequest() : AskLeaderRequest(nullptr) {}
  ~AskLeaderRequest() override;
  explicit PROTOBUF_CONSTEXPR AskLeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskLeaderRequest(const AskLeaderRequest& from);
  AskLeaderRequest(AskLeaderRequest&& from) noexcept
    : AskLeaderRequest() {
    *this = ::std::move(from);
  }

  inline AskLeaderRequest& operator=(const AskLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaderRequest& operator=(AskLeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const AskLeaderRequest*>(
               &_AskLeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AskLeaderRequest& a, AskLeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AskLeaderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskLeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AskLeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AskLeaderRequest& from) {
    AskLeaderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskLeaderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.AskLeaderRequest";
  }
  protected:
  explicit AskLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.AskLeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class AskLeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.AskLeaderResponse) */ {
 public:
  inline AskLeaderResponse() : AskLeaderResponse(nullptr) {}
  ~AskLeaderResponse() override;
  explicit PROTOBUF_CONSTEXPR AskLeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AskLeaderResponse(const AskLeaderResponse& from);
  AskLeaderResponse(AskLeaderResponse&& from) noexcept
    : AskLeaderResponse() {
    *this = ::std::move(from);
  }

  inline AskLeaderResponse& operator=(const AskLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaderResponse& operator=(AskLeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaderResponse* internal_default_instance() {
    return reinterpret_cast<const AskLeaderResponse*>(
               &_AskLeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AskLeaderResponse& a, AskLeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AskLeaderResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AskLeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AskLeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AskLeaderResponse& from) {
    AskLeaderResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskLeaderResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.AskLeaderResponse";
  }
  protected:
  explicit AskLeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaderFieldNumber = 2,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.Peer leader = 2;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::greptime::v1::meta::Peer& leader() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Peer* release_leader();
  ::greptime::v1::meta::Peer* mutable_leader();
  void set_allocated_leader(::greptime::v1::meta::Peer* leader);
  private:
  const ::greptime::v1::meta::Peer& _internal_leader() const;
  ::greptime::v1::meta::Peer* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::greptime::v1::meta::Peer* leader);
  ::greptime::v1::meta::Peer* unsafe_arena_release_leader();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.AskLeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::Peer* leader_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// -------------------------------------------------------------------

class MailboxMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.MailboxMessage) */ {
 public:
  inline MailboxMessage() : MailboxMessage(nullptr) {}
  ~MailboxMessage() override;
  explicit PROTOBUF_CONSTEXPR MailboxMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailboxMessage(const MailboxMessage& from);
  MailboxMessage(MailboxMessage&& from) noexcept
    : MailboxMessage() {
    *this = ::std::move(from);
  }

  inline MailboxMessage& operator=(const MailboxMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailboxMessage& operator=(MailboxMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailboxMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kJson = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const MailboxMessage* internal_default_instance() {
    return reinterpret_cast<const MailboxMessage*>(
               &_MailboxMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MailboxMessage& a, MailboxMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MailboxMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailboxMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailboxMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailboxMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailboxMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailboxMessage& from) {
    MailboxMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailboxMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.MailboxMessage";
  }
  protected:
  explicit MailboxMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubjectFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kIdFieldNumber = 1,
    kTimestampMillisFieldNumber = 5,
    kJsonFieldNumber = 6,
  };
  // string subject = 2;
  void clear_subject();
  const std::string& subject() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subject(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subject();
  PROTOBUF_NODISCARD std::string* release_subject();
  void set_allocated_subject(std::string* subject);
  private:
  const std::string& _internal_subject() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const std::string& value);
  std::string* _internal_mutable_subject();
  public:

  // string from = 3;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 4;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // int64 timestamp_millis = 5;
  void clear_timestamp_millis();
  int64_t timestamp_millis() const;
  void set_timestamp_millis(int64_t value);
  private:
  int64_t _internal_timestamp_millis() const;
  void _internal_set_timestamp_millis(int64_t value);
  public:

  // string json = 6;
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.meta.MailboxMessage)
 private:
  class _Internal;
  void set_has_json();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subject_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
    uint64_t id_;
    int64_t timestamp_millis_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fheartbeat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool HeartbeatRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& HeartbeatRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& HeartbeatRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.header)
  return _internal_header();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* HeartbeatRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.header)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.header)
}

// .greptime.v1.meta.Peer peer = 2;
inline bool HeartbeatRequest::_internal_has_peer() const {
  return this != internal_default_instance() && _impl_.peer_ != nullptr;
}
inline bool HeartbeatRequest::has_peer() const {
  return _internal_has_peer();
}
inline const ::greptime::v1::meta::Peer& HeartbeatRequest::_internal_peer() const {
  const ::greptime::v1::meta::Peer* p = _impl_.peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Peer&>(
      ::greptime::v1::meta::_Peer_default_instance_);
}
inline const ::greptime::v1::meta::Peer& HeartbeatRequest::peer() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.peer)
  return _internal_peer();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_peer(
    ::greptime::v1::meta::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  _impl_.peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.peer)
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::release_peer() {
  
  ::greptime::v1::meta::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.peer)
  
  ::greptime::v1::meta::Peer* temp = _impl_.peer_;
  _impl_.peer_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::_internal_mutable_peer() {
  
  if (_impl_.peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Peer>(GetArenaForAllocation());
    _impl_.peer_ = p;
  }
  return _impl_.peer_;
}
inline ::greptime::v1::meta::Peer* HeartbeatRequest::mutable_peer() {
  ::greptime::v1::meta::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.peer)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_peer(::greptime::v1::meta::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.peer)
}

// .greptime.v1.meta.TimeInterval report_interval = 3;
inline bool HeartbeatRequest::_internal_has_report_interval() const {
  return this != internal_default_instance() && _impl_.report_interval_ != nullptr;
}
inline bool HeartbeatRequest::has_report_interval() const {
  return _internal_has_report_interval();
}
inline const ::greptime::v1::meta::TimeInterval& HeartbeatRequest::_internal_report_interval() const {
  const ::greptime::v1::meta::TimeInterval* p = _impl_.report_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TimeInterval&>(
      ::greptime::v1::meta::_TimeInterval_default_instance_);
}
inline const ::greptime::v1::meta::TimeInterval& HeartbeatRequest::report_interval() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.report_interval)
  return _internal_report_interval();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_report_interval(
    ::greptime::v1::meta::TimeInterval* report_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_interval_);
  }
  _impl_.report_interval_ = report_interval;
  if (report_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.report_interval)
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::release_report_interval() {
  
  ::greptime::v1::meta::TimeInterval* temp = _impl_.report_interval_;
  _impl_.report_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::unsafe_arena_release_report_interval() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.report_interval)
  
  ::greptime::v1::meta::TimeInterval* temp = _impl_.report_interval_;
  _impl_.report_interval_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::_internal_mutable_report_interval() {
  
  if (_impl_.report_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TimeInterval>(GetArenaForAllocation());
    _impl_.report_interval_ = p;
  }
  return _impl_.report_interval_;
}
inline ::greptime::v1::meta::TimeInterval* HeartbeatRequest::mutable_report_interval() {
  ::greptime::v1::meta::TimeInterval* _msg = _internal_mutable_report_interval();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.report_interval)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_report_interval(::greptime::v1::meta::TimeInterval* report_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.report_interval_);
  }
  if (report_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_interval));
    if (message_arena != submessage_arena) {
      report_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report_interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.report_interval_ = report_interval;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.report_interval)
}

// repeated .greptime.v1.meta.RegionStat region_stats = 4;
inline int HeartbeatRequest::_internal_region_stats_size() const {
  return _impl_.region_stats_.size();
}
inline int HeartbeatRequest::region_stats_size() const {
  return _internal_region_stats_size();
}
inline void HeartbeatRequest::clear_region_stats() {
  _impl_.region_stats_.Clear();
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::mutable_region_stats(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _impl_.region_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >*
HeartbeatRequest::mutable_region_stats() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.HeartbeatRequest.region_stats)
  return &_impl_.region_stats_;
}
inline const ::greptime::v1::meta::RegionStat& HeartbeatRequest::_internal_region_stats(int index) const {
  return _impl_.region_stats_.Get(index);
}
inline const ::greptime::v1::meta::RegionStat& HeartbeatRequest::region_stats(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _internal_region_stats(index);
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::_internal_add_region_stats() {
  return _impl_.region_stats_.Add();
}
inline ::greptime::v1::meta::RegionStat* HeartbeatRequest::add_region_stats() {
  ::greptime::v1::meta::RegionStat* _add = _internal_add_region_stats();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionStat >&
HeartbeatRequest::region_stats() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.HeartbeatRequest.region_stats)
  return _impl_.region_stats_;
}

// .greptime.v1.meta.MailboxMessage mailbox_message = 5;
inline bool HeartbeatRequest::_internal_has_mailbox_message() const {
  return this != internal_default_instance() && _impl_.mailbox_message_ != nullptr;
}
inline bool HeartbeatRequest::has_mailbox_message() const {
  return _internal_has_mailbox_message();
}
inline void HeartbeatRequest::clear_mailbox_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.mailbox_message_ != nullptr) {
    delete _impl_.mailbox_message_;
  }
  _impl_.mailbox_message_ = nullptr;
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatRequest::_internal_mailbox_message() const {
  const ::greptime::v1::meta::MailboxMessage* p = _impl_.mailbox_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::MailboxMessage&>(
      ::greptime::v1::meta::_MailboxMessage_default_instance_);
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatRequest::mailbox_message() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  return _internal_mailbox_message();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_mailbox_message(
    ::greptime::v1::meta::MailboxMessage* mailbox_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_message_);
  }
  _impl_.mailbox_message_ = mailbox_message;
  if (mailbox_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.mailbox_message)
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::release_mailbox_message() {
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::unsafe_arena_release_mailbox_message() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::_internal_mutable_mailbox_message() {
  
  if (_impl_.mailbox_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(GetArenaForAllocation());
    _impl_.mailbox_message_ = p;
  }
  return _impl_.mailbox_message_;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatRequest::mutable_mailbox_message() {
  ::greptime::v1::meta::MailboxMessage* _msg = _internal_mutable_mailbox_message();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.mailbox_message)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mailbox_message_;
  }
  if (mailbox_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mailbox_message);
    if (message_arena != submessage_arena) {
      mailbox_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_message_ = mailbox_message;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.mailbox_message)
}

// uint64 duration_since_epoch = 6;
inline void HeartbeatRequest::clear_duration_since_epoch() {
  _impl_.duration_since_epoch_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_duration_since_epoch() const {
  return _impl_.duration_since_epoch_;
}
inline uint64_t HeartbeatRequest::duration_since_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.duration_since_epoch)
  return _internal_duration_since_epoch();
}
inline void HeartbeatRequest::_internal_set_duration_since_epoch(uint64_t value) {
  
  _impl_.duration_since_epoch_ = value;
}
inline void HeartbeatRequest::set_duration_since_epoch(uint64_t value) {
  _internal_set_duration_since_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.HeartbeatRequest.duration_since_epoch)
}

// uint64 node_epoch = 7;
inline void HeartbeatRequest::clear_node_epoch() {
  _impl_.node_epoch_ = uint64_t{0u};
}
inline uint64_t HeartbeatRequest::_internal_node_epoch() const {
  return _impl_.node_epoch_;
}
inline uint64_t HeartbeatRequest::node_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.node_epoch)
  return _internal_node_epoch();
}
inline void HeartbeatRequest::_internal_set_node_epoch(uint64_t value) {
  
  _impl_.node_epoch_ = value;
}
inline void HeartbeatRequest::set_node_epoch(uint64_t value) {
  _internal_set_node_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.HeartbeatRequest.node_epoch)
}

// .greptime.v1.meta.NodeInfo info = 8;
inline bool HeartbeatRequest::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool HeartbeatRequest::has_info() const {
  return _internal_has_info();
}
inline void HeartbeatRequest::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::greptime::v1::meta::NodeInfo& HeartbeatRequest::_internal_info() const {
  const ::greptime::v1::meta::NodeInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::NodeInfo&>(
      ::greptime::v1::meta::_NodeInfo_default_instance_);
}
inline const ::greptime::v1::meta::NodeInfo& HeartbeatRequest::info() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.info)
  return _internal_info();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_info(
    ::greptime::v1::meta::NodeInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.info)
}
inline ::greptime::v1::meta::NodeInfo* HeartbeatRequest::release_info() {
  
  ::greptime::v1::meta::NodeInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::NodeInfo* HeartbeatRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.info)
  
  ::greptime::v1::meta::NodeInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::NodeInfo* HeartbeatRequest::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::NodeInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::greptime::v1::meta::NodeInfo* HeartbeatRequest::mutable_info() {
  ::greptime::v1::meta::NodeInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.info)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_info(::greptime::v1::meta::NodeInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.info)
}

// .greptime.v1.meta.FlowStat flow_stat = 9;
inline bool HeartbeatRequest::_internal_has_flow_stat() const {
  return this != internal_default_instance() && _impl_.flow_stat_ != nullptr;
}
inline bool HeartbeatRequest::has_flow_stat() const {
  return _internal_has_flow_stat();
}
inline void HeartbeatRequest::clear_flow_stat() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_stat_ != nullptr) {
    delete _impl_.flow_stat_;
  }
  _impl_.flow_stat_ = nullptr;
}
inline const ::greptime::v1::meta::FlowStat& HeartbeatRequest::_internal_flow_stat() const {
  const ::greptime::v1::meta::FlowStat* p = _impl_.flow_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::FlowStat&>(
      ::greptime::v1::meta::_FlowStat_default_instance_);
}
inline const ::greptime::v1::meta::FlowStat& HeartbeatRequest::flow_stat() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.flow_stat)
  return _internal_flow_stat();
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_flow_stat(
    ::greptime::v1::meta::FlowStat* flow_stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_stat_);
  }
  _impl_.flow_stat_ = flow_stat;
  if (flow_stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.flow_stat)
}
inline ::greptime::v1::meta::FlowStat* HeartbeatRequest::release_flow_stat() {
  
  ::greptime::v1::meta::FlowStat* temp = _impl_.flow_stat_;
  _impl_.flow_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::FlowStat* HeartbeatRequest::unsafe_arena_release_flow_stat() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.flow_stat)
  
  ::greptime::v1::meta::FlowStat* temp = _impl_.flow_stat_;
  _impl_.flow_stat_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::FlowStat* HeartbeatRequest::_internal_mutable_flow_stat() {
  
  if (_impl_.flow_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::FlowStat>(GetArenaForAllocation());
    _impl_.flow_stat_ = p;
  }
  return _impl_.flow_stat_;
}
inline ::greptime::v1::meta::FlowStat* HeartbeatRequest::mutable_flow_stat() {
  ::greptime::v1::meta::FlowStat* _msg = _internal_mutable_flow_stat();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.flow_stat)
  return _msg;
}
inline void HeartbeatRequest::set_allocated_flow_stat(::greptime::v1::meta::FlowStat* flow_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flow_stat_;
  }
  if (flow_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flow_stat);
    if (message_arena != submessage_arena) {
      flow_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flow_stat_ = flow_stat;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatRequest.flow_stat)
}

// .greptime.v1.meta.DatanodeWorkloads datanode = 10;
inline bool HeartbeatRequest::_internal_has_datanode() const {
  return node_workloads_case() == kDatanode;
}
inline bool HeartbeatRequest::has_datanode() const {
  return _internal_has_datanode();
}
inline void HeartbeatRequest::set_has_datanode() {
  _impl_._oneof_case_[0] = kDatanode;
}
inline void HeartbeatRequest::clear_datanode() {
  if (_internal_has_datanode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.node_workloads_.datanode_;
    }
    clear_has_node_workloads();
  }
}
inline ::greptime::v1::meta::DatanodeWorkloads* HeartbeatRequest::release_datanode() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.datanode)
  if (_internal_has_datanode()) {
    clear_has_node_workloads();
    ::greptime::v1::meta::DatanodeWorkloads* temp = _impl_.node_workloads_.datanode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_workloads_.datanode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::meta::DatanodeWorkloads& HeartbeatRequest::_internal_datanode() const {
  return _internal_has_datanode()
      ? *_impl_.node_workloads_.datanode_
      : reinterpret_cast< ::greptime::v1::meta::DatanodeWorkloads&>(::greptime::v1::meta::_DatanodeWorkloads_default_instance_);
}
inline const ::greptime::v1::meta::DatanodeWorkloads& HeartbeatRequest::datanode() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.datanode)
  return _internal_datanode();
}
inline ::greptime::v1::meta::DatanodeWorkloads* HeartbeatRequest::unsafe_arena_release_datanode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.meta.HeartbeatRequest.datanode)
  if (_internal_has_datanode()) {
    clear_has_node_workloads();
    ::greptime::v1::meta::DatanodeWorkloads* temp = _impl_.node_workloads_.datanode_;
    _impl_.node_workloads_.datanode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_datanode(::greptime::v1::meta::DatanodeWorkloads* datanode) {
  clear_node_workloads();
  if (datanode) {
    set_has_datanode();
    _impl_.node_workloads_.datanode_ = datanode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.datanode)
}
inline ::greptime::v1::meta::DatanodeWorkloads* HeartbeatRequest::_internal_mutable_datanode() {
  if (!_internal_has_datanode()) {
    clear_node_workloads();
    set_has_datanode();
    _impl_.node_workloads_.datanode_ = CreateMaybeMessage< ::greptime::v1::meta::DatanodeWorkloads >(GetArenaForAllocation());
  }
  return _impl_.node_workloads_.datanode_;
}
inline ::greptime::v1::meta::DatanodeWorkloads* HeartbeatRequest::mutable_datanode() {
  ::greptime::v1::meta::DatanodeWorkloads* _msg = _internal_mutable_datanode();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.datanode)
  return _msg;
}

// .greptime.v1.meta.FrontendWorkloads frontend = 11;
inline bool HeartbeatRequest::_internal_has_frontend() const {
  return node_workloads_case() == kFrontend;
}
inline bool HeartbeatRequest::has_frontend() const {
  return _internal_has_frontend();
}
inline void HeartbeatRequest::set_has_frontend() {
  _impl_._oneof_case_[0] = kFrontend;
}
inline void HeartbeatRequest::clear_frontend() {
  if (_internal_has_frontend()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.node_workloads_.frontend_;
    }
    clear_has_node_workloads();
  }
}
inline ::greptime::v1::meta::FrontendWorkloads* HeartbeatRequest::release_frontend() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.frontend)
  if (_internal_has_frontend()) {
    clear_has_node_workloads();
    ::greptime::v1::meta::FrontendWorkloads* temp = _impl_.node_workloads_.frontend_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_workloads_.frontend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::meta::FrontendWorkloads& HeartbeatRequest::_internal_frontend() const {
  return _internal_has_frontend()
      ? *_impl_.node_workloads_.frontend_
      : reinterpret_cast< ::greptime::v1::meta::FrontendWorkloads&>(::greptime::v1::meta::_FrontendWorkloads_default_instance_);
}
inline const ::greptime::v1::meta::FrontendWorkloads& HeartbeatRequest::frontend() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.frontend)
  return _internal_frontend();
}
inline ::greptime::v1::meta::FrontendWorkloads* HeartbeatRequest::unsafe_arena_release_frontend() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.meta.HeartbeatRequest.frontend)
  if (_internal_has_frontend()) {
    clear_has_node_workloads();
    ::greptime::v1::meta::FrontendWorkloads* temp = _impl_.node_workloads_.frontend_;
    _impl_.node_workloads_.frontend_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_frontend(::greptime::v1::meta::FrontendWorkloads* frontend) {
  clear_node_workloads();
  if (frontend) {
    set_has_frontend();
    _impl_.node_workloads_.frontend_ = frontend;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.frontend)
}
inline ::greptime::v1::meta::FrontendWorkloads* HeartbeatRequest::_internal_mutable_frontend() {
  if (!_internal_has_frontend()) {
    clear_node_workloads();
    set_has_frontend();
    _impl_.node_workloads_.frontend_ = CreateMaybeMessage< ::greptime::v1::meta::FrontendWorkloads >(GetArenaForAllocation());
  }
  return _impl_.node_workloads_.frontend_;
}
inline ::greptime::v1::meta::FrontendWorkloads* HeartbeatRequest::mutable_frontend() {
  ::greptime::v1::meta::FrontendWorkloads* _msg = _internal_mutable_frontend();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.frontend)
  return _msg;
}

// .greptime.v1.meta.FlownodeWorkloads flownode = 12;
inline bool HeartbeatRequest::_internal_has_flownode() const {
  return node_workloads_case() == kFlownode;
}
inline bool HeartbeatRequest::has_flownode() const {
  return _internal_has_flownode();
}
inline void HeartbeatRequest::set_has_flownode() {
  _impl_._oneof_case_[0] = kFlownode;
}
inline void HeartbeatRequest::clear_flownode() {
  if (_internal_has_flownode()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.node_workloads_.flownode_;
    }
    clear_has_node_workloads();
  }
}
inline ::greptime::v1::meta::FlownodeWorkloads* HeartbeatRequest::release_flownode() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatRequest.flownode)
  if (_internal_has_flownode()) {
    clear_has_node_workloads();
    ::greptime::v1::meta::FlownodeWorkloads* temp = _impl_.node_workloads_.flownode_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_workloads_.flownode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::meta::FlownodeWorkloads& HeartbeatRequest::_internal_flownode() const {
  return _internal_has_flownode()
      ? *_impl_.node_workloads_.flownode_
      : reinterpret_cast< ::greptime::v1::meta::FlownodeWorkloads&>(::greptime::v1::meta::_FlownodeWorkloads_default_instance_);
}
inline const ::greptime::v1::meta::FlownodeWorkloads& HeartbeatRequest::flownode() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.flownode)
  return _internal_flownode();
}
inline ::greptime::v1::meta::FlownodeWorkloads* HeartbeatRequest::unsafe_arena_release_flownode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.meta.HeartbeatRequest.flownode)
  if (_internal_has_flownode()) {
    clear_has_node_workloads();
    ::greptime::v1::meta::FlownodeWorkloads* temp = _impl_.node_workloads_.flownode_;
    _impl_.node_workloads_.flownode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HeartbeatRequest::unsafe_arena_set_allocated_flownode(::greptime::v1::meta::FlownodeWorkloads* flownode) {
  clear_node_workloads();
  if (flownode) {
    set_has_flownode();
    _impl_.node_workloads_.flownode_ = flownode;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatRequest.flownode)
}
inline ::greptime::v1::meta::FlownodeWorkloads* HeartbeatRequest::_internal_mutable_flownode() {
  if (!_internal_has_flownode()) {
    clear_node_workloads();
    set_has_flownode();
    _impl_.node_workloads_.flownode_ = CreateMaybeMessage< ::greptime::v1::meta::FlownodeWorkloads >(GetArenaForAllocation());
  }
  return _impl_.node_workloads_.flownode_;
}
inline ::greptime::v1::meta::FlownodeWorkloads* HeartbeatRequest::mutable_flownode() {
  ::greptime::v1::meta::FlownodeWorkloads* _msg = _internal_mutable_flownode();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.flownode)
  return _msg;
}

// repeated .greptime.v1.meta.TopicStat topic_stats = 13;
inline int HeartbeatRequest::_internal_topic_stats_size() const {
  return _impl_.topic_stats_.size();
}
inline int HeartbeatRequest::topic_stats_size() const {
  return _internal_topic_stats_size();
}
inline void HeartbeatRequest::clear_topic_stats() {
  _impl_.topic_stats_.Clear();
}
inline ::greptime::v1::meta::TopicStat* HeartbeatRequest::mutable_topic_stats(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatRequest.topic_stats)
  return _impl_.topic_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TopicStat >*
HeartbeatRequest::mutable_topic_stats() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.HeartbeatRequest.topic_stats)
  return &_impl_.topic_stats_;
}
inline const ::greptime::v1::meta::TopicStat& HeartbeatRequest::_internal_topic_stats(int index) const {
  return _impl_.topic_stats_.Get(index);
}
inline const ::greptime::v1::meta::TopicStat& HeartbeatRequest::topic_stats(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatRequest.topic_stats)
  return _internal_topic_stats(index);
}
inline ::greptime::v1::meta::TopicStat* HeartbeatRequest::_internal_add_topic_stats() {
  return _impl_.topic_stats_.Add();
}
inline ::greptime::v1::meta::TopicStat* HeartbeatRequest::add_topic_stats() {
  ::greptime::v1::meta::TopicStat* _add = _internal_add_topic_stats();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.HeartbeatRequest.topic_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TopicStat >&
HeartbeatRequest::topic_stats() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.HeartbeatRequest.topic_stats)
  return _impl_.topic_stats_;
}

inline bool HeartbeatRequest::has_node_workloads() const {
  return node_workloads_case() != NODE_WORKLOADS_NOT_SET;
}
inline void HeartbeatRequest::clear_has_node_workloads() {
  _impl_._oneof_case_[0] = NODE_WORKLOADS_NOT_SET;
}
inline HeartbeatRequest::NodeWorkloadsCase HeartbeatRequest::node_workloads_case() const {
  return HeartbeatRequest::NodeWorkloadsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DatanodeWorkloads

// repeated int32 types = 1;
inline int DatanodeWorkloads::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int DatanodeWorkloads::types_size() const {
  return _internal_types_size();
}
inline void DatanodeWorkloads::clear_types() {
  _impl_.types_.Clear();
}
inline int32_t DatanodeWorkloads::_internal_types(int index) const {
  return _impl_.types_.Get(index);
}
inline int32_t DatanodeWorkloads::types(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DatanodeWorkloads.types)
  return _internal_types(index);
}
inline void DatanodeWorkloads::set_types(int index, int32_t value) {
  _impl_.types_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.DatanodeWorkloads.types)
}
inline void DatanodeWorkloads::_internal_add_types(int32_t value) {
  _impl_.types_.Add(value);
}
inline void DatanodeWorkloads::add_types(int32_t value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.DatanodeWorkloads.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DatanodeWorkloads::_internal_types() const {
  return _impl_.types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DatanodeWorkloads::types() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.DatanodeWorkloads.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DatanodeWorkloads::_internal_mutable_types() {
  return &_impl_.types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DatanodeWorkloads::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.DatanodeWorkloads.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// FrontendWorkloads

// repeated int32 types = 1;
inline int FrontendWorkloads::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int FrontendWorkloads::types_size() const {
  return _internal_types_size();
}
inline void FrontendWorkloads::clear_types() {
  _impl_.types_.Clear();
}
inline int32_t FrontendWorkloads::_internal_types(int index) const {
  return _impl_.types_.Get(index);
}
inline int32_t FrontendWorkloads::types(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.FrontendWorkloads.types)
  return _internal_types(index);
}
inline void FrontendWorkloads::set_types(int index, int32_t value) {
  _impl_.types_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.FrontendWorkloads.types)
}
inline void FrontendWorkloads::_internal_add_types(int32_t value) {
  _impl_.types_.Add(value);
}
inline void FrontendWorkloads::add_types(int32_t value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.FrontendWorkloads.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FrontendWorkloads::_internal_types() const {
  return _impl_.types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FrontendWorkloads::types() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.FrontendWorkloads.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FrontendWorkloads::_internal_mutable_types() {
  return &_impl_.types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FrontendWorkloads::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.FrontendWorkloads.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// FlownodeWorkloads

// repeated int32 types = 1;
inline int FlownodeWorkloads::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int FlownodeWorkloads::types_size() const {
  return _internal_types_size();
}
inline void FlownodeWorkloads::clear_types() {
  _impl_.types_.Clear();
}
inline int32_t FlownodeWorkloads::_internal_types(int index) const {
  return _impl_.types_.Get(index);
}
inline int32_t FlownodeWorkloads::types(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.FlownodeWorkloads.types)
  return _internal_types(index);
}
inline void FlownodeWorkloads::set_types(int index, int32_t value) {
  _impl_.types_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.FlownodeWorkloads.types)
}
inline void FlownodeWorkloads::_internal_add_types(int32_t value) {
  _impl_.types_.Add(value);
}
inline void FlownodeWorkloads::add_types(int32_t value) {
  _internal_add_types(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.FlownodeWorkloads.types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FlownodeWorkloads::_internal_types() const {
  return _impl_.types_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FlownodeWorkloads::types() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.FlownodeWorkloads.types)
  return _internal_types();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FlownodeWorkloads::_internal_mutable_types() {
  return &_impl_.types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FlownodeWorkloads::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.FlownodeWorkloads.types)
  return _internal_mutable_types();
}

// -------------------------------------------------------------------

// NodeInfo

// string version = 1;
inline void NodeInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& NodeInfo::version() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeInfo.version)
}
inline std::string* NodeInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.NodeInfo.version)
  return _s;
}
inline const std::string& NodeInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void NodeInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_version() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.NodeInfo.version)
  return _impl_.version_.Release();
}
inline void NodeInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.NodeInfo.version)
}

// string git_commit = 2;
inline void NodeInfo::clear_git_commit() {
  _impl_.git_commit_.ClearToEmpty();
}
inline const std::string& NodeInfo::git_commit() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeInfo.git_commit)
  return _internal_git_commit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_git_commit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.git_commit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeInfo.git_commit)
}
inline std::string* NodeInfo::mutable_git_commit() {
  std::string* _s = _internal_mutable_git_commit();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.NodeInfo.git_commit)
  return _s;
}
inline const std::string& NodeInfo::_internal_git_commit() const {
  return _impl_.git_commit_.Get();
}
inline void NodeInfo::_internal_set_git_commit(const std::string& value) {
  
  _impl_.git_commit_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_git_commit() {
  
  return _impl_.git_commit_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_git_commit() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.NodeInfo.git_commit)
  return _impl_.git_commit_.Release();
}
inline void NodeInfo::set_allocated_git_commit(std::string* git_commit) {
  if (git_commit != nullptr) {
    
  } else {
    
  }
  _impl_.git_commit_.SetAllocated(git_commit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.git_commit_.IsDefault()) {
    _impl_.git_commit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.NodeInfo.git_commit)
}

// uint64 start_time_ms = 3;
inline void NodeInfo::clear_start_time_ms() {
  _impl_.start_time_ms_ = uint64_t{0u};
}
inline uint64_t NodeInfo::_internal_start_time_ms() const {
  return _impl_.start_time_ms_;
}
inline uint64_t NodeInfo::start_time_ms() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeInfo.start_time_ms)
  return _internal_start_time_ms();
}
inline void NodeInfo::_internal_set_start_time_ms(uint64_t value) {
  
  _impl_.start_time_ms_ = value;
}
inline void NodeInfo::set_start_time_ms(uint64_t value) {
  _internal_set_start_time_ms(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeInfo.start_time_ms)
}

// uint32 cpus = 4;
inline void NodeInfo::clear_cpus() {
  _impl_.cpus_ = 0u;
}
inline uint32_t NodeInfo::_internal_cpus() const {
  return _impl_.cpus_;
}
inline uint32_t NodeInfo::cpus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeInfo.cpus)
  return _internal_cpus();
}
inline void NodeInfo::_internal_set_cpus(uint32_t value) {
  
  _impl_.cpus_ = value;
}
inline void NodeInfo::set_cpus(uint32_t value) {
  _internal_set_cpus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeInfo.cpus)
}

// uint64 memory_bytes = 5;
inline void NodeInfo::clear_memory_bytes() {
  _impl_.memory_bytes_ = uint64_t{0u};
}
inline uint64_t NodeInfo::_internal_memory_bytes() const {
  return _impl_.memory_bytes_;
}
inline uint64_t NodeInfo::memory_bytes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.NodeInfo.memory_bytes)
  return _internal_memory_bytes();
}
inline void NodeInfo::_internal_set_memory_bytes(uint64_t value) {
  
  _impl_.memory_bytes_ = value;
}
inline void NodeInfo::set_memory_bytes(uint64_t value) {
  _internal_set_memory_bytes(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.NodeInfo.memory_bytes)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RegionStat

// uint64 region_id = 1;
inline void RegionStat::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t RegionStat::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t RegionStat::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.region_id)
  return _internal_region_id();
}
inline void RegionStat::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void RegionStat::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.region_id)
}

// int64 rcus = 2;
inline void RegionStat::clear_rcus() {
  _impl_.rcus_ = int64_t{0};
}
inline int64_t RegionStat::_internal_rcus() const {
  return _impl_.rcus_;
}
inline int64_t RegionStat::rcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.rcus)
  return _internal_rcus();
}
inline void RegionStat::_internal_set_rcus(int64_t value) {
  
  _impl_.rcus_ = value;
}
inline void RegionStat::set_rcus(int64_t value) {
  _internal_set_rcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.rcus)
}

// int64 wcus = 3;
inline void RegionStat::clear_wcus() {
  _impl_.wcus_ = int64_t{0};
}
inline int64_t RegionStat::_internal_wcus() const {
  return _impl_.wcus_;
}
inline int64_t RegionStat::wcus() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.wcus)
  return _internal_wcus();
}
inline void RegionStat::_internal_set_wcus(int64_t value) {
  
  _impl_.wcus_ = value;
}
inline void RegionStat::set_wcus(int64_t value) {
  _internal_set_wcus(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.wcus)
}

// int64 approximate_bytes = 4;
inline void RegionStat::clear_approximate_bytes() {
  _impl_.approximate_bytes_ = int64_t{0};
}
inline int64_t RegionStat::_internal_approximate_bytes() const {
  return _impl_.approximate_bytes_;
}
inline int64_t RegionStat::approximate_bytes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.approximate_bytes)
  return _internal_approximate_bytes();
}
inline void RegionStat::_internal_set_approximate_bytes(int64_t value) {
  
  _impl_.approximate_bytes_ = value;
}
inline void RegionStat::set_approximate_bytes(int64_t value) {
  _internal_set_approximate_bytes(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.approximate_bytes)
}

// string engine = 6;
inline void RegionStat::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& RegionStat::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionStat::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.engine)
}
inline std::string* RegionStat::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionStat.engine)
  return _s;
}
inline const std::string& RegionStat::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void RegionStat::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionStat::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionStat::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RegionStat.engine)
  return _impl_.engine_.Release();
}
inline void RegionStat::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RegionStat.engine)
}

// .greptime.v1.meta.RegionRole role = 7;
inline void RegionStat::clear_role() {
  _impl_.role_ = 0;
}
inline ::greptime::v1::meta::RegionRole RegionStat::_internal_role() const {
  return static_cast< ::greptime::v1::meta::RegionRole >(_impl_.role_);
}
inline ::greptime::v1::meta::RegionRole RegionStat::role() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionStat.role)
  return _internal_role();
}
inline void RegionStat::_internal_set_role(::greptime::v1::meta::RegionRole value) {
  
  _impl_.role_ = value;
}
inline void RegionStat::set_role(::greptime::v1::meta::RegionRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionStat.role)
}

// map<string, bytes> extensions = 99;
inline int RegionStat::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int RegionStat::extensions_size() const {
  return _internal_extensions_size();
}
inline void RegionStat::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionStat::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionStat::extensions() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.RegionStat.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionStat::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionStat::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.RegionStat.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// TopicStat

// string topic_name = 1;
inline void TopicStat::clear_topic_name() {
  _impl_.topic_name_.ClearToEmpty();
}
inline const std::string& TopicStat::topic_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TopicStat.topic_name)
  return _internal_topic_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TopicStat::set_topic_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.TopicStat.topic_name)
}
inline std::string* TopicStat::mutable_topic_name() {
  std::string* _s = _internal_mutable_topic_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TopicStat.topic_name)
  return _s;
}
inline const std::string& TopicStat::_internal_topic_name() const {
  return _impl_.topic_name_.Get();
}
inline void TopicStat::_internal_set_topic_name(const std::string& value) {
  
  _impl_.topic_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TopicStat::_internal_mutable_topic_name() {
  
  return _impl_.topic_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TopicStat::release_topic_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.TopicStat.topic_name)
  return _impl_.topic_name_.Release();
}
inline void TopicStat::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    
  } else {
    
  }
  _impl_.topic_name_.SetAllocated(topic_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_name_.IsDefault()) {
    _impl_.topic_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.TopicStat.topic_name)
}

// uint64 record_size = 2;
inline void TopicStat::clear_record_size() {
  _impl_.record_size_ = uint64_t{0u};
}
inline uint64_t TopicStat::_internal_record_size() const {
  return _impl_.record_size_;
}
inline uint64_t TopicStat::record_size() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TopicStat.record_size)
  return _internal_record_size();
}
inline void TopicStat::_internal_set_record_size(uint64_t value) {
  
  _impl_.record_size_ = value;
}
inline void TopicStat::set_record_size(uint64_t value) {
  _internal_set_record_size(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.TopicStat.record_size)
}

// uint64 record_num = 3;
inline void TopicStat::clear_record_num() {
  _impl_.record_num_ = uint64_t{0u};
}
inline uint64_t TopicStat::_internal_record_num() const {
  return _impl_.record_num_;
}
inline uint64_t TopicStat::record_num() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TopicStat.record_num)
  return _internal_record_num();
}
inline void TopicStat::_internal_set_record_num(uint64_t value) {
  
  _impl_.record_num_ = value;
}
inline void TopicStat::set_record_num(uint64_t value) {
  _internal_set_record_num(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.TopicStat.record_num)
}

// uint64 latest_entry_id = 4;
inline void TopicStat::clear_latest_entry_id() {
  _impl_.latest_entry_id_ = uint64_t{0u};
}
inline uint64_t TopicStat::_internal_latest_entry_id() const {
  return _impl_.latest_entry_id_;
}
inline uint64_t TopicStat::latest_entry_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TopicStat.latest_entry_id)
  return _internal_latest_entry_id();
}
inline void TopicStat::_internal_set_latest_entry_id(uint64_t value) {
  
  _impl_.latest_entry_id_ = value;
}
inline void TopicStat::set_latest_entry_id(uint64_t value) {
  _internal_set_latest_entry_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.TopicStat.latest_entry_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FlowStat

// map<uint32, uint64> flow_stat_size = 1;
inline int FlowStat::_internal_flow_stat_size_size() const {
  return _impl_.flow_stat_size_.size();
}
inline int FlowStat::flow_stat_size_size() const {
  return _internal_flow_stat_size_size();
}
inline void FlowStat::clear_flow_stat_size() {
  _impl_.flow_stat_size_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >&
FlowStat::_internal_flow_stat_size() const {
  return _impl_.flow_stat_size_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >&
FlowStat::flow_stat_size() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.FlowStat.flow_stat_size)
  return _internal_flow_stat_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >*
FlowStat::_internal_mutable_flow_stat_size() {
  return _impl_.flow_stat_size_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, uint64_t >*
FlowStat::mutable_flow_stat_size() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.FlowStat.flow_stat_size)
  return _internal_mutable_flow_stat_size();
}

// map<uint32, int64> flow_last_exec_time_map = 2;
inline int FlowStat::_internal_flow_last_exec_time_map_size() const {
  return _impl_.flow_last_exec_time_map_.size();
}
inline int FlowStat::flow_last_exec_time_map_size() const {
  return _internal_flow_last_exec_time_map_size();
}
inline void FlowStat::clear_flow_last_exec_time_map() {
  _impl_.flow_last_exec_time_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >&
FlowStat::_internal_flow_last_exec_time_map() const {
  return _impl_.flow_last_exec_time_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >&
FlowStat::flow_last_exec_time_map() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.FlowStat.flow_last_exec_time_map)
  return _internal_flow_last_exec_time_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >*
FlowStat::_internal_mutable_flow_last_exec_time_map() {
  return _impl_.flow_last_exec_time_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, int64_t >*
FlowStat::mutable_flow_last_exec_time_map() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.FlowStat.flow_last_exec_time_map)
  return _internal_mutable_flow_last_exec_time_map();
}

// -------------------------------------------------------------------

// HeartbeatResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool HeartbeatResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool HeartbeatResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& HeartbeatResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& HeartbeatResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.header)
  return _internal_header();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* HeartbeatResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.header)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.header)
}

// .greptime.v1.meta.MailboxMessage mailbox_message = 2;
inline bool HeartbeatResponse::_internal_has_mailbox_message() const {
  return this != internal_default_instance() && _impl_.mailbox_message_ != nullptr;
}
inline bool HeartbeatResponse::has_mailbox_message() const {
  return _internal_has_mailbox_message();
}
inline void HeartbeatResponse::clear_mailbox_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.mailbox_message_ != nullptr) {
    delete _impl_.mailbox_message_;
  }
  _impl_.mailbox_message_ = nullptr;
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatResponse::_internal_mailbox_message() const {
  const ::greptime::v1::meta::MailboxMessage* p = _impl_.mailbox_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::MailboxMessage&>(
      ::greptime::v1::meta::_MailboxMessage_default_instance_);
}
inline const ::greptime::v1::meta::MailboxMessage& HeartbeatResponse::mailbox_message() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  return _internal_mailbox_message();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_mailbox_message(
    ::greptime::v1::meta::MailboxMessage* mailbox_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mailbox_message_);
  }
  _impl_.mailbox_message_ = mailbox_message;
  if (mailbox_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.mailbox_message)
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::release_mailbox_message() {
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::unsafe_arena_release_mailbox_message() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  
  ::greptime::v1::meta::MailboxMessage* temp = _impl_.mailbox_message_;
  _impl_.mailbox_message_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::_internal_mutable_mailbox_message() {
  
  if (_impl_.mailbox_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::MailboxMessage>(GetArenaForAllocation());
    _impl_.mailbox_message_ = p;
  }
  return _impl_.mailbox_message_;
}
inline ::greptime::v1::meta::MailboxMessage* HeartbeatResponse::mutable_mailbox_message() {
  ::greptime::v1::meta::MailboxMessage* _msg = _internal_mutable_mailbox_message();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.mailbox_message)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_mailbox_message(::greptime::v1::meta::MailboxMessage* mailbox_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mailbox_message_;
  }
  if (mailbox_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mailbox_message);
    if (message_arena != submessage_arena) {
      mailbox_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mailbox_message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mailbox_message_ = mailbox_message;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.mailbox_message)
}

// .greptime.v1.meta.RegionLease region_lease = 3;
inline bool HeartbeatResponse::_internal_has_region_lease() const {
  return this != internal_default_instance() && _impl_.region_lease_ != nullptr;
}
inline bool HeartbeatResponse::has_region_lease() const {
  return _internal_has_region_lease();
}
inline void HeartbeatResponse::clear_region_lease() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_lease_ != nullptr) {
    delete _impl_.region_lease_;
  }
  _impl_.region_lease_ = nullptr;
}
inline const ::greptime::v1::meta::RegionLease& HeartbeatResponse::_internal_region_lease() const {
  const ::greptime::v1::meta::RegionLease* p = _impl_.region_lease_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RegionLease&>(
      ::greptime::v1::meta::_RegionLease_default_instance_);
}
inline const ::greptime::v1::meta::RegionLease& HeartbeatResponse::region_lease() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.HeartbeatResponse.region_lease)
  return _internal_region_lease();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_region_lease(
    ::greptime::v1::meta::RegionLease* region_lease) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_lease_);
  }
  _impl_.region_lease_ = region_lease;
  if (region_lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.HeartbeatResponse.region_lease)
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::release_region_lease() {
  
  ::greptime::v1::meta::RegionLease* temp = _impl_.region_lease_;
  _impl_.region_lease_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::unsafe_arena_release_region_lease() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.HeartbeatResponse.region_lease)
  
  ::greptime::v1::meta::RegionLease* temp = _impl_.region_lease_;
  _impl_.region_lease_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::_internal_mutable_region_lease() {
  
  if (_impl_.region_lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RegionLease>(GetArenaForAllocation());
    _impl_.region_lease_ = p;
  }
  return _impl_.region_lease_;
}
inline ::greptime::v1::meta::RegionLease* HeartbeatResponse::mutable_region_lease() {
  ::greptime::v1::meta::RegionLease* _msg = _internal_mutable_region_lease();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.HeartbeatResponse.region_lease)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_region_lease(::greptime::v1::meta::RegionLease* region_lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_lease_;
  }
  if (region_lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region_lease);
    if (message_arena != submessage_arena) {
      region_lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_lease, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_lease_ = region_lease;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.HeartbeatResponse.region_lease)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GrantedRegion

// uint64 region_id = 1;
inline void GrantedRegion::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t GrantedRegion::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t GrantedRegion::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.GrantedRegion.region_id)
  return _internal_region_id();
}
inline void GrantedRegion::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void GrantedRegion::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.GrantedRegion.region_id)
}

// .greptime.v1.meta.RegionRole role = 2;
inline void GrantedRegion::clear_role() {
  _impl_.role_ = 0;
}
inline ::greptime::v1::meta::RegionRole GrantedRegion::_internal_role() const {
  return static_cast< ::greptime::v1::meta::RegionRole >(_impl_.role_);
}
inline ::greptime::v1::meta::RegionRole GrantedRegion::role() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.GrantedRegion.role)
  return _internal_role();
}
inline void GrantedRegion::_internal_set_role(::greptime::v1::meta::RegionRole value) {
  
  _impl_.role_ = value;
}
inline void GrantedRegion::set_role(::greptime::v1::meta::RegionRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.GrantedRegion.role)
}

// map<string, bytes> extensions = 99;
inline int GrantedRegion::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int GrantedRegion::extensions_size() const {
  return _internal_extensions_size();
}
inline void GrantedRegion::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GrantedRegion::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GrantedRegion::extensions() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.GrantedRegion.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GrantedRegion::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GrantedRegion::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.GrantedRegion.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// RegionLease

// repeated .greptime.v1.meta.GrantedRegion regions = 1;
inline int RegionLease::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int RegionLease::regions_size() const {
  return _internal_regions_size();
}
inline void RegionLease::clear_regions() {
  _impl_.regions_.Clear();
}
inline ::greptime::v1::meta::GrantedRegion* RegionLease::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionLease.regions)
  return _impl_.regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >*
RegionLease::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RegionLease.regions)
  return &_impl_.regions_;
}
inline const ::greptime::v1::meta::GrantedRegion& RegionLease::_internal_regions(int index) const {
  return _impl_.regions_.Get(index);
}
inline const ::greptime::v1::meta::GrantedRegion& RegionLease::regions(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.regions)
  return _internal_regions(index);
}
inline ::greptime::v1::meta::GrantedRegion* RegionLease::_internal_add_regions() {
  return _impl_.regions_.Add();
}
inline ::greptime::v1::meta::GrantedRegion* RegionLease::add_regions() {
  ::greptime::v1::meta::GrantedRegion* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RegionLease.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::GrantedRegion >&
RegionLease::regions() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RegionLease.regions)
  return _impl_.regions_;
}

// uint64 duration_since_epoch = 2;
inline void RegionLease::clear_duration_since_epoch() {
  _impl_.duration_since_epoch_ = uint64_t{0u};
}
inline uint64_t RegionLease::_internal_duration_since_epoch() const {
  return _impl_.duration_since_epoch_;
}
inline uint64_t RegionLease::duration_since_epoch() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.duration_since_epoch)
  return _internal_duration_since_epoch();
}
inline void RegionLease::_internal_set_duration_since_epoch(uint64_t value) {
  
  _impl_.duration_since_epoch_ = value;
}
inline void RegionLease::set_duration_since_epoch(uint64_t value) {
  _internal_set_duration_since_epoch(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.duration_since_epoch)
}

// uint64 lease_seconds = 3;
inline void RegionLease::clear_lease_seconds() {
  _impl_.lease_seconds_ = uint64_t{0u};
}
inline uint64_t RegionLease::_internal_lease_seconds() const {
  return _impl_.lease_seconds_;
}
inline uint64_t RegionLease::lease_seconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.lease_seconds)
  return _internal_lease_seconds();
}
inline void RegionLease::_internal_set_lease_seconds(uint64_t value) {
  
  _impl_.lease_seconds_ = value;
}
inline void RegionLease::set_lease_seconds(uint64_t value) {
  _internal_set_lease_seconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.lease_seconds)
}

// repeated uint64 closeable_region_ids = 4;
inline int RegionLease::_internal_closeable_region_ids_size() const {
  return _impl_.closeable_region_ids_.size();
}
inline int RegionLease::closeable_region_ids_size() const {
  return _internal_closeable_region_ids_size();
}
inline void RegionLease::clear_closeable_region_ids() {
  _impl_.closeable_region_ids_.Clear();
}
inline uint64_t RegionLease::_internal_closeable_region_ids(int index) const {
  return _impl_.closeable_region_ids_.Get(index);
}
inline uint64_t RegionLease::closeable_region_ids(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionLease.closeable_region_ids)
  return _internal_closeable_region_ids(index);
}
inline void RegionLease::set_closeable_region_ids(int index, uint64_t value) {
  _impl_.closeable_region_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionLease.closeable_region_ids)
}
inline void RegionLease::_internal_add_closeable_region_ids(uint64_t value) {
  _impl_.closeable_region_ids_.Add(value);
}
inline void RegionLease::add_closeable_region_ids(uint64_t value) {
  _internal_add_closeable_region_ids(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RegionLease.closeable_region_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RegionLease::_internal_closeable_region_ids() const {
  return _impl_.closeable_region_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RegionLease::closeable_region_ids() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RegionLease.closeable_region_ids)
  return _internal_closeable_region_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RegionLease::_internal_mutable_closeable_region_ids() {
  return &_impl_.closeable_region_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RegionLease::mutable_closeable_region_ids() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RegionLease.closeable_region_ids)
  return _internal_mutable_closeable_region_ids();
}

// -------------------------------------------------------------------

// AskLeaderRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool AskLeaderRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AskLeaderRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& AskLeaderRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& AskLeaderRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderRequest.header)
  return _internal_header();
}
inline void AskLeaderRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* AskLeaderRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderRequest.header)
  return _msg;
}
inline void AskLeaderRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderRequest.header)
}

// -------------------------------------------------------------------

// AskLeaderResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool AskLeaderResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool AskLeaderResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& AskLeaderResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& AskLeaderResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderResponse.header)
  return _internal_header();
}
inline void AskLeaderResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* AskLeaderResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderResponse.header)
  return _msg;
}
inline void AskLeaderResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderResponse.header)
}

// .greptime.v1.meta.Peer leader = 2;
inline bool AskLeaderResponse::_internal_has_leader() const {
  return this != internal_default_instance() && _impl_.leader_ != nullptr;
}
inline bool AskLeaderResponse::has_leader() const {
  return _internal_has_leader();
}
inline const ::greptime::v1::meta::Peer& AskLeaderResponse::_internal_leader() const {
  const ::greptime::v1::meta::Peer* p = _impl_.leader_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Peer&>(
      ::greptime::v1::meta::_Peer_default_instance_);
}
inline const ::greptime::v1::meta::Peer& AskLeaderResponse::leader() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.AskLeaderResponse.leader)
  return _internal_leader();
}
inline void AskLeaderResponse::unsafe_arena_set_allocated_leader(
    ::greptime::v1::meta::Peer* leader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  _impl_.leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.AskLeaderResponse.leader)
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::release_leader() {
  
  ::greptime::v1::meta::Peer* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.AskLeaderResponse.leader)
  
  ::greptime::v1::meta::Peer* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::_internal_mutable_leader() {
  
  if (_impl_.leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Peer>(GetArenaForAllocation());
    _impl_.leader_ = p;
  }
  return _impl_.leader_;
}
inline ::greptime::v1::meta::Peer* AskLeaderResponse::mutable_leader() {
  ::greptime::v1::meta::Peer* _msg = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.AskLeaderResponse.leader)
  return _msg;
}
inline void AskLeaderResponse::set_allocated_leader(::greptime::v1::meta::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader));
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.AskLeaderResponse.leader)
}

// -------------------------------------------------------------------

// MailboxMessage

// uint64 id = 1;
inline void MailboxMessage::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t MailboxMessage::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t MailboxMessage::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.id)
  return _internal_id();
}
inline void MailboxMessage::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void MailboxMessage::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.id)
}

// string subject = 2;
inline void MailboxMessage::clear_subject() {
  _impl_.subject_.ClearToEmpty();
}
inline const std::string& MailboxMessage::subject() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.subject)
  return _internal_subject();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_subject(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subject_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.subject)
}
inline std::string* MailboxMessage::mutable_subject() {
  std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.subject)
  return _s;
}
inline const std::string& MailboxMessage::_internal_subject() const {
  return _impl_.subject_.Get();
}
inline void MailboxMessage::_internal_set_subject(const std::string& value) {
  
  _impl_.subject_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_subject() {
  
  return _impl_.subject_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_subject() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.subject)
  return _impl_.subject_.Release();
}
inline void MailboxMessage::set_allocated_subject(std::string* subject) {
  if (subject != nullptr) {
    
  } else {
    
  }
  _impl_.subject_.SetAllocated(subject, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.subject)
}

// string from = 3;
inline void MailboxMessage::clear_from() {
  _impl_.from_.ClearToEmpty();
}
inline const std::string& MailboxMessage::from() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_from(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.from)
}
inline std::string* MailboxMessage::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.from)
  return _s;
}
inline const std::string& MailboxMessage::_internal_from() const {
  return _impl_.from_.Get();
}
inline void MailboxMessage::_internal_set_from(const std::string& value) {
  
  _impl_.from_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_from() {
  
  return _impl_.from_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_from() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.from)
  return _impl_.from_.Release();
}
inline void MailboxMessage::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  _impl_.from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_.IsDefault()) {
    _impl_.from_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.from)
}

// string to = 4;
inline void MailboxMessage::clear_to() {
  _impl_.to_.ClearToEmpty();
}
inline const std::string& MailboxMessage::to() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MailboxMessage::set_to(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.to)
}
inline std::string* MailboxMessage::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.to)
  return _s;
}
inline const std::string& MailboxMessage::_internal_to() const {
  return _impl_.to_.Get();
}
inline void MailboxMessage::_internal_set_to(const std::string& value) {
  
  _impl_.to_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_to() {
  
  return _impl_.to_.Mutable(GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_to() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.to)
  return _impl_.to_.Release();
}
inline void MailboxMessage::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  _impl_.to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_.IsDefault()) {
    _impl_.to_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.to)
}

// int64 timestamp_millis = 5;
inline void MailboxMessage::clear_timestamp_millis() {
  _impl_.timestamp_millis_ = int64_t{0};
}
inline int64_t MailboxMessage::_internal_timestamp_millis() const {
  return _impl_.timestamp_millis_;
}
inline int64_t MailboxMessage::timestamp_millis() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.timestamp_millis)
  return _internal_timestamp_millis();
}
inline void MailboxMessage::_internal_set_timestamp_millis(int64_t value) {
  
  _impl_.timestamp_millis_ = value;
}
inline void MailboxMessage::set_timestamp_millis(int64_t value) {
  _internal_set_timestamp_millis(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.timestamp_millis)
}

// string json = 6;
inline bool MailboxMessage::_internal_has_json() const {
  return payload_case() == kJson;
}
inline bool MailboxMessage::has_json() const {
  return _internal_has_json();
}
inline void MailboxMessage::set_has_json() {
  _impl_._oneof_case_[0] = kJson;
}
inline void MailboxMessage::clear_json() {
  if (_internal_has_json()) {
    _impl_.payload_.json_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& MailboxMessage::json() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MailboxMessage.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline void MailboxMessage::set_json(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  _impl_.payload_.json_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MailboxMessage.json)
}
inline std::string* MailboxMessage::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MailboxMessage.json)
  return _s;
}
inline const std::string& MailboxMessage::_internal_json() const {
  if (_internal_has_json()) {
    return _impl_.payload_.json_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MailboxMessage::_internal_set_json(const std::string& value) {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  _impl_.payload_.json_.Set(value, GetArenaForAllocation());
}
inline std::string* MailboxMessage::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_payload();
    set_has_json();
    _impl_.payload_.json_.InitDefault();
  }
  return _impl_.payload_.json_.Mutable(      GetArenaForAllocation());
}
inline std::string* MailboxMessage::release_json() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MailboxMessage.json)
  if (_internal_has_json()) {
    clear_has_payload();
    return _impl_.payload_.json_.Release();
  } else {
    return nullptr;
  }
}
inline void MailboxMessage::set_allocated_json(std::string* json) {
  if (has_payload()) {
    clear_payload();
  }
  if (json != nullptr) {
    set_has_json();
    _impl_.payload_.json_.InitAllocated(json, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MailboxMessage.json)
}

inline bool MailboxMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void MailboxMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline MailboxMessage::PayloadCase MailboxMessage::payload_case() const {
  return MailboxMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::meta::RegionRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::meta::RegionRole>() {
  return ::greptime::v1::meta::RegionRole_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fheartbeat_2eproto
