// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/meta/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fmeta_2fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2fstore_2eproto;
namespace greptime {
namespace v1 {
namespace meta {
class BatchDeleteRequest;
struct BatchDeleteRequestDefaultTypeInternal;
extern BatchDeleteRequestDefaultTypeInternal _BatchDeleteRequest_default_instance_;
class BatchDeleteResponse;
struct BatchDeleteResponseDefaultTypeInternal;
extern BatchDeleteResponseDefaultTypeInternal _BatchDeleteResponse_default_instance_;
class BatchGetRequest;
struct BatchGetRequestDefaultTypeInternal;
extern BatchGetRequestDefaultTypeInternal _BatchGetRequest_default_instance_;
class BatchGetResponse;
struct BatchGetResponseDefaultTypeInternal;
extern BatchGetResponseDefaultTypeInternal _BatchGetResponse_default_instance_;
class BatchPutRequest;
struct BatchPutRequestDefaultTypeInternal;
extern BatchPutRequestDefaultTypeInternal _BatchPutRequest_default_instance_;
class BatchPutResponse;
struct BatchPutResponseDefaultTypeInternal;
extern BatchPutResponseDefaultTypeInternal _BatchPutResponse_default_instance_;
class CompareAndPutRequest;
struct CompareAndPutRequestDefaultTypeInternal;
extern CompareAndPutRequestDefaultTypeInternal _CompareAndPutRequest_default_instance_;
class CompareAndPutResponse;
struct CompareAndPutResponseDefaultTypeInternal;
extern CompareAndPutResponseDefaultTypeInternal _CompareAndPutResponse_default_instance_;
class DeleteRangeRequest;
struct DeleteRangeRequestDefaultTypeInternal;
extern DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
class DeleteRangeResponse;
struct DeleteRangeResponseDefaultTypeInternal;
extern DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
class MoveValueRequest;
struct MoveValueRequestDefaultTypeInternal;
extern MoveValueRequestDefaultTypeInternal _MoveValueRequest_default_instance_;
class MoveValueResponse;
struct MoveValueResponseDefaultTypeInternal;
extern MoveValueResponseDefaultTypeInternal _MoveValueResponse_default_instance_;
class PutRequest;
struct PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
struct PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class RangeRequest;
struct RangeRequestDefaultTypeInternal;
extern RangeRequestDefaultTypeInternal _RangeRequest_default_instance_;
class RangeResponse;
struct RangeResponseDefaultTypeInternal;
extern RangeResponseDefaultTypeInternal _RangeResponse_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::meta::BatchDeleteRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::BatchDeleteRequest>(Arena*);
template<> ::greptime::v1::meta::BatchDeleteResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::BatchDeleteResponse>(Arena*);
template<> ::greptime::v1::meta::BatchGetRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::BatchGetRequest>(Arena*);
template<> ::greptime::v1::meta::BatchGetResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::BatchGetResponse>(Arena*);
template<> ::greptime::v1::meta::BatchPutRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::BatchPutRequest>(Arena*);
template<> ::greptime::v1::meta::BatchPutResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::BatchPutResponse>(Arena*);
template<> ::greptime::v1::meta::CompareAndPutRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::CompareAndPutRequest>(Arena*);
template<> ::greptime::v1::meta::CompareAndPutResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::CompareAndPutResponse>(Arena*);
template<> ::greptime::v1::meta::DeleteRangeRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::DeleteRangeRequest>(Arena*);
template<> ::greptime::v1::meta::DeleteRangeResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::DeleteRangeResponse>(Arena*);
template<> ::greptime::v1::meta::MoveValueRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::MoveValueRequest>(Arena*);
template<> ::greptime::v1::meta::MoveValueResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::MoveValueResponse>(Arena*);
template<> ::greptime::v1::meta::PutRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::PutRequest>(Arena*);
template<> ::greptime::v1::meta::PutResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::PutResponse>(Arena*);
template<> ::greptime::v1::meta::RangeRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::RangeRequest>(Arena*);
template<> ::greptime::v1::meta::RangeResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::RangeResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace meta {

// ===================================================================

class RangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RangeRequest) */ {
 public:
  inline RangeRequest() : RangeRequest(nullptr) {}
  ~RangeRequest() override;
  explicit PROTOBUF_CONSTEXPR RangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeRequest(const RangeRequest& from);
  RangeRequest(RangeRequest&& from) noexcept
    : RangeRequest() {
    *this = ::std::move(from);
  }

  inline RangeRequest& operator=(const RangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeRequest& operator=(RangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeRequest* internal_default_instance() {
    return reinterpret_cast<const RangeRequest*>(
               &_RangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RangeRequest& a, RangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeRequest& from) {
    RangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RangeRequest";
  }
  protected:
  explicit RangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kRangeEndFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kLimitFieldNumber = 4,
    kKeysOnlyFieldNumber = 5,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes range_end = 3;
  void clear_range_end();
  const std::string& range_end() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_range_end(ArgT0&& arg0, ArgT... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* range_end);
  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(const std::string& value);
  std::string* _internal_mutable_range_end();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // int64 limit = 4;
  void clear_limit();
  int64_t limit() const;
  void set_limit(int64_t value);
  private:
  int64_t _internal_limit() const;
  void _internal_set_limit(int64_t value);
  public:

  // bool keys_only = 5;
  void clear_keys_only();
  bool keys_only() const;
  void set_keys_only(bool value);
  private:
  bool _internal_keys_only() const;
  void _internal_set_keys_only(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    ::greptime::v1::meta::RequestHeader* header_;
    int64_t limit_;
    bool keys_only_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class RangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RangeResponse) */ {
 public:
  inline RangeResponse() : RangeResponse(nullptr) {}
  ~RangeResponse() override;
  explicit PROTOBUF_CONSTEXPR RangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeResponse(const RangeResponse& from);
  RangeResponse(RangeResponse&& from) noexcept
    : RangeResponse() {
    *this = ::std::move(from);
  }

  inline RangeResponse& operator=(const RangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeResponse& operator=(RangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeResponse* internal_default_instance() {
    return reinterpret_cast<const RangeResponse*>(
               &_RangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RangeResponse& a, RangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeResponse& from) {
    RangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RangeResponse";
  }
  protected:
  explicit RangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kMoreFieldNumber = 3,
  };
  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  ::greptime::v1::meta::KeyValue* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
      mutable_kvs();
  private:
  const ::greptime::v1::meta::KeyValue& _internal_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* _internal_add_kvs();
  public:
  const ::greptime::v1::meta::KeyValue& kvs(int index) const;
  ::greptime::v1::meta::KeyValue* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
      kvs() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // bool more = 3;
  void clear_more();
  bool more() const;
  void set_more(bool value);
  private:
  bool _internal_more() const;
  void _internal_set_more(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue > kvs_;
    ::greptime::v1::meta::ResponseHeader* header_;
    bool more_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class PutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.PutRequest) */ {
 public:
  inline PutRequest() : PutRequest(nullptr) {}
  ~PutRequest() override;
  explicit PROTOBUF_CONSTEXPR PutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutRequest(const PutRequest& from);
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutRequest& from) {
    PutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.PutRequest";
  }
  protected:
  explicit PutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 4,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // bool prev_kv = 4;
  void clear_prev_kv();
  bool prev_kv() const;
  void set_prev_kv(bool value);
  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.PutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::greptime::v1::meta::RequestHeader* header_;
    bool prev_kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class PutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.PutResponse) */ {
 public:
  inline PutResponse() : PutResponse(nullptr) {}
  ~PutResponse() override;
  explicit PROTOBUF_CONSTEXPR PutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutResponse(const PutResponse& from);
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutResponse& from) {
    PutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.PutResponse";
  }
  protected:
  explicit PutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 2,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.KeyValue prev_kv = 2;
  bool has_prev_kv() const;
  private:
  bool _internal_has_prev_kv() const;
  public:
  void clear_prev_kv();
  const ::greptime::v1::meta::KeyValue& prev_kv() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::KeyValue* release_prev_kv();
  ::greptime::v1::meta::KeyValue* mutable_prev_kv();
  void set_allocated_prev_kv(::greptime::v1::meta::KeyValue* prev_kv);
  private:
  const ::greptime::v1::meta::KeyValue& _internal_prev_kv() const;
  ::greptime::v1::meta::KeyValue* _internal_mutable_prev_kv();
  public:
  void unsafe_arena_set_allocated_prev_kv(
      ::greptime::v1::meta::KeyValue* prev_kv);
  ::greptime::v1::meta::KeyValue* unsafe_arena_release_prev_kv();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.PutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::KeyValue* prev_kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class BatchGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.BatchGetRequest) */ {
 public:
  inline BatchGetRequest() : BatchGetRequest(nullptr) {}
  ~BatchGetRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchGetRequest(const BatchGetRequest& from);
  BatchGetRequest(BatchGetRequest&& from) noexcept
    : BatchGetRequest() {
    *this = ::std::move(from);
  }

  inline BatchGetRequest& operator=(const BatchGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchGetRequest& operator=(BatchGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchGetRequest* internal_default_instance() {
    return reinterpret_cast<const BatchGetRequest*>(
               &_BatchGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BatchGetRequest& a, BatchGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchGetRequest& from) {
    BatchGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.BatchGetRequest";
  }
  protected:
  explicit BatchGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated bytes keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.BatchGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class BatchGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.BatchGetResponse) */ {
 public:
  inline BatchGetResponse() : BatchGetResponse(nullptr) {}
  ~BatchGetResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchGetResponse(const BatchGetResponse& from);
  BatchGetResponse(BatchGetResponse&& from) noexcept
    : BatchGetResponse() {
    *this = ::std::move(from);
  }

  inline BatchGetResponse& operator=(const BatchGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchGetResponse& operator=(BatchGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchGetResponse* internal_default_instance() {
    return reinterpret_cast<const BatchGetResponse*>(
               &_BatchGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BatchGetResponse& a, BatchGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchGetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchGetResponse& from) {
    BatchGetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.BatchGetResponse";
  }
  protected:
  explicit BatchGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  ::greptime::v1::meta::KeyValue* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
      mutable_kvs();
  private:
  const ::greptime::v1::meta::KeyValue& _internal_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* _internal_add_kvs();
  public:
  const ::greptime::v1::meta::KeyValue& kvs(int index) const;
  ::greptime::v1::meta::KeyValue* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
      kvs() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.BatchGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue > kvs_;
    ::greptime::v1::meta::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class BatchPutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.BatchPutRequest) */ {
 public:
  inline BatchPutRequest() : BatchPutRequest(nullptr) {}
  ~BatchPutRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchPutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchPutRequest(const BatchPutRequest& from);
  BatchPutRequest(BatchPutRequest&& from) noexcept
    : BatchPutRequest() {
    *this = ::std::move(from);
  }

  inline BatchPutRequest& operator=(const BatchPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchPutRequest& operator=(BatchPutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchPutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchPutRequest* internal_default_instance() {
    return reinterpret_cast<const BatchPutRequest*>(
               &_BatchPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BatchPutRequest& a, BatchPutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchPutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchPutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchPutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchPutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchPutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchPutRequest& from) {
    BatchPutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchPutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.BatchPutRequest";
  }
  protected:
  explicit BatchPutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 3,
  };
  // repeated .greptime.v1.meta.KeyValue kvs = 2;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  ::greptime::v1::meta::KeyValue* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
      mutable_kvs();
  private:
  const ::greptime::v1::meta::KeyValue& _internal_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* _internal_add_kvs();
  public:
  const ::greptime::v1::meta::KeyValue& kvs(int index) const;
  ::greptime::v1::meta::KeyValue* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
      kvs() const;

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // bool prev_kv = 3;
  void clear_prev_kv();
  bool prev_kv() const;
  void set_prev_kv(bool value);
  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.BatchPutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue > kvs_;
    ::greptime::v1::meta::RequestHeader* header_;
    bool prev_kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class BatchPutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.BatchPutResponse) */ {
 public:
  inline BatchPutResponse() : BatchPutResponse(nullptr) {}
  ~BatchPutResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchPutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchPutResponse(const BatchPutResponse& from);
  BatchPutResponse(BatchPutResponse&& from) noexcept
    : BatchPutResponse() {
    *this = ::std::move(from);
  }

  inline BatchPutResponse& operator=(const BatchPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchPutResponse& operator=(BatchPutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchPutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchPutResponse* internal_default_instance() {
    return reinterpret_cast<const BatchPutResponse*>(
               &_BatchPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchPutResponse& a, BatchPutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchPutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchPutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchPutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchPutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchPutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchPutResponse& from) {
    BatchPutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchPutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.BatchPutResponse";
  }
  protected:
  explicit BatchPutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevKvsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
  int prev_kvs_size() const;
  private:
  int _internal_prev_kvs_size() const;
  public:
  void clear_prev_kvs();
  ::greptime::v1::meta::KeyValue* mutable_prev_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
      mutable_prev_kvs();
  private:
  const ::greptime::v1::meta::KeyValue& _internal_prev_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* _internal_add_prev_kvs();
  public:
  const ::greptime::v1::meta::KeyValue& prev_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* add_prev_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
      prev_kvs() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.BatchPutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue > prev_kvs_;
    ::greptime::v1::meta::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class BatchDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.BatchDeleteRequest) */ {
 public:
  inline BatchDeleteRequest() : BatchDeleteRequest(nullptr) {}
  ~BatchDeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchDeleteRequest(const BatchDeleteRequest& from);
  BatchDeleteRequest(BatchDeleteRequest&& from) noexcept
    : BatchDeleteRequest() {
    *this = ::std::move(from);
  }

  inline BatchDeleteRequest& operator=(const BatchDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchDeleteRequest& operator=(BatchDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const BatchDeleteRequest*>(
               &_BatchDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BatchDeleteRequest& a, BatchDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchDeleteRequest& from) {
    BatchDeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.BatchDeleteRequest";
  }
  protected:
  explicit BatchDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 3,
  };
  // repeated bytes keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // bool prev_kv = 3;
  void clear_prev_kv();
  bool prev_kv() const;
  void set_prev_kv(bool value);
  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.BatchDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    ::greptime::v1::meta::RequestHeader* header_;
    bool prev_kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class BatchDeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.BatchDeleteResponse) */ {
 public:
  inline BatchDeleteResponse() : BatchDeleteResponse(nullptr) {}
  ~BatchDeleteResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchDeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchDeleteResponse(const BatchDeleteResponse& from);
  BatchDeleteResponse(BatchDeleteResponse&& from) noexcept
    : BatchDeleteResponse() {
    *this = ::std::move(from);
  }

  inline BatchDeleteResponse& operator=(const BatchDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchDeleteResponse& operator=(BatchDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const BatchDeleteResponse*>(
               &_BatchDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BatchDeleteResponse& a, BatchDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchDeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchDeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchDeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchDeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchDeleteResponse& from) {
    BatchDeleteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchDeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.BatchDeleteResponse";
  }
  protected:
  explicit BatchDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevKvsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
  int prev_kvs_size() const;
  private:
  int _internal_prev_kvs_size() const;
  public:
  void clear_prev_kvs();
  ::greptime::v1::meta::KeyValue* mutable_prev_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
      mutable_prev_kvs();
  private:
  const ::greptime::v1::meta::KeyValue& _internal_prev_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* _internal_add_prev_kvs();
  public:
  const ::greptime::v1::meta::KeyValue& prev_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* add_prev_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
      prev_kvs() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.BatchDeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue > prev_kvs_;
    ::greptime::v1::meta::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class CompareAndPutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.CompareAndPutRequest) */ {
 public:
  inline CompareAndPutRequest() : CompareAndPutRequest(nullptr) {}
  ~CompareAndPutRequest() override;
  explicit PROTOBUF_CONSTEXPR CompareAndPutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompareAndPutRequest(const CompareAndPutRequest& from);
  CompareAndPutRequest(CompareAndPutRequest&& from) noexcept
    : CompareAndPutRequest() {
    *this = ::std::move(from);
  }

  inline CompareAndPutRequest& operator=(const CompareAndPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareAndPutRequest& operator=(CompareAndPutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareAndPutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompareAndPutRequest* internal_default_instance() {
    return reinterpret_cast<const CompareAndPutRequest*>(
               &_CompareAndPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CompareAndPutRequest& a, CompareAndPutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareAndPutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareAndPutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompareAndPutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompareAndPutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompareAndPutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompareAndPutRequest& from) {
    CompareAndPutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareAndPutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.CompareAndPutRequest";
  }
  protected:
  explicit CompareAndPutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kExpectFieldNumber = 3,
    kValueFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes expect = 3;
  void clear_expect();
  const std::string& expect() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expect(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expect();
  PROTOBUF_NODISCARD std::string* release_expect();
  void set_allocated_expect(std::string* expect);
  private:
  const std::string& _internal_expect() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expect(const std::string& value);
  std::string* _internal_mutable_expect();
  public:

  // bytes value = 4;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.CompareAndPutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expect_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class CompareAndPutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.CompareAndPutResponse) */ {
 public:
  inline CompareAndPutResponse() : CompareAndPutResponse(nullptr) {}
  ~CompareAndPutResponse() override;
  explicit PROTOBUF_CONSTEXPR CompareAndPutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompareAndPutResponse(const CompareAndPutResponse& from);
  CompareAndPutResponse(CompareAndPutResponse&& from) noexcept
    : CompareAndPutResponse() {
    *this = ::std::move(from);
  }

  inline CompareAndPutResponse& operator=(const CompareAndPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareAndPutResponse& operator=(CompareAndPutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareAndPutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompareAndPutResponse* internal_default_instance() {
    return reinterpret_cast<const CompareAndPutResponse*>(
               &_CompareAndPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CompareAndPutResponse& a, CompareAndPutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareAndPutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareAndPutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompareAndPutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompareAndPutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompareAndPutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompareAndPutResponse& from) {
    CompareAndPutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareAndPutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.CompareAndPutResponse";
  }
  protected:
  explicit CompareAndPutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.KeyValue prev_kv = 3;
  bool has_prev_kv() const;
  private:
  bool _internal_has_prev_kv() const;
  public:
  void clear_prev_kv();
  const ::greptime::v1::meta::KeyValue& prev_kv() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::KeyValue* release_prev_kv();
  ::greptime::v1::meta::KeyValue* mutable_prev_kv();
  void set_allocated_prev_kv(::greptime::v1::meta::KeyValue* prev_kv);
  private:
  const ::greptime::v1::meta::KeyValue& _internal_prev_kv() const;
  ::greptime::v1::meta::KeyValue* _internal_mutable_prev_kv();
  public:
  void unsafe_arena_set_allocated_prev_kv(
      ::greptime::v1::meta::KeyValue* prev_kv);
  ::greptime::v1::meta::KeyValue* unsafe_arena_release_prev_kv();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.CompareAndPutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::KeyValue* prev_kv_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class DeleteRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.DeleteRangeRequest) */ {
 public:
  inline DeleteRangeRequest() : DeleteRangeRequest(nullptr) {}
  ~DeleteRangeRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRangeRequest(const DeleteRangeRequest& from);
  DeleteRangeRequest(DeleteRangeRequest&& from) noexcept
    : DeleteRangeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRangeRequest& operator=(DeleteRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRangeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeRequest*>(
               &_DeleteRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteRangeRequest& a, DeleteRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRangeRequest& from) {
    DeleteRangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.DeleteRangeRequest";
  }
  protected:
  explicit DeleteRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kRangeEndFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kPrevKvFieldNumber = 4,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes range_end = 3;
  void clear_range_end();
  const std::string& range_end() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_range_end(ArgT0&& arg0, ArgT... args);
  std::string* mutable_range_end();
  PROTOBUF_NODISCARD std::string* release_range_end();
  void set_allocated_range_end(std::string* range_end);
  private:
  const std::string& _internal_range_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_end(const std::string& value);
  std::string* _internal_mutable_range_end();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // bool prev_kv = 4;
  void clear_prev_kv();
  bool prev_kv() const;
  void set_prev_kv(bool value);
  private:
  bool _internal_prev_kv() const;
  void _internal_set_prev_kv(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.DeleteRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_end_;
    ::greptime::v1::meta::RequestHeader* header_;
    bool prev_kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class DeleteRangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.DeleteRangeResponse) */ {
 public:
  inline DeleteRangeResponse() : DeleteRangeResponse(nullptr) {}
  ~DeleteRangeResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteRangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRangeResponse(const DeleteRangeResponse& from);
  DeleteRangeResponse(DeleteRangeResponse&& from) noexcept
    : DeleteRangeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRangeResponse& operator=(DeleteRangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRangeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeResponse*>(
               &_DeleteRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteRangeResponse& a, DeleteRangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRangeResponse& from) {
    DeleteRangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.DeleteRangeResponse";
  }
  protected:
  explicit DeleteRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevKvsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kDeletedFieldNumber = 2,
  };
  // repeated .greptime.v1.meta.KeyValue prev_kvs = 3;
  int prev_kvs_size() const;
  private:
  int _internal_prev_kvs_size() const;
  public:
  void clear_prev_kvs();
  ::greptime::v1::meta::KeyValue* mutable_prev_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
      mutable_prev_kvs();
  private:
  const ::greptime::v1::meta::KeyValue& _internal_prev_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* _internal_add_prev_kvs();
  public:
  const ::greptime::v1::meta::KeyValue& prev_kvs(int index) const;
  ::greptime::v1::meta::KeyValue* add_prev_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
      prev_kvs() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // int64 deleted = 2;
  void clear_deleted();
  int64_t deleted() const;
  void set_deleted(int64_t value);
  private:
  int64_t _internal_deleted() const;
  void _internal_set_deleted(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.DeleteRangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue > prev_kvs_;
    ::greptime::v1::meta::ResponseHeader* header_;
    int64_t deleted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class MoveValueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.MoveValueRequest) */ {
 public:
  inline MoveValueRequest() : MoveValueRequest(nullptr) {}
  ~MoveValueRequest() override;
  explicit PROTOBUF_CONSTEXPR MoveValueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveValueRequest(const MoveValueRequest& from);
  MoveValueRequest(MoveValueRequest&& from) noexcept
    : MoveValueRequest() {
    *this = ::std::move(from);
  }

  inline MoveValueRequest& operator=(const MoveValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveValueRequest& operator=(MoveValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveValueRequest* internal_default_instance() {
    return reinterpret_cast<const MoveValueRequest*>(
               &_MoveValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MoveValueRequest& a, MoveValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveValueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveValueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveValueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveValueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveValueRequest& from) {
    MoveValueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveValueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.MoveValueRequest";
  }
  protected:
  explicit MoveValueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromKeyFieldNumber = 2,
    kToKeyFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // bytes from_key = 2;
  void clear_from_key();
  const std::string& from_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_key();
  PROTOBUF_NODISCARD std::string* release_from_key();
  void set_allocated_from_key(std::string* from_key);
  private:
  const std::string& _internal_from_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_key(const std::string& value);
  std::string* _internal_mutable_from_key();
  public:

  // bytes to_key = 3;
  void clear_to_key();
  const std::string& to_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_key();
  PROTOBUF_NODISCARD std::string* release_to_key();
  void set_allocated_to_key(std::string* to_key);
  private:
  const std::string& _internal_to_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_key(const std::string& value);
  std::string* _internal_mutable_to_key();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.MoveValueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_key_;
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// -------------------------------------------------------------------

class MoveValueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.MoveValueResponse) */ {
 public:
  inline MoveValueResponse() : MoveValueResponse(nullptr) {}
  ~MoveValueResponse() override;
  explicit PROTOBUF_CONSTEXPR MoveValueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveValueResponse(const MoveValueResponse& from);
  MoveValueResponse(MoveValueResponse&& from) noexcept
    : MoveValueResponse() {
    *this = ::std::move(from);
  }

  inline MoveValueResponse& operator=(const MoveValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveValueResponse& operator=(MoveValueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveValueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveValueResponse* internal_default_instance() {
    return reinterpret_cast<const MoveValueResponse*>(
               &_MoveValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MoveValueResponse& a, MoveValueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveValueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveValueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveValueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveValueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveValueResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveValueResponse& from) {
    MoveValueResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveValueResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.MoveValueResponse";
  }
  protected:
  explicit MoveValueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kKvFieldNumber = 2,
  };
  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.KeyValue kv = 2;
  bool has_kv() const;
  private:
  bool _internal_has_kv() const;
  public:
  void clear_kv();
  const ::greptime::v1::meta::KeyValue& kv() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::KeyValue* release_kv();
  ::greptime::v1::meta::KeyValue* mutable_kv();
  void set_allocated_kv(::greptime::v1::meta::KeyValue* kv);
  private:
  const ::greptime::v1::meta::KeyValue& _internal_kv() const;
  ::greptime::v1::meta::KeyValue* _internal_mutable_kv();
  public:
  void unsafe_arena_set_allocated_kv(
      ::greptime::v1::meta::KeyValue* kv);
  ::greptime::v1::meta::KeyValue* unsafe_arena_release_kv();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.MoveValueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::ResponseHeader* header_;
    ::greptime::v1::meta::KeyValue* kv_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2fstore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RangeRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool RangeRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RangeRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& RangeRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& RangeRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeRequest.header)
  return _internal_header();
}
inline void RangeRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RangeRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* RangeRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* RangeRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RangeRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* RangeRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* RangeRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RangeRequest.header)
  return _msg;
}
inline void RangeRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RangeRequest.header)
}

// bytes key = 2;
inline void RangeRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& RangeRequest::key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RangeRequest.key)
}
inline std::string* RangeRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RangeRequest.key)
  return _s;
}
inline const std::string& RangeRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void RangeRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeRequest::release_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RangeRequest.key)
  return _impl_.key_.Release();
}
inline void RangeRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RangeRequest.key)
}

// bytes range_end = 3;
inline void RangeRequest::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& RangeRequest::range_end() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeRequest.range_end)
  return _internal_range_end();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeRequest::set_range_end(ArgT0&& arg0, ArgT... args) {
 
 _impl_.range_end_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RangeRequest.range_end)
}
inline std::string* RangeRequest::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RangeRequest.range_end)
  return _s;
}
inline const std::string& RangeRequest::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void RangeRequest::_internal_set_range_end(const std::string& value) {
  
  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeRequest::_internal_mutable_range_end() {
  
  return _impl_.range_end_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeRequest::release_range_end() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RangeRequest.range_end)
  return _impl_.range_end_.Release();
}
inline void RangeRequest::set_allocated_range_end(std::string* range_end) {
  if (range_end != nullptr) {
    
  } else {
    
  }
  _impl_.range_end_.SetAllocated(range_end, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.range_end_.IsDefault()) {
    _impl_.range_end_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RangeRequest.range_end)
}

// int64 limit = 4;
inline void RangeRequest::clear_limit() {
  _impl_.limit_ = int64_t{0};
}
inline int64_t RangeRequest::_internal_limit() const {
  return _impl_.limit_;
}
inline int64_t RangeRequest::limit() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeRequest.limit)
  return _internal_limit();
}
inline void RangeRequest::_internal_set_limit(int64_t value) {
  
  _impl_.limit_ = value;
}
inline void RangeRequest::set_limit(int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RangeRequest.limit)
}

// bool keys_only = 5;
inline void RangeRequest::clear_keys_only() {
  _impl_.keys_only_ = false;
}
inline bool RangeRequest::_internal_keys_only() const {
  return _impl_.keys_only_;
}
inline bool RangeRequest::keys_only() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeRequest.keys_only)
  return _internal_keys_only();
}
inline void RangeRequest::_internal_set_keys_only(bool value) {
  
  _impl_.keys_only_ = value;
}
inline void RangeRequest::set_keys_only(bool value) {
  _internal_set_keys_only(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RangeRequest.keys_only)
}

// -------------------------------------------------------------------

// RangeResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool RangeResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RangeResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& RangeResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& RangeResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeResponse.header)
  return _internal_header();
}
inline void RangeResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RangeResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* RangeResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* RangeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RangeResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* RangeResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* RangeResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RangeResponse.header)
  return _msg;
}
inline void RangeResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RangeResponse.header)
}

// repeated .greptime.v1.meta.KeyValue kvs = 2;
inline int RangeResponse::_internal_kvs_size() const {
  return _impl_.kvs_.size();
}
inline int RangeResponse::kvs_size() const {
  return _internal_kvs_size();
}
inline ::greptime::v1::meta::KeyValue* RangeResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RangeResponse.kvs)
  return _impl_.kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
RangeResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RangeResponse.kvs)
  return &_impl_.kvs_;
}
inline const ::greptime::v1::meta::KeyValue& RangeResponse::_internal_kvs(int index) const {
  return _impl_.kvs_.Get(index);
}
inline const ::greptime::v1::meta::KeyValue& RangeResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeResponse.kvs)
  return _internal_kvs(index);
}
inline ::greptime::v1::meta::KeyValue* RangeResponse::_internal_add_kvs() {
  return _impl_.kvs_.Add();
}
inline ::greptime::v1::meta::KeyValue* RangeResponse::add_kvs() {
  ::greptime::v1::meta::KeyValue* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RangeResponse.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
RangeResponse::kvs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RangeResponse.kvs)
  return _impl_.kvs_;
}

// bool more = 3;
inline void RangeResponse::clear_more() {
  _impl_.more_ = false;
}
inline bool RangeResponse::_internal_more() const {
  return _impl_.more_;
}
inline bool RangeResponse::more() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RangeResponse.more)
  return _internal_more();
}
inline void RangeResponse::_internal_set_more(bool value) {
  
  _impl_.more_ = value;
}
inline void RangeResponse::set_more(bool value) {
  _internal_set_more(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RangeResponse.more)
}

// -------------------------------------------------------------------

// PutRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool PutRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PutRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& PutRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& PutRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.PutRequest.header)
  return _internal_header();
}
inline void PutRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.PutRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* PutRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* PutRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.PutRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* PutRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* PutRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.PutRequest.header)
  return _msg;
}
inline void PutRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.PutRequest.header)
}

// bytes key = 2;
inline void PutRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& PutRequest::key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.PutRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.PutRequest.key)
}
inline std::string* PutRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.PutRequest.key)
  return _s;
}
inline const std::string& PutRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void PutRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* PutRequest::release_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.PutRequest.key)
  return _impl_.key_.Release();
}
inline void PutRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.PutRequest.key)
}

// bytes value = 3;
inline void PutRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.PutRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.PutRequest.value)
}
inline std::string* PutRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.PutRequest.value)
  return _s;
}
inline const std::string& PutRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void PutRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.PutRequest.value)
  return _impl_.value_.Release();
}
inline void PutRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.PutRequest.value)
}

// bool prev_kv = 4;
inline void PutRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool PutRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline bool PutRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.PutRequest.prev_kv)
  return _internal_prev_kv();
}
inline void PutRequest::_internal_set_prev_kv(bool value) {
  
  _impl_.prev_kv_ = value;
}
inline void PutRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.PutRequest.prev_kv)
}

// -------------------------------------------------------------------

// PutResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool PutResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool PutResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& PutResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& PutResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.PutResponse.header)
  return _internal_header();
}
inline void PutResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.PutResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* PutResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* PutResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.PutResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* PutResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* PutResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.PutResponse.header)
  return _msg;
}
inline void PutResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.PutResponse.header)
}

// .greptime.v1.meta.KeyValue prev_kv = 2;
inline bool PutResponse::_internal_has_prev_kv() const {
  return this != internal_default_instance() && _impl_.prev_kv_ != nullptr;
}
inline bool PutResponse::has_prev_kv() const {
  return _internal_has_prev_kv();
}
inline const ::greptime::v1::meta::KeyValue& PutResponse::_internal_prev_kv() const {
  const ::greptime::v1::meta::KeyValue* p = _impl_.prev_kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::KeyValue&>(
      ::greptime::v1::meta::_KeyValue_default_instance_);
}
inline const ::greptime::v1::meta::KeyValue& PutResponse::prev_kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.PutResponse.prev_kv)
  return _internal_prev_kv();
}
inline void PutResponse::unsafe_arena_set_allocated_prev_kv(
    ::greptime::v1::meta::KeyValue* prev_kv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_kv_);
  }
  _impl_.prev_kv_ = prev_kv;
  if (prev_kv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.PutResponse.prev_kv)
}
inline ::greptime::v1::meta::KeyValue* PutResponse::release_prev_kv() {
  
  ::greptime::v1::meta::KeyValue* temp = _impl_.prev_kv_;
  _impl_.prev_kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::KeyValue* PutResponse::unsafe_arena_release_prev_kv() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.PutResponse.prev_kv)
  
  ::greptime::v1::meta::KeyValue* temp = _impl_.prev_kv_;
  _impl_.prev_kv_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::KeyValue* PutResponse::_internal_mutable_prev_kv() {
  
  if (_impl_.prev_kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::KeyValue>(GetArenaForAllocation());
    _impl_.prev_kv_ = p;
  }
  return _impl_.prev_kv_;
}
inline ::greptime::v1::meta::KeyValue* PutResponse::mutable_prev_kv() {
  ::greptime::v1::meta::KeyValue* _msg = _internal_mutable_prev_kv();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.PutResponse.prev_kv)
  return _msg;
}
inline void PutResponse::set_allocated_prev_kv(::greptime::v1::meta::KeyValue* prev_kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_kv_);
  }
  if (prev_kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_kv));
    if (message_arena != submessage_arena) {
      prev_kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_kv, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prev_kv_ = prev_kv;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.PutResponse.prev_kv)
}

// -------------------------------------------------------------------

// BatchGetRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool BatchGetRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BatchGetRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& BatchGetRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& BatchGetRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchGetRequest.header)
  return _internal_header();
}
inline void BatchGetRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.BatchGetRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* BatchGetRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* BatchGetRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.BatchGetRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* BatchGetRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* BatchGetRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchGetRequest.header)
  return _msg;
}
inline void BatchGetRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.BatchGetRequest.header)
}

// repeated bytes keys = 2;
inline int BatchGetRequest::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int BatchGetRequest::keys_size() const {
  return _internal_keys_size();
}
inline void BatchGetRequest::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* BatchGetRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.meta.BatchGetRequest.keys)
  return _s;
}
inline const std::string& BatchGetRequest::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& BatchGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchGetRequest.keys)
  return _internal_keys(index);
}
inline std::string* BatchGetRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchGetRequest.keys)
  return _impl_.keys_.Mutable(index);
}
inline void BatchGetRequest::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.BatchGetRequest.keys)
}
inline void BatchGetRequest::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.meta.BatchGetRequest.keys)
}
inline void BatchGetRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.meta.BatchGetRequest.keys)
}
inline void BatchGetRequest::set_keys(int index, const void* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.meta.BatchGetRequest.keys)
}
inline std::string* BatchGetRequest::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void BatchGetRequest::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchGetRequest.keys)
}
inline void BatchGetRequest::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchGetRequest.keys)
}
inline void BatchGetRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.meta.BatchGetRequest.keys)
}
inline void BatchGetRequest::add_keys(const void* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.meta.BatchGetRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.BatchGetRequest.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.BatchGetRequest.keys)
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// BatchGetResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool BatchGetResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BatchGetResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& BatchGetResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& BatchGetResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchGetResponse.header)
  return _internal_header();
}
inline void BatchGetResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.BatchGetResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* BatchGetResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* BatchGetResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.BatchGetResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* BatchGetResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* BatchGetResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchGetResponse.header)
  return _msg;
}
inline void BatchGetResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.BatchGetResponse.header)
}

// repeated .greptime.v1.meta.KeyValue kvs = 2;
inline int BatchGetResponse::_internal_kvs_size() const {
  return _impl_.kvs_.size();
}
inline int BatchGetResponse::kvs_size() const {
  return _internal_kvs_size();
}
inline ::greptime::v1::meta::KeyValue* BatchGetResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchGetResponse.kvs)
  return _impl_.kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
BatchGetResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.BatchGetResponse.kvs)
  return &_impl_.kvs_;
}
inline const ::greptime::v1::meta::KeyValue& BatchGetResponse::_internal_kvs(int index) const {
  return _impl_.kvs_.Get(index);
}
inline const ::greptime::v1::meta::KeyValue& BatchGetResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchGetResponse.kvs)
  return _internal_kvs(index);
}
inline ::greptime::v1::meta::KeyValue* BatchGetResponse::_internal_add_kvs() {
  return _impl_.kvs_.Add();
}
inline ::greptime::v1::meta::KeyValue* BatchGetResponse::add_kvs() {
  ::greptime::v1::meta::KeyValue* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchGetResponse.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
BatchGetResponse::kvs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.BatchGetResponse.kvs)
  return _impl_.kvs_;
}

// -------------------------------------------------------------------

// BatchPutRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool BatchPutRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BatchPutRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& BatchPutRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& BatchPutRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchPutRequest.header)
  return _internal_header();
}
inline void BatchPutRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.BatchPutRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* BatchPutRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* BatchPutRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.BatchPutRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* BatchPutRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* BatchPutRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchPutRequest.header)
  return _msg;
}
inline void BatchPutRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.BatchPutRequest.header)
}

// repeated .greptime.v1.meta.KeyValue kvs = 2;
inline int BatchPutRequest::_internal_kvs_size() const {
  return _impl_.kvs_.size();
}
inline int BatchPutRequest::kvs_size() const {
  return _internal_kvs_size();
}
inline ::greptime::v1::meta::KeyValue* BatchPutRequest::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchPutRequest.kvs)
  return _impl_.kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
BatchPutRequest::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.BatchPutRequest.kvs)
  return &_impl_.kvs_;
}
inline const ::greptime::v1::meta::KeyValue& BatchPutRequest::_internal_kvs(int index) const {
  return _impl_.kvs_.Get(index);
}
inline const ::greptime::v1::meta::KeyValue& BatchPutRequest::kvs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchPutRequest.kvs)
  return _internal_kvs(index);
}
inline ::greptime::v1::meta::KeyValue* BatchPutRequest::_internal_add_kvs() {
  return _impl_.kvs_.Add();
}
inline ::greptime::v1::meta::KeyValue* BatchPutRequest::add_kvs() {
  ::greptime::v1::meta::KeyValue* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchPutRequest.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
BatchPutRequest::kvs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.BatchPutRequest.kvs)
  return _impl_.kvs_;
}

// bool prev_kv = 3;
inline void BatchPutRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool BatchPutRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline bool BatchPutRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchPutRequest.prev_kv)
  return _internal_prev_kv();
}
inline void BatchPutRequest::_internal_set_prev_kv(bool value) {
  
  _impl_.prev_kv_ = value;
}
inline void BatchPutRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.BatchPutRequest.prev_kv)
}

// -------------------------------------------------------------------

// BatchPutResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool BatchPutResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BatchPutResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& BatchPutResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& BatchPutResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchPutResponse.header)
  return _internal_header();
}
inline void BatchPutResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.BatchPutResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* BatchPutResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* BatchPutResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.BatchPutResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* BatchPutResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* BatchPutResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchPutResponse.header)
  return _msg;
}
inline void BatchPutResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.BatchPutResponse.header)
}

// repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
inline int BatchPutResponse::_internal_prev_kvs_size() const {
  return _impl_.prev_kvs_.size();
}
inline int BatchPutResponse::prev_kvs_size() const {
  return _internal_prev_kvs_size();
}
inline ::greptime::v1::meta::KeyValue* BatchPutResponse::mutable_prev_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchPutResponse.prev_kvs)
  return _impl_.prev_kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
BatchPutResponse::mutable_prev_kvs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.BatchPutResponse.prev_kvs)
  return &_impl_.prev_kvs_;
}
inline const ::greptime::v1::meta::KeyValue& BatchPutResponse::_internal_prev_kvs(int index) const {
  return _impl_.prev_kvs_.Get(index);
}
inline const ::greptime::v1::meta::KeyValue& BatchPutResponse::prev_kvs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchPutResponse.prev_kvs)
  return _internal_prev_kvs(index);
}
inline ::greptime::v1::meta::KeyValue* BatchPutResponse::_internal_add_prev_kvs() {
  return _impl_.prev_kvs_.Add();
}
inline ::greptime::v1::meta::KeyValue* BatchPutResponse::add_prev_kvs() {
  ::greptime::v1::meta::KeyValue* _add = _internal_add_prev_kvs();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchPutResponse.prev_kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
BatchPutResponse::prev_kvs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.BatchPutResponse.prev_kvs)
  return _impl_.prev_kvs_;
}

// -------------------------------------------------------------------

// BatchDeleteRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool BatchDeleteRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BatchDeleteRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& BatchDeleteRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& BatchDeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchDeleteRequest.header)
  return _internal_header();
}
inline void BatchDeleteRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.BatchDeleteRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* BatchDeleteRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* BatchDeleteRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.BatchDeleteRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* BatchDeleteRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* BatchDeleteRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchDeleteRequest.header)
  return _msg;
}
inline void BatchDeleteRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.BatchDeleteRequest.header)
}

// repeated bytes keys = 2;
inline int BatchDeleteRequest::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int BatchDeleteRequest::keys_size() const {
  return _internal_keys_size();
}
inline void BatchDeleteRequest::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* BatchDeleteRequest::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.meta.BatchDeleteRequest.keys)
  return _s;
}
inline const std::string& BatchDeleteRequest::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& BatchDeleteRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchDeleteRequest.keys)
  return _internal_keys(index);
}
inline std::string* BatchDeleteRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchDeleteRequest.keys)
  return _impl_.keys_.Mutable(index);
}
inline void BatchDeleteRequest::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline void BatchDeleteRequest::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline void BatchDeleteRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline void BatchDeleteRequest::set_keys(int index, const void* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline std::string* BatchDeleteRequest::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void BatchDeleteRequest::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline void BatchDeleteRequest::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline void BatchDeleteRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline void BatchDeleteRequest::add_keys(const void* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.meta.BatchDeleteRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BatchDeleteRequest::keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.BatchDeleteRequest.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BatchDeleteRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.BatchDeleteRequest.keys)
  return &_impl_.keys_;
}

// bool prev_kv = 3;
inline void BatchDeleteRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool BatchDeleteRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline bool BatchDeleteRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchDeleteRequest.prev_kv)
  return _internal_prev_kv();
}
inline void BatchDeleteRequest::_internal_set_prev_kv(bool value) {
  
  _impl_.prev_kv_ = value;
}
inline void BatchDeleteRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.BatchDeleteRequest.prev_kv)
}

// -------------------------------------------------------------------

// BatchDeleteResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool BatchDeleteResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool BatchDeleteResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& BatchDeleteResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& BatchDeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchDeleteResponse.header)
  return _internal_header();
}
inline void BatchDeleteResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.BatchDeleteResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* BatchDeleteResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* BatchDeleteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.BatchDeleteResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* BatchDeleteResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* BatchDeleteResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchDeleteResponse.header)
  return _msg;
}
inline void BatchDeleteResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.BatchDeleteResponse.header)
}

// repeated .greptime.v1.meta.KeyValue prev_kvs = 2;
inline int BatchDeleteResponse::_internal_prev_kvs_size() const {
  return _impl_.prev_kvs_.size();
}
inline int BatchDeleteResponse::prev_kvs_size() const {
  return _internal_prev_kvs_size();
}
inline ::greptime::v1::meta::KeyValue* BatchDeleteResponse::mutable_prev_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.BatchDeleteResponse.prev_kvs)
  return _impl_.prev_kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
BatchDeleteResponse::mutable_prev_kvs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.BatchDeleteResponse.prev_kvs)
  return &_impl_.prev_kvs_;
}
inline const ::greptime::v1::meta::KeyValue& BatchDeleteResponse::_internal_prev_kvs(int index) const {
  return _impl_.prev_kvs_.Get(index);
}
inline const ::greptime::v1::meta::KeyValue& BatchDeleteResponse::prev_kvs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.BatchDeleteResponse.prev_kvs)
  return _internal_prev_kvs(index);
}
inline ::greptime::v1::meta::KeyValue* BatchDeleteResponse::_internal_add_prev_kvs() {
  return _impl_.prev_kvs_.Add();
}
inline ::greptime::v1::meta::KeyValue* BatchDeleteResponse::add_prev_kvs() {
  ::greptime::v1::meta::KeyValue* _add = _internal_add_prev_kvs();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.BatchDeleteResponse.prev_kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
BatchDeleteResponse::prev_kvs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.BatchDeleteResponse.prev_kvs)
  return _impl_.prev_kvs_;
}

// -------------------------------------------------------------------

// CompareAndPutRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool CompareAndPutRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CompareAndPutRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& CompareAndPutRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& CompareAndPutRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutRequest.header)
  return _internal_header();
}
inline void CompareAndPutRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.CompareAndPutRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* CompareAndPutRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* CompareAndPutRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CompareAndPutRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* CompareAndPutRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* CompareAndPutRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CompareAndPutRequest.header)
  return _msg;
}
inline void CompareAndPutRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CompareAndPutRequest.header)
}

// bytes key = 2;
inline void CompareAndPutRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& CompareAndPutRequest::key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompareAndPutRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.CompareAndPutRequest.key)
}
inline std::string* CompareAndPutRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CompareAndPutRequest.key)
  return _s;
}
inline const std::string& CompareAndPutRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void CompareAndPutRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndPutRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* CompareAndPutRequest::release_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CompareAndPutRequest.key)
  return _impl_.key_.Release();
}
inline void CompareAndPutRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CompareAndPutRequest.key)
}

// bytes expect = 3;
inline void CompareAndPutRequest::clear_expect() {
  _impl_.expect_.ClearToEmpty();
}
inline const std::string& CompareAndPutRequest::expect() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutRequest.expect)
  return _internal_expect();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompareAndPutRequest::set_expect(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expect_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.CompareAndPutRequest.expect)
}
inline std::string* CompareAndPutRequest::mutable_expect() {
  std::string* _s = _internal_mutable_expect();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CompareAndPutRequest.expect)
  return _s;
}
inline const std::string& CompareAndPutRequest::_internal_expect() const {
  return _impl_.expect_.Get();
}
inline void CompareAndPutRequest::_internal_set_expect(const std::string& value) {
  
  _impl_.expect_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndPutRequest::_internal_mutable_expect() {
  
  return _impl_.expect_.Mutable(GetArenaForAllocation());
}
inline std::string* CompareAndPutRequest::release_expect() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CompareAndPutRequest.expect)
  return _impl_.expect_.Release();
}
inline void CompareAndPutRequest::set_allocated_expect(std::string* expect) {
  if (expect != nullptr) {
    
  } else {
    
  }
  _impl_.expect_.SetAllocated(expect, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expect_.IsDefault()) {
    _impl_.expect_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CompareAndPutRequest.expect)
}

// bytes value = 4;
inline void CompareAndPutRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& CompareAndPutRequest::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompareAndPutRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.CompareAndPutRequest.value)
}
inline std::string* CompareAndPutRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CompareAndPutRequest.value)
  return _s;
}
inline const std::string& CompareAndPutRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CompareAndPutRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CompareAndPutRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CompareAndPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CompareAndPutRequest.value)
  return _impl_.value_.Release();
}
inline void CompareAndPutRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CompareAndPutRequest.value)
}

// -------------------------------------------------------------------

// CompareAndPutResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool CompareAndPutResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CompareAndPutResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& CompareAndPutResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& CompareAndPutResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutResponse.header)
  return _internal_header();
}
inline void CompareAndPutResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.CompareAndPutResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* CompareAndPutResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* CompareAndPutResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CompareAndPutResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* CompareAndPutResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* CompareAndPutResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CompareAndPutResponse.header)
  return _msg;
}
inline void CompareAndPutResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CompareAndPutResponse.header)
}

// bool success = 2;
inline void CompareAndPutResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CompareAndPutResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CompareAndPutResponse::success() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutResponse.success)
  return _internal_success();
}
inline void CompareAndPutResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CompareAndPutResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.CompareAndPutResponse.success)
}

// .greptime.v1.meta.KeyValue prev_kv = 3;
inline bool CompareAndPutResponse::_internal_has_prev_kv() const {
  return this != internal_default_instance() && _impl_.prev_kv_ != nullptr;
}
inline bool CompareAndPutResponse::has_prev_kv() const {
  return _internal_has_prev_kv();
}
inline const ::greptime::v1::meta::KeyValue& CompareAndPutResponse::_internal_prev_kv() const {
  const ::greptime::v1::meta::KeyValue* p = _impl_.prev_kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::KeyValue&>(
      ::greptime::v1::meta::_KeyValue_default_instance_);
}
inline const ::greptime::v1::meta::KeyValue& CompareAndPutResponse::prev_kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CompareAndPutResponse.prev_kv)
  return _internal_prev_kv();
}
inline void CompareAndPutResponse::unsafe_arena_set_allocated_prev_kv(
    ::greptime::v1::meta::KeyValue* prev_kv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_kv_);
  }
  _impl_.prev_kv_ = prev_kv;
  if (prev_kv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.CompareAndPutResponse.prev_kv)
}
inline ::greptime::v1::meta::KeyValue* CompareAndPutResponse::release_prev_kv() {
  
  ::greptime::v1::meta::KeyValue* temp = _impl_.prev_kv_;
  _impl_.prev_kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::KeyValue* CompareAndPutResponse::unsafe_arena_release_prev_kv() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CompareAndPutResponse.prev_kv)
  
  ::greptime::v1::meta::KeyValue* temp = _impl_.prev_kv_;
  _impl_.prev_kv_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::KeyValue* CompareAndPutResponse::_internal_mutable_prev_kv() {
  
  if (_impl_.prev_kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::KeyValue>(GetArenaForAllocation());
    _impl_.prev_kv_ = p;
  }
  return _impl_.prev_kv_;
}
inline ::greptime::v1::meta::KeyValue* CompareAndPutResponse::mutable_prev_kv() {
  ::greptime::v1::meta::KeyValue* _msg = _internal_mutable_prev_kv();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CompareAndPutResponse.prev_kv)
  return _msg;
}
inline void CompareAndPutResponse::set_allocated_prev_kv(::greptime::v1::meta::KeyValue* prev_kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prev_kv_);
  }
  if (prev_kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_kv));
    if (message_arena != submessage_arena) {
      prev_kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_kv, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.prev_kv_ = prev_kv;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CompareAndPutResponse.prev_kv)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool DeleteRangeRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteRangeRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& DeleteRangeRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& DeleteRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeRequest.header)
  return _internal_header();
}
inline void DeleteRangeRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.DeleteRangeRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* DeleteRangeRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* DeleteRangeRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRangeRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* DeleteRangeRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* DeleteRangeRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRangeRequest.header)
  return _msg;
}
inline void DeleteRangeRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRangeRequest.header)
}

// bytes key = 2;
inline void DeleteRangeRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& DeleteRangeRequest::key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRangeRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.DeleteRangeRequest.key)
}
inline std::string* DeleteRangeRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRangeRequest.key)
  return _s;
}
inline const std::string& DeleteRangeRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void DeleteRangeRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::release_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRangeRequest.key)
  return _impl_.key_.Release();
}
inline void DeleteRangeRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRangeRequest.key)
}

// bytes range_end = 3;
inline void DeleteRangeRequest::clear_range_end() {
  _impl_.range_end_.ClearToEmpty();
}
inline const std::string& DeleteRangeRequest::range_end() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeRequest.range_end)
  return _internal_range_end();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRangeRequest::set_range_end(ArgT0&& arg0, ArgT... args) {
 
 _impl_.range_end_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.DeleteRangeRequest.range_end)
}
inline std::string* DeleteRangeRequest::mutable_range_end() {
  std::string* _s = _internal_mutable_range_end();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRangeRequest.range_end)
  return _s;
}
inline const std::string& DeleteRangeRequest::_internal_range_end() const {
  return _impl_.range_end_.Get();
}
inline void DeleteRangeRequest::_internal_set_range_end(const std::string& value) {
  
  _impl_.range_end_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::_internal_mutable_range_end() {
  
  return _impl_.range_end_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRangeRequest::release_range_end() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRangeRequest.range_end)
  return _impl_.range_end_.Release();
}
inline void DeleteRangeRequest::set_allocated_range_end(std::string* range_end) {
  if (range_end != nullptr) {
    
  } else {
    
  }
  _impl_.range_end_.SetAllocated(range_end, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.range_end_.IsDefault()) {
    _impl_.range_end_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRangeRequest.range_end)
}

// bool prev_kv = 4;
inline void DeleteRangeRequest::clear_prev_kv() {
  _impl_.prev_kv_ = false;
}
inline bool DeleteRangeRequest::_internal_prev_kv() const {
  return _impl_.prev_kv_;
}
inline bool DeleteRangeRequest::prev_kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeRequest.prev_kv)
  return _internal_prev_kv();
}
inline void DeleteRangeRequest::_internal_set_prev_kv(bool value) {
  
  _impl_.prev_kv_ = value;
}
inline void DeleteRangeRequest::set_prev_kv(bool value) {
  _internal_set_prev_kv(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.DeleteRangeRequest.prev_kv)
}

// -------------------------------------------------------------------

// DeleteRangeResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool DeleteRangeResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteRangeResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& DeleteRangeResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& DeleteRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeResponse.header)
  return _internal_header();
}
inline void DeleteRangeResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.DeleteRangeResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* DeleteRangeResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* DeleteRangeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRangeResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* DeleteRangeResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* DeleteRangeResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRangeResponse.header)
  return _msg;
}
inline void DeleteRangeResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRangeResponse.header)
}

// int64 deleted = 2;
inline void DeleteRangeResponse::clear_deleted() {
  _impl_.deleted_ = int64_t{0};
}
inline int64_t DeleteRangeResponse::_internal_deleted() const {
  return _impl_.deleted_;
}
inline int64_t DeleteRangeResponse::deleted() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeResponse.deleted)
  return _internal_deleted();
}
inline void DeleteRangeResponse::_internal_set_deleted(int64_t value) {
  
  _impl_.deleted_ = value;
}
inline void DeleteRangeResponse::set_deleted(int64_t value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.DeleteRangeResponse.deleted)
}

// repeated .greptime.v1.meta.KeyValue prev_kvs = 3;
inline int DeleteRangeResponse::_internal_prev_kvs_size() const {
  return _impl_.prev_kvs_.size();
}
inline int DeleteRangeResponse::prev_kvs_size() const {
  return _internal_prev_kvs_size();
}
inline ::greptime::v1::meta::KeyValue* DeleteRangeResponse::mutable_prev_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRangeResponse.prev_kvs)
  return _impl_.prev_kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >*
DeleteRangeResponse::mutable_prev_kvs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.DeleteRangeResponse.prev_kvs)
  return &_impl_.prev_kvs_;
}
inline const ::greptime::v1::meta::KeyValue& DeleteRangeResponse::_internal_prev_kvs(int index) const {
  return _impl_.prev_kvs_.Get(index);
}
inline const ::greptime::v1::meta::KeyValue& DeleteRangeResponse::prev_kvs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRangeResponse.prev_kvs)
  return _internal_prev_kvs(index);
}
inline ::greptime::v1::meta::KeyValue* DeleteRangeResponse::_internal_add_prev_kvs() {
  return _impl_.prev_kvs_.Add();
}
inline ::greptime::v1::meta::KeyValue* DeleteRangeResponse::add_prev_kvs() {
  ::greptime::v1::meta::KeyValue* _add = _internal_add_prev_kvs();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.DeleteRangeResponse.prev_kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::KeyValue >&
DeleteRangeResponse::prev_kvs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.DeleteRangeResponse.prev_kvs)
  return _impl_.prev_kvs_;
}

// -------------------------------------------------------------------

// MoveValueRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool MoveValueRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MoveValueRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& MoveValueRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& MoveValueRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MoveValueRequest.header)
  return _internal_header();
}
inline void MoveValueRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.MoveValueRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* MoveValueRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* MoveValueRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MoveValueRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* MoveValueRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* MoveValueRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MoveValueRequest.header)
  return _msg;
}
inline void MoveValueRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MoveValueRequest.header)
}

// bytes from_key = 2;
inline void MoveValueRequest::clear_from_key() {
  _impl_.from_key_.ClearToEmpty();
}
inline const std::string& MoveValueRequest::from_key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MoveValueRequest.from_key)
  return _internal_from_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveValueRequest::set_from_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MoveValueRequest.from_key)
}
inline std::string* MoveValueRequest::mutable_from_key() {
  std::string* _s = _internal_mutable_from_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MoveValueRequest.from_key)
  return _s;
}
inline const std::string& MoveValueRequest::_internal_from_key() const {
  return _impl_.from_key_.Get();
}
inline void MoveValueRequest::_internal_set_from_key(const std::string& value) {
  
  _impl_.from_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveValueRequest::_internal_mutable_from_key() {
  
  return _impl_.from_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveValueRequest::release_from_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MoveValueRequest.from_key)
  return _impl_.from_key_.Release();
}
inline void MoveValueRequest::set_allocated_from_key(std::string* from_key) {
  if (from_key != nullptr) {
    
  } else {
    
  }
  _impl_.from_key_.SetAllocated(from_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_key_.IsDefault()) {
    _impl_.from_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MoveValueRequest.from_key)
}

// bytes to_key = 3;
inline void MoveValueRequest::clear_to_key() {
  _impl_.to_key_.ClearToEmpty();
}
inline const std::string& MoveValueRequest::to_key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MoveValueRequest.to_key)
  return _internal_to_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveValueRequest::set_to_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.MoveValueRequest.to_key)
}
inline std::string* MoveValueRequest::mutable_to_key() {
  std::string* _s = _internal_mutable_to_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MoveValueRequest.to_key)
  return _s;
}
inline const std::string& MoveValueRequest::_internal_to_key() const {
  return _impl_.to_key_.Get();
}
inline void MoveValueRequest::_internal_set_to_key(const std::string& value) {
  
  _impl_.to_key_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveValueRequest::_internal_mutable_to_key() {
  
  return _impl_.to_key_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveValueRequest::release_to_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MoveValueRequest.to_key)
  return _impl_.to_key_.Release();
}
inline void MoveValueRequest::set_allocated_to_key(std::string* to_key) {
  if (to_key != nullptr) {
    
  } else {
    
  }
  _impl_.to_key_.SetAllocated(to_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_key_.IsDefault()) {
    _impl_.to_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MoveValueRequest.to_key)
}

// -------------------------------------------------------------------

// MoveValueResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool MoveValueResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool MoveValueResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& MoveValueResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& MoveValueResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MoveValueResponse.header)
  return _internal_header();
}
inline void MoveValueResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.MoveValueResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* MoveValueResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* MoveValueResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MoveValueResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* MoveValueResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* MoveValueResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MoveValueResponse.header)
  return _msg;
}
inline void MoveValueResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MoveValueResponse.header)
}

// .greptime.v1.meta.KeyValue kv = 2;
inline bool MoveValueResponse::_internal_has_kv() const {
  return this != internal_default_instance() && _impl_.kv_ != nullptr;
}
inline bool MoveValueResponse::has_kv() const {
  return _internal_has_kv();
}
inline const ::greptime::v1::meta::KeyValue& MoveValueResponse::_internal_kv() const {
  const ::greptime::v1::meta::KeyValue* p = _impl_.kv_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::KeyValue&>(
      ::greptime::v1::meta::_KeyValue_default_instance_);
}
inline const ::greptime::v1::meta::KeyValue& MoveValueResponse::kv() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.MoveValueResponse.kv)
  return _internal_kv();
}
inline void MoveValueResponse::unsafe_arena_set_allocated_kv(
    ::greptime::v1::meta::KeyValue* kv) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kv_);
  }
  _impl_.kv_ = kv;
  if (kv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.MoveValueResponse.kv)
}
inline ::greptime::v1::meta::KeyValue* MoveValueResponse::release_kv() {
  
  ::greptime::v1::meta::KeyValue* temp = _impl_.kv_;
  _impl_.kv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::KeyValue* MoveValueResponse::unsafe_arena_release_kv() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.MoveValueResponse.kv)
  
  ::greptime::v1::meta::KeyValue* temp = _impl_.kv_;
  _impl_.kv_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::KeyValue* MoveValueResponse::_internal_mutable_kv() {
  
  if (_impl_.kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::KeyValue>(GetArenaForAllocation());
    _impl_.kv_ = p;
  }
  return _impl_.kv_;
}
inline ::greptime::v1::meta::KeyValue* MoveValueResponse::mutable_kv() {
  ::greptime::v1::meta::KeyValue* _msg = _internal_mutable_kv();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.MoveValueResponse.kv)
  return _msg;
}
inline void MoveValueResponse::set_allocated_kv(::greptime::v1::meta::KeyValue* kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kv_);
  }
  if (kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kv));
    if (message_arena != submessage_arena) {
      kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.MoveValueResponse.kv)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2fstore_2eproto
