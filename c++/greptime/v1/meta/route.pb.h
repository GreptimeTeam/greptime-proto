// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2froute_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2froute_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
#include "greptime/v1/meta/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fmeta_2froute_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fmeta_2froute_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2froute_2eproto;
namespace greptime {
namespace v1 {
namespace meta {
class Partition;
struct PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class Region;
struct RegionDefaultTypeInternal;
extern RegionDefaultTypeInternal _Region_default_instance_;
class RegionRoute;
struct RegionRouteDefaultTypeInternal;
extern RegionRouteDefaultTypeInternal _RegionRoute_default_instance_;
class Region_AttrsEntry_DoNotUse;
struct Region_AttrsEntry_DoNotUseDefaultTypeInternal;
extern Region_AttrsEntry_DoNotUseDefaultTypeInternal _Region_AttrsEntry_DoNotUse_default_instance_;
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableRoute;
struct TableRouteDefaultTypeInternal;
extern TableRouteDefaultTypeInternal _TableRoute_default_instance_;
class TableRouteValue;
struct TableRouteValueDefaultTypeInternal;
extern TableRouteValueDefaultTypeInternal _TableRouteValue_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::meta::Partition* Arena::CreateMaybeMessage<::greptime::v1::meta::Partition>(Arena*);
template<> ::greptime::v1::meta::Region* Arena::CreateMaybeMessage<::greptime::v1::meta::Region>(Arena*);
template<> ::greptime::v1::meta::RegionRoute* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionRoute>(Arena*);
template<> ::greptime::v1::meta::Region_AttrsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::Region_AttrsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::Table* Arena::CreateMaybeMessage<::greptime::v1::meta::Table>(Arena*);
template<> ::greptime::v1::meta::TableRoute* Arena::CreateMaybeMessage<::greptime::v1::meta::TableRoute>(Arena*);
template<> ::greptime::v1::meta::TableRouteValue* Arena::CreateMaybeMessage<::greptime::v1::meta::TableRouteValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace meta {

// ===================================================================

class TableRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.TableRoute) */ {
 public:
  inline TableRoute() : TableRoute(nullptr) {}
  ~TableRoute() override;
  explicit PROTOBUF_CONSTEXPR TableRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRoute(const TableRoute& from);
  TableRoute(TableRoute&& from) noexcept
    : TableRoute() {
    *this = ::std::move(from);
  }

  inline TableRoute& operator=(const TableRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRoute& operator=(TableRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRoute* internal_default_instance() {
    return reinterpret_cast<const TableRoute*>(
               &_TableRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TableRoute& a, TableRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRoute& from) {
    TableRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.TableRoute";
  }
  protected:
  explicit TableRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionRoutesFieldNumber = 2,
    kTableFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.RegionRoute region_routes = 2;
  int region_routes_size() const;
  private:
  int _internal_region_routes_size() const;
  public:
  void clear_region_routes();
  ::greptime::v1::meta::RegionRoute* mutable_region_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >*
      mutable_region_routes();
  private:
  const ::greptime::v1::meta::RegionRoute& _internal_region_routes(int index) const;
  ::greptime::v1::meta::RegionRoute* _internal_add_region_routes();
  public:
  const ::greptime::v1::meta::RegionRoute& region_routes(int index) const;
  ::greptime::v1::meta::RegionRoute* add_region_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >&
      region_routes() const;

  // .greptime.v1.meta.Table table = 1;
  bool has_table() const;
  private:
  bool _internal_has_table() const;
  public:
  void clear_table();
  const ::greptime::v1::meta::Table& table() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Table* release_table();
  ::greptime::v1::meta::Table* mutable_table();
  void set_allocated_table(::greptime::v1::meta::Table* table);
  private:
  const ::greptime::v1::meta::Table& _internal_table() const;
  ::greptime::v1::meta::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::greptime::v1::meta::Table* table);
  ::greptime::v1::meta::Table* unsafe_arena_release_table();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.TableRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute > region_routes_;
    ::greptime::v1::meta::Table* table_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class RegionRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionRoute) */ {
 public:
  inline RegionRoute() : RegionRoute(nullptr) {}
  ~RegionRoute() override;
  explicit PROTOBUF_CONSTEXPR RegionRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRoute(const RegionRoute& from);
  RegionRoute(RegionRoute&& from) noexcept
    : RegionRoute() {
    *this = ::std::move(from);
  }

  inline RegionRoute& operator=(const RegionRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRoute& operator=(RegionRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRoute* internal_default_instance() {
    return reinterpret_cast<const RegionRoute*>(
               &_RegionRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegionRoute& a, RegionRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRoute& from) {
    RegionRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionRoute";
  }
  protected:
  explicit RegionRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFollowerPeerIndexesFieldNumber = 3,
    kRegionFieldNumber = 1,
    kLeaderPeerIndexFieldNumber = 2,
  };
  // repeated uint64 follower_peer_indexes = 3;
  int follower_peer_indexes_size() const;
  private:
  int _internal_follower_peer_indexes_size() const;
  public:
  void clear_follower_peer_indexes();
  private:
  uint64_t _internal_follower_peer_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_follower_peer_indexes() const;
  void _internal_add_follower_peer_indexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_follower_peer_indexes();
  public:
  uint64_t follower_peer_indexes(int index) const;
  void set_follower_peer_indexes(int index, uint64_t value);
  void add_follower_peer_indexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      follower_peer_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_follower_peer_indexes();

  // .greptime.v1.meta.Region region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::greptime::v1::meta::Region& region() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Region* release_region();
  ::greptime::v1::meta::Region* mutable_region();
  void set_allocated_region(::greptime::v1::meta::Region* region);
  private:
  const ::greptime::v1::meta::Region& _internal_region() const;
  ::greptime::v1::meta::Region* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::greptime::v1::meta::Region* region);
  ::greptime::v1::meta::Region* unsafe_arena_release_region();

  // uint64 leader_peer_index = 2;
  void clear_leader_peer_index();
  uint64_t leader_peer_index() const;
  void set_leader_peer_index(uint64_t value);
  private:
  uint64_t _internal_leader_peer_index() const;
  void _internal_set_leader_peer_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > follower_peer_indexes_;
    mutable std::atomic<int> _follower_peer_indexes_cached_byte_size_;
    ::greptime::v1::meta::Region* region_;
    uint64_t leader_peer_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class Table final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  explicit PROTOBUF_CONSTEXPR Table(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.Table";
  }
  protected:
  explicit Table(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableSchemaFieldNumber = 3,
    kTableNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes table_schema = 3;
  void clear_table_schema();
  const std::string& table_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_schema();
  PROTOBUF_NODISCARD std::string* release_table_schema();
  void set_allocated_table_schema(std::string* table_schema);
  private:
  const std::string& _internal_table_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_schema(const std::string& value);
  std::string* _internal_mutable_table_schema();
  public:

  // .greptime.v1.TableName table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const ::greptime::v1::TableName& table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableName* release_table_name();
  ::greptime::v1::TableName* mutable_table_name();
  void set_allocated_table_name(::greptime::v1::TableName* table_name);
  private:
  const ::greptime::v1::TableName& _internal_table_name() const;
  ::greptime::v1::TableName* _internal_mutable_table_name();
  public:
  void unsafe_arena_set_allocated_table_name(
      ::greptime::v1::TableName* table_name);
  ::greptime::v1::TableName* unsafe_arena_release_table_name();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.Table)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_schema_;
    ::greptime::v1::TableName* table_name_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class Region_AttrsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Region_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Region_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Region_AttrsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Region_AttrsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Region_AttrsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Region_AttrsEntry_DoNotUse& other);
  static const Region_AttrsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Region_AttrsEntry_DoNotUse*>(&_Region_AttrsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.Region.AttrsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.Region.AttrsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};

// -------------------------------------------------------------------

class Region final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.Region) */ {
 public:
  inline Region() : Region(nullptr) {}
  ~Region() override;
  explicit PROTOBUF_CONSTEXPR Region(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Region(const Region& from);
  Region(Region&& from) noexcept
    : Region() {
    *this = ::std::move(from);
  }

  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline Region& operator=(Region&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const Region* internal_default_instance() {
    return reinterpret_cast<const Region*>(
               &_Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Region& a, Region& b) {
    a.Swap(&b);
  }
  inline void Swap(Region* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Region* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Region* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Region>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Region& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Region& from) {
    Region::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Region* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.Region";
  }
  protected:
  explicit Region(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 100,
    kNameFieldNumber = 2,
    kPartitionFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // map<string, string> attrs = 100;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attrs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attrs();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .greptime.v1.meta.Partition partition = 3;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  const ::greptime::v1::meta::Partition& partition() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Partition* release_partition();
  ::greptime::v1::meta::Partition* mutable_partition();
  void set_allocated_partition(::greptime::v1::meta::Partition* partition);
  private:
  const ::greptime::v1::meta::Partition& _internal_partition() const;
  ::greptime::v1::meta::Partition* _internal_mutable_partition();
  public:
  void unsafe_arena_set_allocated_partition(
      ::greptime::v1::meta::Partition* partition);
  ::greptime::v1::meta::Partition* unsafe_arena_release_partition();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.Region)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Region_AttrsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::greptime::v1::meta::Partition* partition_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class Partition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.Partition) */ {
 public:
  inline Partition() : Partition(nullptr) {}
  ~Partition() override;
  explicit PROTOBUF_CONSTEXPR Partition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Partition(const Partition& from);
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition& operator=(Partition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Partition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }
  inline void Swap(Partition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Partition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Partition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Partition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Partition& from) {
    Partition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.Partition";
  }
  protected:
  explicit Partition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnListFieldNumber = 1,
    kValueListFieldNumber = 2,
    kExpressionFieldNumber = 3,
  };
  // repeated bytes column_list = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int column_list_size() const;
  private:
  int _internal_column_list_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_column_list();
  PROTOBUF_DEPRECATED const std::string& column_list(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_column_list(int index);
  PROTOBUF_DEPRECATED void set_column_list(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_column_list(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_column_list(int index, const char* value);
  PROTOBUF_DEPRECATED void set_column_list(int index, const void* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_column_list();
  PROTOBUF_DEPRECATED void add_column_list(const std::string& value);
  PROTOBUF_DEPRECATED void add_column_list(std::string&& value);
  PROTOBUF_DEPRECATED void add_column_list(const char* value);
  PROTOBUF_DEPRECATED void add_column_list(const void* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_list() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_list();
  private:
  const std::string& _internal_column_list(int index) const;
  std::string* _internal_add_column_list();
  public:

  // repeated bytes value_list = 2 [deprecated = true];
  PROTOBUF_DEPRECATED int value_list_size() const;
  private:
  int _internal_value_list_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_value_list();
  PROTOBUF_DEPRECATED const std::string& value_list(int index) const;
  PROTOBUF_DEPRECATED std::string* mutable_value_list(int index);
  PROTOBUF_DEPRECATED void set_value_list(int index, const std::string& value);
  PROTOBUF_DEPRECATED void set_value_list(int index, std::string&& value);
  PROTOBUF_DEPRECATED void set_value_list(int index, const char* value);
  PROTOBUF_DEPRECATED void set_value_list(int index, const void* value, size_t size);
  PROTOBUF_DEPRECATED std::string* add_value_list();
  PROTOBUF_DEPRECATED void add_value_list(const std::string& value);
  PROTOBUF_DEPRECATED void add_value_list(std::string&& value);
  PROTOBUF_DEPRECATED void add_value_list(const char* value);
  PROTOBUF_DEPRECATED void add_value_list(const void* value, size_t size);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value_list() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value_list();
  private:
  const std::string& _internal_value_list(int index) const;
  std::string* _internal_add_value_list();
  public:

  // string expression = 3;
  void clear_expression();
  const std::string& expression() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expression(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expression();
  PROTOBUF_NODISCARD std::string* release_expression();
  void set_allocated_expression(std::string* expression);
  private:
  const std::string& _internal_expression() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expression(const std::string& value);
  std::string* _internal_mutable_expression();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.Partition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class TableRouteValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.TableRouteValue) */ {
 public:
  inline TableRouteValue() : TableRouteValue(nullptr) {}
  ~TableRouteValue() override;
  explicit PROTOBUF_CONSTEXPR TableRouteValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRouteValue(const TableRouteValue& from);
  TableRouteValue(TableRouteValue&& from) noexcept
    : TableRouteValue() {
    *this = ::std::move(from);
  }

  inline TableRouteValue& operator=(const TableRouteValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRouteValue& operator=(TableRouteValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRouteValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRouteValue* internal_default_instance() {
    return reinterpret_cast<const TableRouteValue*>(
               &_TableRouteValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TableRouteValue& a, TableRouteValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRouteValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRouteValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRouteValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRouteValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRouteValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRouteValue& from) {
    TableRouteValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRouteValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.TableRouteValue";
  }
  protected:
  explicit TableRouteValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
    kTableRouteFieldNumber = 2,
  };
  // repeated .greptime.v1.meta.Peer peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::greptime::v1::meta::Peer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >*
      mutable_peers();
  private:
  const ::greptime::v1::meta::Peer& _internal_peers(int index) const;
  ::greptime::v1::meta::Peer* _internal_add_peers();
  public:
  const ::greptime::v1::meta::Peer& peers(int index) const;
  ::greptime::v1::meta::Peer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >&
      peers() const;

  // .greptime.v1.meta.TableRoute table_route = 2;
  bool has_table_route() const;
  private:
  bool _internal_has_table_route() const;
  public:
  void clear_table_route();
  const ::greptime::v1::meta::TableRoute& table_route() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableRoute* release_table_route();
  ::greptime::v1::meta::TableRoute* mutable_table_route();
  void set_allocated_table_route(::greptime::v1::meta::TableRoute* table_route);
  private:
  const ::greptime::v1::meta::TableRoute& _internal_table_route() const;
  ::greptime::v1::meta::TableRoute* _internal_mutable_table_route();
  public:
  void unsafe_arena_set_allocated_table_route(
      ::greptime::v1::meta::TableRoute* table_route);
  ::greptime::v1::meta::TableRoute* unsafe_arena_release_table_route();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.TableRouteValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer > peers_;
    ::greptime::v1::meta::TableRoute* table_route_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TableRoute

// .greptime.v1.meta.Table table = 1;
inline bool TableRoute::_internal_has_table() const {
  return this != internal_default_instance() && _impl_.table_ != nullptr;
}
inline bool TableRoute::has_table() const {
  return _internal_has_table();
}
inline void TableRoute::clear_table() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_ != nullptr) {
    delete _impl_.table_;
  }
  _impl_.table_ = nullptr;
}
inline const ::greptime::v1::meta::Table& TableRoute::_internal_table() const {
  const ::greptime::v1::meta::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Table&>(
      ::greptime::v1::meta::_Table_default_instance_);
}
inline const ::greptime::v1::meta::Table& TableRoute::table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRoute.table)
  return _internal_table();
}
inline void TableRoute::unsafe_arena_set_allocated_table(
    ::greptime::v1::meta::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.TableRoute.table)
}
inline ::greptime::v1::meta::Table* TableRoute::release_table() {
  
  ::greptime::v1::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Table* TableRoute::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.TableRoute.table)
  
  ::greptime::v1::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Table* TableRoute::_internal_mutable_table() {
  
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::greptime::v1::meta::Table* TableRoute::mutable_table() {
  ::greptime::v1::meta::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRoute.table)
  return _msg;
}
inline void TableRoute::set_allocated_table(::greptime::v1::meta::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_;
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table);
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.TableRoute.table)
}

// repeated .greptime.v1.meta.RegionRoute region_routes = 2;
inline int TableRoute::_internal_region_routes_size() const {
  return _impl_.region_routes_.size();
}
inline int TableRoute::region_routes_size() const {
  return _internal_region_routes_size();
}
inline void TableRoute::clear_region_routes() {
  _impl_.region_routes_.Clear();
}
inline ::greptime::v1::meta::RegionRoute* TableRoute::mutable_region_routes(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRoute.region_routes)
  return _impl_.region_routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >*
TableRoute::mutable_region_routes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.TableRoute.region_routes)
  return &_impl_.region_routes_;
}
inline const ::greptime::v1::meta::RegionRoute& TableRoute::_internal_region_routes(int index) const {
  return _impl_.region_routes_.Get(index);
}
inline const ::greptime::v1::meta::RegionRoute& TableRoute::region_routes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRoute.region_routes)
  return _internal_region_routes(index);
}
inline ::greptime::v1::meta::RegionRoute* TableRoute::_internal_add_region_routes() {
  return _impl_.region_routes_.Add();
}
inline ::greptime::v1::meta::RegionRoute* TableRoute::add_region_routes() {
  ::greptime::v1::meta::RegionRoute* _add = _internal_add_region_routes();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.TableRoute.region_routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >&
TableRoute::region_routes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.TableRoute.region_routes)
  return _impl_.region_routes_;
}

// -------------------------------------------------------------------

// RegionRoute

// .greptime.v1.meta.Region region = 1;
inline bool RegionRoute::_internal_has_region() const {
  return this != internal_default_instance() && _impl_.region_ != nullptr;
}
inline bool RegionRoute::has_region() const {
  return _internal_has_region();
}
inline void RegionRoute::clear_region() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_ != nullptr) {
    delete _impl_.region_;
  }
  _impl_.region_ = nullptr;
}
inline const ::greptime::v1::meta::Region& RegionRoute::_internal_region() const {
  const ::greptime::v1::meta::Region* p = _impl_.region_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Region&>(
      ::greptime::v1::meta::_Region_default_instance_);
}
inline const ::greptime::v1::meta::Region& RegionRoute::region() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionRoute.region)
  return _internal_region();
}
inline void RegionRoute::unsafe_arena_set_allocated_region(
    ::greptime::v1::meta::Region* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_);
  }
  _impl_.region_ = region;
  if (region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RegionRoute.region)
}
inline ::greptime::v1::meta::Region* RegionRoute::release_region() {
  
  ::greptime::v1::meta::Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Region* RegionRoute::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RegionRoute.region)
  
  ::greptime::v1::meta::Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Region* RegionRoute::_internal_mutable_region() {
  
  if (_impl_.region_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Region>(GetArenaForAllocation());
    _impl_.region_ = p;
  }
  return _impl_.region_;
}
inline ::greptime::v1::meta::Region* RegionRoute::mutable_region() {
  ::greptime::v1::meta::Region* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionRoute.region)
  return _msg;
}
inline void RegionRoute::set_allocated_region(::greptime::v1::meta::Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_ = region;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RegionRoute.region)
}

// uint64 leader_peer_index = 2;
inline void RegionRoute::clear_leader_peer_index() {
  _impl_.leader_peer_index_ = uint64_t{0u};
}
inline uint64_t RegionRoute::_internal_leader_peer_index() const {
  return _impl_.leader_peer_index_;
}
inline uint64_t RegionRoute::leader_peer_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionRoute.leader_peer_index)
  return _internal_leader_peer_index();
}
inline void RegionRoute::_internal_set_leader_peer_index(uint64_t value) {
  
  _impl_.leader_peer_index_ = value;
}
inline void RegionRoute::set_leader_peer_index(uint64_t value) {
  _internal_set_leader_peer_index(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionRoute.leader_peer_index)
}

// repeated uint64 follower_peer_indexes = 3;
inline int RegionRoute::_internal_follower_peer_indexes_size() const {
  return _impl_.follower_peer_indexes_.size();
}
inline int RegionRoute::follower_peer_indexes_size() const {
  return _internal_follower_peer_indexes_size();
}
inline void RegionRoute::clear_follower_peer_indexes() {
  _impl_.follower_peer_indexes_.Clear();
}
inline uint64_t RegionRoute::_internal_follower_peer_indexes(int index) const {
  return _impl_.follower_peer_indexes_.Get(index);
}
inline uint64_t RegionRoute::follower_peer_indexes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionRoute.follower_peer_indexes)
  return _internal_follower_peer_indexes(index);
}
inline void RegionRoute::set_follower_peer_indexes(int index, uint64_t value) {
  _impl_.follower_peer_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionRoute.follower_peer_indexes)
}
inline void RegionRoute::_internal_add_follower_peer_indexes(uint64_t value) {
  _impl_.follower_peer_indexes_.Add(value);
}
inline void RegionRoute::add_follower_peer_indexes(uint64_t value) {
  _internal_add_follower_peer_indexes(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RegionRoute.follower_peer_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RegionRoute::_internal_follower_peer_indexes() const {
  return _impl_.follower_peer_indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RegionRoute::follower_peer_indexes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RegionRoute.follower_peer_indexes)
  return _internal_follower_peer_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RegionRoute::_internal_mutable_follower_peer_indexes() {
  return &_impl_.follower_peer_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RegionRoute::mutable_follower_peer_indexes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RegionRoute.follower_peer_indexes)
  return _internal_mutable_follower_peer_indexes();
}

// -------------------------------------------------------------------

// Table

// uint64 id = 1;
inline void Table::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Table::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Table::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Table.id)
  return _internal_id();
}
inline void Table::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Table::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Table.id)
}

// .greptime.v1.TableName table_name = 2;
inline bool Table::_internal_has_table_name() const {
  return this != internal_default_instance() && _impl_.table_name_ != nullptr;
}
inline bool Table::has_table_name() const {
  return _internal_has_table_name();
}
inline const ::greptime::v1::TableName& Table::_internal_table_name() const {
  const ::greptime::v1::TableName* p = _impl_.table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableName&>(
      ::greptime::v1::_TableName_default_instance_);
}
inline const ::greptime::v1::TableName& Table::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Table.table_name)
  return _internal_table_name();
}
inline void Table::unsafe_arena_set_allocated_table_name(
    ::greptime::v1::TableName* table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  _impl_.table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.Table.table_name)
}
inline ::greptime::v1::TableName* Table::release_table_name() {
  
  ::greptime::v1::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableName* Table::unsafe_arena_release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Table.table_name)
  
  ::greptime::v1::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableName* Table::_internal_mutable_table_name() {
  
  if (_impl_.table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableName>(GetArenaForAllocation());
    _impl_.table_name_ = p;
  }
  return _impl_.table_name_;
}
inline ::greptime::v1::TableName* Table::mutable_table_name() {
  ::greptime::v1::TableName* _msg = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Table.table_name)
  return _msg;
}
inline void Table::set_allocated_table_name(::greptime::v1::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name));
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Table.table_name)
}

// bytes table_schema = 3;
inline void Table::clear_table_schema() {
  _impl_.table_schema_.ClearToEmpty();
}
inline const std::string& Table::table_schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Table.table_schema)
  return _internal_table_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Table::set_table_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_schema_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Table.table_schema)
}
inline std::string* Table::mutable_table_schema() {
  std::string* _s = _internal_mutable_table_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Table.table_schema)
  return _s;
}
inline const std::string& Table::_internal_table_schema() const {
  return _impl_.table_schema_.Get();
}
inline void Table::_internal_set_table_schema(const std::string& value) {
  
  _impl_.table_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* Table::_internal_mutable_table_schema() {
  
  return _impl_.table_schema_.Mutable(GetArenaForAllocation());
}
inline std::string* Table::release_table_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Table.table_schema)
  return _impl_.table_schema_.Release();
}
inline void Table::set_allocated_table_schema(std::string* table_schema) {
  if (table_schema != nullptr) {
    
  } else {
    
  }
  _impl_.table_schema_.SetAllocated(table_schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_schema_.IsDefault()) {
    _impl_.table_schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Table.table_schema)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Region

// uint64 id = 1;
inline void Region::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Region::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Region::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Region.id)
  return _internal_id();
}
inline void Region::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Region::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Region.id)
}

// string name = 2;
inline void Region::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Region::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Region.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Region.name)
}
inline std::string* Region::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Region.name)
  return _s;
}
inline const std::string& Region::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Region::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Region::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Region.name)
  return _impl_.name_.Release();
}
inline void Region::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Region.name)
}

// map<string, string> attrs = 100;
inline int Region::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int Region::attrs_size() const {
  return _internal_attrs_size();
}
inline void Region::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Region::_internal_attrs() const {
  return _impl_.attrs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Region::attrs() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.Region.attrs)
  return _internal_attrs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Region::_internal_mutable_attrs() {
  return _impl_.attrs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Region::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.Region.attrs)
  return _internal_mutable_attrs();
}

// .greptime.v1.meta.Partition partition = 3;
inline bool Region::_internal_has_partition() const {
  return this != internal_default_instance() && _impl_.partition_ != nullptr;
}
inline bool Region::has_partition() const {
  return _internal_has_partition();
}
inline void Region::clear_partition() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_ != nullptr) {
    delete _impl_.partition_;
  }
  _impl_.partition_ = nullptr;
}
inline const ::greptime::v1::meta::Partition& Region::_internal_partition() const {
  const ::greptime::v1::meta::Partition* p = _impl_.partition_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Partition&>(
      ::greptime::v1::meta::_Partition_default_instance_);
}
inline const ::greptime::v1::meta::Partition& Region::partition() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Region.partition)
  return _internal_partition();
}
inline void Region::unsafe_arena_set_allocated_partition(
    ::greptime::v1::meta::Partition* partition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_);
  }
  _impl_.partition_ = partition;
  if (partition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.Region.partition)
}
inline ::greptime::v1::meta::Partition* Region::release_partition() {
  
  ::greptime::v1::meta::Partition* temp = _impl_.partition_;
  _impl_.partition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Partition* Region::unsafe_arena_release_partition() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Region.partition)
  
  ::greptime::v1::meta::Partition* temp = _impl_.partition_;
  _impl_.partition_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Partition* Region::_internal_mutable_partition() {
  
  if (_impl_.partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Partition>(GetArenaForAllocation());
    _impl_.partition_ = p;
  }
  return _impl_.partition_;
}
inline ::greptime::v1::meta::Partition* Region::mutable_partition() {
  ::greptime::v1::meta::Partition* _msg = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Region.partition)
  return _msg;
}
inline void Region::set_allocated_partition(::greptime::v1::meta::Partition* partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_;
  }
  if (partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition);
    if (message_arena != submessage_arena) {
      partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_ = partition;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Region.partition)
}

// -------------------------------------------------------------------

// Partition

// repeated bytes column_list = 1 [deprecated = true];
inline int Partition::_internal_column_list_size() const {
  return _impl_.column_list_.size();
}
inline int Partition::column_list_size() const {
  return _internal_column_list_size();
}
inline void Partition::clear_column_list() {
  _impl_.column_list_.Clear();
}
inline std::string* Partition::add_column_list() {
  std::string* _s = _internal_add_column_list();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.meta.Partition.column_list)
  return _s;
}
inline const std::string& Partition::_internal_column_list(int index) const {
  return _impl_.column_list_.Get(index);
}
inline const std::string& Partition::column_list(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Partition.column_list)
  return _internal_column_list(index);
}
inline std::string* Partition::mutable_column_list(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Partition.column_list)
  return _impl_.column_list_.Mutable(index);
}
inline void Partition::set_column_list(int index, const std::string& value) {
  _impl_.column_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.column_list)
}
inline void Partition::set_column_list(int index, std::string&& value) {
  _impl_.column_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.column_list)
}
inline void Partition::set_column_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.meta.Partition.column_list)
}
inline void Partition::set_column_list(int index, const void* value, size_t size) {
  _impl_.column_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.meta.Partition.column_list)
}
inline std::string* Partition::_internal_add_column_list() {
  return _impl_.column_list_.Add();
}
inline void Partition::add_column_list(const std::string& value) {
  _impl_.column_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.column_list)
}
inline void Partition::add_column_list(std::string&& value) {
  _impl_.column_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.column_list)
}
inline void Partition::add_column_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.meta.Partition.column_list)
}
inline void Partition::add_column_list(const void* value, size_t size) {
  _impl_.column_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.meta.Partition.column_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Partition::column_list() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.Partition.column_list)
  return _impl_.column_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Partition::mutable_column_list() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.Partition.column_list)
  return &_impl_.column_list_;
}

// repeated bytes value_list = 2 [deprecated = true];
inline int Partition::_internal_value_list_size() const {
  return _impl_.value_list_.size();
}
inline int Partition::value_list_size() const {
  return _internal_value_list_size();
}
inline void Partition::clear_value_list() {
  _impl_.value_list_.Clear();
}
inline std::string* Partition::add_value_list() {
  std::string* _s = _internal_add_value_list();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.meta.Partition.value_list)
  return _s;
}
inline const std::string& Partition::_internal_value_list(int index) const {
  return _impl_.value_list_.Get(index);
}
inline const std::string& Partition::value_list(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Partition.value_list)
  return _internal_value_list(index);
}
inline std::string* Partition::mutable_value_list(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Partition.value_list)
  return _impl_.value_list_.Mutable(index);
}
inline void Partition::set_value_list(int index, const std::string& value) {
  _impl_.value_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.value_list)
}
inline void Partition::set_value_list(int index, std::string&& value) {
  _impl_.value_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.value_list)
}
inline void Partition::set_value_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.meta.Partition.value_list)
}
inline void Partition::set_value_list(int index, const void* value, size_t size) {
  _impl_.value_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.meta.Partition.value_list)
}
inline std::string* Partition::_internal_add_value_list() {
  return _impl_.value_list_.Add();
}
inline void Partition::add_value_list(const std::string& value) {
  _impl_.value_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.value_list)
}
inline void Partition::add_value_list(std::string&& value) {
  _impl_.value_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.value_list)
}
inline void Partition::add_value_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.meta.Partition.value_list)
}
inline void Partition::add_value_list(const void* value, size_t size) {
  _impl_.value_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.meta.Partition.value_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Partition::value_list() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.Partition.value_list)
  return _impl_.value_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Partition::mutable_value_list() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.Partition.value_list)
  return &_impl_.value_list_;
}

// string expression = 3;
inline void Partition::clear_expression() {
  _impl_.expression_.ClearToEmpty();
}
inline const std::string& Partition::expression() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Partition.expression)
  return _internal_expression();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Partition::set_expression(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expression_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.expression)
}
inline std::string* Partition::mutable_expression() {
  std::string* _s = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Partition.expression)
  return _s;
}
inline const std::string& Partition::_internal_expression() const {
  return _impl_.expression_.Get();
}
inline void Partition::_internal_set_expression(const std::string& value) {
  
  _impl_.expression_.Set(value, GetArenaForAllocation());
}
inline std::string* Partition::_internal_mutable_expression() {
  
  return _impl_.expression_.Mutable(GetArenaForAllocation());
}
inline std::string* Partition::release_expression() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Partition.expression)
  return _impl_.expression_.Release();
}
inline void Partition::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  _impl_.expression_.SetAllocated(expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expression_.IsDefault()) {
    _impl_.expression_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Partition.expression)
}

// -------------------------------------------------------------------

// TableRouteValue

// repeated .greptime.v1.meta.Peer peers = 1;
inline int TableRouteValue::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int TableRouteValue::peers_size() const {
  return _internal_peers_size();
}
inline ::greptime::v1::meta::Peer* TableRouteValue::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRouteValue.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >*
TableRouteValue::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.TableRouteValue.peers)
  return &_impl_.peers_;
}
inline const ::greptime::v1::meta::Peer& TableRouteValue::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::greptime::v1::meta::Peer& TableRouteValue::peers(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRouteValue.peers)
  return _internal_peers(index);
}
inline ::greptime::v1::meta::Peer* TableRouteValue::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::greptime::v1::meta::Peer* TableRouteValue::add_peers() {
  ::greptime::v1::meta::Peer* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.TableRouteValue.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >&
TableRouteValue::peers() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.TableRouteValue.peers)
  return _impl_.peers_;
}

// .greptime.v1.meta.TableRoute table_route = 2;
inline bool TableRouteValue::_internal_has_table_route() const {
  return this != internal_default_instance() && _impl_.table_route_ != nullptr;
}
inline bool TableRouteValue::has_table_route() const {
  return _internal_has_table_route();
}
inline void TableRouteValue::clear_table_route() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_route_ != nullptr) {
    delete _impl_.table_route_;
  }
  _impl_.table_route_ = nullptr;
}
inline const ::greptime::v1::meta::TableRoute& TableRouteValue::_internal_table_route() const {
  const ::greptime::v1::meta::TableRoute* p = _impl_.table_route_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableRoute&>(
      ::greptime::v1::meta::_TableRoute_default_instance_);
}
inline const ::greptime::v1::meta::TableRoute& TableRouteValue::table_route() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRouteValue.table_route)
  return _internal_table_route();
}
inline void TableRouteValue::unsafe_arena_set_allocated_table_route(
    ::greptime::v1::meta::TableRoute* table_route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_route_);
  }
  _impl_.table_route_ = table_route;
  if (table_route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.TableRouteValue.table_route)
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::release_table_route() {
  
  ::greptime::v1::meta::TableRoute* temp = _impl_.table_route_;
  _impl_.table_route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::unsafe_arena_release_table_route() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.TableRouteValue.table_route)
  
  ::greptime::v1::meta::TableRoute* temp = _impl_.table_route_;
  _impl_.table_route_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::_internal_mutable_table_route() {
  
  if (_impl_.table_route_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableRoute>(GetArenaForAllocation());
    _impl_.table_route_ = p;
  }
  return _impl_.table_route_;
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::mutable_table_route() {
  ::greptime::v1::meta::TableRoute* _msg = _internal_mutable_table_route();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRouteValue.table_route)
  return _msg;
}
inline void TableRouteValue::set_allocated_table_route(::greptime::v1::meta::TableRoute* table_route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_route_;
  }
  if (table_route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_route);
    if (message_arena != submessage_arena) {
      table_route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_route_ = table_route;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.TableRouteValue.table_route)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2froute_2eproto
