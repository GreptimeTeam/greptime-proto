// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/meta/route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2froute_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2froute_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/meta/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fmeta_2froute_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fmeta_2froute_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fmeta_2froute_2eproto;
namespace greptime {
namespace v1 {
namespace meta {
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class Partition;
struct PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class Region;
struct RegionDefaultTypeInternal;
extern RegionDefaultTypeInternal _Region_default_instance_;
class RegionRoute;
struct RegionRouteDefaultTypeInternal;
extern RegionRouteDefaultTypeInternal _RegionRoute_default_instance_;
class Region_AttrsEntry_DoNotUse;
struct Region_AttrsEntry_DoNotUseDefaultTypeInternal;
extern Region_AttrsEntry_DoNotUseDefaultTypeInternal _Region_AttrsEntry_DoNotUse_default_instance_;
class RouteRequest;
struct RouteRequestDefaultTypeInternal;
extern RouteRequestDefaultTypeInternal _RouteRequest_default_instance_;
class RouteResponse;
struct RouteResponseDefaultTypeInternal;
extern RouteResponseDefaultTypeInternal _RouteResponse_default_instance_;
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableRoute;
struct TableRouteDefaultTypeInternal;
extern TableRouteDefaultTypeInternal _TableRoute_default_instance_;
class TableRouteValue;
struct TableRouteValueDefaultTypeInternal;
extern TableRouteValueDefaultTypeInternal _TableRouteValue_default_instance_;
}  // namespace meta
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::meta::CreateRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::CreateRequest>(Arena*);
template<> ::greptime::v1::meta::DeleteRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::DeleteRequest>(Arena*);
template<> ::greptime::v1::meta::Partition* Arena::CreateMaybeMessage<::greptime::v1::meta::Partition>(Arena*);
template<> ::greptime::v1::meta::Region* Arena::CreateMaybeMessage<::greptime::v1::meta::Region>(Arena*);
template<> ::greptime::v1::meta::RegionRoute* Arena::CreateMaybeMessage<::greptime::v1::meta::RegionRoute>(Arena*);
template<> ::greptime::v1::meta::Region_AttrsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::meta::Region_AttrsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::meta::RouteRequest* Arena::CreateMaybeMessage<::greptime::v1::meta::RouteRequest>(Arena*);
template<> ::greptime::v1::meta::RouteResponse* Arena::CreateMaybeMessage<::greptime::v1::meta::RouteResponse>(Arena*);
template<> ::greptime::v1::meta::Table* Arena::CreateMaybeMessage<::greptime::v1::meta::Table>(Arena*);
template<> ::greptime::v1::meta::TableRoute* Arena::CreateMaybeMessage<::greptime::v1::meta::TableRoute>(Arena*);
template<> ::greptime::v1::meta::TableRouteValue* Arena::CreateMaybeMessage<::greptime::v1::meta::TableRouteValue>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace meta {

// ===================================================================

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRequest& from) {
    CreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 3,
    kTableInfoFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kTableNameFieldNumber = 2,
  };
  // repeated .greptime.v1.meta.Partition partitions = 3;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  ::greptime::v1::meta::Partition* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Partition >*
      mutable_partitions();
  private:
  const ::greptime::v1::meta::Partition& _internal_partitions(int index) const;
  ::greptime::v1::meta::Partition* _internal_add_partitions();
  public:
  const ::greptime::v1::meta::Partition& partitions(int index) const;
  ::greptime::v1::meta::Partition* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Partition >&
      partitions() const;

  // bytes table_info = 4;
  void clear_table_info();
  const std::string& table_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_info();
  PROTOBUF_NODISCARD std::string* release_table_info();
  void set_allocated_table_info(std::string* table_info);
  private:
  const std::string& _internal_table_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_info(const std::string& value);
  std::string* _internal_mutable_table_info();
  public:

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.TableName table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const ::greptime::v1::meta::TableName& table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableName* release_table_name();
  ::greptime::v1::meta::TableName* mutable_table_name();
  void set_allocated_table_name(::greptime::v1::meta::TableName* table_name);
  private:
  const ::greptime::v1::meta::TableName& _internal_table_name() const;
  ::greptime::v1::meta::TableName* _internal_mutable_table_name();
  public:
  void unsafe_arena_set_allocated_table_name(
      ::greptime::v1::meta::TableName* table_name);
  ::greptime::v1::meta::TableName* unsafe_arena_release_table_name();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Partition > partitions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_info_;
    ::greptime::v1::meta::RequestHeader* header_;
    ::greptime::v1::meta::TableName* table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class RouteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RouteRequest) */ {
 public:
  inline RouteRequest() : RouteRequest(nullptr) {}
  ~RouteRequest() override;
  explicit PROTOBUF_CONSTEXPR RouteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteRequest(const RouteRequest& from);
  RouteRequest(RouteRequest&& from) noexcept
    : RouteRequest() {
    *this = ::std::move(from);
  }

  inline RouteRequest& operator=(const RouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteRequest& operator=(RouteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteRequest* internal_default_instance() {
    return reinterpret_cast<const RouteRequest*>(
               &_RouteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouteRequest& a, RouteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouteRequest& from) {
    RouteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RouteRequest";
  }
  protected:
  explicit RouteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNamesFieldNumber = 2,
    kTableIdsFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.TableName table_names = 2;
  int table_names_size() const;
  private:
  int _internal_table_names_size() const;
  public:
  void clear_table_names();
  ::greptime::v1::meta::TableName* mutable_table_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableName >*
      mutable_table_names();
  private:
  const ::greptime::v1::meta::TableName& _internal_table_names(int index) const;
  ::greptime::v1::meta::TableName* _internal_add_table_names();
  public:
  const ::greptime::v1::meta::TableName& table_names(int index) const;
  ::greptime::v1::meta::TableName* add_table_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableName >&
      table_names() const;

  // repeated .greptime.v1.meta.TableId table_ids = 3;
  int table_ids_size() const;
  private:
  int _internal_table_ids_size() const;
  public:
  void clear_table_ids();
  ::greptime::v1::meta::TableId* mutable_table_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableId >*
      mutable_table_ids();
  private:
  const ::greptime::v1::meta::TableId& _internal_table_ids(int index) const;
  ::greptime::v1::meta::TableId* _internal_add_table_ids();
  public:
  const ::greptime::v1::meta::TableId& table_ids(int index) const;
  ::greptime::v1::meta::TableId* add_table_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableId >&
      table_ids() const;

  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RouteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableName > table_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableId > table_ids_;
    ::greptime::v1::meta::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kTableIdFieldNumber = 3,
  };
  // .greptime.v1.meta.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::RequestHeader* release_header();
  ::greptime::v1::meta::RequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::RequestHeader* header);
  private:
  const ::greptime::v1::meta::RequestHeader& _internal_header() const;
  ::greptime::v1::meta::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::RequestHeader* header);
  ::greptime::v1::meta::RequestHeader* unsafe_arena_release_header();

  // .greptime.v1.meta.TableName table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const ::greptime::v1::meta::TableName& table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableName* release_table_name();
  ::greptime::v1::meta::TableName* mutable_table_name();
  void set_allocated_table_name(::greptime::v1::meta::TableName* table_name);
  private:
  const ::greptime::v1::meta::TableName& _internal_table_name() const;
  ::greptime::v1::meta::TableName* _internal_mutable_table_name();
  public:
  void unsafe_arena_set_allocated_table_name(
      ::greptime::v1::meta::TableName* table_name);
  ::greptime::v1::meta::TableName* unsafe_arena_release_table_name();

  // .greptime.v1.meta.TableId table_id = 3;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::meta::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableId* release_table_id();
  ::greptime::v1::meta::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::meta::TableId* table_id);
  private:
  const ::greptime::v1::meta::TableId& _internal_table_id() const;
  ::greptime::v1::meta::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::meta::TableId* table_id);
  ::greptime::v1::meta::TableId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::meta::RequestHeader* header_;
    ::greptime::v1::meta::TableName* table_name_;
    ::greptime::v1::meta::TableId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class RouteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RouteResponse) */ {
 public:
  inline RouteResponse() : RouteResponse(nullptr) {}
  ~RouteResponse() override;
  explicit PROTOBUF_CONSTEXPR RouteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteResponse(const RouteResponse& from);
  RouteResponse(RouteResponse&& from) noexcept
    : RouteResponse() {
    *this = ::std::move(from);
  }

  inline RouteResponse& operator=(const RouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteResponse& operator=(RouteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteResponse* internal_default_instance() {
    return reinterpret_cast<const RouteResponse*>(
               &_RouteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RouteResponse& a, RouteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RouteResponse& from) {
    RouteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RouteResponse";
  }
  protected:
  explicit RouteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 2,
    kTableRoutesFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.Peer peers = 2;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::greptime::v1::meta::Peer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >*
      mutable_peers();
  private:
  const ::greptime::v1::meta::Peer& _internal_peers(int index) const;
  ::greptime::v1::meta::Peer* _internal_add_peers();
  public:
  const ::greptime::v1::meta::Peer& peers(int index) const;
  ::greptime::v1::meta::Peer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >&
      peers() const;

  // repeated .greptime.v1.meta.TableRoute table_routes = 3;
  int table_routes_size() const;
  private:
  int _internal_table_routes_size() const;
  public:
  void clear_table_routes();
  ::greptime::v1::meta::TableRoute* mutable_table_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableRoute >*
      mutable_table_routes();
  private:
  const ::greptime::v1::meta::TableRoute& _internal_table_routes(int index) const;
  ::greptime::v1::meta::TableRoute* _internal_add_table_routes();
  public:
  const ::greptime::v1::meta::TableRoute& table_routes(int index) const;
  ::greptime::v1::meta::TableRoute* add_table_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableRoute >&
      table_routes() const;

  // .greptime.v1.meta.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::meta::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::ResponseHeader* release_header();
  ::greptime::v1::meta::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::meta::ResponseHeader* header);
  private:
  const ::greptime::v1::meta::ResponseHeader& _internal_header() const;
  ::greptime::v1::meta::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::meta::ResponseHeader* header);
  ::greptime::v1::meta::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RouteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer > peers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableRoute > table_routes_;
    ::greptime::v1::meta::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class TableRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.TableRoute) */ {
 public:
  inline TableRoute() : TableRoute(nullptr) {}
  ~TableRoute() override;
  explicit PROTOBUF_CONSTEXPR TableRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRoute(const TableRoute& from);
  TableRoute(TableRoute&& from) noexcept
    : TableRoute() {
    *this = ::std::move(from);
  }

  inline TableRoute& operator=(const TableRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRoute& operator=(TableRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRoute* internal_default_instance() {
    return reinterpret_cast<const TableRoute*>(
               &_TableRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TableRoute& a, TableRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRoute& from) {
    TableRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.TableRoute";
  }
  protected:
  explicit TableRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionRoutesFieldNumber = 2,
    kTableFieldNumber = 1,
  };
  // repeated .greptime.v1.meta.RegionRoute region_routes = 2;
  int region_routes_size() const;
  private:
  int _internal_region_routes_size() const;
  public:
  void clear_region_routes();
  ::greptime::v1::meta::RegionRoute* mutable_region_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >*
      mutable_region_routes();
  private:
  const ::greptime::v1::meta::RegionRoute& _internal_region_routes(int index) const;
  ::greptime::v1::meta::RegionRoute* _internal_add_region_routes();
  public:
  const ::greptime::v1::meta::RegionRoute& region_routes(int index) const;
  ::greptime::v1::meta::RegionRoute* add_region_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >&
      region_routes() const;

  // .greptime.v1.meta.Table table = 1;
  bool has_table() const;
  private:
  bool _internal_has_table() const;
  public:
  void clear_table();
  const ::greptime::v1::meta::Table& table() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Table* release_table();
  ::greptime::v1::meta::Table* mutable_table();
  void set_allocated_table(::greptime::v1::meta::Table* table);
  private:
  const ::greptime::v1::meta::Table& _internal_table() const;
  ::greptime::v1::meta::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::greptime::v1::meta::Table* table);
  ::greptime::v1::meta::Table* unsafe_arena_release_table();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.TableRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute > region_routes_;
    ::greptime::v1::meta::Table* table_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class RegionRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.RegionRoute) */ {
 public:
  inline RegionRoute() : RegionRoute(nullptr) {}
  ~RegionRoute() override;
  explicit PROTOBUF_CONSTEXPR RegionRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRoute(const RegionRoute& from);
  RegionRoute(RegionRoute&& from) noexcept
    : RegionRoute() {
    *this = ::std::move(from);
  }

  inline RegionRoute& operator=(const RegionRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRoute& operator=(RegionRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRoute* internal_default_instance() {
    return reinterpret_cast<const RegionRoute*>(
               &_RegionRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegionRoute& a, RegionRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRoute& from) {
    RegionRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.RegionRoute";
  }
  protected:
  explicit RegionRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFollowerPeerIndexesFieldNumber = 3,
    kRegionFieldNumber = 1,
    kLeaderPeerIndexFieldNumber = 2,
  };
  // repeated uint64 follower_peer_indexes = 3;
  int follower_peer_indexes_size() const;
  private:
  int _internal_follower_peer_indexes_size() const;
  public:
  void clear_follower_peer_indexes();
  private:
  uint64_t _internal_follower_peer_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_follower_peer_indexes() const;
  void _internal_add_follower_peer_indexes(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_follower_peer_indexes();
  public:
  uint64_t follower_peer_indexes(int index) const;
  void set_follower_peer_indexes(int index, uint64_t value);
  void add_follower_peer_indexes(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      follower_peer_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_follower_peer_indexes();

  // .greptime.v1.meta.Region region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::greptime::v1::meta::Region& region() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Region* release_region();
  ::greptime::v1::meta::Region* mutable_region();
  void set_allocated_region(::greptime::v1::meta::Region* region);
  private:
  const ::greptime::v1::meta::Region& _internal_region() const;
  ::greptime::v1::meta::Region* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::greptime::v1::meta::Region* region);
  ::greptime::v1::meta::Region* unsafe_arena_release_region();

  // uint64 leader_peer_index = 2;
  void clear_leader_peer_index();
  uint64_t leader_peer_index() const;
  void set_leader_peer_index(uint64_t value);
  private:
  uint64_t _internal_leader_peer_index() const;
  void _internal_set_leader_peer_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.RegionRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > follower_peer_indexes_;
    mutable std::atomic<int> _follower_peer_indexes_cached_byte_size_;
    ::greptime::v1::meta::Region* region_;
    uint64_t leader_peer_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class Table final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  explicit PROTOBUF_CONSTEXPR Table(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.Table";
  }
  protected:
  explicit Table(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableSchemaFieldNumber = 3,
    kTableNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes table_schema = 3;
  void clear_table_schema();
  const std::string& table_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_schema();
  PROTOBUF_NODISCARD std::string* release_table_schema();
  void set_allocated_table_schema(std::string* table_schema);
  private:
  const std::string& _internal_table_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_schema(const std::string& value);
  std::string* _internal_mutable_table_schema();
  public:

  // .greptime.v1.meta.TableName table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const ::greptime::v1::meta::TableName& table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableName* release_table_name();
  ::greptime::v1::meta::TableName* mutable_table_name();
  void set_allocated_table_name(::greptime::v1::meta::TableName* table_name);
  private:
  const ::greptime::v1::meta::TableName& _internal_table_name() const;
  ::greptime::v1::meta::TableName* _internal_mutable_table_name();
  public:
  void unsafe_arena_set_allocated_table_name(
      ::greptime::v1::meta::TableName* table_name);
  ::greptime::v1::meta::TableName* unsafe_arena_release_table_name();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.Table)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_schema_;
    ::greptime::v1::meta::TableName* table_name_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class Region_AttrsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Region_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Region_AttrsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Region_AttrsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Region_AttrsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Region_AttrsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Region_AttrsEntry_DoNotUse& other);
  static const Region_AttrsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Region_AttrsEntry_DoNotUse*>(&_Region_AttrsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.Region.AttrsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.meta.Region.AttrsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};

// -------------------------------------------------------------------

class Region final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.Region) */ {
 public:
  inline Region() : Region(nullptr) {}
  ~Region() override;
  explicit PROTOBUF_CONSTEXPR Region(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Region(const Region& from);
  Region(Region&& from) noexcept
    : Region() {
    *this = ::std::move(from);
  }

  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline Region& operator=(Region&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const Region* internal_default_instance() {
    return reinterpret_cast<const Region*>(
               &_Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Region& a, Region& b) {
    a.Swap(&b);
  }
  inline void Swap(Region* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Region* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Region* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Region>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Region& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Region& from) {
    Region::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Region* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.Region";
  }
  protected:
  explicit Region(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttrsFieldNumber = 100,
    kNameFieldNumber = 2,
    kPartitionFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // map<string, string> attrs = 100;
  int attrs_size() const;
  private:
  int _internal_attrs_size() const;
  public:
  void clear_attrs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_attrs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      attrs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_attrs();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .greptime.v1.meta.Partition partition = 3;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  const ::greptime::v1::meta::Partition& partition() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::Partition* release_partition();
  ::greptime::v1::meta::Partition* mutable_partition();
  void set_allocated_partition(::greptime::v1::meta::Partition* partition);
  private:
  const ::greptime::v1::meta::Partition& _internal_partition() const;
  ::greptime::v1::meta::Partition* _internal_mutable_partition();
  public:
  void unsafe_arena_set_allocated_partition(
      ::greptime::v1::meta::Partition* partition);
  ::greptime::v1::meta::Partition* unsafe_arena_release_partition();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.Region)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Region_AttrsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> attrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::greptime::v1::meta::Partition* partition_;
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class Partition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.Partition) */ {
 public:
  inline Partition() : Partition(nullptr) {}
  ~Partition() override;
  explicit PROTOBUF_CONSTEXPR Partition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Partition(const Partition& from);
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition& operator=(Partition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Partition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }
  inline void Swap(Partition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Partition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Partition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Partition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Partition& from) {
    Partition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.Partition";
  }
  protected:
  explicit Partition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnListFieldNumber = 1,
    kValueListFieldNumber = 2,
  };
  // repeated bytes column_list = 1;
  int column_list_size() const;
  private:
  int _internal_column_list_size() const;
  public:
  void clear_column_list();
  const std::string& column_list(int index) const;
  std::string* mutable_column_list(int index);
  void set_column_list(int index, const std::string& value);
  void set_column_list(int index, std::string&& value);
  void set_column_list(int index, const char* value);
  void set_column_list(int index, const void* value, size_t size);
  std::string* add_column_list();
  void add_column_list(const std::string& value);
  void add_column_list(std::string&& value);
  void add_column_list(const char* value);
  void add_column_list(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_list();
  private:
  const std::string& _internal_column_list(int index) const;
  std::string* _internal_add_column_list();
  public:

  // repeated bytes value_list = 2;
  int value_list_size() const;
  private:
  int _internal_value_list_size() const;
  public:
  void clear_value_list();
  const std::string& value_list(int index) const;
  std::string* mutable_value_list(int index);
  void set_value_list(int index, const std::string& value);
  void set_value_list(int index, std::string&& value);
  void set_value_list(int index, const char* value);
  void set_value_list(int index, const void* value, size_t size);
  std::string* add_value_list();
  void add_value_list(const std::string& value);
  void add_value_list(std::string&& value);
  void add_value_list(const char* value);
  void add_value_list(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value_list();
  private:
  const std::string& _internal_value_list(int index) const;
  std::string* _internal_add_value_list();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.Partition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// -------------------------------------------------------------------

class TableRouteValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.meta.TableRouteValue) */ {
 public:
  inline TableRouteValue() : TableRouteValue(nullptr) {}
  ~TableRouteValue() override;
  explicit PROTOBUF_CONSTEXPR TableRouteValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRouteValue(const TableRouteValue& from);
  TableRouteValue(TableRouteValue&& from) noexcept
    : TableRouteValue() {
    *this = ::std::move(from);
  }

  inline TableRouteValue& operator=(const TableRouteValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRouteValue& operator=(TableRouteValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRouteValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRouteValue* internal_default_instance() {
    return reinterpret_cast<const TableRouteValue*>(
               &_TableRouteValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TableRouteValue& a, TableRouteValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRouteValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRouteValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRouteValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRouteValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRouteValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRouteValue& from) {
    TableRouteValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRouteValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.meta.TableRouteValue";
  }
  protected:
  explicit TableRouteValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
    kTableRouteFieldNumber = 2,
  };
  // repeated .greptime.v1.meta.Peer peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::greptime::v1::meta::Peer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >*
      mutable_peers();
  private:
  const ::greptime::v1::meta::Peer& _internal_peers(int index) const;
  ::greptime::v1::meta::Peer* _internal_add_peers();
  public:
  const ::greptime::v1::meta::Peer& peers(int index) const;
  ::greptime::v1::meta::Peer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >&
      peers() const;

  // .greptime.v1.meta.TableRoute table_route = 2;
  bool has_table_route() const;
  private:
  bool _internal_has_table_route() const;
  public:
  void clear_table_route();
  const ::greptime::v1::meta::TableRoute& table_route() const;
  PROTOBUF_NODISCARD ::greptime::v1::meta::TableRoute* release_table_route();
  ::greptime::v1::meta::TableRoute* mutable_table_route();
  void set_allocated_table_route(::greptime::v1::meta::TableRoute* table_route);
  private:
  const ::greptime::v1::meta::TableRoute& _internal_table_route() const;
  ::greptime::v1::meta::TableRoute* _internal_mutable_table_route();
  public:
  void unsafe_arena_set_allocated_table_route(
      ::greptime::v1::meta::TableRoute* table_route);
  ::greptime::v1::meta::TableRoute* unsafe_arena_release_table_route();

  // @@protoc_insertion_point(class_scope:greptime.v1.meta.TableRouteValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer > peers_;
    ::greptime::v1::meta::TableRoute* table_route_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fmeta_2froute_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool CreateRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool CreateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& CreateRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& CreateRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CreateRequest.header)
  return _internal_header();
}
inline void CreateRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.CreateRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* CreateRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* CreateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CreateRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* CreateRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* CreateRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CreateRequest.header)
  return _msg;
}
inline void CreateRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CreateRequest.header)
}

// .greptime.v1.meta.TableName table_name = 2;
inline bool CreateRequest::_internal_has_table_name() const {
  return this != internal_default_instance() && _impl_.table_name_ != nullptr;
}
inline bool CreateRequest::has_table_name() const {
  return _internal_has_table_name();
}
inline const ::greptime::v1::meta::TableName& CreateRequest::_internal_table_name() const {
  const ::greptime::v1::meta::TableName* p = _impl_.table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableName&>(
      ::greptime::v1::meta::_TableName_default_instance_);
}
inline const ::greptime::v1::meta::TableName& CreateRequest::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CreateRequest.table_name)
  return _internal_table_name();
}
inline void CreateRequest::unsafe_arena_set_allocated_table_name(
    ::greptime::v1::meta::TableName* table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  _impl_.table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.CreateRequest.table_name)
}
inline ::greptime::v1::meta::TableName* CreateRequest::release_table_name() {
  
  ::greptime::v1::meta::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableName* CreateRequest::unsafe_arena_release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CreateRequest.table_name)
  
  ::greptime::v1::meta::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableName* CreateRequest::_internal_mutable_table_name() {
  
  if (_impl_.table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableName>(GetArenaForAllocation());
    _impl_.table_name_ = p;
  }
  return _impl_.table_name_;
}
inline ::greptime::v1::meta::TableName* CreateRequest::mutable_table_name() {
  ::greptime::v1::meta::TableName* _msg = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CreateRequest.table_name)
  return _msg;
}
inline void CreateRequest::set_allocated_table_name(::greptime::v1::meta::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name));
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CreateRequest.table_name)
}

// repeated .greptime.v1.meta.Partition partitions = 3;
inline int CreateRequest::_internal_partitions_size() const {
  return _impl_.partitions_.size();
}
inline int CreateRequest::partitions_size() const {
  return _internal_partitions_size();
}
inline void CreateRequest::clear_partitions() {
  _impl_.partitions_.Clear();
}
inline ::greptime::v1::meta::Partition* CreateRequest::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CreateRequest.partitions)
  return _impl_.partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Partition >*
CreateRequest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.CreateRequest.partitions)
  return &_impl_.partitions_;
}
inline const ::greptime::v1::meta::Partition& CreateRequest::_internal_partitions(int index) const {
  return _impl_.partitions_.Get(index);
}
inline const ::greptime::v1::meta::Partition& CreateRequest::partitions(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CreateRequest.partitions)
  return _internal_partitions(index);
}
inline ::greptime::v1::meta::Partition* CreateRequest::_internal_add_partitions() {
  return _impl_.partitions_.Add();
}
inline ::greptime::v1::meta::Partition* CreateRequest::add_partitions() {
  ::greptime::v1::meta::Partition* _add = _internal_add_partitions();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.CreateRequest.partitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Partition >&
CreateRequest::partitions() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.CreateRequest.partitions)
  return _impl_.partitions_;
}

// bytes table_info = 4;
inline void CreateRequest::clear_table_info() {
  _impl_.table_info_.ClearToEmpty();
}
inline const std::string& CreateRequest::table_info() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.CreateRequest.table_info)
  return _internal_table_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_table_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.CreateRequest.table_info)
}
inline std::string* CreateRequest::mutable_table_info() {
  std::string* _s = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.CreateRequest.table_info)
  return _s;
}
inline const std::string& CreateRequest::_internal_table_info() const {
  return _impl_.table_info_.Get();
}
inline void CreateRequest::_internal_set_table_info(const std::string& value) {
  
  _impl_.table_info_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_table_info() {
  
  return _impl_.table_info_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_table_info() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.CreateRequest.table_info)
  return _impl_.table_info_.Release();
}
inline void CreateRequest::set_allocated_table_info(std::string* table_info) {
  if (table_info != nullptr) {
    
  } else {
    
  }
  _impl_.table_info_.SetAllocated(table_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_info_.IsDefault()) {
    _impl_.table_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.CreateRequest.table_info)
}

// -------------------------------------------------------------------

// RouteRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool RouteRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RouteRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& RouteRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& RouteRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RouteRequest.header)
  return _internal_header();
}
inline void RouteRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RouteRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* RouteRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* RouteRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RouteRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* RouteRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* RouteRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RouteRequest.header)
  return _msg;
}
inline void RouteRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RouteRequest.header)
}

// repeated .greptime.v1.meta.TableName table_names = 2;
inline int RouteRequest::_internal_table_names_size() const {
  return _impl_.table_names_.size();
}
inline int RouteRequest::table_names_size() const {
  return _internal_table_names_size();
}
inline ::greptime::v1::meta::TableName* RouteRequest::mutable_table_names(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RouteRequest.table_names)
  return _impl_.table_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableName >*
RouteRequest::mutable_table_names() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RouteRequest.table_names)
  return &_impl_.table_names_;
}
inline const ::greptime::v1::meta::TableName& RouteRequest::_internal_table_names(int index) const {
  return _impl_.table_names_.Get(index);
}
inline const ::greptime::v1::meta::TableName& RouteRequest::table_names(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RouteRequest.table_names)
  return _internal_table_names(index);
}
inline ::greptime::v1::meta::TableName* RouteRequest::_internal_add_table_names() {
  return _impl_.table_names_.Add();
}
inline ::greptime::v1::meta::TableName* RouteRequest::add_table_names() {
  ::greptime::v1::meta::TableName* _add = _internal_add_table_names();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RouteRequest.table_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableName >&
RouteRequest::table_names() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RouteRequest.table_names)
  return _impl_.table_names_;
}

// repeated .greptime.v1.meta.TableId table_ids = 3;
inline int RouteRequest::_internal_table_ids_size() const {
  return _impl_.table_ids_.size();
}
inline int RouteRequest::table_ids_size() const {
  return _internal_table_ids_size();
}
inline ::greptime::v1::meta::TableId* RouteRequest::mutable_table_ids(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RouteRequest.table_ids)
  return _impl_.table_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableId >*
RouteRequest::mutable_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RouteRequest.table_ids)
  return &_impl_.table_ids_;
}
inline const ::greptime::v1::meta::TableId& RouteRequest::_internal_table_ids(int index) const {
  return _impl_.table_ids_.Get(index);
}
inline const ::greptime::v1::meta::TableId& RouteRequest::table_ids(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RouteRequest.table_ids)
  return _internal_table_ids(index);
}
inline ::greptime::v1::meta::TableId* RouteRequest::_internal_add_table_ids() {
  return _impl_.table_ids_.Add();
}
inline ::greptime::v1::meta::TableId* RouteRequest::add_table_ids() {
  ::greptime::v1::meta::TableId* _add = _internal_add_table_ids();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RouteRequest.table_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableId >&
RouteRequest::table_ids() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RouteRequest.table_ids)
  return _impl_.table_ids_;
}

// -------------------------------------------------------------------

// DeleteRequest

// .greptime.v1.meta.RequestHeader header = 1;
inline bool DeleteRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool DeleteRequest::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::RequestHeader& DeleteRequest::_internal_header() const {
  const ::greptime::v1::meta::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::RequestHeader&>(
      ::greptime::v1::meta::_RequestHeader_default_instance_);
}
inline const ::greptime::v1::meta::RequestHeader& DeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRequest.header)
  return _internal_header();
}
inline void DeleteRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.DeleteRequest.header)
}
inline ::greptime::v1::meta::RequestHeader* DeleteRequest::release_header() {
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* DeleteRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRequest.header)
  
  ::greptime::v1::meta::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::RequestHeader* DeleteRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::RequestHeader* DeleteRequest::mutable_header() {
  ::greptime::v1::meta::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRequest.header)
  return _msg;
}
inline void DeleteRequest::set_allocated_header(::greptime::v1::meta::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRequest.header)
}

// .greptime.v1.meta.TableName table_name = 2;
inline bool DeleteRequest::_internal_has_table_name() const {
  return this != internal_default_instance() && _impl_.table_name_ != nullptr;
}
inline bool DeleteRequest::has_table_name() const {
  return _internal_has_table_name();
}
inline const ::greptime::v1::meta::TableName& DeleteRequest::_internal_table_name() const {
  const ::greptime::v1::meta::TableName* p = _impl_.table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableName&>(
      ::greptime::v1::meta::_TableName_default_instance_);
}
inline const ::greptime::v1::meta::TableName& DeleteRequest::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRequest.table_name)
  return _internal_table_name();
}
inline void DeleteRequest::unsafe_arena_set_allocated_table_name(
    ::greptime::v1::meta::TableName* table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  _impl_.table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.DeleteRequest.table_name)
}
inline ::greptime::v1::meta::TableName* DeleteRequest::release_table_name() {
  
  ::greptime::v1::meta::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableName* DeleteRequest::unsafe_arena_release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRequest.table_name)
  
  ::greptime::v1::meta::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableName* DeleteRequest::_internal_mutable_table_name() {
  
  if (_impl_.table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableName>(GetArenaForAllocation());
    _impl_.table_name_ = p;
  }
  return _impl_.table_name_;
}
inline ::greptime::v1::meta::TableName* DeleteRequest::mutable_table_name() {
  ::greptime::v1::meta::TableName* _msg = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRequest.table_name)
  return _msg;
}
inline void DeleteRequest::set_allocated_table_name(::greptime::v1::meta::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name));
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRequest.table_name)
}

// .greptime.v1.meta.TableId table_id = 3;
inline bool DeleteRequest::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool DeleteRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline const ::greptime::v1::meta::TableId& DeleteRequest::_internal_table_id() const {
  const ::greptime::v1::meta::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableId&>(
      ::greptime::v1::meta::_TableId_default_instance_);
}
inline const ::greptime::v1::meta::TableId& DeleteRequest::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.DeleteRequest.table_id)
  return _internal_table_id();
}
inline void DeleteRequest::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::meta::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.DeleteRequest.table_id)
}
inline ::greptime::v1::meta::TableId* DeleteRequest::release_table_id() {
  
  ::greptime::v1::meta::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableId* DeleteRequest::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.DeleteRequest.table_id)
  
  ::greptime::v1::meta::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableId* DeleteRequest::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::meta::TableId* DeleteRequest::mutable_table_id() {
  ::greptime::v1::meta::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.DeleteRequest.table_id)
  return _msg;
}
inline void DeleteRequest::set_allocated_table_id(::greptime::v1::meta::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_id));
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.DeleteRequest.table_id)
}

// -------------------------------------------------------------------

// RouteResponse

// .greptime.v1.meta.ResponseHeader header = 1;
inline bool RouteResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RouteResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::meta::ResponseHeader& RouteResponse::_internal_header() const {
  const ::greptime::v1::meta::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::ResponseHeader&>(
      ::greptime::v1::meta::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::meta::ResponseHeader& RouteResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RouteResponse.header)
  return _internal_header();
}
inline void RouteResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::meta::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RouteResponse.header)
}
inline ::greptime::v1::meta::ResponseHeader* RouteResponse::release_header() {
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* RouteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RouteResponse.header)
  
  ::greptime::v1::meta::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::ResponseHeader* RouteResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::meta::ResponseHeader* RouteResponse::mutable_header() {
  ::greptime::v1::meta::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RouteResponse.header)
  return _msg;
}
inline void RouteResponse::set_allocated_header(::greptime::v1::meta::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RouteResponse.header)
}

// repeated .greptime.v1.meta.Peer peers = 2;
inline int RouteResponse::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int RouteResponse::peers_size() const {
  return _internal_peers_size();
}
inline ::greptime::v1::meta::Peer* RouteResponse::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RouteResponse.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >*
RouteResponse::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RouteResponse.peers)
  return &_impl_.peers_;
}
inline const ::greptime::v1::meta::Peer& RouteResponse::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::greptime::v1::meta::Peer& RouteResponse::peers(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RouteResponse.peers)
  return _internal_peers(index);
}
inline ::greptime::v1::meta::Peer* RouteResponse::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::greptime::v1::meta::Peer* RouteResponse::add_peers() {
  ::greptime::v1::meta::Peer* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RouteResponse.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >&
RouteResponse::peers() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RouteResponse.peers)
  return _impl_.peers_;
}

// repeated .greptime.v1.meta.TableRoute table_routes = 3;
inline int RouteResponse::_internal_table_routes_size() const {
  return _impl_.table_routes_.size();
}
inline int RouteResponse::table_routes_size() const {
  return _internal_table_routes_size();
}
inline void RouteResponse::clear_table_routes() {
  _impl_.table_routes_.Clear();
}
inline ::greptime::v1::meta::TableRoute* RouteResponse::mutable_table_routes(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RouteResponse.table_routes)
  return _impl_.table_routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableRoute >*
RouteResponse::mutable_table_routes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RouteResponse.table_routes)
  return &_impl_.table_routes_;
}
inline const ::greptime::v1::meta::TableRoute& RouteResponse::_internal_table_routes(int index) const {
  return _impl_.table_routes_.Get(index);
}
inline const ::greptime::v1::meta::TableRoute& RouteResponse::table_routes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RouteResponse.table_routes)
  return _internal_table_routes(index);
}
inline ::greptime::v1::meta::TableRoute* RouteResponse::_internal_add_table_routes() {
  return _impl_.table_routes_.Add();
}
inline ::greptime::v1::meta::TableRoute* RouteResponse::add_table_routes() {
  ::greptime::v1::meta::TableRoute* _add = _internal_add_table_routes();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RouteResponse.table_routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::TableRoute >&
RouteResponse::table_routes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RouteResponse.table_routes)
  return _impl_.table_routes_;
}

// -------------------------------------------------------------------

// TableRoute

// .greptime.v1.meta.Table table = 1;
inline bool TableRoute::_internal_has_table() const {
  return this != internal_default_instance() && _impl_.table_ != nullptr;
}
inline bool TableRoute::has_table() const {
  return _internal_has_table();
}
inline void TableRoute::clear_table() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_ != nullptr) {
    delete _impl_.table_;
  }
  _impl_.table_ = nullptr;
}
inline const ::greptime::v1::meta::Table& TableRoute::_internal_table() const {
  const ::greptime::v1::meta::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Table&>(
      ::greptime::v1::meta::_Table_default_instance_);
}
inline const ::greptime::v1::meta::Table& TableRoute::table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRoute.table)
  return _internal_table();
}
inline void TableRoute::unsafe_arena_set_allocated_table(
    ::greptime::v1::meta::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.TableRoute.table)
}
inline ::greptime::v1::meta::Table* TableRoute::release_table() {
  
  ::greptime::v1::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Table* TableRoute::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.TableRoute.table)
  
  ::greptime::v1::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Table* TableRoute::_internal_mutable_table() {
  
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::greptime::v1::meta::Table* TableRoute::mutable_table() {
  ::greptime::v1::meta::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRoute.table)
  return _msg;
}
inline void TableRoute::set_allocated_table(::greptime::v1::meta::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_;
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table);
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.TableRoute.table)
}

// repeated .greptime.v1.meta.RegionRoute region_routes = 2;
inline int TableRoute::_internal_region_routes_size() const {
  return _impl_.region_routes_.size();
}
inline int TableRoute::region_routes_size() const {
  return _internal_region_routes_size();
}
inline void TableRoute::clear_region_routes() {
  _impl_.region_routes_.Clear();
}
inline ::greptime::v1::meta::RegionRoute* TableRoute::mutable_region_routes(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRoute.region_routes)
  return _impl_.region_routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >*
TableRoute::mutable_region_routes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.TableRoute.region_routes)
  return &_impl_.region_routes_;
}
inline const ::greptime::v1::meta::RegionRoute& TableRoute::_internal_region_routes(int index) const {
  return _impl_.region_routes_.Get(index);
}
inline const ::greptime::v1::meta::RegionRoute& TableRoute::region_routes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRoute.region_routes)
  return _internal_region_routes(index);
}
inline ::greptime::v1::meta::RegionRoute* TableRoute::_internal_add_region_routes() {
  return _impl_.region_routes_.Add();
}
inline ::greptime::v1::meta::RegionRoute* TableRoute::add_region_routes() {
  ::greptime::v1::meta::RegionRoute* _add = _internal_add_region_routes();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.TableRoute.region_routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::RegionRoute >&
TableRoute::region_routes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.TableRoute.region_routes)
  return _impl_.region_routes_;
}

// -------------------------------------------------------------------

// RegionRoute

// .greptime.v1.meta.Region region = 1;
inline bool RegionRoute::_internal_has_region() const {
  return this != internal_default_instance() && _impl_.region_ != nullptr;
}
inline bool RegionRoute::has_region() const {
  return _internal_has_region();
}
inline void RegionRoute::clear_region() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_ != nullptr) {
    delete _impl_.region_;
  }
  _impl_.region_ = nullptr;
}
inline const ::greptime::v1::meta::Region& RegionRoute::_internal_region() const {
  const ::greptime::v1::meta::Region* p = _impl_.region_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Region&>(
      ::greptime::v1::meta::_Region_default_instance_);
}
inline const ::greptime::v1::meta::Region& RegionRoute::region() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionRoute.region)
  return _internal_region();
}
inline void RegionRoute::unsafe_arena_set_allocated_region(
    ::greptime::v1::meta::Region* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_);
  }
  _impl_.region_ = region;
  if (region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.RegionRoute.region)
}
inline ::greptime::v1::meta::Region* RegionRoute::release_region() {
  
  ::greptime::v1::meta::Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Region* RegionRoute::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.RegionRoute.region)
  
  ::greptime::v1::meta::Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Region* RegionRoute::_internal_mutable_region() {
  
  if (_impl_.region_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Region>(GetArenaForAllocation());
    _impl_.region_ = p;
  }
  return _impl_.region_;
}
inline ::greptime::v1::meta::Region* RegionRoute::mutable_region() {
  ::greptime::v1::meta::Region* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.RegionRoute.region)
  return _msg;
}
inline void RegionRoute::set_allocated_region(::greptime::v1::meta::Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_ = region;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.RegionRoute.region)
}

// uint64 leader_peer_index = 2;
inline void RegionRoute::clear_leader_peer_index() {
  _impl_.leader_peer_index_ = uint64_t{0u};
}
inline uint64_t RegionRoute::_internal_leader_peer_index() const {
  return _impl_.leader_peer_index_;
}
inline uint64_t RegionRoute::leader_peer_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionRoute.leader_peer_index)
  return _internal_leader_peer_index();
}
inline void RegionRoute::_internal_set_leader_peer_index(uint64_t value) {
  
  _impl_.leader_peer_index_ = value;
}
inline void RegionRoute::set_leader_peer_index(uint64_t value) {
  _internal_set_leader_peer_index(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionRoute.leader_peer_index)
}

// repeated uint64 follower_peer_indexes = 3;
inline int RegionRoute::_internal_follower_peer_indexes_size() const {
  return _impl_.follower_peer_indexes_.size();
}
inline int RegionRoute::follower_peer_indexes_size() const {
  return _internal_follower_peer_indexes_size();
}
inline void RegionRoute::clear_follower_peer_indexes() {
  _impl_.follower_peer_indexes_.Clear();
}
inline uint64_t RegionRoute::_internal_follower_peer_indexes(int index) const {
  return _impl_.follower_peer_indexes_.Get(index);
}
inline uint64_t RegionRoute::follower_peer_indexes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.RegionRoute.follower_peer_indexes)
  return _internal_follower_peer_indexes(index);
}
inline void RegionRoute::set_follower_peer_indexes(int index, uint64_t value) {
  _impl_.follower_peer_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.RegionRoute.follower_peer_indexes)
}
inline void RegionRoute::_internal_add_follower_peer_indexes(uint64_t value) {
  _impl_.follower_peer_indexes_.Add(value);
}
inline void RegionRoute::add_follower_peer_indexes(uint64_t value) {
  _internal_add_follower_peer_indexes(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.RegionRoute.follower_peer_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RegionRoute::_internal_follower_peer_indexes() const {
  return _impl_.follower_peer_indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
RegionRoute::follower_peer_indexes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.RegionRoute.follower_peer_indexes)
  return _internal_follower_peer_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RegionRoute::_internal_mutable_follower_peer_indexes() {
  return &_impl_.follower_peer_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
RegionRoute::mutable_follower_peer_indexes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.RegionRoute.follower_peer_indexes)
  return _internal_mutable_follower_peer_indexes();
}

// -------------------------------------------------------------------

// Table

// uint64 id = 1;
inline void Table::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Table::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Table::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Table.id)
  return _internal_id();
}
inline void Table::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Table::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Table.id)
}

// .greptime.v1.meta.TableName table_name = 2;
inline bool Table::_internal_has_table_name() const {
  return this != internal_default_instance() && _impl_.table_name_ != nullptr;
}
inline bool Table::has_table_name() const {
  return _internal_has_table_name();
}
inline const ::greptime::v1::meta::TableName& Table::_internal_table_name() const {
  const ::greptime::v1::meta::TableName* p = _impl_.table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableName&>(
      ::greptime::v1::meta::_TableName_default_instance_);
}
inline const ::greptime::v1::meta::TableName& Table::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Table.table_name)
  return _internal_table_name();
}
inline void Table::unsafe_arena_set_allocated_table_name(
    ::greptime::v1::meta::TableName* table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  _impl_.table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.Table.table_name)
}
inline ::greptime::v1::meta::TableName* Table::release_table_name() {
  
  ::greptime::v1::meta::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableName* Table::unsafe_arena_release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Table.table_name)
  
  ::greptime::v1::meta::TableName* temp = _impl_.table_name_;
  _impl_.table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableName* Table::_internal_mutable_table_name() {
  
  if (_impl_.table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableName>(GetArenaForAllocation());
    _impl_.table_name_ = p;
  }
  return _impl_.table_name_;
}
inline ::greptime::v1::meta::TableName* Table::mutable_table_name() {
  ::greptime::v1::meta::TableName* _msg = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Table.table_name)
  return _msg;
}
inline void Table::set_allocated_table_name(::greptime::v1::meta::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name));
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Table.table_name)
}

// bytes table_schema = 3;
inline void Table::clear_table_schema() {
  _impl_.table_schema_.ClearToEmpty();
}
inline const std::string& Table::table_schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Table.table_schema)
  return _internal_table_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Table::set_table_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_schema_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Table.table_schema)
}
inline std::string* Table::mutable_table_schema() {
  std::string* _s = _internal_mutable_table_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Table.table_schema)
  return _s;
}
inline const std::string& Table::_internal_table_schema() const {
  return _impl_.table_schema_.Get();
}
inline void Table::_internal_set_table_schema(const std::string& value) {
  
  _impl_.table_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* Table::_internal_mutable_table_schema() {
  
  return _impl_.table_schema_.Mutable(GetArenaForAllocation());
}
inline std::string* Table::release_table_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Table.table_schema)
  return _impl_.table_schema_.Release();
}
inline void Table::set_allocated_table_schema(std::string* table_schema) {
  if (table_schema != nullptr) {
    
  } else {
    
  }
  _impl_.table_schema_.SetAllocated(table_schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_schema_.IsDefault()) {
    _impl_.table_schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Table.table_schema)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Region

// uint64 id = 1;
inline void Region::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Region::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Region::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Region.id)
  return _internal_id();
}
inline void Region::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Region::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Region.id)
}

// string name = 2;
inline void Region::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Region::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Region.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Region::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Region.name)
}
inline std::string* Region::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Region.name)
  return _s;
}
inline const std::string& Region::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Region::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Region::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Region::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Region.name)
  return _impl_.name_.Release();
}
inline void Region::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Region.name)
}

// .greptime.v1.meta.Partition partition = 3;
inline bool Region::_internal_has_partition() const {
  return this != internal_default_instance() && _impl_.partition_ != nullptr;
}
inline bool Region::has_partition() const {
  return _internal_has_partition();
}
inline void Region::clear_partition() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_ != nullptr) {
    delete _impl_.partition_;
  }
  _impl_.partition_ = nullptr;
}
inline const ::greptime::v1::meta::Partition& Region::_internal_partition() const {
  const ::greptime::v1::meta::Partition* p = _impl_.partition_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::Partition&>(
      ::greptime::v1::meta::_Partition_default_instance_);
}
inline const ::greptime::v1::meta::Partition& Region::partition() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Region.partition)
  return _internal_partition();
}
inline void Region::unsafe_arena_set_allocated_partition(
    ::greptime::v1::meta::Partition* partition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_);
  }
  _impl_.partition_ = partition;
  if (partition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.Region.partition)
}
inline ::greptime::v1::meta::Partition* Region::release_partition() {
  
  ::greptime::v1::meta::Partition* temp = _impl_.partition_;
  _impl_.partition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::Partition* Region::unsafe_arena_release_partition() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.Region.partition)
  
  ::greptime::v1::meta::Partition* temp = _impl_.partition_;
  _impl_.partition_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::Partition* Region::_internal_mutable_partition() {
  
  if (_impl_.partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::Partition>(GetArenaForAllocation());
    _impl_.partition_ = p;
  }
  return _impl_.partition_;
}
inline ::greptime::v1::meta::Partition* Region::mutable_partition() {
  ::greptime::v1::meta::Partition* _msg = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Region.partition)
  return _msg;
}
inline void Region::set_allocated_partition(::greptime::v1::meta::Partition* partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_;
  }
  if (partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition);
    if (message_arena != submessage_arena) {
      partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.partition_ = partition;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.Region.partition)
}

// map<string, string> attrs = 100;
inline int Region::_internal_attrs_size() const {
  return _impl_.attrs_.size();
}
inline int Region::attrs_size() const {
  return _internal_attrs_size();
}
inline void Region::clear_attrs() {
  _impl_.attrs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Region::_internal_attrs() const {
  return _impl_.attrs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Region::attrs() const {
  // @@protoc_insertion_point(field_map:greptime.v1.meta.Region.attrs)
  return _internal_attrs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Region::_internal_mutable_attrs() {
  return _impl_.attrs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Region::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.meta.Region.attrs)
  return _internal_mutable_attrs();
}

// -------------------------------------------------------------------

// Partition

// repeated bytes column_list = 1;
inline int Partition::_internal_column_list_size() const {
  return _impl_.column_list_.size();
}
inline int Partition::column_list_size() const {
  return _internal_column_list_size();
}
inline void Partition::clear_column_list() {
  _impl_.column_list_.Clear();
}
inline std::string* Partition::add_column_list() {
  std::string* _s = _internal_add_column_list();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.meta.Partition.column_list)
  return _s;
}
inline const std::string& Partition::_internal_column_list(int index) const {
  return _impl_.column_list_.Get(index);
}
inline const std::string& Partition::column_list(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Partition.column_list)
  return _internal_column_list(index);
}
inline std::string* Partition::mutable_column_list(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Partition.column_list)
  return _impl_.column_list_.Mutable(index);
}
inline void Partition::set_column_list(int index, const std::string& value) {
  _impl_.column_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.column_list)
}
inline void Partition::set_column_list(int index, std::string&& value) {
  _impl_.column_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.column_list)
}
inline void Partition::set_column_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.meta.Partition.column_list)
}
inline void Partition::set_column_list(int index, const void* value, size_t size) {
  _impl_.column_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.meta.Partition.column_list)
}
inline std::string* Partition::_internal_add_column_list() {
  return _impl_.column_list_.Add();
}
inline void Partition::add_column_list(const std::string& value) {
  _impl_.column_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.column_list)
}
inline void Partition::add_column_list(std::string&& value) {
  _impl_.column_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.column_list)
}
inline void Partition::add_column_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.meta.Partition.column_list)
}
inline void Partition::add_column_list(const void* value, size_t size) {
  _impl_.column_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.meta.Partition.column_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Partition::column_list() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.Partition.column_list)
  return _impl_.column_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Partition::mutable_column_list() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.Partition.column_list)
  return &_impl_.column_list_;
}

// repeated bytes value_list = 2;
inline int Partition::_internal_value_list_size() const {
  return _impl_.value_list_.size();
}
inline int Partition::value_list_size() const {
  return _internal_value_list_size();
}
inline void Partition::clear_value_list() {
  _impl_.value_list_.Clear();
}
inline std::string* Partition::add_value_list() {
  std::string* _s = _internal_add_value_list();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.meta.Partition.value_list)
  return _s;
}
inline const std::string& Partition::_internal_value_list(int index) const {
  return _impl_.value_list_.Get(index);
}
inline const std::string& Partition::value_list(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.Partition.value_list)
  return _internal_value_list(index);
}
inline std::string* Partition::mutable_value_list(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.Partition.value_list)
  return _impl_.value_list_.Mutable(index);
}
inline void Partition::set_value_list(int index, const std::string& value) {
  _impl_.value_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.value_list)
}
inline void Partition::set_value_list(int index, std::string&& value) {
  _impl_.value_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.meta.Partition.value_list)
}
inline void Partition::set_value_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.meta.Partition.value_list)
}
inline void Partition::set_value_list(int index, const void* value, size_t size) {
  _impl_.value_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.meta.Partition.value_list)
}
inline std::string* Partition::_internal_add_value_list() {
  return _impl_.value_list_.Add();
}
inline void Partition::add_value_list(const std::string& value) {
  _impl_.value_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.value_list)
}
inline void Partition::add_value_list(std::string&& value) {
  _impl_.value_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.meta.Partition.value_list)
}
inline void Partition::add_value_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.value_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.meta.Partition.value_list)
}
inline void Partition::add_value_list(const void* value, size_t size) {
  _impl_.value_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.meta.Partition.value_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Partition::value_list() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.Partition.value_list)
  return _impl_.value_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Partition::mutable_value_list() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.Partition.value_list)
  return &_impl_.value_list_;
}

// -------------------------------------------------------------------

// TableRouteValue

// repeated .greptime.v1.meta.Peer peers = 1;
inline int TableRouteValue::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int TableRouteValue::peers_size() const {
  return _internal_peers_size();
}
inline ::greptime::v1::meta::Peer* TableRouteValue::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRouteValue.peers)
  return _impl_.peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >*
TableRouteValue::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.meta.TableRouteValue.peers)
  return &_impl_.peers_;
}
inline const ::greptime::v1::meta::Peer& TableRouteValue::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const ::greptime::v1::meta::Peer& TableRouteValue::peers(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRouteValue.peers)
  return _internal_peers(index);
}
inline ::greptime::v1::meta::Peer* TableRouteValue::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline ::greptime::v1::meta::Peer* TableRouteValue::add_peers() {
  ::greptime::v1::meta::Peer* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:greptime.v1.meta.TableRouteValue.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::meta::Peer >&
TableRouteValue::peers() const {
  // @@protoc_insertion_point(field_list:greptime.v1.meta.TableRouteValue.peers)
  return _impl_.peers_;
}

// .greptime.v1.meta.TableRoute table_route = 2;
inline bool TableRouteValue::_internal_has_table_route() const {
  return this != internal_default_instance() && _impl_.table_route_ != nullptr;
}
inline bool TableRouteValue::has_table_route() const {
  return _internal_has_table_route();
}
inline void TableRouteValue::clear_table_route() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_route_ != nullptr) {
    delete _impl_.table_route_;
  }
  _impl_.table_route_ = nullptr;
}
inline const ::greptime::v1::meta::TableRoute& TableRouteValue::_internal_table_route() const {
  const ::greptime::v1::meta::TableRoute* p = _impl_.table_route_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::meta::TableRoute&>(
      ::greptime::v1::meta::_TableRoute_default_instance_);
}
inline const ::greptime::v1::meta::TableRoute& TableRouteValue::table_route() const {
  // @@protoc_insertion_point(field_get:greptime.v1.meta.TableRouteValue.table_route)
  return _internal_table_route();
}
inline void TableRouteValue::unsafe_arena_set_allocated_table_route(
    ::greptime::v1::meta::TableRoute* table_route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_route_);
  }
  _impl_.table_route_ = table_route;
  if (table_route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.meta.TableRouteValue.table_route)
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::release_table_route() {
  
  ::greptime::v1::meta::TableRoute* temp = _impl_.table_route_;
  _impl_.table_route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::unsafe_arena_release_table_route() {
  // @@protoc_insertion_point(field_release:greptime.v1.meta.TableRouteValue.table_route)
  
  ::greptime::v1::meta::TableRoute* temp = _impl_.table_route_;
  _impl_.table_route_ = nullptr;
  return temp;
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::_internal_mutable_table_route() {
  
  if (_impl_.table_route_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::meta::TableRoute>(GetArenaForAllocation());
    _impl_.table_route_ = p;
  }
  return _impl_.table_route_;
}
inline ::greptime::v1::meta::TableRoute* TableRouteValue::mutable_table_route() {
  ::greptime::v1::meta::TableRoute* _msg = _internal_mutable_table_route();
  // @@protoc_insertion_point(field_mutable:greptime.v1.meta.TableRouteValue.table_route)
  return _msg;
}
inline void TableRouteValue::set_allocated_table_route(::greptime::v1::meta::TableRoute* table_route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_route_;
  }
  if (table_route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_route);
    if (message_arena != submessage_arena) {
      table_route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_route_ = table_route;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.meta.TableRouteValue.table_route)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fmeta_2froute_2eproto
