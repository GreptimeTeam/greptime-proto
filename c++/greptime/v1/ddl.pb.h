// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/ddl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fddl_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fddl_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fddl_2eproto;
namespace greptime {
namespace v1 {
class AddColumn;
struct AddColumnDefaultTypeInternal;
extern AddColumnDefaultTypeInternal _AddColumn_default_instance_;
class AddColumnLocation;
struct AddColumnLocationDefaultTypeInternal;
extern AddColumnLocationDefaultTypeInternal _AddColumnLocation_default_instance_;
class AddColumns;
struct AddColumnsDefaultTypeInternal;
extern AddColumnsDefaultTypeInternal _AddColumns_default_instance_;
class AlterExpr;
struct AlterExprDefaultTypeInternal;
extern AlterExprDefaultTypeInternal _AlterExpr_default_instance_;
class ColumnDef;
struct ColumnDefDefaultTypeInternal;
extern ColumnDefDefaultTypeInternal _ColumnDef_default_instance_;
class CreateDatabaseExpr;
struct CreateDatabaseExprDefaultTypeInternal;
extern CreateDatabaseExprDefaultTypeInternal _CreateDatabaseExpr_default_instance_;
class CreateDatabaseExpr_OptionsEntry_DoNotUse;
struct CreateDatabaseExpr_OptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateDatabaseExpr_OptionsEntry_DoNotUseDefaultTypeInternal _CreateDatabaseExpr_OptionsEntry_DoNotUse_default_instance_;
class CreateTableExpr;
struct CreateTableExprDefaultTypeInternal;
extern CreateTableExprDefaultTypeInternal _CreateTableExpr_default_instance_;
class CreateTableExpr_TableOptionsEntry_DoNotUse;
struct CreateTableExpr_TableOptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateTableExpr_TableOptionsEntry_DoNotUseDefaultTypeInternal _CreateTableExpr_TableOptionsEntry_DoNotUse_default_instance_;
class DdlRequest;
struct DdlRequestDefaultTypeInternal;
extern DdlRequestDefaultTypeInternal _DdlRequest_default_instance_;
class DropColumn;
struct DropColumnDefaultTypeInternal;
extern DropColumnDefaultTypeInternal _DropColumn_default_instance_;
class DropColumns;
struct DropColumnsDefaultTypeInternal;
extern DropColumnsDefaultTypeInternal _DropColumns_default_instance_;
class DropTableExpr;
struct DropTableExprDefaultTypeInternal;
extern DropTableExprDefaultTypeInternal _DropTableExpr_default_instance_;
class RenameTable;
struct RenameTableDefaultTypeInternal;
extern RenameTableDefaultTypeInternal _RenameTable_default_instance_;
class TableId;
struct TableIdDefaultTypeInternal;
extern TableIdDefaultTypeInternal _TableId_default_instance_;
class TruncateTableExpr;
struct TruncateTableExprDefaultTypeInternal;
extern TruncateTableExprDefaultTypeInternal _TruncateTableExpr_default_instance_;
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::AddColumn* Arena::CreateMaybeMessage<::greptime::v1::AddColumn>(Arena*);
template<> ::greptime::v1::AddColumnLocation* Arena::CreateMaybeMessage<::greptime::v1::AddColumnLocation>(Arena*);
template<> ::greptime::v1::AddColumns* Arena::CreateMaybeMessage<::greptime::v1::AddColumns>(Arena*);
template<> ::greptime::v1::AlterExpr* Arena::CreateMaybeMessage<::greptime::v1::AlterExpr>(Arena*);
template<> ::greptime::v1::ColumnDef* Arena::CreateMaybeMessage<::greptime::v1::ColumnDef>(Arena*);
template<> ::greptime::v1::CreateDatabaseExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateDatabaseExpr>(Arena*);
template<> ::greptime::v1::CreateDatabaseExpr_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateDatabaseExpr_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateTableExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateTableExpr>(Arena*);
template<> ::greptime::v1::CreateTableExpr_TableOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateTableExpr_TableOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::DdlRequest* Arena::CreateMaybeMessage<::greptime::v1::DdlRequest>(Arena*);
template<> ::greptime::v1::DropColumn* Arena::CreateMaybeMessage<::greptime::v1::DropColumn>(Arena*);
template<> ::greptime::v1::DropColumns* Arena::CreateMaybeMessage<::greptime::v1::DropColumns>(Arena*);
template<> ::greptime::v1::DropTableExpr* Arena::CreateMaybeMessage<::greptime::v1::DropTableExpr>(Arena*);
template<> ::greptime::v1::RenameTable* Arena::CreateMaybeMessage<::greptime::v1::RenameTable>(Arena*);
template<> ::greptime::v1::TableId* Arena::CreateMaybeMessage<::greptime::v1::TableId>(Arena*);
template<> ::greptime::v1::TruncateTableExpr* Arena::CreateMaybeMessage<::greptime::v1::TruncateTableExpr>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {

enum AddColumnLocation_LocationType : int {
  AddColumnLocation_LocationType_FIRST = 0,
  AddColumnLocation_LocationType_AFTER = 1,
  AddColumnLocation_LocationType_AddColumnLocation_LocationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddColumnLocation_LocationType_AddColumnLocation_LocationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddColumnLocation_LocationType_IsValid(int value);
constexpr AddColumnLocation_LocationType AddColumnLocation_LocationType_LocationType_MIN = AddColumnLocation_LocationType_FIRST;
constexpr AddColumnLocation_LocationType AddColumnLocation_LocationType_LocationType_MAX = AddColumnLocation_LocationType_AFTER;
constexpr int AddColumnLocation_LocationType_LocationType_ARRAYSIZE = AddColumnLocation_LocationType_LocationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddColumnLocation_LocationType_descriptor();
template<typename T>
inline const std::string& AddColumnLocation_LocationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddColumnLocation_LocationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddColumnLocation_LocationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddColumnLocation_LocationType_descriptor(), enum_t_value);
}
inline bool AddColumnLocation_LocationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddColumnLocation_LocationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddColumnLocation_LocationType>(
    AddColumnLocation_LocationType_descriptor(), name, value);
}
// ===================================================================

class DdlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DdlRequest) */ {
 public:
  inline DdlRequest() : DdlRequest(nullptr) {}
  ~DdlRequest() override;
  explicit PROTOBUF_CONSTEXPR DdlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlRequest(const DdlRequest& from);
  DdlRequest(DdlRequest&& from) noexcept
    : DdlRequest() {
    *this = ::std::move(from);
  }

  inline DdlRequest& operator=(const DdlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlRequest& operator=(DdlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ExprCase {
    kCreateDatabase = 1,
    kCreateTable = 2,
    kAlter = 3,
    kDropTable = 4,
    kTruncateTable = 7,
    EXPR_NOT_SET = 0,
  };

  static inline const DdlRequest* internal_default_instance() {
    return reinterpret_cast<const DdlRequest*>(
               &_DdlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DdlRequest& a, DdlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DdlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DdlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DdlRequest& from) {
    DdlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DdlRequest";
  }
  protected:
  explicit DdlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateDatabaseFieldNumber = 1,
    kCreateTableFieldNumber = 2,
    kAlterFieldNumber = 3,
    kDropTableFieldNumber = 4,
    kTruncateTableFieldNumber = 7,
  };
  // .greptime.v1.CreateDatabaseExpr create_database = 1;
  bool has_create_database() const;
  private:
  bool _internal_has_create_database() const;
  public:
  void clear_create_database();
  const ::greptime::v1::CreateDatabaseExpr& create_database() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateDatabaseExpr* release_create_database();
  ::greptime::v1::CreateDatabaseExpr* mutable_create_database();
  void set_allocated_create_database(::greptime::v1::CreateDatabaseExpr* create_database);
  private:
  const ::greptime::v1::CreateDatabaseExpr& _internal_create_database() const;
  ::greptime::v1::CreateDatabaseExpr* _internal_mutable_create_database();
  public:
  void unsafe_arena_set_allocated_create_database(
      ::greptime::v1::CreateDatabaseExpr* create_database);
  ::greptime::v1::CreateDatabaseExpr* unsafe_arena_release_create_database();

  // .greptime.v1.CreateTableExpr create_table = 2;
  bool has_create_table() const;
  private:
  bool _internal_has_create_table() const;
  public:
  void clear_create_table();
  const ::greptime::v1::CreateTableExpr& create_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateTableExpr* release_create_table();
  ::greptime::v1::CreateTableExpr* mutable_create_table();
  void set_allocated_create_table(::greptime::v1::CreateTableExpr* create_table);
  private:
  const ::greptime::v1::CreateTableExpr& _internal_create_table() const;
  ::greptime::v1::CreateTableExpr* _internal_mutable_create_table();
  public:
  void unsafe_arena_set_allocated_create_table(
      ::greptime::v1::CreateTableExpr* create_table);
  ::greptime::v1::CreateTableExpr* unsafe_arena_release_create_table();

  // .greptime.v1.AlterExpr alter = 3;
  bool has_alter() const;
  private:
  bool _internal_has_alter() const;
  public:
  void clear_alter();
  const ::greptime::v1::AlterExpr& alter() const;
  PROTOBUF_NODISCARD ::greptime::v1::AlterExpr* release_alter();
  ::greptime::v1::AlterExpr* mutable_alter();
  void set_allocated_alter(::greptime::v1::AlterExpr* alter);
  private:
  const ::greptime::v1::AlterExpr& _internal_alter() const;
  ::greptime::v1::AlterExpr* _internal_mutable_alter();
  public:
  void unsafe_arena_set_allocated_alter(
      ::greptime::v1::AlterExpr* alter);
  ::greptime::v1::AlterExpr* unsafe_arena_release_alter();

  // .greptime.v1.DropTableExpr drop_table = 4;
  bool has_drop_table() const;
  private:
  bool _internal_has_drop_table() const;
  public:
  void clear_drop_table();
  const ::greptime::v1::DropTableExpr& drop_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropTableExpr* release_drop_table();
  ::greptime::v1::DropTableExpr* mutable_drop_table();
  void set_allocated_drop_table(::greptime::v1::DropTableExpr* drop_table);
  private:
  const ::greptime::v1::DropTableExpr& _internal_drop_table() const;
  ::greptime::v1::DropTableExpr* _internal_mutable_drop_table();
  public:
  void unsafe_arena_set_allocated_drop_table(
      ::greptime::v1::DropTableExpr* drop_table);
  ::greptime::v1::DropTableExpr* unsafe_arena_release_drop_table();

  // .greptime.v1.TruncateTableExpr truncate_table = 7;
  bool has_truncate_table() const;
  private:
  bool _internal_has_truncate_table() const;
  public:
  void clear_truncate_table();
  const ::greptime::v1::TruncateTableExpr& truncate_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::TruncateTableExpr* release_truncate_table();
  ::greptime::v1::TruncateTableExpr* mutable_truncate_table();
  void set_allocated_truncate_table(::greptime::v1::TruncateTableExpr* truncate_table);
  private:
  const ::greptime::v1::TruncateTableExpr& _internal_truncate_table() const;
  ::greptime::v1::TruncateTableExpr* _internal_mutable_truncate_table();
  public:
  void unsafe_arena_set_allocated_truncate_table(
      ::greptime::v1::TruncateTableExpr* truncate_table);
  ::greptime::v1::TruncateTableExpr* unsafe_arena_release_truncate_table();

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.DdlRequest)
 private:
  class _Internal;
  void set_has_create_database();
  void set_has_create_table();
  void set_has_alter();
  void set_has_drop_table();
  void set_has_truncate_table();

  inline bool has_expr() const;
  inline void clear_has_expr();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ExprUnion {
      constexpr ExprUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::CreateDatabaseExpr* create_database_;
      ::greptime::v1::CreateTableExpr* create_table_;
      ::greptime::v1::AlterExpr* alter_;
      ::greptime::v1::DropTableExpr* drop_table_;
      ::greptime::v1::TruncateTableExpr* truncate_table_;
    } expr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateTableExpr_TableOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableExpr_TableOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableExpr_TableOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateTableExpr_TableOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateTableExpr_TableOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateTableExpr_TableOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateTableExpr_TableOptionsEntry_DoNotUse& other);
  static const CreateTableExpr_TableOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateTableExpr_TableOptionsEntry_DoNotUse*>(&_CreateTableExpr_TableOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTableExpr.TableOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTableExpr.TableOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateTableExpr) */ {
 public:
  inline CreateTableExpr() : CreateTableExpr(nullptr) {}
  ~CreateTableExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableExpr(const CreateTableExpr& from);
  CreateTableExpr(CreateTableExpr&& from) noexcept
    : CreateTableExpr() {
    *this = ::std::move(from);
  }

  inline CreateTableExpr& operator=(const CreateTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableExpr& operator=(CreateTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableExpr* internal_default_instance() {
    return reinterpret_cast<const CreateTableExpr*>(
               &_CreateTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateTableExpr& a, CreateTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableExpr& from) {
    CreateTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateTableExpr";
  }
  protected:
  explicit CreateTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 5,
    kPrimaryKeysFieldNumber = 7,
    kTableOptionsFieldNumber = 9,
    kRegionNumbersFieldNumber = 11,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kDescFieldNumber = 4,
    kTimeIndexFieldNumber = 6,
    kEngineFieldNumber = 12,
    kTableIdFieldNumber = 10,
    kCreateIfNotExistsFieldNumber = 8,
  };
  // repeated .greptime.v1.ColumnDef column_defs = 5;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::greptime::v1::ColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >*
      mutable_column_defs();
  private:
  const ::greptime::v1::ColumnDef& _internal_column_defs(int index) const;
  ::greptime::v1::ColumnDef* _internal_add_column_defs();
  public:
  const ::greptime::v1::ColumnDef& column_defs(int index) const;
  ::greptime::v1::ColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >&
      column_defs() const;

  // repeated string primary_keys = 7;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // map<string, string> table_options = 9;
  int table_options_size() const;
  private:
  int _internal_table_options_size() const;
  public:
  void clear_table_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_table_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_table_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      table_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_table_options();

  // repeated uint32 region_numbers = 11;
  int region_numbers_size() const;
  private:
  int _internal_region_numbers_size() const;
  public:
  void clear_region_numbers();
  private:
  uint32_t _internal_region_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_region_numbers() const;
  void _internal_add_region_numbers(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_region_numbers();
  public:
  uint32_t region_numbers(int index) const;
  void set_region_numbers(int index, uint32_t value);
  void add_region_numbers(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      region_numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_region_numbers();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string desc = 4;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // string time_index = 6;
  void clear_time_index();
  const std::string& time_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_index();
  PROTOBUF_NODISCARD std::string* release_time_index();
  void set_allocated_time_index(std::string* time_index);
  private:
  const std::string& _internal_time_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_index(const std::string& value);
  std::string* _internal_mutable_time_index();
  public:

  // string engine = 12;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // .greptime.v1.TableId table_id = 10;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // bool create_if_not_exists = 8;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateTableExpr_TableOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> table_options_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > region_numbers_;
    mutable std::atomic<int> _region_numbers_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::greptime::v1::TableId* table_id_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AlterExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AlterExpr) */ {
 public:
  inline AlterExpr() : AlterExpr(nullptr) {}
  ~AlterExpr() override;
  explicit PROTOBUF_CONSTEXPR AlterExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterExpr(const AlterExpr& from);
  AlterExpr(AlterExpr&& from) noexcept
    : AlterExpr() {
    *this = ::std::move(from);
  }

  inline AlterExpr& operator=(const AlterExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterExpr& operator=(AlterExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterExpr& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kAddColumns = 4,
    kDropColumns = 5,
    kRenameTable = 6,
    KIND_NOT_SET = 0,
  };

  static inline const AlterExpr* internal_default_instance() {
    return reinterpret_cast<const AlterExpr*>(
               &_AlterExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AlterExpr& a, AlterExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterExpr& from) {
    AlterExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AlterExpr";
  }
  protected:
  explicit AlterExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kAddColumnsFieldNumber = 4,
    kDropColumnsFieldNumber = 5,
    kRenameTableFieldNumber = 6,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.AddColumns add_columns = 4;
  bool has_add_columns() const;
  private:
  bool _internal_has_add_columns() const;
  public:
  void clear_add_columns();
  const ::greptime::v1::AddColumns& add_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumns* release_add_columns();
  ::greptime::v1::AddColumns* mutable_add_columns();
  void set_allocated_add_columns(::greptime::v1::AddColumns* add_columns);
  private:
  const ::greptime::v1::AddColumns& _internal_add_columns() const;
  ::greptime::v1::AddColumns* _internal_mutable_add_columns();
  public:
  void unsafe_arena_set_allocated_add_columns(
      ::greptime::v1::AddColumns* add_columns);
  ::greptime::v1::AddColumns* unsafe_arena_release_add_columns();

  // .greptime.v1.DropColumns drop_columns = 5;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::greptime::v1::DropColumns& drop_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropColumns* release_drop_columns();
  ::greptime::v1::DropColumns* mutable_drop_columns();
  void set_allocated_drop_columns(::greptime::v1::DropColumns* drop_columns);
  private:
  const ::greptime::v1::DropColumns& _internal_drop_columns() const;
  ::greptime::v1::DropColumns* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::greptime::v1::DropColumns* drop_columns);
  ::greptime::v1::DropColumns* unsafe_arena_release_drop_columns();

  // .greptime.v1.RenameTable rename_table = 6;
  bool has_rename_table() const;
  private:
  bool _internal_has_rename_table() const;
  public:
  void clear_rename_table();
  const ::greptime::v1::RenameTable& rename_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::RenameTable* release_rename_table();
  ::greptime::v1::RenameTable* mutable_rename_table();
  void set_allocated_rename_table(::greptime::v1::RenameTable* rename_table);
  private:
  const ::greptime::v1::RenameTable& _internal_rename_table() const;
  ::greptime::v1::RenameTable* _internal_mutable_rename_table();
  public:
  void unsafe_arena_set_allocated_rename_table(
      ::greptime::v1::RenameTable* rename_table);
  ::greptime::v1::RenameTable* unsafe_arena_release_rename_table();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.AlterExpr)
 private:
  class _Internal;
  void set_has_add_columns();
  void set_has_drop_columns();
  void set_has_rename_table();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::AddColumns* add_columns_;
      ::greptime::v1::DropColumns* drop_columns_;
      ::greptime::v1::RenameTable* rename_table_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropTableExpr) */ {
 public:
  inline DropTableExpr() : DropTableExpr(nullptr) {}
  ~DropTableExpr() override;
  explicit PROTOBUF_CONSTEXPR DropTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTableExpr(const DropTableExpr& from);
  DropTableExpr(DropTableExpr&& from) noexcept
    : DropTableExpr() {
    *this = ::std::move(from);
  }

  inline DropTableExpr& operator=(const DropTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTableExpr& operator=(DropTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTableExpr* internal_default_instance() {
    return reinterpret_cast<const DropTableExpr*>(
               &_DropTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DropTableExpr& a, DropTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTableExpr& from) {
    DropTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropTableExpr";
  }
  protected:
  explicit DropTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.TableId table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.DropTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::greptime::v1::TableId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateDatabaseExpr_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateDatabaseExpr_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateDatabaseExpr_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateDatabaseExpr_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateDatabaseExpr_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateDatabaseExpr_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateDatabaseExpr_OptionsEntry_DoNotUse& other);
  static const CreateDatabaseExpr_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateDatabaseExpr_OptionsEntry_DoNotUse*>(&_CreateDatabaseExpr_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateDatabaseExpr.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateDatabaseExpr.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateDatabaseExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateDatabaseExpr) */ {
 public:
  inline CreateDatabaseExpr() : CreateDatabaseExpr(nullptr) {}
  ~CreateDatabaseExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateDatabaseExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatabaseExpr(const CreateDatabaseExpr& from);
  CreateDatabaseExpr(CreateDatabaseExpr&& from) noexcept
    : CreateDatabaseExpr() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseExpr& operator=(const CreateDatabaseExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatabaseExpr& operator=(CreateDatabaseExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatabaseExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatabaseExpr* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseExpr*>(
               &_CreateDatabaseExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreateDatabaseExpr& a, CreateDatabaseExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatabaseExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatabaseExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatabaseExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatabaseExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDatabaseExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDatabaseExpr& from) {
    CreateDatabaseExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatabaseExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateDatabaseExpr";
  }
  protected:
  explicit CreateDatabaseExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 3,
    kDatabaseNameFieldNumber = 1,
    kCreateIfNotExistsFieldNumber = 2,
  };
  // map<string, string> options = 3;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string database_name = 1;
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_NODISCARD std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // bool create_if_not_exists = 2;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateDatabaseExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateDatabaseExpr_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class TruncateTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TruncateTableExpr) */ {
 public:
  inline TruncateTableExpr() : TruncateTableExpr(nullptr) {}
  ~TruncateTableExpr() override;
  explicit PROTOBUF_CONSTEXPR TruncateTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateTableExpr(const TruncateTableExpr& from);
  TruncateTableExpr(TruncateTableExpr&& from) noexcept
    : TruncateTableExpr() {
    *this = ::std::move(from);
  }

  inline TruncateTableExpr& operator=(const TruncateTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateTableExpr& operator=(TruncateTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const TruncateTableExpr* internal_default_instance() {
    return reinterpret_cast<const TruncateTableExpr*>(
               &_TruncateTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TruncateTableExpr& a, TruncateTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TruncateTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TruncateTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TruncateTableExpr& from) {
    TruncateTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TruncateTableExpr";
  }
  protected:
  explicit TruncateTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.TableId table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.TruncateTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::greptime::v1::TableId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumns) */ {
 public:
  inline AddColumns() : AddColumns(nullptr) {}
  ~AddColumns() override;
  explicit PROTOBUF_CONSTEXPR AddColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumns(const AddColumns& from);
  AddColumns(AddColumns&& from) noexcept
    : AddColumns() {
    *this = ::std::move(from);
  }

  inline AddColumns& operator=(const AddColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumns& operator=(AddColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumns* internal_default_instance() {
    return reinterpret_cast<const AddColumns*>(
               &_AddColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddColumns& a, AddColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumns& from) {
    AddColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumns";
  }
  protected:
  explicit AddColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.AddColumn add_columns = 1;
  int add_columns_size() const;
  private:
  int _internal_add_columns_size() const;
  public:
  void clear_add_columns();
  ::greptime::v1::AddColumn* mutable_add_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >*
      mutable_add_columns();
  private:
  const ::greptime::v1::AddColumn& _internal_add_columns(int index) const;
  ::greptime::v1::AddColumn* _internal_add_add_columns();
  public:
  const ::greptime::v1::AddColumn& add_columns(int index) const;
  ::greptime::v1::AddColumn* add_add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >&
      add_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn > add_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropColumns) */ {
 public:
  inline DropColumns() : DropColumns(nullptr) {}
  ~DropColumns() override;
  explicit PROTOBUF_CONSTEXPR DropColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumns(const DropColumns& from);
  DropColumns(DropColumns&& from) noexcept
    : DropColumns() {
    *this = ::std::move(from);
  }

  inline DropColumns& operator=(const DropColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumns& operator=(DropColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumns* internal_default_instance() {
    return reinterpret_cast<const DropColumns*>(
               &_DropColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DropColumns& a, DropColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumns& from) {
    DropColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropColumns";
  }
  protected:
  explicit DropColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.DropColumn drop_columns = 1;
  int drop_columns_size() const;
  private:
  int _internal_drop_columns_size() const;
  public:
  void clear_drop_columns();
  ::greptime::v1::DropColumn* mutable_drop_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >*
      mutable_drop_columns();
  private:
  const ::greptime::v1::DropColumn& _internal_drop_columns(int index) const;
  ::greptime::v1::DropColumn* _internal_add_drop_columns();
  public:
  const ::greptime::v1::DropColumn& drop_columns(int index) const;
  ::greptime::v1::DropColumn* add_drop_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >&
      drop_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.DropColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn > drop_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class RenameTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.RenameTable) */ {
 public:
  inline RenameTable() : RenameTable(nullptr) {}
  ~RenameTable() override;
  explicit PROTOBUF_CONSTEXPR RenameTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameTable(const RenameTable& from);
  RenameTable(RenameTable&& from) noexcept
    : RenameTable() {
    *this = ::std::move(from);
  }

  inline RenameTable& operator=(const RenameTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameTable& operator=(RenameTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameTable* internal_default_instance() {
    return reinterpret_cast<const RenameTable*>(
               &_RenameTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RenameTable& a, RenameTable& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameTable& from) {
    RenameTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.RenameTable";
  }
  protected:
  explicit RenameTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTableNameFieldNumber = 1,
  };
  // string new_table_name = 1;
  void clear_new_table_name();
  const std::string& new_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_table_name();
  PROTOBUF_NODISCARD std::string* release_new_table_name();
  void set_allocated_new_table_name(std::string* new_table_name);
  private:
  const std::string& _internal_new_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_table_name(const std::string& value);
  std::string* _internal_mutable_new_table_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.RenameTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumn) */ {
 public:
  inline AddColumn() : AddColumn(nullptr) {}
  ~AddColumn() override;
  explicit PROTOBUF_CONSTEXPR AddColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumn(const AddColumn& from);
  AddColumn(AddColumn&& from) noexcept
    : AddColumn() {
    *this = ::std::move(from);
  }

  inline AddColumn& operator=(const AddColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumn& operator=(AddColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumn* internal_default_instance() {
    return reinterpret_cast<const AddColumn*>(
               &_AddColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AddColumn& a, AddColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumn& from) {
    AddColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumn";
  }
  protected:
  explicit AddColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefFieldNumber = 1,
    kLocationFieldNumber = 3,
  };
  // .greptime.v1.ColumnDef column_def = 1;
  bool has_column_def() const;
  private:
  bool _internal_has_column_def() const;
  public:
  void clear_column_def();
  const ::greptime::v1::ColumnDef& column_def() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDef* release_column_def();
  ::greptime::v1::ColumnDef* mutable_column_def();
  void set_allocated_column_def(::greptime::v1::ColumnDef* column_def);
  private:
  const ::greptime::v1::ColumnDef& _internal_column_def() const;
  ::greptime::v1::ColumnDef* _internal_mutable_column_def();
  public:
  void unsafe_arena_set_allocated_column_def(
      ::greptime::v1::ColumnDef* column_def);
  ::greptime::v1::ColumnDef* unsafe_arena_release_column_def();

  // .greptime.v1.AddColumnLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::greptime::v1::AddColumnLocation& location() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumnLocation* release_location();
  ::greptime::v1::AddColumnLocation* mutable_location();
  void set_allocated_location(::greptime::v1::AddColumnLocation* location);
  private:
  const ::greptime::v1::AddColumnLocation& _internal_location() const;
  ::greptime::v1::AddColumnLocation* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::greptime::v1::AddColumnLocation* location);
  ::greptime::v1::AddColumnLocation* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::ColumnDef* column_def_;
    ::greptime::v1::AddColumnLocation* location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropColumn) */ {
 public:
  inline DropColumn() : DropColumn(nullptr) {}
  ~DropColumn() override;
  explicit PROTOBUF_CONSTEXPR DropColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumn(const DropColumn& from);
  DropColumn(DropColumn&& from) noexcept
    : DropColumn() {
    *this = ::std::move(from);
  }

  inline DropColumn& operator=(const DropColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumn& operator=(DropColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumn* internal_default_instance() {
    return reinterpret_cast<const DropColumn*>(
               &_DropColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DropColumn& a, DropColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumn& from) {
    DropColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropColumn";
  }
  protected:
  explicit DropColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class TableId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TableId) */ {
 public:
  inline TableId() : TableId(nullptr) {}
  ~TableId() override;
  explicit PROTOBUF_CONSTEXPR TableId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableId(const TableId& from);
  TableId(TableId&& from) noexcept
    : TableId() {
    *this = ::std::move(from);
  }

  inline TableId& operator=(const TableId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableId& operator=(TableId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableId* internal_default_instance() {
    return reinterpret_cast<const TableId*>(
               &_TableId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TableId& a, TableId& b) {
    a.Swap(&b);
  }
  inline void Swap(TableId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableId& from) {
    TableId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TableId";
  }
  protected:
  explicit TableId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TableId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ColumnDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnDef) */ {
 public:
  inline ColumnDef() : ColumnDef(nullptr) {}
  ~ColumnDef() override;
  explicit PROTOBUF_CONSTEXPR ColumnDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDef(const ColumnDef& from);
  ColumnDef(ColumnDef&& from) noexcept
    : ColumnDef() {
    *this = ::std::move(from);
  }

  inline ColumnDef& operator=(const ColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDef& operator=(ColumnDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDef* internal_default_instance() {
    return reinterpret_cast<const ColumnDef*>(
               &_ColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ColumnDef& a, ColumnDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDef& from) {
    ColumnDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnDef";
  }
  protected:
  explicit ColumnDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultConstraintFieldNumber = 4,
    kDatatypeFieldNumber = 2,
    kIsNullableFieldNumber = 3,
    kSemanticTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes default_constraint = 4;
  void clear_default_constraint();
  const std::string& default_constraint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_constraint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_constraint();
  PROTOBUF_NODISCARD std::string* release_default_constraint();
  void set_allocated_default_constraint(std::string* default_constraint);
  private:
  const std::string& _internal_default_constraint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_constraint(const std::string& value);
  std::string* _internal_mutable_default_constraint();
  public:

  // .greptime.v1.ColumnDataType datatype = 2;
  void clear_datatype();
  ::greptime::v1::ColumnDataType datatype() const;
  void set_datatype(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_datatype() const;
  void _internal_set_datatype(::greptime::v1::ColumnDataType value);
  public:

  // bool is_nullable = 3;
  void clear_is_nullable();
  bool is_nullable() const;
  void set_is_nullable(bool value);
  private:
  bool _internal_is_nullable() const;
  void _internal_set_is_nullable(bool value);
  public:

  // .greptime.v1.SemanticType semantic_type = 5;
  void clear_semantic_type();
  ::greptime::v1::SemanticType semantic_type() const;
  void set_semantic_type(::greptime::v1::SemanticType value);
  private:
  ::greptime::v1::SemanticType _internal_semantic_type() const;
  void _internal_set_semantic_type(::greptime::v1::SemanticType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_constraint_;
    int datatype_;
    bool is_nullable_;
    int semantic_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumnLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumnLocation) */ {
 public:
  inline AddColumnLocation() : AddColumnLocation(nullptr) {}
  ~AddColumnLocation() override;
  explicit PROTOBUF_CONSTEXPR AddColumnLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumnLocation(const AddColumnLocation& from);
  AddColumnLocation(AddColumnLocation&& from) noexcept
    : AddColumnLocation() {
    *this = ::std::move(from);
  }

  inline AddColumnLocation& operator=(const AddColumnLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumnLocation& operator=(AddColumnLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumnLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumnLocation* internal_default_instance() {
    return reinterpret_cast<const AddColumnLocation*>(
               &_AddColumnLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AddColumnLocation& a, AddColumnLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumnLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumnLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumnLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumnLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumnLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumnLocation& from) {
    AddColumnLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumnLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumnLocation";
  }
  protected:
  explicit AddColumnLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AddColumnLocation_LocationType LocationType;
  static constexpr LocationType FIRST =
    AddColumnLocation_LocationType_FIRST;
  static constexpr LocationType AFTER =
    AddColumnLocation_LocationType_AFTER;
  static inline bool LocationType_IsValid(int value) {
    return AddColumnLocation_LocationType_IsValid(value);
  }
  static constexpr LocationType LocationType_MIN =
    AddColumnLocation_LocationType_LocationType_MIN;
  static constexpr LocationType LocationType_MAX =
    AddColumnLocation_LocationType_LocationType_MAX;
  static constexpr int LocationType_ARRAYSIZE =
    AddColumnLocation_LocationType_LocationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocationType_descriptor() {
    return AddColumnLocation_LocationType_descriptor();
  }
  template<typename T>
  static inline const std::string& LocationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocationType_Name.");
    return AddColumnLocation_LocationType_Name(enum_t_value);
  }
  static inline bool LocationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocationType* value) {
    return AddColumnLocation_LocationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAfterColumnNameFieldNumber = 2,
    kLocationTypeFieldNumber = 1,
  };
  // string after_column_name = 2;
  void clear_after_column_name();
  const std::string& after_column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_after_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_after_column_name();
  PROTOBUF_NODISCARD std::string* release_after_column_name();
  void set_allocated_after_column_name(std::string* after_column_name);
  private:
  const std::string& _internal_after_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_after_column_name(const std::string& value);
  std::string* _internal_mutable_after_column_name();
  public:

  // .greptime.v1.AddColumnLocation.LocationType location_type = 1;
  void clear_location_type();
  ::greptime::v1::AddColumnLocation_LocationType location_type() const;
  void set_location_type(::greptime::v1::AddColumnLocation_LocationType value);
  private:
  ::greptime::v1::AddColumnLocation_LocationType _internal_location_type() const;
  void _internal_set_location_type(::greptime::v1::AddColumnLocation_LocationType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumnLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr after_column_name_;
    int location_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DdlRequest

// .greptime.v1.CreateDatabaseExpr create_database = 1;
inline bool DdlRequest::_internal_has_create_database() const {
  return expr_case() == kCreateDatabase;
}
inline bool DdlRequest::has_create_database() const {
  return _internal_has_create_database();
}
inline void DdlRequest::set_has_create_database() {
  _impl_._oneof_case_[0] = kCreateDatabase;
}
inline void DdlRequest::clear_create_database() {
  if (_internal_has_create_database()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_database_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::release_create_database() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_database)
  if (_internal_has_create_database()) {
    clear_has_expr();
    ::greptime::v1::CreateDatabaseExpr* temp = _impl_.expr_.create_database_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateDatabaseExpr& DdlRequest::_internal_create_database() const {
  return _internal_has_create_database()
      ? *_impl_.expr_.create_database_
      : reinterpret_cast< ::greptime::v1::CreateDatabaseExpr&>(::greptime::v1::_CreateDatabaseExpr_default_instance_);
}
inline const ::greptime::v1::CreateDatabaseExpr& DdlRequest::create_database() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_database)
  return _internal_create_database();
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::unsafe_arena_release_create_database() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_database)
  if (_internal_has_create_database()) {
    clear_has_expr();
    ::greptime::v1::CreateDatabaseExpr* temp = _impl_.expr_.create_database_;
    _impl_.expr_.create_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_database(::greptime::v1::CreateDatabaseExpr* create_database) {
  clear_expr();
  if (create_database) {
    set_has_create_database();
    _impl_.expr_.create_database_ = create_database;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_database)
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::_internal_mutable_create_database() {
  if (!_internal_has_create_database()) {
    clear_expr();
    set_has_create_database();
    _impl_.expr_.create_database_ = CreateMaybeMessage< ::greptime::v1::CreateDatabaseExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_database_;
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::mutable_create_database() {
  ::greptime::v1::CreateDatabaseExpr* _msg = _internal_mutable_create_database();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_database)
  return _msg;
}

// .greptime.v1.CreateTableExpr create_table = 2;
inline bool DdlRequest::_internal_has_create_table() const {
  return expr_case() == kCreateTable;
}
inline bool DdlRequest::has_create_table() const {
  return _internal_has_create_table();
}
inline void DdlRequest::set_has_create_table() {
  _impl_._oneof_case_[0] = kCreateTable;
}
inline void DdlRequest::clear_create_table() {
  if (_internal_has_create_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::release_create_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_table)
  if (_internal_has_create_table()) {
    clear_has_expr();
    ::greptime::v1::CreateTableExpr* temp = _impl_.expr_.create_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateTableExpr& DdlRequest::_internal_create_table() const {
  return _internal_has_create_table()
      ? *_impl_.expr_.create_table_
      : reinterpret_cast< ::greptime::v1::CreateTableExpr&>(::greptime::v1::_CreateTableExpr_default_instance_);
}
inline const ::greptime::v1::CreateTableExpr& DdlRequest::create_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_table)
  return _internal_create_table();
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::unsafe_arena_release_create_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_table)
  if (_internal_has_create_table()) {
    clear_has_expr();
    ::greptime::v1::CreateTableExpr* temp = _impl_.expr_.create_table_;
    _impl_.expr_.create_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_table(::greptime::v1::CreateTableExpr* create_table) {
  clear_expr();
  if (create_table) {
    set_has_create_table();
    _impl_.expr_.create_table_ = create_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_table)
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::_internal_mutable_create_table() {
  if (!_internal_has_create_table()) {
    clear_expr();
    set_has_create_table();
    _impl_.expr_.create_table_ = CreateMaybeMessage< ::greptime::v1::CreateTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_table_;
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::mutable_create_table() {
  ::greptime::v1::CreateTableExpr* _msg = _internal_mutable_create_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_table)
  return _msg;
}

// .greptime.v1.AlterExpr alter = 3;
inline bool DdlRequest::_internal_has_alter() const {
  return expr_case() == kAlter;
}
inline bool DdlRequest::has_alter() const {
  return _internal_has_alter();
}
inline void DdlRequest::set_has_alter() {
  _impl_._oneof_case_[0] = kAlter;
}
inline void DdlRequest::clear_alter() {
  if (_internal_has_alter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.alter_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::AlterExpr* DdlRequest::release_alter() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.alter)
  if (_internal_has_alter()) {
    clear_has_expr();
    ::greptime::v1::AlterExpr* temp = _impl_.expr_.alter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AlterExpr& DdlRequest::_internal_alter() const {
  return _internal_has_alter()
      ? *_impl_.expr_.alter_
      : reinterpret_cast< ::greptime::v1::AlterExpr&>(::greptime::v1::_AlterExpr_default_instance_);
}
inline const ::greptime::v1::AlterExpr& DdlRequest::alter() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.alter)
  return _internal_alter();
}
inline ::greptime::v1::AlterExpr* DdlRequest::unsafe_arena_release_alter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.alter)
  if (_internal_has_alter()) {
    clear_has_expr();
    ::greptime::v1::AlterExpr* temp = _impl_.expr_.alter_;
    _impl_.expr_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_alter(::greptime::v1::AlterExpr* alter) {
  clear_expr();
  if (alter) {
    set_has_alter();
    _impl_.expr_.alter_ = alter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.alter)
}
inline ::greptime::v1::AlterExpr* DdlRequest::_internal_mutable_alter() {
  if (!_internal_has_alter()) {
    clear_expr();
    set_has_alter();
    _impl_.expr_.alter_ = CreateMaybeMessage< ::greptime::v1::AlterExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.alter_;
}
inline ::greptime::v1::AlterExpr* DdlRequest::mutable_alter() {
  ::greptime::v1::AlterExpr* _msg = _internal_mutable_alter();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.alter)
  return _msg;
}

// .greptime.v1.DropTableExpr drop_table = 4;
inline bool DdlRequest::_internal_has_drop_table() const {
  return expr_case() == kDropTable;
}
inline bool DdlRequest::has_drop_table() const {
  return _internal_has_drop_table();
}
inline void DdlRequest::set_has_drop_table() {
  _impl_._oneof_case_[0] = kDropTable;
}
inline void DdlRequest::clear_drop_table() {
  if (_internal_has_drop_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropTableExpr* DdlRequest::release_drop_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_table)
  if (_internal_has_drop_table()) {
    clear_has_expr();
    ::greptime::v1::DropTableExpr* temp = _impl_.expr_.drop_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropTableExpr& DdlRequest::_internal_drop_table() const {
  return _internal_has_drop_table()
      ? *_impl_.expr_.drop_table_
      : reinterpret_cast< ::greptime::v1::DropTableExpr&>(::greptime::v1::_DropTableExpr_default_instance_);
}
inline const ::greptime::v1::DropTableExpr& DdlRequest::drop_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_table)
  return _internal_drop_table();
}
inline ::greptime::v1::DropTableExpr* DdlRequest::unsafe_arena_release_drop_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_table)
  if (_internal_has_drop_table()) {
    clear_has_expr();
    ::greptime::v1::DropTableExpr* temp = _impl_.expr_.drop_table_;
    _impl_.expr_.drop_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_table(::greptime::v1::DropTableExpr* drop_table) {
  clear_expr();
  if (drop_table) {
    set_has_drop_table();
    _impl_.expr_.drop_table_ = drop_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_table)
}
inline ::greptime::v1::DropTableExpr* DdlRequest::_internal_mutable_drop_table() {
  if (!_internal_has_drop_table()) {
    clear_expr();
    set_has_drop_table();
    _impl_.expr_.drop_table_ = CreateMaybeMessage< ::greptime::v1::DropTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_table_;
}
inline ::greptime::v1::DropTableExpr* DdlRequest::mutable_drop_table() {
  ::greptime::v1::DropTableExpr* _msg = _internal_mutable_drop_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_table)
  return _msg;
}

// .greptime.v1.TruncateTableExpr truncate_table = 7;
inline bool DdlRequest::_internal_has_truncate_table() const {
  return expr_case() == kTruncateTable;
}
inline bool DdlRequest::has_truncate_table() const {
  return _internal_has_truncate_table();
}
inline void DdlRequest::set_has_truncate_table() {
  _impl_._oneof_case_[0] = kTruncateTable;
}
inline void DdlRequest::clear_truncate_table() {
  if (_internal_has_truncate_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.truncate_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::release_truncate_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.truncate_table)
  if (_internal_has_truncate_table()) {
    clear_has_expr();
    ::greptime::v1::TruncateTableExpr* temp = _impl_.expr_.truncate_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.truncate_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::TruncateTableExpr& DdlRequest::_internal_truncate_table() const {
  return _internal_has_truncate_table()
      ? *_impl_.expr_.truncate_table_
      : reinterpret_cast< ::greptime::v1::TruncateTableExpr&>(::greptime::v1::_TruncateTableExpr_default_instance_);
}
inline const ::greptime::v1::TruncateTableExpr& DdlRequest::truncate_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.truncate_table)
  return _internal_truncate_table();
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::unsafe_arena_release_truncate_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.truncate_table)
  if (_internal_has_truncate_table()) {
    clear_has_expr();
    ::greptime::v1::TruncateTableExpr* temp = _impl_.expr_.truncate_table_;
    _impl_.expr_.truncate_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_truncate_table(::greptime::v1::TruncateTableExpr* truncate_table) {
  clear_expr();
  if (truncate_table) {
    set_has_truncate_table();
    _impl_.expr_.truncate_table_ = truncate_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.truncate_table)
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::_internal_mutable_truncate_table() {
  if (!_internal_has_truncate_table()) {
    clear_expr();
    set_has_truncate_table();
    _impl_.expr_.truncate_table_ = CreateMaybeMessage< ::greptime::v1::TruncateTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.truncate_table_;
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::mutable_truncate_table() {
  ::greptime::v1::TruncateTableExpr* _msg = _internal_mutable_truncate_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.truncate_table)
  return _msg;
}

inline bool DdlRequest::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void DdlRequest::clear_has_expr() {
  _impl_._oneof_case_[0] = EXPR_NOT_SET;
}
inline DdlRequest::ExprCase DdlRequest::expr_case() const {
  return DdlRequest::ExprCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateTableExpr

// string catalog_name = 1;
inline void CreateTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.catalog_name)
}
inline std::string* CreateTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.catalog_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.schema_name)
}
inline std::string* CreateTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.schema_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.schema_name)
}

// string table_name = 3;
inline void CreateTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.table_name)
}
inline std::string* CreateTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.table_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void CreateTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void CreateTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.table_name)
}

// string desc = 4;
inline void CreateTableExpr::clear_desc() {
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::desc() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_desc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.desc)
}
inline std::string* CreateTableExpr::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.desc)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_desc() const {
  return _impl_.desc_.Get();
}
inline void CreateTableExpr::_internal_set_desc(const std::string& value) {
  
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_desc() {
  
  return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_desc() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.desc)
  return _impl_.desc_.Release();
}
inline void CreateTableExpr::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_.IsDefault()) {
    _impl_.desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.desc)
}

// repeated .greptime.v1.ColumnDef column_defs = 5;
inline int CreateTableExpr::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int CreateTableExpr::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void CreateTableExpr::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >*
CreateTableExpr::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.column_defs)
  return &_impl_.column_defs_;
}
inline const ::greptime::v1::ColumnDef& CreateTableExpr::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::greptime::v1::ColumnDef& CreateTableExpr::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.column_defs)
  return _internal_column_defs(index);
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::add_column_defs() {
  ::greptime::v1::ColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >&
CreateTableExpr::column_defs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.column_defs)
  return _impl_.column_defs_;
}

// string time_index = 6;
inline void CreateTableExpr::clear_time_index() {
  _impl_.time_index_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::time_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.time_index)
  return _internal_time_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_time_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.time_index)
}
inline std::string* CreateTableExpr::mutable_time_index() {
  std::string* _s = _internal_mutable_time_index();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.time_index)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_time_index() const {
  return _impl_.time_index_.Get();
}
inline void CreateTableExpr::_internal_set_time_index(const std::string& value) {
  
  _impl_.time_index_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_time_index() {
  
  return _impl_.time_index_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_time_index() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.time_index)
  return _impl_.time_index_.Release();
}
inline void CreateTableExpr::set_allocated_time_index(std::string* time_index) {
  if (time_index != nullptr) {
    
  } else {
    
  }
  _impl_.time_index_.SetAllocated(time_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_index_.IsDefault()) {
    _impl_.time_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.time_index)
}

// repeated string primary_keys = 7;
inline int CreateTableExpr::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int CreateTableExpr::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void CreateTableExpr::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* CreateTableExpr::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateTableExpr.primary_keys)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& CreateTableExpr::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* CreateTableExpr::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void CreateTableExpr::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateTableExpr.primary_keys)
}
inline std::string* CreateTableExpr::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void CreateTableExpr::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateTableExpr.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateTableExpr::primary_keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateTableExpr::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.primary_keys)
  return &_impl_.primary_keys_;
}

// bool create_if_not_exists = 8;
inline void CreateTableExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateTableExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateTableExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateTableExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateTableExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.create_if_not_exists)
}

// map<string, string> table_options = 9;
inline int CreateTableExpr::_internal_table_options_size() const {
  return _impl_.table_options_.size();
}
inline int CreateTableExpr::table_options_size() const {
  return _internal_table_options_size();
}
inline void CreateTableExpr::clear_table_options() {
  _impl_.table_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableExpr::_internal_table_options() const {
  return _impl_.table_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableExpr::table_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateTableExpr.table_options)
  return _internal_table_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableExpr::_internal_mutable_table_options() {
  return _impl_.table_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableExpr::mutable_table_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateTableExpr.table_options)
  return _internal_mutable_table_options();
}

// .greptime.v1.TableId table_id = 10;
inline bool CreateTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool CreateTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void CreateTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& CreateTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& CreateTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.table_id)
  return _internal_table_id();
}
inline void CreateTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateTableExpr.table_id)
}
inline ::greptime::v1::TableId* CreateTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* CreateTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* CreateTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* CreateTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.table_id)
  return _msg;
}
inline void CreateTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.table_id)
}

// repeated uint32 region_numbers = 11;
inline int CreateTableExpr::_internal_region_numbers_size() const {
  return _impl_.region_numbers_.size();
}
inline int CreateTableExpr::region_numbers_size() const {
  return _internal_region_numbers_size();
}
inline void CreateTableExpr::clear_region_numbers() {
  _impl_.region_numbers_.Clear();
}
inline uint32_t CreateTableExpr::_internal_region_numbers(int index) const {
  return _impl_.region_numbers_.Get(index);
}
inline uint32_t CreateTableExpr::region_numbers(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.region_numbers)
  return _internal_region_numbers(index);
}
inline void CreateTableExpr::set_region_numbers(int index, uint32_t value) {
  _impl_.region_numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.region_numbers)
}
inline void CreateTableExpr::_internal_add_region_numbers(uint32_t value) {
  _impl_.region_numbers_.Add(value);
}
inline void CreateTableExpr::add_region_numbers(uint32_t value) {
  _internal_add_region_numbers(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.region_numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CreateTableExpr::_internal_region_numbers() const {
  return _impl_.region_numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CreateTableExpr::region_numbers() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.region_numbers)
  return _internal_region_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CreateTableExpr::_internal_mutable_region_numbers() {
  return &_impl_.region_numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CreateTableExpr::mutable_region_numbers() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.region_numbers)
  return _internal_mutable_region_numbers();
}

// string engine = 12;
inline void CreateTableExpr::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.engine)
}
inline std::string* CreateTableExpr::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.engine)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void CreateTableExpr::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.engine)
  return _impl_.engine_.Release();
}
inline void CreateTableExpr::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.engine)
}

// -------------------------------------------------------------------

// AlterExpr

// string catalog_name = 1;
inline void AlterExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& AlterExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterExpr.catalog_name)
}
inline std::string* AlterExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.catalog_name)
  return _s;
}
inline const std::string& AlterExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void AlterExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void AlterExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterExpr.catalog_name)
}

// string schema_name = 2;
inline void AlterExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& AlterExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterExpr.schema_name)
}
inline std::string* AlterExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.schema_name)
  return _s;
}
inline const std::string& AlterExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void AlterExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void AlterExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterExpr.schema_name)
}

// string table_name = 3;
inline void AlterExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& AlterExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterExpr.table_name)
}
inline std::string* AlterExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.table_name)
  return _s;
}
inline const std::string& AlterExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void AlterExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void AlterExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterExpr.table_name)
}

// .greptime.v1.AddColumns add_columns = 4;
inline bool AlterExpr::_internal_has_add_columns() const {
  return kind_case() == kAddColumns;
}
inline bool AlterExpr::has_add_columns() const {
  return _internal_has_add_columns();
}
inline void AlterExpr::set_has_add_columns() {
  _impl_._oneof_case_[0] = kAddColumns;
}
inline void AlterExpr::clear_add_columns() {
  if (_internal_has_add_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.add_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::AddColumns* AlterExpr::release_add_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::AddColumns* temp = _impl_.kind_.add_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AddColumns& AlterExpr::_internal_add_columns() const {
  return _internal_has_add_columns()
      ? *_impl_.kind_.add_columns_
      : reinterpret_cast< ::greptime::v1::AddColumns&>(::greptime::v1::_AddColumns_default_instance_);
}
inline const ::greptime::v1::AddColumns& AlterExpr::add_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.add_columns)
  return _internal_add_columns();
}
inline ::greptime::v1::AddColumns* AlterExpr::unsafe_arena_release_add_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::AddColumns* temp = _impl_.kind_.add_columns_;
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_add_columns(::greptime::v1::AddColumns* add_columns) {
  clear_kind();
  if (add_columns) {
    set_has_add_columns();
    _impl_.kind_.add_columns_ = add_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.add_columns)
}
inline ::greptime::v1::AddColumns* AlterExpr::_internal_mutable_add_columns() {
  if (!_internal_has_add_columns()) {
    clear_kind();
    set_has_add_columns();
    _impl_.kind_.add_columns_ = CreateMaybeMessage< ::greptime::v1::AddColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.add_columns_;
}
inline ::greptime::v1::AddColumns* AlterExpr::mutable_add_columns() {
  ::greptime::v1::AddColumns* _msg = _internal_mutable_add_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.add_columns)
  return _msg;
}

// .greptime.v1.DropColumns drop_columns = 5;
inline bool AlterExpr::_internal_has_drop_columns() const {
  return kind_case() == kDropColumns;
}
inline bool AlterExpr::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void AlterExpr::set_has_drop_columns() {
  _impl_._oneof_case_[0] = kDropColumns;
}
inline void AlterExpr::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.drop_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::DropColumns* AlterExpr::release_drop_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::DropColumns* temp = _impl_.kind_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropColumns& AlterExpr::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *_impl_.kind_.drop_columns_
      : reinterpret_cast< ::greptime::v1::DropColumns&>(::greptime::v1::_DropColumns_default_instance_);
}
inline const ::greptime::v1::DropColumns& AlterExpr::drop_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.drop_columns)
  return _internal_drop_columns();
}
inline ::greptime::v1::DropColumns* AlterExpr::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::DropColumns* temp = _impl_.kind_.drop_columns_;
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_drop_columns(::greptime::v1::DropColumns* drop_columns) {
  clear_kind();
  if (drop_columns) {
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.drop_columns)
}
inline ::greptime::v1::DropColumns* AlterExpr::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_kind();
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = CreateMaybeMessage< ::greptime::v1::DropColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.drop_columns_;
}
inline ::greptime::v1::DropColumns* AlterExpr::mutable_drop_columns() {
  ::greptime::v1::DropColumns* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.drop_columns)
  return _msg;
}

// .greptime.v1.RenameTable rename_table = 6;
inline bool AlterExpr::_internal_has_rename_table() const {
  return kind_case() == kRenameTable;
}
inline bool AlterExpr::has_rename_table() const {
  return _internal_has_rename_table();
}
inline void AlterExpr::set_has_rename_table() {
  _impl_._oneof_case_[0] = kRenameTable;
}
inline void AlterExpr::clear_rename_table() {
  if (_internal_has_rename_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.rename_table_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::RenameTable* AlterExpr::release_rename_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.rename_table)
  if (_internal_has_rename_table()) {
    clear_has_kind();
    ::greptime::v1::RenameTable* temp = _impl_.kind_.rename_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.rename_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::RenameTable& AlterExpr::_internal_rename_table() const {
  return _internal_has_rename_table()
      ? *_impl_.kind_.rename_table_
      : reinterpret_cast< ::greptime::v1::RenameTable&>(::greptime::v1::_RenameTable_default_instance_);
}
inline const ::greptime::v1::RenameTable& AlterExpr::rename_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.rename_table)
  return _internal_rename_table();
}
inline ::greptime::v1::RenameTable* AlterExpr::unsafe_arena_release_rename_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.rename_table)
  if (_internal_has_rename_table()) {
    clear_has_kind();
    ::greptime::v1::RenameTable* temp = _impl_.kind_.rename_table_;
    _impl_.kind_.rename_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_rename_table(::greptime::v1::RenameTable* rename_table) {
  clear_kind();
  if (rename_table) {
    set_has_rename_table();
    _impl_.kind_.rename_table_ = rename_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.rename_table)
}
inline ::greptime::v1::RenameTable* AlterExpr::_internal_mutable_rename_table() {
  if (!_internal_has_rename_table()) {
    clear_kind();
    set_has_rename_table();
    _impl_.kind_.rename_table_ = CreateMaybeMessage< ::greptime::v1::RenameTable >(GetArenaForAllocation());
  }
  return _impl_.kind_.rename_table_;
}
inline ::greptime::v1::RenameTable* AlterExpr::mutable_rename_table() {
  ::greptime::v1::RenameTable* _msg = _internal_mutable_rename_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.rename_table)
  return _msg;
}

inline bool AlterExpr::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AlterExpr::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline AlterExpr::KindCase AlterExpr::kind_case() const {
  return AlterExpr::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DropTableExpr

// string catalog_name = 1;
inline void DropTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.catalog_name)
}
inline std::string* DropTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.catalog_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.catalog_name)
}

// string schema_name = 2;
inline void DropTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.schema_name)
}
inline std::string* DropTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.schema_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.schema_name)
}

// string table_name = 3;
inline void DropTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.table_name)
}
inline std::string* DropTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.table_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DropTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void DropTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.table_name)
}

// .greptime.v1.TableId table_id = 4;
inline bool DropTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool DropTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void DropTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& DropTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& DropTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.table_id)
  return _internal_table_id();
}
inline void DropTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropTableExpr.table_id)
}
inline ::greptime::v1::TableId* DropTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* DropTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* DropTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* DropTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.table_id)
  return _msg;
}
inline void DropTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.table_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateDatabaseExpr

// string database_name = 1;
inline void CreateDatabaseExpr::clear_database_name() {
  _impl_.database_name_.ClearToEmpty();
}
inline const std::string& CreateDatabaseExpr::database_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseExpr::set_database_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.database_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.database_name)
}
inline std::string* CreateDatabaseExpr::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateDatabaseExpr.database_name)
  return _s;
}
inline const std::string& CreateDatabaseExpr::_internal_database_name() const {
  return _impl_.database_name_.Get();
}
inline void CreateDatabaseExpr::_internal_set_database_name(const std::string& value) {
  
  _impl_.database_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::_internal_mutable_database_name() {
  
  return _impl_.database_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::release_database_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateDatabaseExpr.database_name)
  return _impl_.database_name_.Release();
}
inline void CreateDatabaseExpr::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    
  } else {
    
  }
  _impl_.database_name_.SetAllocated(database_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.database_name_.IsDefault()) {
    _impl_.database_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateDatabaseExpr.database_name)
}

// bool create_if_not_exists = 2;
inline void CreateDatabaseExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateDatabaseExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateDatabaseExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateDatabaseExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateDatabaseExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.create_if_not_exists)
}

// map<string, string> options = 3;
inline int CreateDatabaseExpr::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int CreateDatabaseExpr::options_size() const {
  return _internal_options_size();
}
inline void CreateDatabaseExpr::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateDatabaseExpr::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateDatabaseExpr::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateDatabaseExpr.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateDatabaseExpr::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateDatabaseExpr::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateDatabaseExpr.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// TruncateTableExpr

// string catalog_name = 1;
inline void TruncateTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.catalog_name)
}
inline std::string* TruncateTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.catalog_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void TruncateTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void TruncateTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.catalog_name)
}

// string schema_name = 2;
inline void TruncateTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.schema_name)
}
inline std::string* TruncateTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.schema_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TruncateTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void TruncateTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.schema_name)
}

// string table_name = 3;
inline void TruncateTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.table_name)
}
inline std::string* TruncateTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.table_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TruncateTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void TruncateTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.table_name)
}

// .greptime.v1.TableId table_id = 4;
inline bool TruncateTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool TruncateTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void TruncateTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& TruncateTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& TruncateTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.table_id)
  return _internal_table_id();
}
inline void TruncateTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.TruncateTableExpr.table_id)
}
inline ::greptime::v1::TableId* TruncateTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* TruncateTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* TruncateTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* TruncateTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.table_id)
  return _msg;
}
inline void TruncateTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.table_id)
}

// -------------------------------------------------------------------

// AddColumns

// repeated .greptime.v1.AddColumn add_columns = 1;
inline int AddColumns::_internal_add_columns_size() const {
  return _impl_.add_columns_.size();
}
inline int AddColumns::add_columns_size() const {
  return _internal_add_columns_size();
}
inline void AddColumns::clear_add_columns() {
  _impl_.add_columns_.Clear();
}
inline ::greptime::v1::AddColumn* AddColumns::mutable_add_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumns.add_columns)
  return _impl_.add_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >*
AddColumns::mutable_add_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.AddColumns.add_columns)
  return &_impl_.add_columns_;
}
inline const ::greptime::v1::AddColumn& AddColumns::_internal_add_columns(int index) const {
  return _impl_.add_columns_.Get(index);
}
inline const ::greptime::v1::AddColumn& AddColumns::add_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumns.add_columns)
  return _internal_add_columns(index);
}
inline ::greptime::v1::AddColumn* AddColumns::_internal_add_add_columns() {
  return _impl_.add_columns_.Add();
}
inline ::greptime::v1::AddColumn* AddColumns::add_add_columns() {
  ::greptime::v1::AddColumn* _add = _internal_add_add_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.AddColumns.add_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >&
AddColumns::add_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.AddColumns.add_columns)
  return _impl_.add_columns_;
}

// -------------------------------------------------------------------

// DropColumns

// repeated .greptime.v1.DropColumn drop_columns = 1;
inline int DropColumns::_internal_drop_columns_size() const {
  return _impl_.drop_columns_.size();
}
inline int DropColumns::drop_columns_size() const {
  return _internal_drop_columns_size();
}
inline void DropColumns::clear_drop_columns() {
  _impl_.drop_columns_.Clear();
}
inline ::greptime::v1::DropColumn* DropColumns::mutable_drop_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropColumns.drop_columns)
  return _impl_.drop_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >*
DropColumns::mutable_drop_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.DropColumns.drop_columns)
  return &_impl_.drop_columns_;
}
inline const ::greptime::v1::DropColumn& DropColumns::_internal_drop_columns(int index) const {
  return _impl_.drop_columns_.Get(index);
}
inline const ::greptime::v1::DropColumn& DropColumns::drop_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropColumns.drop_columns)
  return _internal_drop_columns(index);
}
inline ::greptime::v1::DropColumn* DropColumns::_internal_add_drop_columns() {
  return _impl_.drop_columns_.Add();
}
inline ::greptime::v1::DropColumn* DropColumns::add_drop_columns() {
  ::greptime::v1::DropColumn* _add = _internal_add_drop_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.DropColumns.drop_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >&
DropColumns::drop_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.DropColumns.drop_columns)
  return _impl_.drop_columns_;
}

// -------------------------------------------------------------------

// RenameTable

// string new_table_name = 1;
inline void RenameTable::clear_new_table_name() {
  _impl_.new_table_name_.ClearToEmpty();
}
inline const std::string& RenameTable::new_table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RenameTable.new_table_name)
  return _internal_new_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameTable::set_new_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RenameTable.new_table_name)
}
inline std::string* RenameTable::mutable_new_table_name() {
  std::string* _s = _internal_mutable_new_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RenameTable.new_table_name)
  return _s;
}
inline const std::string& RenameTable::_internal_new_table_name() const {
  return _impl_.new_table_name_.Get();
}
inline void RenameTable::_internal_set_new_table_name(const std::string& value) {
  
  _impl_.new_table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameTable::_internal_mutable_new_table_name() {
  
  return _impl_.new_table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameTable::release_new_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.RenameTable.new_table_name)
  return _impl_.new_table_name_.Release();
}
inline void RenameTable::set_allocated_new_table_name(std::string* new_table_name) {
  if (new_table_name != nullptr) {
    
  } else {
    
  }
  _impl_.new_table_name_.SetAllocated(new_table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_table_name_.IsDefault()) {
    _impl_.new_table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RenameTable.new_table_name)
}

// -------------------------------------------------------------------

// AddColumn

// .greptime.v1.ColumnDef column_def = 1;
inline bool AddColumn::_internal_has_column_def() const {
  return this != internal_default_instance() && _impl_.column_def_ != nullptr;
}
inline bool AddColumn::has_column_def() const {
  return _internal_has_column_def();
}
inline void AddColumn::clear_column_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_def_ != nullptr) {
    delete _impl_.column_def_;
  }
  _impl_.column_def_ = nullptr;
}
inline const ::greptime::v1::ColumnDef& AddColumn::_internal_column_def() const {
  const ::greptime::v1::ColumnDef* p = _impl_.column_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDef&>(
      ::greptime::v1::_ColumnDef_default_instance_);
}
inline const ::greptime::v1::ColumnDef& AddColumn::column_def() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.column_def)
  return _internal_column_def();
}
inline void AddColumn::unsafe_arena_set_allocated_column_def(
    ::greptime::v1::ColumnDef* column_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  _impl_.column_def_ = column_def;
  if (column_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AddColumn.column_def)
}
inline ::greptime::v1::ColumnDef* AddColumn::release_column_def() {
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDef* AddColumn::unsafe_arena_release_column_def() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumn.column_def)
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDef* AddColumn::_internal_mutable_column_def() {
  
  if (_impl_.column_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDef>(GetArenaForAllocation());
    _impl_.column_def_ = p;
  }
  return _impl_.column_def_;
}
inline ::greptime::v1::ColumnDef* AddColumn::mutable_column_def() {
  ::greptime::v1::ColumnDef* _msg = _internal_mutable_column_def();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumn.column_def)
  return _msg;
}
inline void AddColumn::set_allocated_column_def(::greptime::v1::ColumnDef* column_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_def_;
  }
  if (column_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_def);
    if (message_arena != submessage_arena) {
      column_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_def_ = column_def;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumn.column_def)
}

// .greptime.v1.AddColumnLocation location = 3;
inline bool AddColumn::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AddColumn::has_location() const {
  return _internal_has_location();
}
inline void AddColumn::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::_internal_location() const {
  const ::greptime::v1::AddColumnLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AddColumnLocation&>(
      ::greptime::v1::_AddColumnLocation_default_instance_);
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::location() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.location)
  return _internal_location();
}
inline void AddColumn::unsafe_arena_set_allocated_location(
    ::greptime::v1::AddColumnLocation* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AddColumn.location)
}
inline ::greptime::v1::AddColumnLocation* AddColumn::release_location() {
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumn.location)
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AddColumnLocation>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::mutable_location() {
  ::greptime::v1::AddColumnLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumn.location)
  return _msg;
}
inline void AddColumn::set_allocated_location(::greptime::v1::AddColumnLocation* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumn.location)
}

// -------------------------------------------------------------------

// DropColumn

// string name = 1;
inline void DropColumn::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DropColumn::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropColumn.name)
}
inline std::string* DropColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropColumn.name)
  return _s;
}
inline const std::string& DropColumn::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DropColumn::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropColumn::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropColumn::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropColumn.name)
  return _impl_.name_.Release();
}
inline void DropColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropColumn.name)
}

// -------------------------------------------------------------------

// TableId

// uint32 id = 1;
inline void TableId::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t TableId::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t TableId::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableId.id)
  return _internal_id();
}
inline void TableId::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void TableId::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.TableId.id)
}

// -------------------------------------------------------------------

// ColumnDef

// string name = 1;
inline void ColumnDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDef::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.name)
}
inline std::string* ColumnDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.name)
  return _s;
}
inline const std::string& ColumnDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.name)
  return _impl_.name_.Release();
}
inline void ColumnDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.name)
}

// .greptime.v1.ColumnDataType datatype = 2;
inline void ColumnDef::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::greptime::v1::ColumnDataType ColumnDef::_internal_datatype() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.datatype_);
}
inline ::greptime::v1::ColumnDataType ColumnDef::datatype() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.datatype)
  return _internal_datatype();
}
inline void ColumnDef::_internal_set_datatype(::greptime::v1::ColumnDataType value) {
  
  _impl_.datatype_ = value;
}
inline void ColumnDef::set_datatype(::greptime::v1::ColumnDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.datatype)
}

// bool is_nullable = 3;
inline void ColumnDef::clear_is_nullable() {
  _impl_.is_nullable_ = false;
}
inline bool ColumnDef::_internal_is_nullable() const {
  return _impl_.is_nullable_;
}
inline bool ColumnDef::is_nullable() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.is_nullable)
  return _internal_is_nullable();
}
inline void ColumnDef::_internal_set_is_nullable(bool value) {
  
  _impl_.is_nullable_ = value;
}
inline void ColumnDef::set_is_nullable(bool value) {
  _internal_set_is_nullable(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.is_nullable)
}

// bytes default_constraint = 4;
inline void ColumnDef::clear_default_constraint() {
  _impl_.default_constraint_.ClearToEmpty();
}
inline const std::string& ColumnDef::default_constraint() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.default_constraint)
  return _internal_default_constraint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_default_constraint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_constraint_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.default_constraint)
}
inline std::string* ColumnDef::mutable_default_constraint() {
  std::string* _s = _internal_mutable_default_constraint();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.default_constraint)
  return _s;
}
inline const std::string& ColumnDef::_internal_default_constraint() const {
  return _impl_.default_constraint_.Get();
}
inline void ColumnDef::_internal_set_default_constraint(const std::string& value) {
  
  _impl_.default_constraint_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_default_constraint() {
  
  return _impl_.default_constraint_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_default_constraint() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.default_constraint)
  return _impl_.default_constraint_.Release();
}
inline void ColumnDef::set_allocated_default_constraint(std::string* default_constraint) {
  if (default_constraint != nullptr) {
    
  } else {
    
  }
  _impl_.default_constraint_.SetAllocated(default_constraint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_constraint_.IsDefault()) {
    _impl_.default_constraint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.default_constraint)
}

// .greptime.v1.SemanticType semantic_type = 5;
inline void ColumnDef::clear_semantic_type() {
  _impl_.semantic_type_ = 0;
}
inline ::greptime::v1::SemanticType ColumnDef::_internal_semantic_type() const {
  return static_cast< ::greptime::v1::SemanticType >(_impl_.semantic_type_);
}
inline ::greptime::v1::SemanticType ColumnDef::semantic_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.semantic_type)
  return _internal_semantic_type();
}
inline void ColumnDef::_internal_set_semantic_type(::greptime::v1::SemanticType value) {
  
  _impl_.semantic_type_ = value;
}
inline void ColumnDef::set_semantic_type(::greptime::v1::SemanticType value) {
  _internal_set_semantic_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.semantic_type)
}

// -------------------------------------------------------------------

// AddColumnLocation

// .greptime.v1.AddColumnLocation.LocationType location_type = 1;
inline void AddColumnLocation::clear_location_type() {
  _impl_.location_type_ = 0;
}
inline ::greptime::v1::AddColumnLocation_LocationType AddColumnLocation::_internal_location_type() const {
  return static_cast< ::greptime::v1::AddColumnLocation_LocationType >(_impl_.location_type_);
}
inline ::greptime::v1::AddColumnLocation_LocationType AddColumnLocation::location_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumnLocation.location_type)
  return _internal_location_type();
}
inline void AddColumnLocation::_internal_set_location_type(::greptime::v1::AddColumnLocation_LocationType value) {
  
  _impl_.location_type_ = value;
}
inline void AddColumnLocation::set_location_type(::greptime::v1::AddColumnLocation_LocationType value) {
  _internal_set_location_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumnLocation.location_type)
}

// string after_column_name = 2;
inline void AddColumnLocation::clear_after_column_name() {
  _impl_.after_column_name_.ClearToEmpty();
}
inline const std::string& AddColumnLocation::after_column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumnLocation.after_column_name)
  return _internal_after_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddColumnLocation::set_after_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.after_column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumnLocation.after_column_name)
}
inline std::string* AddColumnLocation::mutable_after_column_name() {
  std::string* _s = _internal_mutable_after_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumnLocation.after_column_name)
  return _s;
}
inline const std::string& AddColumnLocation::_internal_after_column_name() const {
  return _impl_.after_column_name_.Get();
}
inline void AddColumnLocation::_internal_set_after_column_name(const std::string& value) {
  
  _impl_.after_column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddColumnLocation::_internal_mutable_after_column_name() {
  
  return _impl_.after_column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddColumnLocation::release_after_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumnLocation.after_column_name)
  return _impl_.after_column_name_.Release();
}
inline void AddColumnLocation::set_allocated_after_column_name(std::string* after_column_name) {
  if (after_column_name != nullptr) {
    
  } else {
    
  }
  _impl_.after_column_name_.SetAllocated(after_column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.after_column_name_.IsDefault()) {
    _impl_.after_column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumnLocation.after_column_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::AddColumnLocation_LocationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::AddColumnLocation_LocationType>() {
  return ::greptime::v1::AddColumnLocation_LocationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto
