// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/ddl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fddl_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fddl_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fddl_2eproto;
namespace greptime {
namespace v1 {
class AddColumn;
struct AddColumnDefaultTypeInternal;
extern AddColumnDefaultTypeInternal _AddColumn_default_instance_;
class AddColumnLocation;
struct AddColumnLocationDefaultTypeInternal;
extern AddColumnLocationDefaultTypeInternal _AddColumnLocation_default_instance_;
class AddColumns;
struct AddColumnsDefaultTypeInternal;
extern AddColumnsDefaultTypeInternal _AddColumns_default_instance_;
class AlterDatabaseExpr;
struct AlterDatabaseExprDefaultTypeInternal;
extern AlterDatabaseExprDefaultTypeInternal _AlterDatabaseExpr_default_instance_;
class AlterTableExpr;
struct AlterTableExprDefaultTypeInternal;
extern AlterTableExprDefaultTypeInternal _AlterTableExpr_default_instance_;
class ColumnDef;
struct ColumnDefDefaultTypeInternal;
extern ColumnDefDefaultTypeInternal _ColumnDef_default_instance_;
class CreateDatabaseExpr;
struct CreateDatabaseExprDefaultTypeInternal;
extern CreateDatabaseExprDefaultTypeInternal _CreateDatabaseExpr_default_instance_;
class CreateDatabaseExpr_OptionsEntry_DoNotUse;
struct CreateDatabaseExpr_OptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateDatabaseExpr_OptionsEntry_DoNotUseDefaultTypeInternal _CreateDatabaseExpr_OptionsEntry_DoNotUse_default_instance_;
class CreateFlowExpr;
struct CreateFlowExprDefaultTypeInternal;
extern CreateFlowExprDefaultTypeInternal _CreateFlowExpr_default_instance_;
class CreateFlowExpr_FlowOptionsEntry_DoNotUse;
struct CreateFlowExpr_FlowOptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateFlowExpr_FlowOptionsEntry_DoNotUseDefaultTypeInternal _CreateFlowExpr_FlowOptionsEntry_DoNotUse_default_instance_;
class CreateTableExpr;
struct CreateTableExprDefaultTypeInternal;
extern CreateTableExprDefaultTypeInternal _CreateTableExpr_default_instance_;
class CreateTableExpr_TableOptionsEntry_DoNotUse;
struct CreateTableExpr_TableOptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateTableExpr_TableOptionsEntry_DoNotUseDefaultTypeInternal _CreateTableExpr_TableOptionsEntry_DoNotUse_default_instance_;
class CreateTriggerExpr;
struct CreateTriggerExprDefaultTypeInternal;
extern CreateTriggerExprDefaultTypeInternal _CreateTriggerExpr_default_instance_;
class CreateTriggerExpr_AnnotationsEntry_DoNotUse;
struct CreateTriggerExpr_AnnotationsEntry_DoNotUseDefaultTypeInternal;
extern CreateTriggerExpr_AnnotationsEntry_DoNotUseDefaultTypeInternal _CreateTriggerExpr_AnnotationsEntry_DoNotUse_default_instance_;
class CreateTriggerExpr_LabelsEntry_DoNotUse;
struct CreateTriggerExpr_LabelsEntry_DoNotUseDefaultTypeInternal;
extern CreateTriggerExpr_LabelsEntry_DoNotUseDefaultTypeInternal _CreateTriggerExpr_LabelsEntry_DoNotUse_default_instance_;
class CreateViewExpr;
struct CreateViewExprDefaultTypeInternal;
extern CreateViewExprDefaultTypeInternal _CreateViewExpr_default_instance_;
class DdlRequest;
struct DdlRequestDefaultTypeInternal;
extern DdlRequestDefaultTypeInternal _DdlRequest_default_instance_;
class DropColumn;
struct DropColumnDefaultTypeInternal;
extern DropColumnDefaultTypeInternal _DropColumn_default_instance_;
class DropColumns;
struct DropColumnsDefaultTypeInternal;
extern DropColumnsDefaultTypeInternal _DropColumns_default_instance_;
class DropDatabaseExpr;
struct DropDatabaseExprDefaultTypeInternal;
extern DropDatabaseExprDefaultTypeInternal _DropDatabaseExpr_default_instance_;
class DropDefault;
struct DropDefaultDefaultTypeInternal;
extern DropDefaultDefaultTypeInternal _DropDefault_default_instance_;
class DropDefaults;
struct DropDefaultsDefaultTypeInternal;
extern DropDefaultsDefaultTypeInternal _DropDefaults_default_instance_;
class DropFlowExpr;
struct DropFlowExprDefaultTypeInternal;
extern DropFlowExprDefaultTypeInternal _DropFlowExpr_default_instance_;
class DropTableExpr;
struct DropTableExprDefaultTypeInternal;
extern DropTableExprDefaultTypeInternal _DropTableExpr_default_instance_;
class DropTriggerExpr;
struct DropTriggerExprDefaultTypeInternal;
extern DropTriggerExprDefaultTypeInternal _DropTriggerExpr_default_instance_;
class DropViewExpr;
struct DropViewExprDefaultTypeInternal;
extern DropViewExprDefaultTypeInternal _DropViewExpr_default_instance_;
class FlowId;
struct FlowIdDefaultTypeInternal;
extern FlowIdDefaultTypeInternal _FlowId_default_instance_;
class ModifyColumnType;
struct ModifyColumnTypeDefaultTypeInternal;
extern ModifyColumnTypeDefaultTypeInternal _ModifyColumnType_default_instance_;
class ModifyColumnTypes;
struct ModifyColumnTypesDefaultTypeInternal;
extern ModifyColumnTypesDefaultTypeInternal _ModifyColumnTypes_default_instance_;
class NotifyChannel;
struct NotifyChannelDefaultTypeInternal;
extern NotifyChannelDefaultTypeInternal _NotifyChannel_default_instance_;
class Option;
struct OptionDefaultTypeInternal;
extern OptionDefaultTypeInternal _Option_default_instance_;
class RenameTable;
struct RenameTableDefaultTypeInternal;
extern RenameTableDefaultTypeInternal _RenameTable_default_instance_;
class SetDatabaseOptions;
struct SetDatabaseOptionsDefaultTypeInternal;
extern SetDatabaseOptionsDefaultTypeInternal _SetDatabaseOptions_default_instance_;
class SetFulltext;
struct SetFulltextDefaultTypeInternal;
extern SetFulltextDefaultTypeInternal _SetFulltext_default_instance_;
class SetIndex;
struct SetIndexDefaultTypeInternal;
extern SetIndexDefaultTypeInternal _SetIndex_default_instance_;
class SetIndexes;
struct SetIndexesDefaultTypeInternal;
extern SetIndexesDefaultTypeInternal _SetIndexes_default_instance_;
class SetInverted;
struct SetInvertedDefaultTypeInternal;
extern SetInvertedDefaultTypeInternal _SetInverted_default_instance_;
class SetSkipping;
struct SetSkippingDefaultTypeInternal;
extern SetSkippingDefaultTypeInternal _SetSkipping_default_instance_;
class SetTableOptions;
struct SetTableOptionsDefaultTypeInternal;
extern SetTableOptionsDefaultTypeInternal _SetTableOptions_default_instance_;
class TableId;
struct TableIdDefaultTypeInternal;
extern TableIdDefaultTypeInternal _TableId_default_instance_;
class TruncateTableExpr;
struct TruncateTableExprDefaultTypeInternal;
extern TruncateTableExprDefaultTypeInternal _TruncateTableExpr_default_instance_;
class UnsetDatabaseOptions;
struct UnsetDatabaseOptionsDefaultTypeInternal;
extern UnsetDatabaseOptionsDefaultTypeInternal _UnsetDatabaseOptions_default_instance_;
class UnsetFulltext;
struct UnsetFulltextDefaultTypeInternal;
extern UnsetFulltextDefaultTypeInternal _UnsetFulltext_default_instance_;
class UnsetIndex;
struct UnsetIndexDefaultTypeInternal;
extern UnsetIndexDefaultTypeInternal _UnsetIndex_default_instance_;
class UnsetIndexes;
struct UnsetIndexesDefaultTypeInternal;
extern UnsetIndexesDefaultTypeInternal _UnsetIndexes_default_instance_;
class UnsetInverted;
struct UnsetInvertedDefaultTypeInternal;
extern UnsetInvertedDefaultTypeInternal _UnsetInverted_default_instance_;
class UnsetSkipping;
struct UnsetSkippingDefaultTypeInternal;
extern UnsetSkippingDefaultTypeInternal _UnsetSkipping_default_instance_;
class UnsetTableOptions;
struct UnsetTableOptionsDefaultTypeInternal;
extern UnsetTableOptionsDefaultTypeInternal _UnsetTableOptions_default_instance_;
class WebhookOptions;
struct WebhookOptionsDefaultTypeInternal;
extern WebhookOptionsDefaultTypeInternal _WebhookOptions_default_instance_;
class WebhookOptions_OptsEntry_DoNotUse;
struct WebhookOptions_OptsEntry_DoNotUseDefaultTypeInternal;
extern WebhookOptions_OptsEntry_DoNotUseDefaultTypeInternal _WebhookOptions_OptsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::AddColumn* Arena::CreateMaybeMessage<::greptime::v1::AddColumn>(Arena*);
template<> ::greptime::v1::AddColumnLocation* Arena::CreateMaybeMessage<::greptime::v1::AddColumnLocation>(Arena*);
template<> ::greptime::v1::AddColumns* Arena::CreateMaybeMessage<::greptime::v1::AddColumns>(Arena*);
template<> ::greptime::v1::AlterDatabaseExpr* Arena::CreateMaybeMessage<::greptime::v1::AlterDatabaseExpr>(Arena*);
template<> ::greptime::v1::AlterTableExpr* Arena::CreateMaybeMessage<::greptime::v1::AlterTableExpr>(Arena*);
template<> ::greptime::v1::ColumnDef* Arena::CreateMaybeMessage<::greptime::v1::ColumnDef>(Arena*);
template<> ::greptime::v1::CreateDatabaseExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateDatabaseExpr>(Arena*);
template<> ::greptime::v1::CreateDatabaseExpr_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateDatabaseExpr_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateFlowExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateFlowExpr>(Arena*);
template<> ::greptime::v1::CreateFlowExpr_FlowOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateFlowExpr_FlowOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateTableExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateTableExpr>(Arena*);
template<> ::greptime::v1::CreateTableExpr_TableOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateTableExpr_TableOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateTriggerExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateTriggerExpr>(Arena*);
template<> ::greptime::v1::CreateTriggerExpr_AnnotationsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateTriggerExpr_AnnotationsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateTriggerExpr_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateTriggerExpr_LabelsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateViewExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateViewExpr>(Arena*);
template<> ::greptime::v1::DdlRequest* Arena::CreateMaybeMessage<::greptime::v1::DdlRequest>(Arena*);
template<> ::greptime::v1::DropColumn* Arena::CreateMaybeMessage<::greptime::v1::DropColumn>(Arena*);
template<> ::greptime::v1::DropColumns* Arena::CreateMaybeMessage<::greptime::v1::DropColumns>(Arena*);
template<> ::greptime::v1::DropDatabaseExpr* Arena::CreateMaybeMessage<::greptime::v1::DropDatabaseExpr>(Arena*);
template<> ::greptime::v1::DropDefault* Arena::CreateMaybeMessage<::greptime::v1::DropDefault>(Arena*);
template<> ::greptime::v1::DropDefaults* Arena::CreateMaybeMessage<::greptime::v1::DropDefaults>(Arena*);
template<> ::greptime::v1::DropFlowExpr* Arena::CreateMaybeMessage<::greptime::v1::DropFlowExpr>(Arena*);
template<> ::greptime::v1::DropTableExpr* Arena::CreateMaybeMessage<::greptime::v1::DropTableExpr>(Arena*);
template<> ::greptime::v1::DropTriggerExpr* Arena::CreateMaybeMessage<::greptime::v1::DropTriggerExpr>(Arena*);
template<> ::greptime::v1::DropViewExpr* Arena::CreateMaybeMessage<::greptime::v1::DropViewExpr>(Arena*);
template<> ::greptime::v1::FlowId* Arena::CreateMaybeMessage<::greptime::v1::FlowId>(Arena*);
template<> ::greptime::v1::ModifyColumnType* Arena::CreateMaybeMessage<::greptime::v1::ModifyColumnType>(Arena*);
template<> ::greptime::v1::ModifyColumnTypes* Arena::CreateMaybeMessage<::greptime::v1::ModifyColumnTypes>(Arena*);
template<> ::greptime::v1::NotifyChannel* Arena::CreateMaybeMessage<::greptime::v1::NotifyChannel>(Arena*);
template<> ::greptime::v1::Option* Arena::CreateMaybeMessage<::greptime::v1::Option>(Arena*);
template<> ::greptime::v1::RenameTable* Arena::CreateMaybeMessage<::greptime::v1::RenameTable>(Arena*);
template<> ::greptime::v1::SetDatabaseOptions* Arena::CreateMaybeMessage<::greptime::v1::SetDatabaseOptions>(Arena*);
template<> ::greptime::v1::SetFulltext* Arena::CreateMaybeMessage<::greptime::v1::SetFulltext>(Arena*);
template<> ::greptime::v1::SetIndex* Arena::CreateMaybeMessage<::greptime::v1::SetIndex>(Arena*);
template<> ::greptime::v1::SetIndexes* Arena::CreateMaybeMessage<::greptime::v1::SetIndexes>(Arena*);
template<> ::greptime::v1::SetInverted* Arena::CreateMaybeMessage<::greptime::v1::SetInverted>(Arena*);
template<> ::greptime::v1::SetSkipping* Arena::CreateMaybeMessage<::greptime::v1::SetSkipping>(Arena*);
template<> ::greptime::v1::SetTableOptions* Arena::CreateMaybeMessage<::greptime::v1::SetTableOptions>(Arena*);
template<> ::greptime::v1::TableId* Arena::CreateMaybeMessage<::greptime::v1::TableId>(Arena*);
template<> ::greptime::v1::TruncateTableExpr* Arena::CreateMaybeMessage<::greptime::v1::TruncateTableExpr>(Arena*);
template<> ::greptime::v1::UnsetDatabaseOptions* Arena::CreateMaybeMessage<::greptime::v1::UnsetDatabaseOptions>(Arena*);
template<> ::greptime::v1::UnsetFulltext* Arena::CreateMaybeMessage<::greptime::v1::UnsetFulltext>(Arena*);
template<> ::greptime::v1::UnsetIndex* Arena::CreateMaybeMessage<::greptime::v1::UnsetIndex>(Arena*);
template<> ::greptime::v1::UnsetIndexes* Arena::CreateMaybeMessage<::greptime::v1::UnsetIndexes>(Arena*);
template<> ::greptime::v1::UnsetInverted* Arena::CreateMaybeMessage<::greptime::v1::UnsetInverted>(Arena*);
template<> ::greptime::v1::UnsetSkipping* Arena::CreateMaybeMessage<::greptime::v1::UnsetSkipping>(Arena*);
template<> ::greptime::v1::UnsetTableOptions* Arena::CreateMaybeMessage<::greptime::v1::UnsetTableOptions>(Arena*);
template<> ::greptime::v1::WebhookOptions* Arena::CreateMaybeMessage<::greptime::v1::WebhookOptions>(Arena*);
template<> ::greptime::v1::WebhookOptions_OptsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::WebhookOptions_OptsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {

enum AddColumnLocation_LocationType : int {
  AddColumnLocation_LocationType_FIRST = 0,
  AddColumnLocation_LocationType_AFTER = 1,
  AddColumnLocation_LocationType_AddColumnLocation_LocationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddColumnLocation_LocationType_AddColumnLocation_LocationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddColumnLocation_LocationType_IsValid(int value);
constexpr AddColumnLocation_LocationType AddColumnLocation_LocationType_LocationType_MIN = AddColumnLocation_LocationType_FIRST;
constexpr AddColumnLocation_LocationType AddColumnLocation_LocationType_LocationType_MAX = AddColumnLocation_LocationType_AFTER;
constexpr int AddColumnLocation_LocationType_LocationType_ARRAYSIZE = AddColumnLocation_LocationType_LocationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddColumnLocation_LocationType_descriptor();
template<typename T>
inline const std::string& AddColumnLocation_LocationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddColumnLocation_LocationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddColumnLocation_LocationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddColumnLocation_LocationType_descriptor(), enum_t_value);
}
inline bool AddColumnLocation_LocationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddColumnLocation_LocationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddColumnLocation_LocationType>(
    AddColumnLocation_LocationType_descriptor(), name, value);
}
enum Analyzer : int {
  ENGLISH = 0,
  CHINESE = 1,
  Analyzer_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Analyzer_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Analyzer_IsValid(int value);
constexpr Analyzer Analyzer_MIN = ENGLISH;
constexpr Analyzer Analyzer_MAX = CHINESE;
constexpr int Analyzer_ARRAYSIZE = Analyzer_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Analyzer_descriptor();
template<typename T>
inline const std::string& Analyzer_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Analyzer>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Analyzer_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Analyzer_descriptor(), enum_t_value);
}
inline bool Analyzer_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Analyzer* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Analyzer>(
    Analyzer_descriptor(), name, value);
}
enum FulltextBackend : int {
  TANTIVY = 0,
  BLOOM = 1,
  FulltextBackend_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FulltextBackend_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FulltextBackend_IsValid(int value);
constexpr FulltextBackend FulltextBackend_MIN = TANTIVY;
constexpr FulltextBackend FulltextBackend_MAX = BLOOM;
constexpr int FulltextBackend_ARRAYSIZE = FulltextBackend_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FulltextBackend_descriptor();
template<typename T>
inline const std::string& FulltextBackend_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FulltextBackend>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FulltextBackend_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FulltextBackend_descriptor(), enum_t_value);
}
inline bool FulltextBackend_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FulltextBackend* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FulltextBackend>(
    FulltextBackend_descriptor(), name, value);
}
enum SkippingIndexType : int {
  BLOOM_FILTER = 0,
  SkippingIndexType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SkippingIndexType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SkippingIndexType_IsValid(int value);
constexpr SkippingIndexType SkippingIndexType_MIN = BLOOM_FILTER;
constexpr SkippingIndexType SkippingIndexType_MAX = BLOOM_FILTER;
constexpr int SkippingIndexType_ARRAYSIZE = SkippingIndexType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SkippingIndexType_descriptor();
template<typename T>
inline const std::string& SkippingIndexType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SkippingIndexType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SkippingIndexType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SkippingIndexType_descriptor(), enum_t_value);
}
inline bool SkippingIndexType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SkippingIndexType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SkippingIndexType>(
    SkippingIndexType_descriptor(), name, value);
}
// ===================================================================

class DdlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DdlRequest) */ {
 public:
  inline DdlRequest() : DdlRequest(nullptr) {}
  ~DdlRequest() override;
  explicit PROTOBUF_CONSTEXPR DdlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlRequest(const DdlRequest& from);
  DdlRequest(DdlRequest&& from) noexcept
    : DdlRequest() {
    *this = ::std::move(from);
  }

  inline DdlRequest& operator=(const DdlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlRequest& operator=(DdlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ExprCase {
    kCreateDatabase = 1,
    kCreateTable = 2,
    kAlterTable = 3,
    kDropTable = 4,
    kTruncateTable = 7,
    kCreateFlow = 8,
    kDropFlow = 9,
    kCreateView = 10,
    kDropView = 11,
    kAlterDatabase = 12,
    EXPR_NOT_SET = 0,
  };

  static inline const DdlRequest* internal_default_instance() {
    return reinterpret_cast<const DdlRequest*>(
               &_DdlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DdlRequest& a, DdlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DdlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DdlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DdlRequest& from) {
    DdlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DdlRequest";
  }
  protected:
  explicit DdlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateDatabaseFieldNumber = 1,
    kCreateTableFieldNumber = 2,
    kAlterTableFieldNumber = 3,
    kDropTableFieldNumber = 4,
    kTruncateTableFieldNumber = 7,
    kCreateFlowFieldNumber = 8,
    kDropFlowFieldNumber = 9,
    kCreateViewFieldNumber = 10,
    kDropViewFieldNumber = 11,
    kAlterDatabaseFieldNumber = 12,
  };
  // .greptime.v1.CreateDatabaseExpr create_database = 1;
  bool has_create_database() const;
  private:
  bool _internal_has_create_database() const;
  public:
  void clear_create_database();
  const ::greptime::v1::CreateDatabaseExpr& create_database() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateDatabaseExpr* release_create_database();
  ::greptime::v1::CreateDatabaseExpr* mutable_create_database();
  void set_allocated_create_database(::greptime::v1::CreateDatabaseExpr* create_database);
  private:
  const ::greptime::v1::CreateDatabaseExpr& _internal_create_database() const;
  ::greptime::v1::CreateDatabaseExpr* _internal_mutable_create_database();
  public:
  void unsafe_arena_set_allocated_create_database(
      ::greptime::v1::CreateDatabaseExpr* create_database);
  ::greptime::v1::CreateDatabaseExpr* unsafe_arena_release_create_database();

  // .greptime.v1.CreateTableExpr create_table = 2;
  bool has_create_table() const;
  private:
  bool _internal_has_create_table() const;
  public:
  void clear_create_table();
  const ::greptime::v1::CreateTableExpr& create_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateTableExpr* release_create_table();
  ::greptime::v1::CreateTableExpr* mutable_create_table();
  void set_allocated_create_table(::greptime::v1::CreateTableExpr* create_table);
  private:
  const ::greptime::v1::CreateTableExpr& _internal_create_table() const;
  ::greptime::v1::CreateTableExpr* _internal_mutable_create_table();
  public:
  void unsafe_arena_set_allocated_create_table(
      ::greptime::v1::CreateTableExpr* create_table);
  ::greptime::v1::CreateTableExpr* unsafe_arena_release_create_table();

  // .greptime.v1.AlterTableExpr alter_table = 3;
  bool has_alter_table() const;
  private:
  bool _internal_has_alter_table() const;
  public:
  void clear_alter_table();
  const ::greptime::v1::AlterTableExpr& alter_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::AlterTableExpr* release_alter_table();
  ::greptime::v1::AlterTableExpr* mutable_alter_table();
  void set_allocated_alter_table(::greptime::v1::AlterTableExpr* alter_table);
  private:
  const ::greptime::v1::AlterTableExpr& _internal_alter_table() const;
  ::greptime::v1::AlterTableExpr* _internal_mutable_alter_table();
  public:
  void unsafe_arena_set_allocated_alter_table(
      ::greptime::v1::AlterTableExpr* alter_table);
  ::greptime::v1::AlterTableExpr* unsafe_arena_release_alter_table();

  // .greptime.v1.DropTableExpr drop_table = 4;
  bool has_drop_table() const;
  private:
  bool _internal_has_drop_table() const;
  public:
  void clear_drop_table();
  const ::greptime::v1::DropTableExpr& drop_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropTableExpr* release_drop_table();
  ::greptime::v1::DropTableExpr* mutable_drop_table();
  void set_allocated_drop_table(::greptime::v1::DropTableExpr* drop_table);
  private:
  const ::greptime::v1::DropTableExpr& _internal_drop_table() const;
  ::greptime::v1::DropTableExpr* _internal_mutable_drop_table();
  public:
  void unsafe_arena_set_allocated_drop_table(
      ::greptime::v1::DropTableExpr* drop_table);
  ::greptime::v1::DropTableExpr* unsafe_arena_release_drop_table();

  // .greptime.v1.TruncateTableExpr truncate_table = 7;
  bool has_truncate_table() const;
  private:
  bool _internal_has_truncate_table() const;
  public:
  void clear_truncate_table();
  const ::greptime::v1::TruncateTableExpr& truncate_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::TruncateTableExpr* release_truncate_table();
  ::greptime::v1::TruncateTableExpr* mutable_truncate_table();
  void set_allocated_truncate_table(::greptime::v1::TruncateTableExpr* truncate_table);
  private:
  const ::greptime::v1::TruncateTableExpr& _internal_truncate_table() const;
  ::greptime::v1::TruncateTableExpr* _internal_mutable_truncate_table();
  public:
  void unsafe_arena_set_allocated_truncate_table(
      ::greptime::v1::TruncateTableExpr* truncate_table);
  ::greptime::v1::TruncateTableExpr* unsafe_arena_release_truncate_table();

  // .greptime.v1.CreateFlowExpr create_flow = 8;
  bool has_create_flow() const;
  private:
  bool _internal_has_create_flow() const;
  public:
  void clear_create_flow();
  const ::greptime::v1::CreateFlowExpr& create_flow() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateFlowExpr* release_create_flow();
  ::greptime::v1::CreateFlowExpr* mutable_create_flow();
  void set_allocated_create_flow(::greptime::v1::CreateFlowExpr* create_flow);
  private:
  const ::greptime::v1::CreateFlowExpr& _internal_create_flow() const;
  ::greptime::v1::CreateFlowExpr* _internal_mutable_create_flow();
  public:
  void unsafe_arena_set_allocated_create_flow(
      ::greptime::v1::CreateFlowExpr* create_flow);
  ::greptime::v1::CreateFlowExpr* unsafe_arena_release_create_flow();

  // .greptime.v1.DropFlowExpr drop_flow = 9;
  bool has_drop_flow() const;
  private:
  bool _internal_has_drop_flow() const;
  public:
  void clear_drop_flow();
  const ::greptime::v1::DropFlowExpr& drop_flow() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropFlowExpr* release_drop_flow();
  ::greptime::v1::DropFlowExpr* mutable_drop_flow();
  void set_allocated_drop_flow(::greptime::v1::DropFlowExpr* drop_flow);
  private:
  const ::greptime::v1::DropFlowExpr& _internal_drop_flow() const;
  ::greptime::v1::DropFlowExpr* _internal_mutable_drop_flow();
  public:
  void unsafe_arena_set_allocated_drop_flow(
      ::greptime::v1::DropFlowExpr* drop_flow);
  ::greptime::v1::DropFlowExpr* unsafe_arena_release_drop_flow();

  // .greptime.v1.CreateViewExpr create_view = 10;
  bool has_create_view() const;
  private:
  bool _internal_has_create_view() const;
  public:
  void clear_create_view();
  const ::greptime::v1::CreateViewExpr& create_view() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateViewExpr* release_create_view();
  ::greptime::v1::CreateViewExpr* mutable_create_view();
  void set_allocated_create_view(::greptime::v1::CreateViewExpr* create_view);
  private:
  const ::greptime::v1::CreateViewExpr& _internal_create_view() const;
  ::greptime::v1::CreateViewExpr* _internal_mutable_create_view();
  public:
  void unsafe_arena_set_allocated_create_view(
      ::greptime::v1::CreateViewExpr* create_view);
  ::greptime::v1::CreateViewExpr* unsafe_arena_release_create_view();

  // .greptime.v1.DropViewExpr drop_view = 11;
  bool has_drop_view() const;
  private:
  bool _internal_has_drop_view() const;
  public:
  void clear_drop_view();
  const ::greptime::v1::DropViewExpr& drop_view() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropViewExpr* release_drop_view();
  ::greptime::v1::DropViewExpr* mutable_drop_view();
  void set_allocated_drop_view(::greptime::v1::DropViewExpr* drop_view);
  private:
  const ::greptime::v1::DropViewExpr& _internal_drop_view() const;
  ::greptime::v1::DropViewExpr* _internal_mutable_drop_view();
  public:
  void unsafe_arena_set_allocated_drop_view(
      ::greptime::v1::DropViewExpr* drop_view);
  ::greptime::v1::DropViewExpr* unsafe_arena_release_drop_view();

  // .greptime.v1.AlterDatabaseExpr alter_database = 12;
  bool has_alter_database() const;
  private:
  bool _internal_has_alter_database() const;
  public:
  void clear_alter_database();
  const ::greptime::v1::AlterDatabaseExpr& alter_database() const;
  PROTOBUF_NODISCARD ::greptime::v1::AlterDatabaseExpr* release_alter_database();
  ::greptime::v1::AlterDatabaseExpr* mutable_alter_database();
  void set_allocated_alter_database(::greptime::v1::AlterDatabaseExpr* alter_database);
  private:
  const ::greptime::v1::AlterDatabaseExpr& _internal_alter_database() const;
  ::greptime::v1::AlterDatabaseExpr* _internal_mutable_alter_database();
  public:
  void unsafe_arena_set_allocated_alter_database(
      ::greptime::v1::AlterDatabaseExpr* alter_database);
  ::greptime::v1::AlterDatabaseExpr* unsafe_arena_release_alter_database();

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.DdlRequest)
 private:
  class _Internal;
  void set_has_create_database();
  void set_has_create_table();
  void set_has_alter_table();
  void set_has_drop_table();
  void set_has_truncate_table();
  void set_has_create_flow();
  void set_has_drop_flow();
  void set_has_create_view();
  void set_has_drop_view();
  void set_has_alter_database();

  inline bool has_expr() const;
  inline void clear_has_expr();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ExprUnion {
      constexpr ExprUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::CreateDatabaseExpr* create_database_;
      ::greptime::v1::CreateTableExpr* create_table_;
      ::greptime::v1::AlterTableExpr* alter_table_;
      ::greptime::v1::DropTableExpr* drop_table_;
      ::greptime::v1::TruncateTableExpr* truncate_table_;
      ::greptime::v1::CreateFlowExpr* create_flow_;
      ::greptime::v1::DropFlowExpr* drop_flow_;
      ::greptime::v1::CreateViewExpr* create_view_;
      ::greptime::v1::DropViewExpr* drop_view_;
      ::greptime::v1::AlterDatabaseExpr* alter_database_;
    } expr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateFlowExpr_FlowOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateFlowExpr_FlowOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateFlowExpr_FlowOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateFlowExpr_FlowOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateFlowExpr_FlowOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateFlowExpr_FlowOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateFlowExpr_FlowOptionsEntry_DoNotUse& other);
  static const CreateFlowExpr_FlowOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateFlowExpr_FlowOptionsEntry_DoNotUse*>(&_CreateFlowExpr_FlowOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateFlowExpr.FlowOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateFlowExpr.FlowOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateFlowExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateFlowExpr) */ {
 public:
  inline CreateFlowExpr() : CreateFlowExpr(nullptr) {}
  ~CreateFlowExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateFlowExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFlowExpr(const CreateFlowExpr& from);
  CreateFlowExpr(CreateFlowExpr&& from) noexcept
    : CreateFlowExpr() {
    *this = ::std::move(from);
  }

  inline CreateFlowExpr& operator=(const CreateFlowExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlowExpr& operator=(CreateFlowExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFlowExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFlowExpr* internal_default_instance() {
    return reinterpret_cast<const CreateFlowExpr*>(
               &_CreateFlowExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateFlowExpr& a, CreateFlowExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlowExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlowExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFlowExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFlowExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFlowExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateFlowExpr& from) {
    CreateFlowExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlowExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateFlowExpr";
  }
  protected:
  explicit CreateFlowExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSourceTableNamesFieldNumber = 3,
    kFlowOptionsFieldNumber = 10,
    kCatalogNameFieldNumber = 1,
    kFlowNameFieldNumber = 2,
    kCommentFieldNumber = 8,
    kSqlFieldNumber = 9,
    kSinkTableNameFieldNumber = 4,
    kExpireAfterFieldNumber = 7,
    kOrReplaceFieldNumber = 5,
    kCreateIfNotExistsFieldNumber = 6,
  };
  // repeated .greptime.v1.TableName source_table_names = 3;
  int source_table_names_size() const;
  private:
  int _internal_source_table_names_size() const;
  public:
  void clear_source_table_names();
  ::greptime::v1::TableName* mutable_source_table_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
      mutable_source_table_names();
  private:
  const ::greptime::v1::TableName& _internal_source_table_names(int index) const;
  ::greptime::v1::TableName* _internal_add_source_table_names();
  public:
  const ::greptime::v1::TableName& source_table_names(int index) const;
  ::greptime::v1::TableName* add_source_table_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
      source_table_names() const;

  // map<string, string> flow_options = 10;
  int flow_options_size() const;
  private:
  int _internal_flow_options_size() const;
  public:
  void clear_flow_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_flow_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_flow_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      flow_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_flow_options();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string flow_name = 2;
  void clear_flow_name();
  const std::string& flow_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flow_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flow_name();
  PROTOBUF_NODISCARD std::string* release_flow_name();
  void set_allocated_flow_name(std::string* flow_name);
  private:
  const std::string& _internal_flow_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_name(const std::string& value);
  std::string* _internal_mutable_flow_name();
  public:

  // string comment = 8;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string sql = 9;
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // .greptime.v1.TableName sink_table_name = 4;
  bool has_sink_table_name() const;
  private:
  bool _internal_has_sink_table_name() const;
  public:
  void clear_sink_table_name();
  const ::greptime::v1::TableName& sink_table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableName* release_sink_table_name();
  ::greptime::v1::TableName* mutable_sink_table_name();
  void set_allocated_sink_table_name(::greptime::v1::TableName* sink_table_name);
  private:
  const ::greptime::v1::TableName& _internal_sink_table_name() const;
  ::greptime::v1::TableName* _internal_mutable_sink_table_name();
  public:
  void unsafe_arena_set_allocated_sink_table_name(
      ::greptime::v1::TableName* sink_table_name);
  ::greptime::v1::TableName* unsafe_arena_release_sink_table_name();

  // .greptime.v1.ExpireAfter expire_after = 7;
  bool has_expire_after() const;
  private:
  bool _internal_has_expire_after() const;
  public:
  void clear_expire_after();
  const ::greptime::v1::ExpireAfter& expire_after() const;
  PROTOBUF_NODISCARD ::greptime::v1::ExpireAfter* release_expire_after();
  ::greptime::v1::ExpireAfter* mutable_expire_after();
  void set_allocated_expire_after(::greptime::v1::ExpireAfter* expire_after);
  private:
  const ::greptime::v1::ExpireAfter& _internal_expire_after() const;
  ::greptime::v1::ExpireAfter* _internal_mutable_expire_after();
  public:
  void unsafe_arena_set_allocated_expire_after(
      ::greptime::v1::ExpireAfter* expire_after);
  ::greptime::v1::ExpireAfter* unsafe_arena_release_expire_after();

  // bool or_replace = 5;
  void clear_or_replace();
  bool or_replace() const;
  void set_or_replace(bool value);
  private:
  bool _internal_or_replace() const;
  void _internal_set_or_replace(bool value);
  public:

  // bool create_if_not_exists = 6;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateFlowExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName > source_table_names_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateFlowExpr_FlowOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> flow_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::greptime::v1::TableName* sink_table_name_;
    ::greptime::v1::ExpireAfter* expire_after_;
    bool or_replace_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropFlowExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropFlowExpr) */ {
 public:
  inline DropFlowExpr() : DropFlowExpr(nullptr) {}
  ~DropFlowExpr() override;
  explicit PROTOBUF_CONSTEXPR DropFlowExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropFlowExpr(const DropFlowExpr& from);
  DropFlowExpr(DropFlowExpr&& from) noexcept
    : DropFlowExpr() {
    *this = ::std::move(from);
  }

  inline DropFlowExpr& operator=(const DropFlowExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropFlowExpr& operator=(DropFlowExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropFlowExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropFlowExpr* internal_default_instance() {
    return reinterpret_cast<const DropFlowExpr*>(
               &_DropFlowExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DropFlowExpr& a, DropFlowExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropFlowExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropFlowExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropFlowExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropFlowExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropFlowExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropFlowExpr& from) {
    DropFlowExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropFlowExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropFlowExpr";
  }
  protected:
  explicit DropFlowExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kFlowNameFieldNumber = 2,
    kFlowIdFieldNumber = 3,
    kDropIfExistsFieldNumber = 5,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string flow_name = 2;
  void clear_flow_name();
  const std::string& flow_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flow_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flow_name();
  PROTOBUF_NODISCARD std::string* release_flow_name();
  void set_allocated_flow_name(std::string* flow_name);
  private:
  const std::string& _internal_flow_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_name(const std::string& value);
  std::string* _internal_mutable_flow_name();
  public:

  // .greptime.v1.FlowId flow_id = 3;
  bool has_flow_id() const;
  private:
  bool _internal_has_flow_id() const;
  public:
  void clear_flow_id();
  const ::greptime::v1::FlowId& flow_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::FlowId* release_flow_id();
  ::greptime::v1::FlowId* mutable_flow_id();
  void set_allocated_flow_id(::greptime::v1::FlowId* flow_id);
  private:
  const ::greptime::v1::FlowId& _internal_flow_id() const;
  ::greptime::v1::FlowId* _internal_mutable_flow_id();
  public:
  void unsafe_arena_set_allocated_flow_id(
      ::greptime::v1::FlowId* flow_id);
  ::greptime::v1::FlowId* unsafe_arena_release_flow_id();

  // bool drop_if_exists = 5;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropFlowExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_name_;
    ::greptime::v1::FlowId* flow_id_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateViewExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateViewExpr) */ {
 public:
  inline CreateViewExpr() : CreateViewExpr(nullptr) {}
  ~CreateViewExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateViewExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateViewExpr(const CreateViewExpr& from);
  CreateViewExpr(CreateViewExpr&& from) noexcept
    : CreateViewExpr() {
    *this = ::std::move(from);
  }

  inline CreateViewExpr& operator=(const CreateViewExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateViewExpr& operator=(CreateViewExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateViewExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateViewExpr* internal_default_instance() {
    return reinterpret_cast<const CreateViewExpr*>(
               &_CreateViewExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateViewExpr& a, CreateViewExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateViewExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateViewExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateViewExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateViewExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateViewExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateViewExpr& from) {
    CreateViewExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateViewExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateViewExpr";
  }
  protected:
  explicit CreateViewExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNamesFieldNumber = 7,
    kColumnsFieldNumber = 8,
    kPlanColumnsFieldNumber = 9,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kViewNameFieldNumber = 3,
    kLogicalPlanFieldNumber = 4,
    kDefinitionFieldNumber = 10,
    kCreateIfNotExistsFieldNumber = 5,
    kOrReplaceFieldNumber = 6,
  };
  // repeated .greptime.v1.TableName table_names = 7;
  int table_names_size() const;
  private:
  int _internal_table_names_size() const;
  public:
  void clear_table_names();
  ::greptime::v1::TableName* mutable_table_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
      mutable_table_names();
  private:
  const ::greptime::v1::TableName& _internal_table_names(int index) const;
  ::greptime::v1::TableName* _internal_add_table_names();
  public:
  const ::greptime::v1::TableName& table_names(int index) const;
  ::greptime::v1::TableName* add_table_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
      table_names() const;

  // repeated string columns = 8;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // repeated string plan_columns = 9;
  int plan_columns_size() const;
  private:
  int _internal_plan_columns_size() const;
  public:
  void clear_plan_columns();
  const std::string& plan_columns(int index) const;
  std::string* mutable_plan_columns(int index);
  void set_plan_columns(int index, const std::string& value);
  void set_plan_columns(int index, std::string&& value);
  void set_plan_columns(int index, const char* value);
  void set_plan_columns(int index, const char* value, size_t size);
  std::string* add_plan_columns();
  void add_plan_columns(const std::string& value);
  void add_plan_columns(std::string&& value);
  void add_plan_columns(const char* value);
  void add_plan_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& plan_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_plan_columns();
  private:
  const std::string& _internal_plan_columns(int index) const;
  std::string* _internal_add_plan_columns();
  public:

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string view_name = 3;
  void clear_view_name();
  const std::string& view_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_name();
  PROTOBUF_NODISCARD std::string* release_view_name();
  void set_allocated_view_name(std::string* view_name);
  private:
  const std::string& _internal_view_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_name(const std::string& value);
  std::string* _internal_mutable_view_name();
  public:

  // bytes logical_plan = 4;
  void clear_logical_plan();
  const std::string& logical_plan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_plan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_plan();
  PROTOBUF_NODISCARD std::string* release_logical_plan();
  void set_allocated_logical_plan(std::string* logical_plan);
  private:
  const std::string& _internal_logical_plan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_plan(const std::string& value);
  std::string* _internal_mutable_logical_plan();
  public:

  // string definition = 10;
  void clear_definition();
  const std::string& definition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_definition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_definition();
  PROTOBUF_NODISCARD std::string* release_definition();
  void set_allocated_definition(std::string* definition);
  private:
  const std::string& _internal_definition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_definition(const std::string& value);
  std::string* _internal_mutable_definition();
  public:

  // bool create_if_not_exists = 5;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // bool or_replace = 6;
  void clear_or_replace();
  bool or_replace() const;
  void set_or_replace(bool value);
  private:
  bool _internal_or_replace() const;
  void _internal_set_or_replace(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateViewExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName > table_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> plan_columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_plan_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definition_;
    bool create_if_not_exists_;
    bool or_replace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropViewExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropViewExpr) */ {
 public:
  inline DropViewExpr() : DropViewExpr(nullptr) {}
  ~DropViewExpr() override;
  explicit PROTOBUF_CONSTEXPR DropViewExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropViewExpr(const DropViewExpr& from);
  DropViewExpr(DropViewExpr&& from) noexcept
    : DropViewExpr() {
    *this = ::std::move(from);
  }

  inline DropViewExpr& operator=(const DropViewExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropViewExpr& operator=(DropViewExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropViewExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropViewExpr* internal_default_instance() {
    return reinterpret_cast<const DropViewExpr*>(
               &_DropViewExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DropViewExpr& a, DropViewExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropViewExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropViewExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropViewExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropViewExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropViewExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropViewExpr& from) {
    DropViewExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropViewExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropViewExpr";
  }
  protected:
  explicit DropViewExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kViewNameFieldNumber = 3,
    kViewIdFieldNumber = 4,
    kDropIfExistsFieldNumber = 5,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string view_name = 3;
  void clear_view_name();
  const std::string& view_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_name();
  PROTOBUF_NODISCARD std::string* release_view_name();
  void set_allocated_view_name(std::string* view_name);
  private:
  const std::string& _internal_view_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_name(const std::string& value);
  std::string* _internal_mutable_view_name();
  public:

  // .greptime.v1.TableId view_id = 4;
  bool has_view_id() const;
  private:
  bool _internal_has_view_id() const;
  public:
  void clear_view_id();
  const ::greptime::v1::TableId& view_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_view_id();
  ::greptime::v1::TableId* mutable_view_id();
  void set_allocated_view_id(::greptime::v1::TableId* view_id);
  private:
  const ::greptime::v1::TableId& _internal_view_id() const;
  ::greptime::v1::TableId* _internal_mutable_view_id();
  public:
  void unsafe_arena_set_allocated_view_id(
      ::greptime::v1::TableId* view_id);
  ::greptime::v1::TableId* unsafe_arena_release_view_id();

  // bool drop_if_exists = 5;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropViewExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_name_;
    ::greptime::v1::TableId* view_id_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateTableExpr_TableOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableExpr_TableOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableExpr_TableOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateTableExpr_TableOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateTableExpr_TableOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateTableExpr_TableOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateTableExpr_TableOptionsEntry_DoNotUse& other);
  static const CreateTableExpr_TableOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateTableExpr_TableOptionsEntry_DoNotUse*>(&_CreateTableExpr_TableOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTableExpr.TableOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTableExpr.TableOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateTableExpr) */ {
 public:
  inline CreateTableExpr() : CreateTableExpr(nullptr) {}
  ~CreateTableExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableExpr(const CreateTableExpr& from);
  CreateTableExpr(CreateTableExpr&& from) noexcept
    : CreateTableExpr() {
    *this = ::std::move(from);
  }

  inline CreateTableExpr& operator=(const CreateTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableExpr& operator=(CreateTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableExpr* internal_default_instance() {
    return reinterpret_cast<const CreateTableExpr*>(
               &_CreateTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateTableExpr& a, CreateTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableExpr& from) {
    CreateTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateTableExpr";
  }
  protected:
  explicit CreateTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 5,
    kPrimaryKeysFieldNumber = 7,
    kTableOptionsFieldNumber = 9,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kDescFieldNumber = 4,
    kTimeIndexFieldNumber = 6,
    kEngineFieldNumber = 12,
    kTableIdFieldNumber = 10,
    kCreateIfNotExistsFieldNumber = 8,
  };
  // repeated .greptime.v1.ColumnDef column_defs = 5;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::greptime::v1::ColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >*
      mutable_column_defs();
  private:
  const ::greptime::v1::ColumnDef& _internal_column_defs(int index) const;
  ::greptime::v1::ColumnDef* _internal_add_column_defs();
  public:
  const ::greptime::v1::ColumnDef& column_defs(int index) const;
  ::greptime::v1::ColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >&
      column_defs() const;

  // repeated string primary_keys = 7;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // map<string, string> table_options = 9;
  int table_options_size() const;
  private:
  int _internal_table_options_size() const;
  public:
  void clear_table_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_table_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_table_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      table_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_table_options();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string desc = 4;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // string time_index = 6;
  void clear_time_index();
  const std::string& time_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_index();
  PROTOBUF_NODISCARD std::string* release_time_index();
  void set_allocated_time_index(std::string* time_index);
  private:
  const std::string& _internal_time_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_index(const std::string& value);
  std::string* _internal_mutable_time_index();
  public:

  // string engine = 12;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // .greptime.v1.TableId table_id = 10;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // bool create_if_not_exists = 8;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateTableExpr_TableOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> table_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::greptime::v1::TableId* table_id_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AlterTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AlterTableExpr) */ {
 public:
  inline AlterTableExpr() : AlterTableExpr(nullptr) {}
  ~AlterTableExpr() override;
  explicit PROTOBUF_CONSTEXPR AlterTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterTableExpr(const AlterTableExpr& from);
  AlterTableExpr(AlterTableExpr&& from) noexcept
    : AlterTableExpr() {
    *this = ::std::move(from);
  }

  inline AlterTableExpr& operator=(const AlterTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterTableExpr& operator=(AlterTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterTableExpr& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kAddColumns = 4,
    kDropColumns = 5,
    kRenameTable = 6,
    kModifyColumnTypes = 7,
    kSetTableOptions = 8,
    kUnsetTableOptions = 11,
    kSetIndex = 12,
    kUnsetIndex = 13,
    kDropDefaults = 14,
    kSetIndexes = 15,
    kUnsetIndexes = 16,
    KIND_NOT_SET = 0,
  };

  static inline const AlterTableExpr* internal_default_instance() {
    return reinterpret_cast<const AlterTableExpr*>(
               &_AlterTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AlterTableExpr& a, AlterTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterTableExpr& from) {
    AlterTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AlterTableExpr";
  }
  protected:
  explicit AlterTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kAddColumnsFieldNumber = 4,
    kDropColumnsFieldNumber = 5,
    kRenameTableFieldNumber = 6,
    kModifyColumnTypesFieldNumber = 7,
    kSetTableOptionsFieldNumber = 8,
    kUnsetTableOptionsFieldNumber = 11,
    kSetIndexFieldNumber = 12,
    kUnsetIndexFieldNumber = 13,
    kDropDefaultsFieldNumber = 14,
    kSetIndexesFieldNumber = 15,
    kUnsetIndexesFieldNumber = 16,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.AddColumns add_columns = 4;
  bool has_add_columns() const;
  private:
  bool _internal_has_add_columns() const;
  public:
  void clear_add_columns();
  const ::greptime::v1::AddColumns& add_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumns* release_add_columns();
  ::greptime::v1::AddColumns* mutable_add_columns();
  void set_allocated_add_columns(::greptime::v1::AddColumns* add_columns);
  private:
  const ::greptime::v1::AddColumns& _internal_add_columns() const;
  ::greptime::v1::AddColumns* _internal_mutable_add_columns();
  public:
  void unsafe_arena_set_allocated_add_columns(
      ::greptime::v1::AddColumns* add_columns);
  ::greptime::v1::AddColumns* unsafe_arena_release_add_columns();

  // .greptime.v1.DropColumns drop_columns = 5;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::greptime::v1::DropColumns& drop_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropColumns* release_drop_columns();
  ::greptime::v1::DropColumns* mutable_drop_columns();
  void set_allocated_drop_columns(::greptime::v1::DropColumns* drop_columns);
  private:
  const ::greptime::v1::DropColumns& _internal_drop_columns() const;
  ::greptime::v1::DropColumns* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::greptime::v1::DropColumns* drop_columns);
  ::greptime::v1::DropColumns* unsafe_arena_release_drop_columns();

  // .greptime.v1.RenameTable rename_table = 6;
  bool has_rename_table() const;
  private:
  bool _internal_has_rename_table() const;
  public:
  void clear_rename_table();
  const ::greptime::v1::RenameTable& rename_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::RenameTable* release_rename_table();
  ::greptime::v1::RenameTable* mutable_rename_table();
  void set_allocated_rename_table(::greptime::v1::RenameTable* rename_table);
  private:
  const ::greptime::v1::RenameTable& _internal_rename_table() const;
  ::greptime::v1::RenameTable* _internal_mutable_rename_table();
  public:
  void unsafe_arena_set_allocated_rename_table(
      ::greptime::v1::RenameTable* rename_table);
  ::greptime::v1::RenameTable* unsafe_arena_release_rename_table();

  // .greptime.v1.ModifyColumnTypes modify_column_types = 7;
  bool has_modify_column_types() const;
  private:
  bool _internal_has_modify_column_types() const;
  public:
  void clear_modify_column_types();
  const ::greptime::v1::ModifyColumnTypes& modify_column_types() const;
  PROTOBUF_NODISCARD ::greptime::v1::ModifyColumnTypes* release_modify_column_types();
  ::greptime::v1::ModifyColumnTypes* mutable_modify_column_types();
  void set_allocated_modify_column_types(::greptime::v1::ModifyColumnTypes* modify_column_types);
  private:
  const ::greptime::v1::ModifyColumnTypes& _internal_modify_column_types() const;
  ::greptime::v1::ModifyColumnTypes* _internal_mutable_modify_column_types();
  public:
  void unsafe_arena_set_allocated_modify_column_types(
      ::greptime::v1::ModifyColumnTypes* modify_column_types);
  ::greptime::v1::ModifyColumnTypes* unsafe_arena_release_modify_column_types();

  // .greptime.v1.SetTableOptions set_table_options = 8;
  bool has_set_table_options() const;
  private:
  bool _internal_has_set_table_options() const;
  public:
  void clear_set_table_options();
  const ::greptime::v1::SetTableOptions& set_table_options() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetTableOptions* release_set_table_options();
  ::greptime::v1::SetTableOptions* mutable_set_table_options();
  void set_allocated_set_table_options(::greptime::v1::SetTableOptions* set_table_options);
  private:
  const ::greptime::v1::SetTableOptions& _internal_set_table_options() const;
  ::greptime::v1::SetTableOptions* _internal_mutable_set_table_options();
  public:
  void unsafe_arena_set_allocated_set_table_options(
      ::greptime::v1::SetTableOptions* set_table_options);
  ::greptime::v1::SetTableOptions* unsafe_arena_release_set_table_options();

  // .greptime.v1.UnsetTableOptions unset_table_options = 11;
  bool has_unset_table_options() const;
  private:
  bool _internal_has_unset_table_options() const;
  public:
  void clear_unset_table_options();
  const ::greptime::v1::UnsetTableOptions& unset_table_options() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetTableOptions* release_unset_table_options();
  ::greptime::v1::UnsetTableOptions* mutable_unset_table_options();
  void set_allocated_unset_table_options(::greptime::v1::UnsetTableOptions* unset_table_options);
  private:
  const ::greptime::v1::UnsetTableOptions& _internal_unset_table_options() const;
  ::greptime::v1::UnsetTableOptions* _internal_mutable_unset_table_options();
  public:
  void unsafe_arena_set_allocated_unset_table_options(
      ::greptime::v1::UnsetTableOptions* unset_table_options);
  ::greptime::v1::UnsetTableOptions* unsafe_arena_release_unset_table_options();

  // .greptime.v1.SetIndex set_index = 12;
  bool has_set_index() const;
  private:
  bool _internal_has_set_index() const;
  public:
  void clear_set_index();
  const ::greptime::v1::SetIndex& set_index() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetIndex* release_set_index();
  ::greptime::v1::SetIndex* mutable_set_index();
  void set_allocated_set_index(::greptime::v1::SetIndex* set_index);
  private:
  const ::greptime::v1::SetIndex& _internal_set_index() const;
  ::greptime::v1::SetIndex* _internal_mutable_set_index();
  public:
  void unsafe_arena_set_allocated_set_index(
      ::greptime::v1::SetIndex* set_index);
  ::greptime::v1::SetIndex* unsafe_arena_release_set_index();

  // .greptime.v1.UnsetIndex unset_index = 13;
  bool has_unset_index() const;
  private:
  bool _internal_has_unset_index() const;
  public:
  void clear_unset_index();
  const ::greptime::v1::UnsetIndex& unset_index() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetIndex* release_unset_index();
  ::greptime::v1::UnsetIndex* mutable_unset_index();
  void set_allocated_unset_index(::greptime::v1::UnsetIndex* unset_index);
  private:
  const ::greptime::v1::UnsetIndex& _internal_unset_index() const;
  ::greptime::v1::UnsetIndex* _internal_mutable_unset_index();
  public:
  void unsafe_arena_set_allocated_unset_index(
      ::greptime::v1::UnsetIndex* unset_index);
  ::greptime::v1::UnsetIndex* unsafe_arena_release_unset_index();

  // .greptime.v1.DropDefaults drop_defaults = 14;
  bool has_drop_defaults() const;
  private:
  bool _internal_has_drop_defaults() const;
  public:
  void clear_drop_defaults();
  const ::greptime::v1::DropDefaults& drop_defaults() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropDefaults* release_drop_defaults();
  ::greptime::v1::DropDefaults* mutable_drop_defaults();
  void set_allocated_drop_defaults(::greptime::v1::DropDefaults* drop_defaults);
  private:
  const ::greptime::v1::DropDefaults& _internal_drop_defaults() const;
  ::greptime::v1::DropDefaults* _internal_mutable_drop_defaults();
  public:
  void unsafe_arena_set_allocated_drop_defaults(
      ::greptime::v1::DropDefaults* drop_defaults);
  ::greptime::v1::DropDefaults* unsafe_arena_release_drop_defaults();

  // .greptime.v1.SetIndexes set_indexes = 15;
  bool has_set_indexes() const;
  private:
  bool _internal_has_set_indexes() const;
  public:
  void clear_set_indexes();
  const ::greptime::v1::SetIndexes& set_indexes() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetIndexes* release_set_indexes();
  ::greptime::v1::SetIndexes* mutable_set_indexes();
  void set_allocated_set_indexes(::greptime::v1::SetIndexes* set_indexes);
  private:
  const ::greptime::v1::SetIndexes& _internal_set_indexes() const;
  ::greptime::v1::SetIndexes* _internal_mutable_set_indexes();
  public:
  void unsafe_arena_set_allocated_set_indexes(
      ::greptime::v1::SetIndexes* set_indexes);
  ::greptime::v1::SetIndexes* unsafe_arena_release_set_indexes();

  // .greptime.v1.UnsetIndexes unset_indexes = 16;
  bool has_unset_indexes() const;
  private:
  bool _internal_has_unset_indexes() const;
  public:
  void clear_unset_indexes();
  const ::greptime::v1::UnsetIndexes& unset_indexes() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetIndexes* release_unset_indexes();
  ::greptime::v1::UnsetIndexes* mutable_unset_indexes();
  void set_allocated_unset_indexes(::greptime::v1::UnsetIndexes* unset_indexes);
  private:
  const ::greptime::v1::UnsetIndexes& _internal_unset_indexes() const;
  ::greptime::v1::UnsetIndexes* _internal_mutable_unset_indexes();
  public:
  void unsafe_arena_set_allocated_unset_indexes(
      ::greptime::v1::UnsetIndexes* unset_indexes);
  ::greptime::v1::UnsetIndexes* unsafe_arena_release_unset_indexes();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.AlterTableExpr)
 private:
  class _Internal;
  void set_has_add_columns();
  void set_has_drop_columns();
  void set_has_rename_table();
  void set_has_modify_column_types();
  void set_has_set_table_options();
  void set_has_unset_table_options();
  void set_has_set_index();
  void set_has_unset_index();
  void set_has_drop_defaults();
  void set_has_set_indexes();
  void set_has_unset_indexes();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::AddColumns* add_columns_;
      ::greptime::v1::DropColumns* drop_columns_;
      ::greptime::v1::RenameTable* rename_table_;
      ::greptime::v1::ModifyColumnTypes* modify_column_types_;
      ::greptime::v1::SetTableOptions* set_table_options_;
      ::greptime::v1::UnsetTableOptions* unset_table_options_;
      ::greptime::v1::SetIndex* set_index_;
      ::greptime::v1::UnsetIndex* unset_index_;
      ::greptime::v1::DropDefaults* drop_defaults_;
      ::greptime::v1::SetIndexes* set_indexes_;
      ::greptime::v1::UnsetIndexes* unset_indexes_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropDefault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropDefault) */ {
 public:
  inline DropDefault() : DropDefault(nullptr) {}
  ~DropDefault() override;
  explicit PROTOBUF_CONSTEXPR DropDefault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropDefault(const DropDefault& from);
  DropDefault(DropDefault&& from) noexcept
    : DropDefault() {
    *this = ::std::move(from);
  }

  inline DropDefault& operator=(const DropDefault& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropDefault& operator=(DropDefault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropDefault& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropDefault* internal_default_instance() {
    return reinterpret_cast<const DropDefault*>(
               &_DropDefault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DropDefault& a, DropDefault& b) {
    a.Swap(&b);
  }
  inline void Swap(DropDefault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropDefault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropDefault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropDefault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropDefault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropDefault& from) {
    DropDefault::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropDefault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropDefault";
  }
  protected:
  explicit DropDefault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropDefault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetIndexes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetIndexes) */ {
 public:
  inline SetIndexes() : SetIndexes(nullptr) {}
  ~SetIndexes() override;
  explicit PROTOBUF_CONSTEXPR SetIndexes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetIndexes(const SetIndexes& from);
  SetIndexes(SetIndexes&& from) noexcept
    : SetIndexes() {
    *this = ::std::move(from);
  }

  inline SetIndexes& operator=(const SetIndexes& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetIndexes& operator=(SetIndexes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetIndexes& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetIndexes* internal_default_instance() {
    return reinterpret_cast<const SetIndexes*>(
               &_SetIndexes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetIndexes& a, SetIndexes& b) {
    a.Swap(&b);
  }
  inline void Swap(SetIndexes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetIndexes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetIndexes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetIndexes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetIndexes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetIndexes& from) {
    SetIndexes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetIndexes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetIndexes";
  }
  protected:
  explicit SetIndexes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetIndexesFieldNumber = 1,
  };
  // repeated .greptime.v1.SetIndex set_indexes = 1;
  int set_indexes_size() const;
  private:
  int _internal_set_indexes_size() const;
  public:
  void clear_set_indexes();
  ::greptime::v1::SetIndex* mutable_set_indexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::SetIndex >*
      mutable_set_indexes();
  private:
  const ::greptime::v1::SetIndex& _internal_set_indexes(int index) const;
  ::greptime::v1::SetIndex* _internal_add_set_indexes();
  public:
  const ::greptime::v1::SetIndex& set_indexes(int index) const;
  ::greptime::v1::SetIndex* add_set_indexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::SetIndex >&
      set_indexes() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.SetIndexes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::SetIndex > set_indexes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetIndexes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetIndexes) */ {
 public:
  inline UnsetIndexes() : UnsetIndexes(nullptr) {}
  ~UnsetIndexes() override;
  explicit PROTOBUF_CONSTEXPR UnsetIndexes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetIndexes(const UnsetIndexes& from);
  UnsetIndexes(UnsetIndexes&& from) noexcept
    : UnsetIndexes() {
    *this = ::std::move(from);
  }

  inline UnsetIndexes& operator=(const UnsetIndexes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetIndexes& operator=(UnsetIndexes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetIndexes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetIndexes* internal_default_instance() {
    return reinterpret_cast<const UnsetIndexes*>(
               &_UnsetIndexes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UnsetIndexes& a, UnsetIndexes& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetIndexes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetIndexes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetIndexes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetIndexes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetIndexes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetIndexes& from) {
    UnsetIndexes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetIndexes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetIndexes";
  }
  protected:
  explicit UnsetIndexes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnsetIndexesFieldNumber = 1,
  };
  // repeated .greptime.v1.UnsetIndex unset_indexes = 1;
  int unset_indexes_size() const;
  private:
  int _internal_unset_indexes_size() const;
  public:
  void clear_unset_indexes();
  ::greptime::v1::UnsetIndex* mutable_unset_indexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::UnsetIndex >*
      mutable_unset_indexes();
  private:
  const ::greptime::v1::UnsetIndex& _internal_unset_indexes(int index) const;
  ::greptime::v1::UnsetIndex* _internal_add_unset_indexes();
  public:
  const ::greptime::v1::UnsetIndex& unset_indexes(int index) const;
  ::greptime::v1::UnsetIndex* add_unset_indexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::UnsetIndex >&
      unset_indexes() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetIndexes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::UnsetIndex > unset_indexes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetIndex) */ {
 public:
  inline SetIndex() : SetIndex(nullptr) {}
  ~SetIndex() override;
  explicit PROTOBUF_CONSTEXPR SetIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetIndex(const SetIndex& from);
  SetIndex(SetIndex&& from) noexcept
    : SetIndex() {
    *this = ::std::move(from);
  }

  inline SetIndex& operator=(const SetIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetIndex& operator=(SetIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetIndex& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kFulltext = 1,
    kInverted = 2,
    kSkipping = 3,
    OPTIONS_NOT_SET = 0,
  };

  static inline const SetIndex* internal_default_instance() {
    return reinterpret_cast<const SetIndex*>(
               &_SetIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetIndex& a, SetIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(SetIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetIndex& from) {
    SetIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetIndex";
  }
  protected:
  explicit SetIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFulltextFieldNumber = 1,
    kInvertedFieldNumber = 2,
    kSkippingFieldNumber = 3,
  };
  // .greptime.v1.SetFulltext fulltext = 1;
  bool has_fulltext() const;
  private:
  bool _internal_has_fulltext() const;
  public:
  void clear_fulltext();
  const ::greptime::v1::SetFulltext& fulltext() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetFulltext* release_fulltext();
  ::greptime::v1::SetFulltext* mutable_fulltext();
  void set_allocated_fulltext(::greptime::v1::SetFulltext* fulltext);
  private:
  const ::greptime::v1::SetFulltext& _internal_fulltext() const;
  ::greptime::v1::SetFulltext* _internal_mutable_fulltext();
  public:
  void unsafe_arena_set_allocated_fulltext(
      ::greptime::v1::SetFulltext* fulltext);
  ::greptime::v1::SetFulltext* unsafe_arena_release_fulltext();

  // .greptime.v1.SetInverted inverted = 2;
  bool has_inverted() const;
  private:
  bool _internal_has_inverted() const;
  public:
  void clear_inverted();
  const ::greptime::v1::SetInverted& inverted() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetInverted* release_inverted();
  ::greptime::v1::SetInverted* mutable_inverted();
  void set_allocated_inverted(::greptime::v1::SetInverted* inverted);
  private:
  const ::greptime::v1::SetInverted& _internal_inverted() const;
  ::greptime::v1::SetInverted* _internal_mutable_inverted();
  public:
  void unsafe_arena_set_allocated_inverted(
      ::greptime::v1::SetInverted* inverted);
  ::greptime::v1::SetInverted* unsafe_arena_release_inverted();

  // .greptime.v1.SetSkipping skipping = 3;
  bool has_skipping() const;
  private:
  bool _internal_has_skipping() const;
  public:
  void clear_skipping();
  const ::greptime::v1::SetSkipping& skipping() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetSkipping* release_skipping();
  ::greptime::v1::SetSkipping* mutable_skipping();
  void set_allocated_skipping(::greptime::v1::SetSkipping* skipping);
  private:
  const ::greptime::v1::SetSkipping& _internal_skipping() const;
  ::greptime::v1::SetSkipping* _internal_mutable_skipping();
  public:
  void unsafe_arena_set_allocated_skipping(
      ::greptime::v1::SetSkipping* skipping);
  ::greptime::v1::SetSkipping* unsafe_arena_release_skipping();

  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.SetIndex)
 private:
  class _Internal;
  void set_has_fulltext();
  void set_has_inverted();
  void set_has_skipping();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::SetFulltext* fulltext_;
      ::greptime::v1::SetInverted* inverted_;
      ::greptime::v1::SetSkipping* skipping_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetIndex) */ {
 public:
  inline UnsetIndex() : UnsetIndex(nullptr) {}
  ~UnsetIndex() override;
  explicit PROTOBUF_CONSTEXPR UnsetIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetIndex(const UnsetIndex& from);
  UnsetIndex(UnsetIndex&& from) noexcept
    : UnsetIndex() {
    *this = ::std::move(from);
  }

  inline UnsetIndex& operator=(const UnsetIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetIndex& operator=(UnsetIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetIndex& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kFulltext = 1,
    kInverted = 2,
    kSkipping = 3,
    OPTIONS_NOT_SET = 0,
  };

  static inline const UnsetIndex* internal_default_instance() {
    return reinterpret_cast<const UnsetIndex*>(
               &_UnsetIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnsetIndex& a, UnsetIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetIndex& from) {
    UnsetIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetIndex";
  }
  protected:
  explicit UnsetIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFulltextFieldNumber = 1,
    kInvertedFieldNumber = 2,
    kSkippingFieldNumber = 3,
  };
  // .greptime.v1.UnsetFulltext fulltext = 1;
  bool has_fulltext() const;
  private:
  bool _internal_has_fulltext() const;
  public:
  void clear_fulltext();
  const ::greptime::v1::UnsetFulltext& fulltext() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetFulltext* release_fulltext();
  ::greptime::v1::UnsetFulltext* mutable_fulltext();
  void set_allocated_fulltext(::greptime::v1::UnsetFulltext* fulltext);
  private:
  const ::greptime::v1::UnsetFulltext& _internal_fulltext() const;
  ::greptime::v1::UnsetFulltext* _internal_mutable_fulltext();
  public:
  void unsafe_arena_set_allocated_fulltext(
      ::greptime::v1::UnsetFulltext* fulltext);
  ::greptime::v1::UnsetFulltext* unsafe_arena_release_fulltext();

  // .greptime.v1.UnsetInverted inverted = 2;
  bool has_inverted() const;
  private:
  bool _internal_has_inverted() const;
  public:
  void clear_inverted();
  const ::greptime::v1::UnsetInverted& inverted() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetInverted* release_inverted();
  ::greptime::v1::UnsetInverted* mutable_inverted();
  void set_allocated_inverted(::greptime::v1::UnsetInverted* inverted);
  private:
  const ::greptime::v1::UnsetInverted& _internal_inverted() const;
  ::greptime::v1::UnsetInverted* _internal_mutable_inverted();
  public:
  void unsafe_arena_set_allocated_inverted(
      ::greptime::v1::UnsetInverted* inverted);
  ::greptime::v1::UnsetInverted* unsafe_arena_release_inverted();

  // .greptime.v1.UnsetSkipping skipping = 3;
  bool has_skipping() const;
  private:
  bool _internal_has_skipping() const;
  public:
  void clear_skipping();
  const ::greptime::v1::UnsetSkipping& skipping() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetSkipping* release_skipping();
  ::greptime::v1::UnsetSkipping* mutable_skipping();
  void set_allocated_skipping(::greptime::v1::UnsetSkipping* skipping);
  private:
  const ::greptime::v1::UnsetSkipping& _internal_skipping() const;
  ::greptime::v1::UnsetSkipping* _internal_mutable_skipping();
  public:
  void unsafe_arena_set_allocated_skipping(
      ::greptime::v1::UnsetSkipping* skipping);
  ::greptime::v1::UnsetSkipping* unsafe_arena_release_skipping();

  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetIndex)
 private:
  class _Internal;
  void set_has_fulltext();
  void set_has_inverted();
  void set_has_skipping();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::UnsetFulltext* fulltext_;
      ::greptime::v1::UnsetInverted* inverted_;
      ::greptime::v1::UnsetSkipping* skipping_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropTableExpr) */ {
 public:
  inline DropTableExpr() : DropTableExpr(nullptr) {}
  ~DropTableExpr() override;
  explicit PROTOBUF_CONSTEXPR DropTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTableExpr(const DropTableExpr& from);
  DropTableExpr(DropTableExpr&& from) noexcept
    : DropTableExpr() {
    *this = ::std::move(from);
  }

  inline DropTableExpr& operator=(const DropTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTableExpr& operator=(DropTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTableExpr* internal_default_instance() {
    return reinterpret_cast<const DropTableExpr*>(
               &_DropTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DropTableExpr& a, DropTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTableExpr& from) {
    DropTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropTableExpr";
  }
  protected:
  explicit DropTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
    kDropIfExistsFieldNumber = 5,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.TableId table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // bool drop_if_exists = 5;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::greptime::v1::TableId* table_id_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateDatabaseExpr_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateDatabaseExpr_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateDatabaseExpr_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateDatabaseExpr_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateDatabaseExpr_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateDatabaseExpr_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateDatabaseExpr_OptionsEntry_DoNotUse& other);
  static const CreateDatabaseExpr_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateDatabaseExpr_OptionsEntry_DoNotUse*>(&_CreateDatabaseExpr_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateDatabaseExpr.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateDatabaseExpr.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateDatabaseExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateDatabaseExpr) */ {
 public:
  inline CreateDatabaseExpr() : CreateDatabaseExpr(nullptr) {}
  ~CreateDatabaseExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateDatabaseExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatabaseExpr(const CreateDatabaseExpr& from);
  CreateDatabaseExpr(CreateDatabaseExpr&& from) noexcept
    : CreateDatabaseExpr() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseExpr& operator=(const CreateDatabaseExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatabaseExpr& operator=(CreateDatabaseExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatabaseExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatabaseExpr* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseExpr*>(
               &_CreateDatabaseExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateDatabaseExpr& a, CreateDatabaseExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatabaseExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatabaseExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatabaseExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatabaseExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDatabaseExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDatabaseExpr& from) {
    CreateDatabaseExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatabaseExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateDatabaseExpr";
  }
  protected:
  explicit CreateDatabaseExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kCreateIfNotExistsFieldNumber = 3,
  };
  // map<string, string> options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // bool create_if_not_exists = 3;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateDatabaseExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateDatabaseExpr_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class TruncateTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TruncateTableExpr) */ {
 public:
  inline TruncateTableExpr() : TruncateTableExpr(nullptr) {}
  ~TruncateTableExpr() override;
  explicit PROTOBUF_CONSTEXPR TruncateTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateTableExpr(const TruncateTableExpr& from);
  TruncateTableExpr(TruncateTableExpr&& from) noexcept
    : TruncateTableExpr() {
    *this = ::std::move(from);
  }

  inline TruncateTableExpr& operator=(const TruncateTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateTableExpr& operator=(TruncateTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const TruncateTableExpr* internal_default_instance() {
    return reinterpret_cast<const TruncateTableExpr*>(
               &_TruncateTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TruncateTableExpr& a, TruncateTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TruncateTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TruncateTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TruncateTableExpr& from) {
    TruncateTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TruncateTableExpr";
  }
  protected:
  explicit TruncateTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.TableId table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.TruncateTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::greptime::v1::TableId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropDatabaseExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropDatabaseExpr) */ {
 public:
  inline DropDatabaseExpr() : DropDatabaseExpr(nullptr) {}
  ~DropDatabaseExpr() override;
  explicit PROTOBUF_CONSTEXPR DropDatabaseExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropDatabaseExpr(const DropDatabaseExpr& from);
  DropDatabaseExpr(DropDatabaseExpr&& from) noexcept
    : DropDatabaseExpr() {
    *this = ::std::move(from);
  }

  inline DropDatabaseExpr& operator=(const DropDatabaseExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropDatabaseExpr& operator=(DropDatabaseExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropDatabaseExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropDatabaseExpr* internal_default_instance() {
    return reinterpret_cast<const DropDatabaseExpr*>(
               &_DropDatabaseExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DropDatabaseExpr& a, DropDatabaseExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropDatabaseExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropDatabaseExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropDatabaseExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropDatabaseExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropDatabaseExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropDatabaseExpr& from) {
    DropDatabaseExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropDatabaseExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropDatabaseExpr";
  }
  protected:
  explicit DropDatabaseExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kDropIfExistsFieldNumber = 3,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // bool drop_if_exists = 3;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropDatabaseExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumns) */ {
 public:
  inline AddColumns() : AddColumns(nullptr) {}
  ~AddColumns() override;
  explicit PROTOBUF_CONSTEXPR AddColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumns(const AddColumns& from);
  AddColumns(AddColumns&& from) noexcept
    : AddColumns() {
    *this = ::std::move(from);
  }

  inline AddColumns& operator=(const AddColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumns& operator=(AddColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumns* internal_default_instance() {
    return reinterpret_cast<const AddColumns*>(
               &_AddColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AddColumns& a, AddColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumns& from) {
    AddColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumns";
  }
  protected:
  explicit AddColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.AddColumn add_columns = 1;
  int add_columns_size() const;
  private:
  int _internal_add_columns_size() const;
  public:
  void clear_add_columns();
  ::greptime::v1::AddColumn* mutable_add_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >*
      mutable_add_columns();
  private:
  const ::greptime::v1::AddColumn& _internal_add_columns(int index) const;
  ::greptime::v1::AddColumn* _internal_add_add_columns();
  public:
  const ::greptime::v1::AddColumn& add_columns(int index) const;
  ::greptime::v1::AddColumn* add_add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >&
      add_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn > add_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropDefaults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropDefaults) */ {
 public:
  inline DropDefaults() : DropDefaults(nullptr) {}
  ~DropDefaults() override;
  explicit PROTOBUF_CONSTEXPR DropDefaults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropDefaults(const DropDefaults& from);
  DropDefaults(DropDefaults&& from) noexcept
    : DropDefaults() {
    *this = ::std::move(from);
  }

  inline DropDefaults& operator=(const DropDefaults& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropDefaults& operator=(DropDefaults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropDefaults& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropDefaults* internal_default_instance() {
    return reinterpret_cast<const DropDefaults*>(
               &_DropDefaults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DropDefaults& a, DropDefaults& b) {
    a.Swap(&b);
  }
  inline void Swap(DropDefaults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropDefaults* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropDefaults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropDefaults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropDefaults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropDefaults& from) {
    DropDefaults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropDefaults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropDefaults";
  }
  protected:
  explicit DropDefaults(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropDefaultsFieldNumber = 1,
  };
  // repeated .greptime.v1.DropDefault drop_defaults = 1;
  int drop_defaults_size() const;
  private:
  int _internal_drop_defaults_size() const;
  public:
  void clear_drop_defaults();
  ::greptime::v1::DropDefault* mutable_drop_defaults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropDefault >*
      mutable_drop_defaults();
  private:
  const ::greptime::v1::DropDefault& _internal_drop_defaults(int index) const;
  ::greptime::v1::DropDefault* _internal_add_drop_defaults();
  public:
  const ::greptime::v1::DropDefault& drop_defaults(int index) const;
  ::greptime::v1::DropDefault* add_drop_defaults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropDefault >&
      drop_defaults() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.DropDefaults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropDefault > drop_defaults_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropColumns) */ {
 public:
  inline DropColumns() : DropColumns(nullptr) {}
  ~DropColumns() override;
  explicit PROTOBUF_CONSTEXPR DropColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumns(const DropColumns& from);
  DropColumns(DropColumns&& from) noexcept
    : DropColumns() {
    *this = ::std::move(from);
  }

  inline DropColumns& operator=(const DropColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumns& operator=(DropColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumns* internal_default_instance() {
    return reinterpret_cast<const DropColumns*>(
               &_DropColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DropColumns& a, DropColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumns& from) {
    DropColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropColumns";
  }
  protected:
  explicit DropColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.DropColumn drop_columns = 1;
  int drop_columns_size() const;
  private:
  int _internal_drop_columns_size() const;
  public:
  void clear_drop_columns();
  ::greptime::v1::DropColumn* mutable_drop_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >*
      mutable_drop_columns();
  private:
  const ::greptime::v1::DropColumn& _internal_drop_columns(int index) const;
  ::greptime::v1::DropColumn* _internal_add_drop_columns();
  public:
  const ::greptime::v1::DropColumn& drop_columns(int index) const;
  ::greptime::v1::DropColumn* add_drop_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >&
      drop_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.DropColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn > drop_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ModifyColumnTypes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ModifyColumnTypes) */ {
 public:
  inline ModifyColumnTypes() : ModifyColumnTypes(nullptr) {}
  ~ModifyColumnTypes() override;
  explicit PROTOBUF_CONSTEXPR ModifyColumnTypes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyColumnTypes(const ModifyColumnTypes& from);
  ModifyColumnTypes(ModifyColumnTypes&& from) noexcept
    : ModifyColumnTypes() {
    *this = ::std::move(from);
  }

  inline ModifyColumnTypes& operator=(const ModifyColumnTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyColumnTypes& operator=(ModifyColumnTypes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyColumnTypes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyColumnTypes* internal_default_instance() {
    return reinterpret_cast<const ModifyColumnTypes*>(
               &_ModifyColumnTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ModifyColumnTypes& a, ModifyColumnTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyColumnTypes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyColumnTypes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyColumnTypes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyColumnTypes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyColumnTypes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyColumnTypes& from) {
    ModifyColumnTypes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyColumnTypes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ModifyColumnTypes";
  }
  protected:
  explicit ModifyColumnTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModifyColumnTypesFieldNumber = 1,
  };
  // repeated .greptime.v1.ModifyColumnType modify_column_types = 1;
  int modify_column_types_size() const;
  private:
  int _internal_modify_column_types_size() const;
  public:
  void clear_modify_column_types();
  ::greptime::v1::ModifyColumnType* mutable_modify_column_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ModifyColumnType >*
      mutable_modify_column_types();
  private:
  const ::greptime::v1::ModifyColumnType& _internal_modify_column_types(int index) const;
  ::greptime::v1::ModifyColumnType* _internal_add_modify_column_types();
  public:
  const ::greptime::v1::ModifyColumnType& modify_column_types(int index) const;
  ::greptime::v1::ModifyColumnType* add_modify_column_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ModifyColumnType >&
      modify_column_types() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.ModifyColumnTypes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ModifyColumnType > modify_column_types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class RenameTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.RenameTable) */ {
 public:
  inline RenameTable() : RenameTable(nullptr) {}
  ~RenameTable() override;
  explicit PROTOBUF_CONSTEXPR RenameTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameTable(const RenameTable& from);
  RenameTable(RenameTable&& from) noexcept
    : RenameTable() {
    *this = ::std::move(from);
  }

  inline RenameTable& operator=(const RenameTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameTable& operator=(RenameTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameTable* internal_default_instance() {
    return reinterpret_cast<const RenameTable*>(
               &_RenameTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RenameTable& a, RenameTable& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameTable& from) {
    RenameTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.RenameTable";
  }
  protected:
  explicit RenameTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTableNameFieldNumber = 1,
  };
  // string new_table_name = 1;
  void clear_new_table_name();
  const std::string& new_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_table_name();
  PROTOBUF_NODISCARD std::string* release_new_table_name();
  void set_allocated_new_table_name(std::string* new_table_name);
  private:
  const std::string& _internal_new_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_table_name(const std::string& value);
  std::string* _internal_mutable_new_table_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.RenameTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumn) */ {
 public:
  inline AddColumn() : AddColumn(nullptr) {}
  ~AddColumn() override;
  explicit PROTOBUF_CONSTEXPR AddColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumn(const AddColumn& from);
  AddColumn(AddColumn&& from) noexcept
    : AddColumn() {
    *this = ::std::move(from);
  }

  inline AddColumn& operator=(const AddColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumn& operator=(AddColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumn* internal_default_instance() {
    return reinterpret_cast<const AddColumn*>(
               &_AddColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AddColumn& a, AddColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumn& from) {
    AddColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumn";
  }
  protected:
  explicit AddColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefFieldNumber = 1,
    kLocationFieldNumber = 3,
    kAddIfNotExistsFieldNumber = 4,
  };
  // .greptime.v1.ColumnDef column_def = 1;
  bool has_column_def() const;
  private:
  bool _internal_has_column_def() const;
  public:
  void clear_column_def();
  const ::greptime::v1::ColumnDef& column_def() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDef* release_column_def();
  ::greptime::v1::ColumnDef* mutable_column_def();
  void set_allocated_column_def(::greptime::v1::ColumnDef* column_def);
  private:
  const ::greptime::v1::ColumnDef& _internal_column_def() const;
  ::greptime::v1::ColumnDef* _internal_mutable_column_def();
  public:
  void unsafe_arena_set_allocated_column_def(
      ::greptime::v1::ColumnDef* column_def);
  ::greptime::v1::ColumnDef* unsafe_arena_release_column_def();

  // .greptime.v1.AddColumnLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::greptime::v1::AddColumnLocation& location() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumnLocation* release_location();
  ::greptime::v1::AddColumnLocation* mutable_location();
  void set_allocated_location(::greptime::v1::AddColumnLocation* location);
  private:
  const ::greptime::v1::AddColumnLocation& _internal_location() const;
  ::greptime::v1::AddColumnLocation* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::greptime::v1::AddColumnLocation* location);
  ::greptime::v1::AddColumnLocation* unsafe_arena_release_location();

  // bool add_if_not_exists = 4;
  void clear_add_if_not_exists();
  bool add_if_not_exists() const;
  void set_add_if_not_exists(bool value);
  private:
  bool _internal_add_if_not_exists() const;
  void _internal_set_add_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::ColumnDef* column_def_;
    ::greptime::v1::AddColumnLocation* location_;
    bool add_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ModifyColumnType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ModifyColumnType) */ {
 public:
  inline ModifyColumnType() : ModifyColumnType(nullptr) {}
  ~ModifyColumnType() override;
  explicit PROTOBUF_CONSTEXPR ModifyColumnType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModifyColumnType(const ModifyColumnType& from);
  ModifyColumnType(ModifyColumnType&& from) noexcept
    : ModifyColumnType() {
    *this = ::std::move(from);
  }

  inline ModifyColumnType& operator=(const ModifyColumnType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyColumnType& operator=(ModifyColumnType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModifyColumnType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModifyColumnType* internal_default_instance() {
    return reinterpret_cast<const ModifyColumnType*>(
               &_ModifyColumnType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ModifyColumnType& a, ModifyColumnType& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyColumnType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyColumnType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModifyColumnType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModifyColumnType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModifyColumnType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModifyColumnType& from) {
    ModifyColumnType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyColumnType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ModifyColumnType";
  }
  protected:
  explicit ModifyColumnType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kTargetTypeExtensionFieldNumber = 3,
    kTargetTypeFieldNumber = 2,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .greptime.v1.ColumnDataTypeExtension target_type_extension = 3;
  bool has_target_type_extension() const;
  private:
  bool _internal_has_target_type_extension() const;
  public:
  void clear_target_type_extension();
  const ::greptime::v1::ColumnDataTypeExtension& target_type_extension() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDataTypeExtension* release_target_type_extension();
  ::greptime::v1::ColumnDataTypeExtension* mutable_target_type_extension();
  void set_allocated_target_type_extension(::greptime::v1::ColumnDataTypeExtension* target_type_extension);
  private:
  const ::greptime::v1::ColumnDataTypeExtension& _internal_target_type_extension() const;
  ::greptime::v1::ColumnDataTypeExtension* _internal_mutable_target_type_extension();
  public:
  void unsafe_arena_set_allocated_target_type_extension(
      ::greptime::v1::ColumnDataTypeExtension* target_type_extension);
  ::greptime::v1::ColumnDataTypeExtension* unsafe_arena_release_target_type_extension();

  // .greptime.v1.ColumnDataType target_type = 2;
  void clear_target_type();
  ::greptime::v1::ColumnDataType target_type() const;
  void set_target_type(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_target_type() const;
  void _internal_set_target_type(::greptime::v1::ColumnDataType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ModifyColumnType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    ::greptime::v1::ColumnDataTypeExtension* target_type_extension_;
    int target_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class Option final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Option) */ {
 public:
  inline Option() : Option(nullptr) {}
  ~Option() override;
  explicit PROTOBUF_CONSTEXPR Option(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Option(const Option& from);
  Option(Option&& from) noexcept
    : Option() {
    *this = ::std::move(from);
  }

  inline Option& operator=(const Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline Option& operator=(Option&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Option& default_instance() {
    return *internal_default_instance();
  }
  static inline const Option* internal_default_instance() {
    return reinterpret_cast<const Option*>(
               &_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Option& a, Option& b) {
    a.Swap(&b);
  }
  inline void Swap(Option* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Option* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Option* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Option>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Option& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Option& from) {
    Option::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Option* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Option";
  }
  protected:
  explicit Option(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Option)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetTableOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetTableOptions) */ {
 public:
  inline SetTableOptions() : SetTableOptions(nullptr) {}
  ~SetTableOptions() override;
  explicit PROTOBUF_CONSTEXPR SetTableOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTableOptions(const SetTableOptions& from);
  SetTableOptions(SetTableOptions&& from) noexcept
    : SetTableOptions() {
    *this = ::std::move(from);
  }

  inline SetTableOptions& operator=(const SetTableOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTableOptions& operator=(SetTableOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTableOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTableOptions* internal_default_instance() {
    return reinterpret_cast<const SetTableOptions*>(
               &_SetTableOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetTableOptions& a, SetTableOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTableOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTableOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTableOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTableOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTableOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetTableOptions& from) {
    SetTableOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTableOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetTableOptions";
  }
  protected:
  explicit SetTableOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableOptionsFieldNumber = 1,
  };
  // repeated .greptime.v1.Option table_options = 1;
  int table_options_size() const;
  private:
  int _internal_table_options_size() const;
  public:
  void clear_table_options();
  ::greptime::v1::Option* mutable_table_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >*
      mutable_table_options();
  private:
  const ::greptime::v1::Option& _internal_table_options(int index) const;
  ::greptime::v1::Option* _internal_add_table_options();
  public:
  const ::greptime::v1::Option& table_options(int index) const;
  ::greptime::v1::Option* add_table_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >&
      table_options() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.SetTableOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option > table_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetTableOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetTableOptions) */ {
 public:
  inline UnsetTableOptions() : UnsetTableOptions(nullptr) {}
  ~UnsetTableOptions() override;
  explicit PROTOBUF_CONSTEXPR UnsetTableOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetTableOptions(const UnsetTableOptions& from);
  UnsetTableOptions(UnsetTableOptions&& from) noexcept
    : UnsetTableOptions() {
    *this = ::std::move(from);
  }

  inline UnsetTableOptions& operator=(const UnsetTableOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetTableOptions& operator=(UnsetTableOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetTableOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetTableOptions* internal_default_instance() {
    return reinterpret_cast<const UnsetTableOptions*>(
               &_UnsetTableOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UnsetTableOptions& a, UnsetTableOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetTableOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetTableOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetTableOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetTableOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetTableOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetTableOptions& from) {
    UnsetTableOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetTableOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetTableOptions";
  }
  protected:
  explicit UnsetTableOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetTableOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropColumn) */ {
 public:
  inline DropColumn() : DropColumn(nullptr) {}
  ~DropColumn() override;
  explicit PROTOBUF_CONSTEXPR DropColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumn(const DropColumn& from);
  DropColumn(DropColumn&& from) noexcept
    : DropColumn() {
    *this = ::std::move(from);
  }

  inline DropColumn& operator=(const DropColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumn& operator=(DropColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumn* internal_default_instance() {
    return reinterpret_cast<const DropColumn*>(
               &_DropColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DropColumn& a, DropColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumn& from) {
    DropColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropColumn";
  }
  protected:
  explicit DropColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class TableId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TableId) */ {
 public:
  inline TableId() : TableId(nullptr) {}
  ~TableId() override;
  explicit PROTOBUF_CONSTEXPR TableId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableId(const TableId& from);
  TableId(TableId&& from) noexcept
    : TableId() {
    *this = ::std::move(from);
  }

  inline TableId& operator=(const TableId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableId& operator=(TableId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableId* internal_default_instance() {
    return reinterpret_cast<const TableId*>(
               &_TableId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TableId& a, TableId& b) {
    a.Swap(&b);
  }
  inline void Swap(TableId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableId& from) {
    TableId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TableId";
  }
  protected:
  explicit TableId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TableId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class FlowId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.FlowId) */ {
 public:
  inline FlowId() : FlowId(nullptr) {}
  ~FlowId() override;
  explicit PROTOBUF_CONSTEXPR FlowId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowId(const FlowId& from);
  FlowId(FlowId&& from) noexcept
    : FlowId() {
    *this = ::std::move(from);
  }

  inline FlowId& operator=(const FlowId& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowId& operator=(FlowId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowId& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowId* internal_default_instance() {
    return reinterpret_cast<const FlowId*>(
               &_FlowId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(FlowId& a, FlowId& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowId& from) {
    FlowId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.FlowId";
  }
  protected:
  explicit FlowId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.FlowId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ColumnDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnDef) */ {
 public:
  inline ColumnDef() : ColumnDef(nullptr) {}
  ~ColumnDef() override;
  explicit PROTOBUF_CONSTEXPR ColumnDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDef(const ColumnDef& from);
  ColumnDef(ColumnDef&& from) noexcept
    : ColumnDef() {
    *this = ::std::move(from);
  }

  inline ColumnDef& operator=(const ColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDef& operator=(ColumnDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDef* internal_default_instance() {
    return reinterpret_cast<const ColumnDef*>(
               &_ColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ColumnDef& a, ColumnDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDef& from) {
    ColumnDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnDef";
  }
  protected:
  explicit ColumnDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultConstraintFieldNumber = 4,
    kCommentFieldNumber = 6,
    kDatatypeExtensionFieldNumber = 7,
    kOptionsFieldNumber = 8,
    kDataTypeFieldNumber = 2,
    kIsNullableFieldNumber = 3,
    kSemanticTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes default_constraint = 4;
  void clear_default_constraint();
  const std::string& default_constraint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_constraint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_constraint();
  PROTOBUF_NODISCARD std::string* release_default_constraint();
  void set_allocated_default_constraint(std::string* default_constraint);
  private:
  const std::string& _internal_default_constraint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_constraint(const std::string& value);
  std::string* _internal_mutable_default_constraint();
  public:

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .greptime.v1.ColumnDataTypeExtension datatype_extension = 7;
  bool has_datatype_extension() const;
  private:
  bool _internal_has_datatype_extension() const;
  public:
  void clear_datatype_extension();
  const ::greptime::v1::ColumnDataTypeExtension& datatype_extension() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDataTypeExtension* release_datatype_extension();
  ::greptime::v1::ColumnDataTypeExtension* mutable_datatype_extension();
  void set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  private:
  const ::greptime::v1::ColumnDataTypeExtension& _internal_datatype_extension() const;
  ::greptime::v1::ColumnDataTypeExtension* _internal_mutable_datatype_extension();
  public:
  void unsafe_arena_set_allocated_datatype_extension(
      ::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  ::greptime::v1::ColumnDataTypeExtension* unsafe_arena_release_datatype_extension();

  // .greptime.v1.ColumnOptions options = 8;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::greptime::v1::ColumnOptions& options() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnOptions* release_options();
  ::greptime::v1::ColumnOptions* mutable_options();
  void set_allocated_options(::greptime::v1::ColumnOptions* options);
  private:
  const ::greptime::v1::ColumnOptions& _internal_options() const;
  ::greptime::v1::ColumnOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::greptime::v1::ColumnOptions* options);
  ::greptime::v1::ColumnOptions* unsafe_arena_release_options();

  // .greptime.v1.ColumnDataType data_type = 2;
  void clear_data_type();
  ::greptime::v1::ColumnDataType data_type() const;
  void set_data_type(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_data_type() const;
  void _internal_set_data_type(::greptime::v1::ColumnDataType value);
  public:

  // bool is_nullable = 3;
  void clear_is_nullable();
  bool is_nullable() const;
  void set_is_nullable(bool value);
  private:
  bool _internal_is_nullable() const;
  void _internal_set_is_nullable(bool value);
  public:

  // .greptime.v1.SemanticType semantic_type = 5;
  void clear_semantic_type();
  ::greptime::v1::SemanticType semantic_type() const;
  void set_semantic_type(::greptime::v1::SemanticType value);
  private:
  ::greptime::v1::SemanticType _internal_semantic_type() const;
  void _internal_set_semantic_type(::greptime::v1::SemanticType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_constraint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension_;
    ::greptime::v1::ColumnOptions* options_;
    int data_type_;
    bool is_nullable_;
    int semantic_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumnLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumnLocation) */ {
 public:
  inline AddColumnLocation() : AddColumnLocation(nullptr) {}
  ~AddColumnLocation() override;
  explicit PROTOBUF_CONSTEXPR AddColumnLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumnLocation(const AddColumnLocation& from);
  AddColumnLocation(AddColumnLocation&& from) noexcept
    : AddColumnLocation() {
    *this = ::std::move(from);
  }

  inline AddColumnLocation& operator=(const AddColumnLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumnLocation& operator=(AddColumnLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumnLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumnLocation* internal_default_instance() {
    return reinterpret_cast<const AddColumnLocation*>(
               &_AddColumnLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AddColumnLocation& a, AddColumnLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumnLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumnLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumnLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumnLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumnLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumnLocation& from) {
    AddColumnLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumnLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumnLocation";
  }
  protected:
  explicit AddColumnLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AddColumnLocation_LocationType LocationType;
  static constexpr LocationType FIRST =
    AddColumnLocation_LocationType_FIRST;
  static constexpr LocationType AFTER =
    AddColumnLocation_LocationType_AFTER;
  static inline bool LocationType_IsValid(int value) {
    return AddColumnLocation_LocationType_IsValid(value);
  }
  static constexpr LocationType LocationType_MIN =
    AddColumnLocation_LocationType_LocationType_MIN;
  static constexpr LocationType LocationType_MAX =
    AddColumnLocation_LocationType_LocationType_MAX;
  static constexpr int LocationType_ARRAYSIZE =
    AddColumnLocation_LocationType_LocationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocationType_descriptor() {
    return AddColumnLocation_LocationType_descriptor();
  }
  template<typename T>
  static inline const std::string& LocationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocationType_Name.");
    return AddColumnLocation_LocationType_Name(enum_t_value);
  }
  static inline bool LocationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocationType* value) {
    return AddColumnLocation_LocationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAfterColumnNameFieldNumber = 2,
    kLocationTypeFieldNumber = 1,
  };
  // string after_column_name = 2;
  void clear_after_column_name();
  const std::string& after_column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_after_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_after_column_name();
  PROTOBUF_NODISCARD std::string* release_after_column_name();
  void set_allocated_after_column_name(std::string* after_column_name);
  private:
  const std::string& _internal_after_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_after_column_name(const std::string& value);
  std::string* _internal_mutable_after_column_name();
  public:

  // .greptime.v1.AddColumnLocation.LocationType location_type = 1;
  void clear_location_type();
  ::greptime::v1::AddColumnLocation_LocationType location_type() const;
  void set_location_type(::greptime::v1::AddColumnLocation_LocationType value);
  private:
  ::greptime::v1::AddColumnLocation_LocationType _internal_location_type() const;
  void _internal_set_location_type(::greptime::v1::AddColumnLocation_LocationType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumnLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr after_column_name_;
    int location_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetFulltext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetFulltext) */ {
 public:
  inline SetFulltext() : SetFulltext(nullptr) {}
  ~SetFulltext() override;
  explicit PROTOBUF_CONSTEXPR SetFulltext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFulltext(const SetFulltext& from);
  SetFulltext(SetFulltext&& from) noexcept
    : SetFulltext() {
    *this = ::std::move(from);
  }

  inline SetFulltext& operator=(const SetFulltext& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFulltext& operator=(SetFulltext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFulltext& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFulltext* internal_default_instance() {
    return reinterpret_cast<const SetFulltext*>(
               &_SetFulltext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetFulltext& a, SetFulltext& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFulltext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFulltext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFulltext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFulltext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFulltext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetFulltext& from) {
    SetFulltext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFulltext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetFulltext";
  }
  protected:
  explicit SetFulltext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kAnalyzerFieldNumber = 3,
    kEnableFieldNumber = 2,
    kCaseSensitiveFieldNumber = 4,
    kGranularityFieldNumber = 6,
    kFalsePositiveRateFieldNumber = 7,
    kBackendFieldNumber = 5,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .greptime.v1.Analyzer analyzer = 3;
  void clear_analyzer();
  ::greptime::v1::Analyzer analyzer() const;
  void set_analyzer(::greptime::v1::Analyzer value);
  private:
  ::greptime::v1::Analyzer _internal_analyzer() const;
  void _internal_set_analyzer(::greptime::v1::Analyzer value);
  public:

  // bool enable = 2;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // bool case_sensitive = 4;
  void clear_case_sensitive();
  bool case_sensitive() const;
  void set_case_sensitive(bool value);
  private:
  bool _internal_case_sensitive() const;
  void _internal_set_case_sensitive(bool value);
  public:

  // uint64 granularity = 6;
  void clear_granularity();
  uint64_t granularity() const;
  void set_granularity(uint64_t value);
  private:
  uint64_t _internal_granularity() const;
  void _internal_set_granularity(uint64_t value);
  public:

  // double false_positive_rate = 7;
  void clear_false_positive_rate();
  double false_positive_rate() const;
  void set_false_positive_rate(double value);
  private:
  double _internal_false_positive_rate() const;
  void _internal_set_false_positive_rate(double value);
  public:

  // .greptime.v1.FulltextBackend backend = 5;
  void clear_backend();
  ::greptime::v1::FulltextBackend backend() const;
  void set_backend(::greptime::v1::FulltextBackend value);
  private:
  ::greptime::v1::FulltextBackend _internal_backend() const;
  void _internal_set_backend(::greptime::v1::FulltextBackend value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.SetFulltext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    int analyzer_;
    bool enable_;
    bool case_sensitive_;
    uint64_t granularity_;
    double false_positive_rate_;
    int backend_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetFulltext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetFulltext) */ {
 public:
  inline UnsetFulltext() : UnsetFulltext(nullptr) {}
  ~UnsetFulltext() override;
  explicit PROTOBUF_CONSTEXPR UnsetFulltext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetFulltext(const UnsetFulltext& from);
  UnsetFulltext(UnsetFulltext&& from) noexcept
    : UnsetFulltext() {
    *this = ::std::move(from);
  }

  inline UnsetFulltext& operator=(const UnsetFulltext& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetFulltext& operator=(UnsetFulltext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetFulltext& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetFulltext* internal_default_instance() {
    return reinterpret_cast<const UnsetFulltext*>(
               &_UnsetFulltext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UnsetFulltext& a, UnsetFulltext& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetFulltext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetFulltext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetFulltext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetFulltext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetFulltext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetFulltext& from) {
    UnsetFulltext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetFulltext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetFulltext";
  }
  protected:
  explicit UnsetFulltext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetFulltext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetInverted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetInverted) */ {
 public:
  inline SetInverted() : SetInverted(nullptr) {}
  ~SetInverted() override;
  explicit PROTOBUF_CONSTEXPR SetInverted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetInverted(const SetInverted& from);
  SetInverted(SetInverted&& from) noexcept
    : SetInverted() {
    *this = ::std::move(from);
  }

  inline SetInverted& operator=(const SetInverted& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetInverted& operator=(SetInverted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetInverted& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetInverted* internal_default_instance() {
    return reinterpret_cast<const SetInverted*>(
               &_SetInverted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SetInverted& a, SetInverted& b) {
    a.Swap(&b);
  }
  inline void Swap(SetInverted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetInverted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetInverted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetInverted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetInverted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetInverted& from) {
    SetInverted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetInverted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetInverted";
  }
  protected:
  explicit SetInverted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.SetInverted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetInverted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetInverted) */ {
 public:
  inline UnsetInverted() : UnsetInverted(nullptr) {}
  ~UnsetInverted() override;
  explicit PROTOBUF_CONSTEXPR UnsetInverted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetInverted(const UnsetInverted& from);
  UnsetInverted(UnsetInverted&& from) noexcept
    : UnsetInverted() {
    *this = ::std::move(from);
  }

  inline UnsetInverted& operator=(const UnsetInverted& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetInverted& operator=(UnsetInverted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetInverted& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetInverted* internal_default_instance() {
    return reinterpret_cast<const UnsetInverted*>(
               &_UnsetInverted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(UnsetInverted& a, UnsetInverted& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetInverted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetInverted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetInverted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetInverted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetInverted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetInverted& from) {
    UnsetInverted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetInverted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetInverted";
  }
  protected:
  explicit UnsetInverted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetInverted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetSkipping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetSkipping) */ {
 public:
  inline SetSkipping() : SetSkipping(nullptr) {}
  ~SetSkipping() override;
  explicit PROTOBUF_CONSTEXPR SetSkipping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSkipping(const SetSkipping& from);
  SetSkipping(SetSkipping&& from) noexcept
    : SetSkipping() {
    *this = ::std::move(from);
  }

  inline SetSkipping& operator=(const SetSkipping& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSkipping& operator=(SetSkipping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSkipping& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSkipping* internal_default_instance() {
    return reinterpret_cast<const SetSkipping*>(
               &_SetSkipping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(SetSkipping& a, SetSkipping& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSkipping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSkipping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSkipping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSkipping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSkipping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSkipping& from) {
    SetSkipping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSkipping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetSkipping";
  }
  protected:
  explicit SetSkipping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kGranularityFieldNumber = 3,
    kEnableFieldNumber = 2,
    kSkippingIndexTypeFieldNumber = 4,
    kFalsePositiveRateFieldNumber = 5,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // uint64 granularity = 3;
  void clear_granularity();
  uint64_t granularity() const;
  void set_granularity(uint64_t value);
  private:
  uint64_t _internal_granularity() const;
  void _internal_set_granularity(uint64_t value);
  public:

  // bool enable = 2;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // .greptime.v1.SkippingIndexType skipping_index_type = 4;
  void clear_skipping_index_type();
  ::greptime::v1::SkippingIndexType skipping_index_type() const;
  void set_skipping_index_type(::greptime::v1::SkippingIndexType value);
  private:
  ::greptime::v1::SkippingIndexType _internal_skipping_index_type() const;
  void _internal_set_skipping_index_type(::greptime::v1::SkippingIndexType value);
  public:

  // double false_positive_rate = 5;
  void clear_false_positive_rate();
  double false_positive_rate() const;
  void set_false_positive_rate(double value);
  private:
  double _internal_false_positive_rate() const;
  void _internal_set_false_positive_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.SetSkipping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    uint64_t granularity_;
    bool enable_;
    int skipping_index_type_;
    double false_positive_rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetSkipping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetSkipping) */ {
 public:
  inline UnsetSkipping() : UnsetSkipping(nullptr) {}
  ~UnsetSkipping() override;
  explicit PROTOBUF_CONSTEXPR UnsetSkipping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetSkipping(const UnsetSkipping& from);
  UnsetSkipping(UnsetSkipping&& from) noexcept
    : UnsetSkipping() {
    *this = ::std::move(from);
  }

  inline UnsetSkipping& operator=(const UnsetSkipping& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetSkipping& operator=(UnsetSkipping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetSkipping& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetSkipping* internal_default_instance() {
    return reinterpret_cast<const UnsetSkipping*>(
               &_UnsetSkipping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(UnsetSkipping& a, UnsetSkipping& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetSkipping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetSkipping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetSkipping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetSkipping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetSkipping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetSkipping& from) {
    UnsetSkipping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetSkipping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetSkipping";
  }
  protected:
  explicit UnsetSkipping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetSkipping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AlterDatabaseExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AlterDatabaseExpr) */ {
 public:
  inline AlterDatabaseExpr() : AlterDatabaseExpr(nullptr) {}
  ~AlterDatabaseExpr() override;
  explicit PROTOBUF_CONSTEXPR AlterDatabaseExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterDatabaseExpr(const AlterDatabaseExpr& from);
  AlterDatabaseExpr(AlterDatabaseExpr&& from) noexcept
    : AlterDatabaseExpr() {
    *this = ::std::move(from);
  }

  inline AlterDatabaseExpr& operator=(const AlterDatabaseExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterDatabaseExpr& operator=(AlterDatabaseExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterDatabaseExpr& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kSetDatabaseOptions = 3,
    kUnsetDatabaseOptions = 4,
    KIND_NOT_SET = 0,
  };

  static inline const AlterDatabaseExpr* internal_default_instance() {
    return reinterpret_cast<const AlterDatabaseExpr*>(
               &_AlterDatabaseExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(AlterDatabaseExpr& a, AlterDatabaseExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterDatabaseExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterDatabaseExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterDatabaseExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterDatabaseExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterDatabaseExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterDatabaseExpr& from) {
    AlterDatabaseExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterDatabaseExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AlterDatabaseExpr";
  }
  protected:
  explicit AlterDatabaseExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kSetDatabaseOptionsFieldNumber = 3,
    kUnsetDatabaseOptionsFieldNumber = 4,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // .greptime.v1.SetDatabaseOptions set_database_options = 3;
  bool has_set_database_options() const;
  private:
  bool _internal_has_set_database_options() const;
  public:
  void clear_set_database_options();
  const ::greptime::v1::SetDatabaseOptions& set_database_options() const;
  PROTOBUF_NODISCARD ::greptime::v1::SetDatabaseOptions* release_set_database_options();
  ::greptime::v1::SetDatabaseOptions* mutable_set_database_options();
  void set_allocated_set_database_options(::greptime::v1::SetDatabaseOptions* set_database_options);
  private:
  const ::greptime::v1::SetDatabaseOptions& _internal_set_database_options() const;
  ::greptime::v1::SetDatabaseOptions* _internal_mutable_set_database_options();
  public:
  void unsafe_arena_set_allocated_set_database_options(
      ::greptime::v1::SetDatabaseOptions* set_database_options);
  ::greptime::v1::SetDatabaseOptions* unsafe_arena_release_set_database_options();

  // .greptime.v1.UnsetDatabaseOptions unset_database_options = 4;
  bool has_unset_database_options() const;
  private:
  bool _internal_has_unset_database_options() const;
  public:
  void clear_unset_database_options();
  const ::greptime::v1::UnsetDatabaseOptions& unset_database_options() const;
  PROTOBUF_NODISCARD ::greptime::v1::UnsetDatabaseOptions* release_unset_database_options();
  ::greptime::v1::UnsetDatabaseOptions* mutable_unset_database_options();
  void set_allocated_unset_database_options(::greptime::v1::UnsetDatabaseOptions* unset_database_options);
  private:
  const ::greptime::v1::UnsetDatabaseOptions& _internal_unset_database_options() const;
  ::greptime::v1::UnsetDatabaseOptions* _internal_mutable_unset_database_options();
  public:
  void unsafe_arena_set_allocated_unset_database_options(
      ::greptime::v1::UnsetDatabaseOptions* unset_database_options);
  ::greptime::v1::UnsetDatabaseOptions* unsafe_arena_release_unset_database_options();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.AlterDatabaseExpr)
 private:
  class _Internal;
  void set_has_set_database_options();
  void set_has_unset_database_options();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::SetDatabaseOptions* set_database_options_;
      ::greptime::v1::UnsetDatabaseOptions* unset_database_options_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class SetDatabaseOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SetDatabaseOptions) */ {
 public:
  inline SetDatabaseOptions() : SetDatabaseOptions(nullptr) {}
  ~SetDatabaseOptions() override;
  explicit PROTOBUF_CONSTEXPR SetDatabaseOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDatabaseOptions(const SetDatabaseOptions& from);
  SetDatabaseOptions(SetDatabaseOptions&& from) noexcept
    : SetDatabaseOptions() {
    *this = ::std::move(from);
  }

  inline SetDatabaseOptions& operator=(const SetDatabaseOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDatabaseOptions& operator=(SetDatabaseOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDatabaseOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDatabaseOptions* internal_default_instance() {
    return reinterpret_cast<const SetDatabaseOptions*>(
               &_SetDatabaseOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SetDatabaseOptions& a, SetDatabaseOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDatabaseOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDatabaseOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDatabaseOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDatabaseOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetDatabaseOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetDatabaseOptions& from) {
    SetDatabaseOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDatabaseOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SetDatabaseOptions";
  }
  protected:
  explicit SetDatabaseOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetDatabaseOptionsFieldNumber = 1,
  };
  // repeated .greptime.v1.Option set_database_options = 1;
  int set_database_options_size() const;
  private:
  int _internal_set_database_options_size() const;
  public:
  void clear_set_database_options();
  ::greptime::v1::Option* mutable_set_database_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >*
      mutable_set_database_options();
  private:
  const ::greptime::v1::Option& _internal_set_database_options(int index) const;
  ::greptime::v1::Option* _internal_add_set_database_options();
  public:
  const ::greptime::v1::Option& set_database_options(int index) const;
  ::greptime::v1::Option* add_set_database_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >&
      set_database_options() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.SetDatabaseOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option > set_database_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class UnsetDatabaseOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.UnsetDatabaseOptions) */ {
 public:
  inline UnsetDatabaseOptions() : UnsetDatabaseOptions(nullptr) {}
  ~UnsetDatabaseOptions() override;
  explicit PROTOBUF_CONSTEXPR UnsetDatabaseOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsetDatabaseOptions(const UnsetDatabaseOptions& from);
  UnsetDatabaseOptions(UnsetDatabaseOptions&& from) noexcept
    : UnsetDatabaseOptions() {
    *this = ::std::move(from);
  }

  inline UnsetDatabaseOptions& operator=(const UnsetDatabaseOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsetDatabaseOptions& operator=(UnsetDatabaseOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsetDatabaseOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsetDatabaseOptions* internal_default_instance() {
    return reinterpret_cast<const UnsetDatabaseOptions*>(
               &_UnsetDatabaseOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(UnsetDatabaseOptions& a, UnsetDatabaseOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsetDatabaseOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsetDatabaseOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsetDatabaseOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsetDatabaseOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsetDatabaseOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnsetDatabaseOptions& from) {
    UnsetDatabaseOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsetDatabaseOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.UnsetDatabaseOptions";
  }
  protected:
  explicit UnsetDatabaseOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated string keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.UnsetDatabaseOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerExpr_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTriggerExpr_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTriggerExpr_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateTriggerExpr_LabelsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateTriggerExpr_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateTriggerExpr_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateTriggerExpr_LabelsEntry_DoNotUse& other);
  static const CreateTriggerExpr_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateTriggerExpr_LabelsEntry_DoNotUse*>(&_CreateTriggerExpr_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTriggerExpr.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTriggerExpr.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateTriggerExpr_AnnotationsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTriggerExpr_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTriggerExpr_AnnotationsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateTriggerExpr_AnnotationsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateTriggerExpr_AnnotationsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateTriggerExpr_AnnotationsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateTriggerExpr_AnnotationsEntry_DoNotUse& other);
  static const CreateTriggerExpr_AnnotationsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateTriggerExpr_AnnotationsEntry_DoNotUse*>(&_CreateTriggerExpr_AnnotationsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTriggerExpr.AnnotationsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTriggerExpr.AnnotationsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateTriggerExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateTriggerExpr) */ {
 public:
  inline CreateTriggerExpr() : CreateTriggerExpr(nullptr) {}
  ~CreateTriggerExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateTriggerExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTriggerExpr(const CreateTriggerExpr& from);
  CreateTriggerExpr(CreateTriggerExpr&& from) noexcept
    : CreateTriggerExpr() {
    *this = ::std::move(from);
  }

  inline CreateTriggerExpr& operator=(const CreateTriggerExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTriggerExpr& operator=(CreateTriggerExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTriggerExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTriggerExpr* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerExpr*>(
               &_CreateTriggerExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CreateTriggerExpr& a, CreateTriggerExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTriggerExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTriggerExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTriggerExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTriggerExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTriggerExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTriggerExpr& from) {
    CreateTriggerExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateTriggerExpr";
  }
  protected:
  explicit CreateTriggerExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 5,
    kLabelsFieldNumber = 6,
    kAnnotationsFieldNumber = 7,
    kCatalogNameFieldNumber = 1,
    kTriggerNameFieldNumber = 2,
    kSqlFieldNumber = 4,
    kIntervalFieldNumber = 8,
    kCreateIfNotExistsFieldNumber = 3,
  };
  // repeated .greptime.v1.NotifyChannel channels = 5;
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  ::greptime::v1::NotifyChannel* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::NotifyChannel >*
      mutable_channels();
  private:
  const ::greptime::v1::NotifyChannel& _internal_channels(int index) const;
  ::greptime::v1::NotifyChannel* _internal_add_channels();
  public:
  const ::greptime::v1::NotifyChannel& channels(int index) const;
  ::greptime::v1::NotifyChannel* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::NotifyChannel >&
      channels() const;

  // map<string, string> labels = 6;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // map<string, string> annotations = 7;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_annotations();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      annotations() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_annotations();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string trigger_name = 2;
  void clear_trigger_name();
  const std::string& trigger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_name();
  PROTOBUF_NODISCARD std::string* release_trigger_name();
  void set_allocated_trigger_name(std::string* trigger_name);
  private:
  const std::string& _internal_trigger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_name(const std::string& value);
  std::string* _internal_mutable_trigger_name();
  public:

  // string sql = 4;
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // uint64 interval = 8;
  void clear_interval();
  uint64_t interval() const;
  void set_interval(uint64_t value);
  private:
  uint64_t _internal_interval() const;
  void _internal_set_interval(uint64_t value);
  public:

  // bool create_if_not_exists = 3;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateTriggerExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::NotifyChannel > channels_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateTriggerExpr_LabelsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateTriggerExpr_AnnotationsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> annotations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    uint64_t interval_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class NotifyChannel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.NotifyChannel) */ {
 public:
  inline NotifyChannel() : NotifyChannel(nullptr) {}
  ~NotifyChannel() override;
  explicit PROTOBUF_CONSTEXPR NotifyChannel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotifyChannel(const NotifyChannel& from);
  NotifyChannel(NotifyChannel&& from) noexcept
    : NotifyChannel() {
    *this = ::std::move(from);
  }

  inline NotifyChannel& operator=(const NotifyChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyChannel& operator=(NotifyChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyChannel& default_instance() {
    return *internal_default_instance();
  }
  enum ChannelTypeCase {
    kWebhook = 2,
    CHANNEL_TYPE_NOT_SET = 0,
  };

  static inline const NotifyChannel* internal_default_instance() {
    return reinterpret_cast<const NotifyChannel*>(
               &_NotifyChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(NotifyChannel& a, NotifyChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(NotifyChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotifyChannel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotifyChannel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NotifyChannel& from) {
    NotifyChannel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyChannel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.NotifyChannel";
  }
  protected:
  explicit NotifyChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kWebhookFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .greptime.v1.WebhookOptions webhook = 2;
  bool has_webhook() const;
  private:
  bool _internal_has_webhook() const;
  public:
  void clear_webhook();
  const ::greptime::v1::WebhookOptions& webhook() const;
  PROTOBUF_NODISCARD ::greptime::v1::WebhookOptions* release_webhook();
  ::greptime::v1::WebhookOptions* mutable_webhook();
  void set_allocated_webhook(::greptime::v1::WebhookOptions* webhook);
  private:
  const ::greptime::v1::WebhookOptions& _internal_webhook() const;
  ::greptime::v1::WebhookOptions* _internal_mutable_webhook();
  public:
  void unsafe_arena_set_allocated_webhook(
      ::greptime::v1::WebhookOptions* webhook);
  ::greptime::v1::WebhookOptions* unsafe_arena_release_webhook();

  void clear_channel_type();
  ChannelTypeCase channel_type_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.NotifyChannel)
 private:
  class _Internal;
  void set_has_webhook();

  inline bool has_channel_type() const;
  inline void clear_has_channel_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    union ChannelTypeUnion {
      constexpr ChannelTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::WebhookOptions* webhook_;
    } channel_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class WebhookOptions_OptsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WebhookOptions_OptsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WebhookOptions_OptsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WebhookOptions_OptsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR WebhookOptions_OptsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WebhookOptions_OptsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WebhookOptions_OptsEntry_DoNotUse& other);
  static const WebhookOptions_OptsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WebhookOptions_OptsEntry_DoNotUse*>(&_WebhookOptions_OptsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.WebhookOptions.OptsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.WebhookOptions.OptsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class WebhookOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.WebhookOptions) */ {
 public:
  inline WebhookOptions() : WebhookOptions(nullptr) {}
  ~WebhookOptions() override;
  explicit PROTOBUF_CONSTEXPR WebhookOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebhookOptions(const WebhookOptions& from);
  WebhookOptions(WebhookOptions&& from) noexcept
    : WebhookOptions() {
    *this = ::std::move(from);
  }

  inline WebhookOptions& operator=(const WebhookOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebhookOptions& operator=(WebhookOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WebhookOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebhookOptions* internal_default_instance() {
    return reinterpret_cast<const WebhookOptions*>(
               &_WebhookOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(WebhookOptions& a, WebhookOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(WebhookOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebhookOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebhookOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebhookOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WebhookOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WebhookOptions& from) {
    WebhookOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebhookOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.WebhookOptions";
  }
  protected:
  explicit WebhookOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptsFieldNumber = 2,
    kUrlFieldNumber = 1,
  };
  // map<string, string> opts = 2;
  int opts_size() const;
  private:
  int _internal_opts_size() const;
  public:
  void clear_opts();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_opts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_opts();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      opts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_opts();

  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.WebhookOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WebhookOptions_OptsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> opts_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropTriggerExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropTriggerExpr) */ {
 public:
  inline DropTriggerExpr() : DropTriggerExpr(nullptr) {}
  ~DropTriggerExpr() override;
  explicit PROTOBUF_CONSTEXPR DropTriggerExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTriggerExpr(const DropTriggerExpr& from);
  DropTriggerExpr(DropTriggerExpr&& from) noexcept
    : DropTriggerExpr() {
    *this = ::std::move(from);
  }

  inline DropTriggerExpr& operator=(const DropTriggerExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTriggerExpr& operator=(DropTriggerExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTriggerExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTriggerExpr* internal_default_instance() {
    return reinterpret_cast<const DropTriggerExpr*>(
               &_DropTriggerExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(DropTriggerExpr& a, DropTriggerExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTriggerExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTriggerExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTriggerExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTriggerExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTriggerExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTriggerExpr& from) {
    DropTriggerExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTriggerExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropTriggerExpr";
  }
  protected:
  explicit DropTriggerExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kTriggerNameFieldNumber = 2,
    kDropIfExistsFieldNumber = 3,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string trigger_name = 2;
  void clear_trigger_name();
  const std::string& trigger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_name();
  PROTOBUF_NODISCARD std::string* release_trigger_name();
  void set_allocated_trigger_name(std::string* trigger_name);
  private:
  const std::string& _internal_trigger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_name(const std::string& value);
  std::string* _internal_mutable_trigger_name();
  public:

  // bool drop_if_exists = 3;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropTriggerExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_name_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DdlRequest

// .greptime.v1.CreateDatabaseExpr create_database = 1;
inline bool DdlRequest::_internal_has_create_database() const {
  return expr_case() == kCreateDatabase;
}
inline bool DdlRequest::has_create_database() const {
  return _internal_has_create_database();
}
inline void DdlRequest::set_has_create_database() {
  _impl_._oneof_case_[0] = kCreateDatabase;
}
inline void DdlRequest::clear_create_database() {
  if (_internal_has_create_database()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_database_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::release_create_database() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_database)
  if (_internal_has_create_database()) {
    clear_has_expr();
    ::greptime::v1::CreateDatabaseExpr* temp = _impl_.expr_.create_database_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateDatabaseExpr& DdlRequest::_internal_create_database() const {
  return _internal_has_create_database()
      ? *_impl_.expr_.create_database_
      : reinterpret_cast< ::greptime::v1::CreateDatabaseExpr&>(::greptime::v1::_CreateDatabaseExpr_default_instance_);
}
inline const ::greptime::v1::CreateDatabaseExpr& DdlRequest::create_database() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_database)
  return _internal_create_database();
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::unsafe_arena_release_create_database() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_database)
  if (_internal_has_create_database()) {
    clear_has_expr();
    ::greptime::v1::CreateDatabaseExpr* temp = _impl_.expr_.create_database_;
    _impl_.expr_.create_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_database(::greptime::v1::CreateDatabaseExpr* create_database) {
  clear_expr();
  if (create_database) {
    set_has_create_database();
    _impl_.expr_.create_database_ = create_database;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_database)
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::_internal_mutable_create_database() {
  if (!_internal_has_create_database()) {
    clear_expr();
    set_has_create_database();
    _impl_.expr_.create_database_ = CreateMaybeMessage< ::greptime::v1::CreateDatabaseExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_database_;
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::mutable_create_database() {
  ::greptime::v1::CreateDatabaseExpr* _msg = _internal_mutable_create_database();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_database)
  return _msg;
}

// .greptime.v1.CreateTableExpr create_table = 2;
inline bool DdlRequest::_internal_has_create_table() const {
  return expr_case() == kCreateTable;
}
inline bool DdlRequest::has_create_table() const {
  return _internal_has_create_table();
}
inline void DdlRequest::set_has_create_table() {
  _impl_._oneof_case_[0] = kCreateTable;
}
inline void DdlRequest::clear_create_table() {
  if (_internal_has_create_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::release_create_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_table)
  if (_internal_has_create_table()) {
    clear_has_expr();
    ::greptime::v1::CreateTableExpr* temp = _impl_.expr_.create_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateTableExpr& DdlRequest::_internal_create_table() const {
  return _internal_has_create_table()
      ? *_impl_.expr_.create_table_
      : reinterpret_cast< ::greptime::v1::CreateTableExpr&>(::greptime::v1::_CreateTableExpr_default_instance_);
}
inline const ::greptime::v1::CreateTableExpr& DdlRequest::create_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_table)
  return _internal_create_table();
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::unsafe_arena_release_create_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_table)
  if (_internal_has_create_table()) {
    clear_has_expr();
    ::greptime::v1::CreateTableExpr* temp = _impl_.expr_.create_table_;
    _impl_.expr_.create_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_table(::greptime::v1::CreateTableExpr* create_table) {
  clear_expr();
  if (create_table) {
    set_has_create_table();
    _impl_.expr_.create_table_ = create_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_table)
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::_internal_mutable_create_table() {
  if (!_internal_has_create_table()) {
    clear_expr();
    set_has_create_table();
    _impl_.expr_.create_table_ = CreateMaybeMessage< ::greptime::v1::CreateTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_table_;
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::mutable_create_table() {
  ::greptime::v1::CreateTableExpr* _msg = _internal_mutable_create_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_table)
  return _msg;
}

// .greptime.v1.AlterTableExpr alter_table = 3;
inline bool DdlRequest::_internal_has_alter_table() const {
  return expr_case() == kAlterTable;
}
inline bool DdlRequest::has_alter_table() const {
  return _internal_has_alter_table();
}
inline void DdlRequest::set_has_alter_table() {
  _impl_._oneof_case_[0] = kAlterTable;
}
inline void DdlRequest::clear_alter_table() {
  if (_internal_has_alter_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.alter_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::AlterTableExpr* DdlRequest::release_alter_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.alter_table)
  if (_internal_has_alter_table()) {
    clear_has_expr();
    ::greptime::v1::AlterTableExpr* temp = _impl_.expr_.alter_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.alter_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AlterTableExpr& DdlRequest::_internal_alter_table() const {
  return _internal_has_alter_table()
      ? *_impl_.expr_.alter_table_
      : reinterpret_cast< ::greptime::v1::AlterTableExpr&>(::greptime::v1::_AlterTableExpr_default_instance_);
}
inline const ::greptime::v1::AlterTableExpr& DdlRequest::alter_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.alter_table)
  return _internal_alter_table();
}
inline ::greptime::v1::AlterTableExpr* DdlRequest::unsafe_arena_release_alter_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.alter_table)
  if (_internal_has_alter_table()) {
    clear_has_expr();
    ::greptime::v1::AlterTableExpr* temp = _impl_.expr_.alter_table_;
    _impl_.expr_.alter_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_alter_table(::greptime::v1::AlterTableExpr* alter_table) {
  clear_expr();
  if (alter_table) {
    set_has_alter_table();
    _impl_.expr_.alter_table_ = alter_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.alter_table)
}
inline ::greptime::v1::AlterTableExpr* DdlRequest::_internal_mutable_alter_table() {
  if (!_internal_has_alter_table()) {
    clear_expr();
    set_has_alter_table();
    _impl_.expr_.alter_table_ = CreateMaybeMessage< ::greptime::v1::AlterTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.alter_table_;
}
inline ::greptime::v1::AlterTableExpr* DdlRequest::mutable_alter_table() {
  ::greptime::v1::AlterTableExpr* _msg = _internal_mutable_alter_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.alter_table)
  return _msg;
}

// .greptime.v1.DropTableExpr drop_table = 4;
inline bool DdlRequest::_internal_has_drop_table() const {
  return expr_case() == kDropTable;
}
inline bool DdlRequest::has_drop_table() const {
  return _internal_has_drop_table();
}
inline void DdlRequest::set_has_drop_table() {
  _impl_._oneof_case_[0] = kDropTable;
}
inline void DdlRequest::clear_drop_table() {
  if (_internal_has_drop_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropTableExpr* DdlRequest::release_drop_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_table)
  if (_internal_has_drop_table()) {
    clear_has_expr();
    ::greptime::v1::DropTableExpr* temp = _impl_.expr_.drop_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropTableExpr& DdlRequest::_internal_drop_table() const {
  return _internal_has_drop_table()
      ? *_impl_.expr_.drop_table_
      : reinterpret_cast< ::greptime::v1::DropTableExpr&>(::greptime::v1::_DropTableExpr_default_instance_);
}
inline const ::greptime::v1::DropTableExpr& DdlRequest::drop_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_table)
  return _internal_drop_table();
}
inline ::greptime::v1::DropTableExpr* DdlRequest::unsafe_arena_release_drop_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_table)
  if (_internal_has_drop_table()) {
    clear_has_expr();
    ::greptime::v1::DropTableExpr* temp = _impl_.expr_.drop_table_;
    _impl_.expr_.drop_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_table(::greptime::v1::DropTableExpr* drop_table) {
  clear_expr();
  if (drop_table) {
    set_has_drop_table();
    _impl_.expr_.drop_table_ = drop_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_table)
}
inline ::greptime::v1::DropTableExpr* DdlRequest::_internal_mutable_drop_table() {
  if (!_internal_has_drop_table()) {
    clear_expr();
    set_has_drop_table();
    _impl_.expr_.drop_table_ = CreateMaybeMessage< ::greptime::v1::DropTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_table_;
}
inline ::greptime::v1::DropTableExpr* DdlRequest::mutable_drop_table() {
  ::greptime::v1::DropTableExpr* _msg = _internal_mutable_drop_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_table)
  return _msg;
}

// .greptime.v1.TruncateTableExpr truncate_table = 7;
inline bool DdlRequest::_internal_has_truncate_table() const {
  return expr_case() == kTruncateTable;
}
inline bool DdlRequest::has_truncate_table() const {
  return _internal_has_truncate_table();
}
inline void DdlRequest::set_has_truncate_table() {
  _impl_._oneof_case_[0] = kTruncateTable;
}
inline void DdlRequest::clear_truncate_table() {
  if (_internal_has_truncate_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.truncate_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::release_truncate_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.truncate_table)
  if (_internal_has_truncate_table()) {
    clear_has_expr();
    ::greptime::v1::TruncateTableExpr* temp = _impl_.expr_.truncate_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.truncate_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::TruncateTableExpr& DdlRequest::_internal_truncate_table() const {
  return _internal_has_truncate_table()
      ? *_impl_.expr_.truncate_table_
      : reinterpret_cast< ::greptime::v1::TruncateTableExpr&>(::greptime::v1::_TruncateTableExpr_default_instance_);
}
inline const ::greptime::v1::TruncateTableExpr& DdlRequest::truncate_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.truncate_table)
  return _internal_truncate_table();
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::unsafe_arena_release_truncate_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.truncate_table)
  if (_internal_has_truncate_table()) {
    clear_has_expr();
    ::greptime::v1::TruncateTableExpr* temp = _impl_.expr_.truncate_table_;
    _impl_.expr_.truncate_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_truncate_table(::greptime::v1::TruncateTableExpr* truncate_table) {
  clear_expr();
  if (truncate_table) {
    set_has_truncate_table();
    _impl_.expr_.truncate_table_ = truncate_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.truncate_table)
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::_internal_mutable_truncate_table() {
  if (!_internal_has_truncate_table()) {
    clear_expr();
    set_has_truncate_table();
    _impl_.expr_.truncate_table_ = CreateMaybeMessage< ::greptime::v1::TruncateTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.truncate_table_;
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::mutable_truncate_table() {
  ::greptime::v1::TruncateTableExpr* _msg = _internal_mutable_truncate_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.truncate_table)
  return _msg;
}

// .greptime.v1.CreateFlowExpr create_flow = 8;
inline bool DdlRequest::_internal_has_create_flow() const {
  return expr_case() == kCreateFlow;
}
inline bool DdlRequest::has_create_flow() const {
  return _internal_has_create_flow();
}
inline void DdlRequest::set_has_create_flow() {
  _impl_._oneof_case_[0] = kCreateFlow;
}
inline void DdlRequest::clear_create_flow() {
  if (_internal_has_create_flow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_flow_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::release_create_flow() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_flow)
  if (_internal_has_create_flow()) {
    clear_has_expr();
    ::greptime::v1::CreateFlowExpr* temp = _impl_.expr_.create_flow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateFlowExpr& DdlRequest::_internal_create_flow() const {
  return _internal_has_create_flow()
      ? *_impl_.expr_.create_flow_
      : reinterpret_cast< ::greptime::v1::CreateFlowExpr&>(::greptime::v1::_CreateFlowExpr_default_instance_);
}
inline const ::greptime::v1::CreateFlowExpr& DdlRequest::create_flow() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_flow)
  return _internal_create_flow();
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::unsafe_arena_release_create_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_flow)
  if (_internal_has_create_flow()) {
    clear_has_expr();
    ::greptime::v1::CreateFlowExpr* temp = _impl_.expr_.create_flow_;
    _impl_.expr_.create_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_flow(::greptime::v1::CreateFlowExpr* create_flow) {
  clear_expr();
  if (create_flow) {
    set_has_create_flow();
    _impl_.expr_.create_flow_ = create_flow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_flow)
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::_internal_mutable_create_flow() {
  if (!_internal_has_create_flow()) {
    clear_expr();
    set_has_create_flow();
    _impl_.expr_.create_flow_ = CreateMaybeMessage< ::greptime::v1::CreateFlowExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_flow_;
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::mutable_create_flow() {
  ::greptime::v1::CreateFlowExpr* _msg = _internal_mutable_create_flow();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_flow)
  return _msg;
}

// .greptime.v1.DropFlowExpr drop_flow = 9;
inline bool DdlRequest::_internal_has_drop_flow() const {
  return expr_case() == kDropFlow;
}
inline bool DdlRequest::has_drop_flow() const {
  return _internal_has_drop_flow();
}
inline void DdlRequest::set_has_drop_flow() {
  _impl_._oneof_case_[0] = kDropFlow;
}
inline void DdlRequest::clear_drop_flow() {
  if (_internal_has_drop_flow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_flow_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::release_drop_flow() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_flow)
  if (_internal_has_drop_flow()) {
    clear_has_expr();
    ::greptime::v1::DropFlowExpr* temp = _impl_.expr_.drop_flow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropFlowExpr& DdlRequest::_internal_drop_flow() const {
  return _internal_has_drop_flow()
      ? *_impl_.expr_.drop_flow_
      : reinterpret_cast< ::greptime::v1::DropFlowExpr&>(::greptime::v1::_DropFlowExpr_default_instance_);
}
inline const ::greptime::v1::DropFlowExpr& DdlRequest::drop_flow() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_flow)
  return _internal_drop_flow();
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::unsafe_arena_release_drop_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_flow)
  if (_internal_has_drop_flow()) {
    clear_has_expr();
    ::greptime::v1::DropFlowExpr* temp = _impl_.expr_.drop_flow_;
    _impl_.expr_.drop_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_flow(::greptime::v1::DropFlowExpr* drop_flow) {
  clear_expr();
  if (drop_flow) {
    set_has_drop_flow();
    _impl_.expr_.drop_flow_ = drop_flow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_flow)
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::_internal_mutable_drop_flow() {
  if (!_internal_has_drop_flow()) {
    clear_expr();
    set_has_drop_flow();
    _impl_.expr_.drop_flow_ = CreateMaybeMessage< ::greptime::v1::DropFlowExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_flow_;
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::mutable_drop_flow() {
  ::greptime::v1::DropFlowExpr* _msg = _internal_mutable_drop_flow();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_flow)
  return _msg;
}

// .greptime.v1.CreateViewExpr create_view = 10;
inline bool DdlRequest::_internal_has_create_view() const {
  return expr_case() == kCreateView;
}
inline bool DdlRequest::has_create_view() const {
  return _internal_has_create_view();
}
inline void DdlRequest::set_has_create_view() {
  _impl_._oneof_case_[0] = kCreateView;
}
inline void DdlRequest::clear_create_view() {
  if (_internal_has_create_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_view_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::release_create_view() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_view)
  if (_internal_has_create_view()) {
    clear_has_expr();
    ::greptime::v1::CreateViewExpr* temp = _impl_.expr_.create_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateViewExpr& DdlRequest::_internal_create_view() const {
  return _internal_has_create_view()
      ? *_impl_.expr_.create_view_
      : reinterpret_cast< ::greptime::v1::CreateViewExpr&>(::greptime::v1::_CreateViewExpr_default_instance_);
}
inline const ::greptime::v1::CreateViewExpr& DdlRequest::create_view() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_view)
  return _internal_create_view();
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::unsafe_arena_release_create_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_view)
  if (_internal_has_create_view()) {
    clear_has_expr();
    ::greptime::v1::CreateViewExpr* temp = _impl_.expr_.create_view_;
    _impl_.expr_.create_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_view(::greptime::v1::CreateViewExpr* create_view) {
  clear_expr();
  if (create_view) {
    set_has_create_view();
    _impl_.expr_.create_view_ = create_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_view)
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::_internal_mutable_create_view() {
  if (!_internal_has_create_view()) {
    clear_expr();
    set_has_create_view();
    _impl_.expr_.create_view_ = CreateMaybeMessage< ::greptime::v1::CreateViewExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_view_;
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::mutable_create_view() {
  ::greptime::v1::CreateViewExpr* _msg = _internal_mutable_create_view();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_view)
  return _msg;
}

// .greptime.v1.DropViewExpr drop_view = 11;
inline bool DdlRequest::_internal_has_drop_view() const {
  return expr_case() == kDropView;
}
inline bool DdlRequest::has_drop_view() const {
  return _internal_has_drop_view();
}
inline void DdlRequest::set_has_drop_view() {
  _impl_._oneof_case_[0] = kDropView;
}
inline void DdlRequest::clear_drop_view() {
  if (_internal_has_drop_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_view_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropViewExpr* DdlRequest::release_drop_view() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_view)
  if (_internal_has_drop_view()) {
    clear_has_expr();
    ::greptime::v1::DropViewExpr* temp = _impl_.expr_.drop_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropViewExpr& DdlRequest::_internal_drop_view() const {
  return _internal_has_drop_view()
      ? *_impl_.expr_.drop_view_
      : reinterpret_cast< ::greptime::v1::DropViewExpr&>(::greptime::v1::_DropViewExpr_default_instance_);
}
inline const ::greptime::v1::DropViewExpr& DdlRequest::drop_view() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_view)
  return _internal_drop_view();
}
inline ::greptime::v1::DropViewExpr* DdlRequest::unsafe_arena_release_drop_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_view)
  if (_internal_has_drop_view()) {
    clear_has_expr();
    ::greptime::v1::DropViewExpr* temp = _impl_.expr_.drop_view_;
    _impl_.expr_.drop_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_view(::greptime::v1::DropViewExpr* drop_view) {
  clear_expr();
  if (drop_view) {
    set_has_drop_view();
    _impl_.expr_.drop_view_ = drop_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_view)
}
inline ::greptime::v1::DropViewExpr* DdlRequest::_internal_mutable_drop_view() {
  if (!_internal_has_drop_view()) {
    clear_expr();
    set_has_drop_view();
    _impl_.expr_.drop_view_ = CreateMaybeMessage< ::greptime::v1::DropViewExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_view_;
}
inline ::greptime::v1::DropViewExpr* DdlRequest::mutable_drop_view() {
  ::greptime::v1::DropViewExpr* _msg = _internal_mutable_drop_view();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_view)
  return _msg;
}

// .greptime.v1.AlterDatabaseExpr alter_database = 12;
inline bool DdlRequest::_internal_has_alter_database() const {
  return expr_case() == kAlterDatabase;
}
inline bool DdlRequest::has_alter_database() const {
  return _internal_has_alter_database();
}
inline void DdlRequest::set_has_alter_database() {
  _impl_._oneof_case_[0] = kAlterDatabase;
}
inline void DdlRequest::clear_alter_database() {
  if (_internal_has_alter_database()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.alter_database_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::AlterDatabaseExpr* DdlRequest::release_alter_database() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.alter_database)
  if (_internal_has_alter_database()) {
    clear_has_expr();
    ::greptime::v1::AlterDatabaseExpr* temp = _impl_.expr_.alter_database_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.alter_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AlterDatabaseExpr& DdlRequest::_internal_alter_database() const {
  return _internal_has_alter_database()
      ? *_impl_.expr_.alter_database_
      : reinterpret_cast< ::greptime::v1::AlterDatabaseExpr&>(::greptime::v1::_AlterDatabaseExpr_default_instance_);
}
inline const ::greptime::v1::AlterDatabaseExpr& DdlRequest::alter_database() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.alter_database)
  return _internal_alter_database();
}
inline ::greptime::v1::AlterDatabaseExpr* DdlRequest::unsafe_arena_release_alter_database() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.alter_database)
  if (_internal_has_alter_database()) {
    clear_has_expr();
    ::greptime::v1::AlterDatabaseExpr* temp = _impl_.expr_.alter_database_;
    _impl_.expr_.alter_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_alter_database(::greptime::v1::AlterDatabaseExpr* alter_database) {
  clear_expr();
  if (alter_database) {
    set_has_alter_database();
    _impl_.expr_.alter_database_ = alter_database;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.alter_database)
}
inline ::greptime::v1::AlterDatabaseExpr* DdlRequest::_internal_mutable_alter_database() {
  if (!_internal_has_alter_database()) {
    clear_expr();
    set_has_alter_database();
    _impl_.expr_.alter_database_ = CreateMaybeMessage< ::greptime::v1::AlterDatabaseExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.alter_database_;
}
inline ::greptime::v1::AlterDatabaseExpr* DdlRequest::mutable_alter_database() {
  ::greptime::v1::AlterDatabaseExpr* _msg = _internal_mutable_alter_database();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.alter_database)
  return _msg;
}

inline bool DdlRequest::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void DdlRequest::clear_has_expr() {
  _impl_._oneof_case_[0] = EXPR_NOT_SET;
}
inline DdlRequest::ExprCase DdlRequest::expr_case() const {
  return DdlRequest::ExprCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateFlowExpr

// string catalog_name = 1;
inline void CreateFlowExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.catalog_name)
}
inline std::string* CreateFlowExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.catalog_name)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateFlowExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateFlowExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.catalog_name)
}

// string flow_name = 2;
inline void CreateFlowExpr::clear_flow_name() {
  _impl_.flow_name_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::flow_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.flow_name)
  return _internal_flow_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_flow_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flow_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.flow_name)
}
inline std::string* CreateFlowExpr::mutable_flow_name() {
  std::string* _s = _internal_mutable_flow_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.flow_name)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_flow_name() const {
  return _impl_.flow_name_.Get();
}
inline void CreateFlowExpr::_internal_set_flow_name(const std::string& value) {
  
  _impl_.flow_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_flow_name() {
  
  return _impl_.flow_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_flow_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.flow_name)
  return _impl_.flow_name_.Release();
}
inline void CreateFlowExpr::set_allocated_flow_name(std::string* flow_name) {
  if (flow_name != nullptr) {
    
  } else {
    
  }
  _impl_.flow_name_.SetAllocated(flow_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flow_name_.IsDefault()) {
    _impl_.flow_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.flow_name)
}

// repeated .greptime.v1.TableName source_table_names = 3;
inline int CreateFlowExpr::_internal_source_table_names_size() const {
  return _impl_.source_table_names_.size();
}
inline int CreateFlowExpr::source_table_names_size() const {
  return _internal_source_table_names_size();
}
inline ::greptime::v1::TableName* CreateFlowExpr::mutable_source_table_names(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.source_table_names)
  return _impl_.source_table_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
CreateFlowExpr::mutable_source_table_names() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateFlowExpr.source_table_names)
  return &_impl_.source_table_names_;
}
inline const ::greptime::v1::TableName& CreateFlowExpr::_internal_source_table_names(int index) const {
  return _impl_.source_table_names_.Get(index);
}
inline const ::greptime::v1::TableName& CreateFlowExpr::source_table_names(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.source_table_names)
  return _internal_source_table_names(index);
}
inline ::greptime::v1::TableName* CreateFlowExpr::_internal_add_source_table_names() {
  return _impl_.source_table_names_.Add();
}
inline ::greptime::v1::TableName* CreateFlowExpr::add_source_table_names() {
  ::greptime::v1::TableName* _add = _internal_add_source_table_names();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateFlowExpr.source_table_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
CreateFlowExpr::source_table_names() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateFlowExpr.source_table_names)
  return _impl_.source_table_names_;
}

// .greptime.v1.TableName sink_table_name = 4;
inline bool CreateFlowExpr::_internal_has_sink_table_name() const {
  return this != internal_default_instance() && _impl_.sink_table_name_ != nullptr;
}
inline bool CreateFlowExpr::has_sink_table_name() const {
  return _internal_has_sink_table_name();
}
inline const ::greptime::v1::TableName& CreateFlowExpr::_internal_sink_table_name() const {
  const ::greptime::v1::TableName* p = _impl_.sink_table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableName&>(
      ::greptime::v1::_TableName_default_instance_);
}
inline const ::greptime::v1::TableName& CreateFlowExpr::sink_table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.sink_table_name)
  return _internal_sink_table_name();
}
inline void CreateFlowExpr::unsafe_arena_set_allocated_sink_table_name(
    ::greptime::v1::TableName* sink_table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_table_name_);
  }
  _impl_.sink_table_name_ = sink_table_name;
  if (sink_table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateFlowExpr.sink_table_name)
}
inline ::greptime::v1::TableName* CreateFlowExpr::release_sink_table_name() {
  
  ::greptime::v1::TableName* temp = _impl_.sink_table_name_;
  _impl_.sink_table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableName* CreateFlowExpr::unsafe_arena_release_sink_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.sink_table_name)
  
  ::greptime::v1::TableName* temp = _impl_.sink_table_name_;
  _impl_.sink_table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableName* CreateFlowExpr::_internal_mutable_sink_table_name() {
  
  if (_impl_.sink_table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableName>(GetArenaForAllocation());
    _impl_.sink_table_name_ = p;
  }
  return _impl_.sink_table_name_;
}
inline ::greptime::v1::TableName* CreateFlowExpr::mutable_sink_table_name() {
  ::greptime::v1::TableName* _msg = _internal_mutable_sink_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.sink_table_name)
  return _msg;
}
inline void CreateFlowExpr::set_allocated_sink_table_name(::greptime::v1::TableName* sink_table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_table_name_);
  }
  if (sink_table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sink_table_name));
    if (message_arena != submessage_arena) {
      sink_table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sink_table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sink_table_name_ = sink_table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.sink_table_name)
}

// bool or_replace = 5;
inline void CreateFlowExpr::clear_or_replace() {
  _impl_.or_replace_ = false;
}
inline bool CreateFlowExpr::_internal_or_replace() const {
  return _impl_.or_replace_;
}
inline bool CreateFlowExpr::or_replace() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.or_replace)
  return _internal_or_replace();
}
inline void CreateFlowExpr::_internal_set_or_replace(bool value) {
  
  _impl_.or_replace_ = value;
}
inline void CreateFlowExpr::set_or_replace(bool value) {
  _internal_set_or_replace(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.or_replace)
}

// bool create_if_not_exists = 6;
inline void CreateFlowExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateFlowExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateFlowExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateFlowExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateFlowExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.create_if_not_exists)
}

// .greptime.v1.ExpireAfter expire_after = 7;
inline bool CreateFlowExpr::_internal_has_expire_after() const {
  return this != internal_default_instance() && _impl_.expire_after_ != nullptr;
}
inline bool CreateFlowExpr::has_expire_after() const {
  return _internal_has_expire_after();
}
inline const ::greptime::v1::ExpireAfter& CreateFlowExpr::_internal_expire_after() const {
  const ::greptime::v1::ExpireAfter* p = _impl_.expire_after_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ExpireAfter&>(
      ::greptime::v1::_ExpireAfter_default_instance_);
}
inline const ::greptime::v1::ExpireAfter& CreateFlowExpr::expire_after() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.expire_after)
  return _internal_expire_after();
}
inline void CreateFlowExpr::unsafe_arena_set_allocated_expire_after(
    ::greptime::v1::ExpireAfter* expire_after) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_after_);
  }
  _impl_.expire_after_ = expire_after;
  if (expire_after) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateFlowExpr.expire_after)
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::release_expire_after() {
  
  ::greptime::v1::ExpireAfter* temp = _impl_.expire_after_;
  _impl_.expire_after_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::unsafe_arena_release_expire_after() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.expire_after)
  
  ::greptime::v1::ExpireAfter* temp = _impl_.expire_after_;
  _impl_.expire_after_ = nullptr;
  return temp;
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::_internal_mutable_expire_after() {
  
  if (_impl_.expire_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ExpireAfter>(GetArenaForAllocation());
    _impl_.expire_after_ = p;
  }
  return _impl_.expire_after_;
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::mutable_expire_after() {
  ::greptime::v1::ExpireAfter* _msg = _internal_mutable_expire_after();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.expire_after)
  return _msg;
}
inline void CreateFlowExpr::set_allocated_expire_after(::greptime::v1::ExpireAfter* expire_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_after_);
  }
  if (expire_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_after));
    if (message_arena != submessage_arena) {
      expire_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire_after, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expire_after_ = expire_after;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.expire_after)
}

// string comment = 8;
inline void CreateFlowExpr::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::comment() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.comment)
}
inline std::string* CreateFlowExpr::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.comment)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void CreateFlowExpr::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_comment() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.comment)
  return _impl_.comment_.Release();
}
inline void CreateFlowExpr::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.comment)
}

// string sql = 9;
inline void CreateFlowExpr::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::sql() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.sql)
}
inline std::string* CreateFlowExpr::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.sql)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void CreateFlowExpr::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_sql() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.sql)
  return _impl_.sql_.Release();
}
inline void CreateFlowExpr::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.sql)
}

// map<string, string> flow_options = 10;
inline int CreateFlowExpr::_internal_flow_options_size() const {
  return _impl_.flow_options_.size();
}
inline int CreateFlowExpr::flow_options_size() const {
  return _internal_flow_options_size();
}
inline void CreateFlowExpr::clear_flow_options() {
  _impl_.flow_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateFlowExpr::_internal_flow_options() const {
  return _impl_.flow_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateFlowExpr::flow_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateFlowExpr.flow_options)
  return _internal_flow_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateFlowExpr::_internal_mutable_flow_options() {
  return _impl_.flow_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateFlowExpr::mutable_flow_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateFlowExpr.flow_options)
  return _internal_mutable_flow_options();
}

// -------------------------------------------------------------------

// DropFlowExpr

// string catalog_name = 1;
inline void DropFlowExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropFlowExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropFlowExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropFlowExpr.catalog_name)
}
inline std::string* DropFlowExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropFlowExpr.catalog_name)
  return _s;
}
inline const std::string& DropFlowExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropFlowExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropFlowExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropFlowExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropFlowExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropFlowExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropFlowExpr.catalog_name)
}

// string flow_name = 2;
inline void DropFlowExpr::clear_flow_name() {
  _impl_.flow_name_.ClearToEmpty();
}
inline const std::string& DropFlowExpr::flow_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.flow_name)
  return _internal_flow_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropFlowExpr::set_flow_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flow_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropFlowExpr.flow_name)
}
inline std::string* DropFlowExpr::mutable_flow_name() {
  std::string* _s = _internal_mutable_flow_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropFlowExpr.flow_name)
  return _s;
}
inline const std::string& DropFlowExpr::_internal_flow_name() const {
  return _impl_.flow_name_.Get();
}
inline void DropFlowExpr::_internal_set_flow_name(const std::string& value) {
  
  _impl_.flow_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropFlowExpr::_internal_mutable_flow_name() {
  
  return _impl_.flow_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropFlowExpr::release_flow_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropFlowExpr.flow_name)
  return _impl_.flow_name_.Release();
}
inline void DropFlowExpr::set_allocated_flow_name(std::string* flow_name) {
  if (flow_name != nullptr) {
    
  } else {
    
  }
  _impl_.flow_name_.SetAllocated(flow_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flow_name_.IsDefault()) {
    _impl_.flow_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropFlowExpr.flow_name)
}

// .greptime.v1.FlowId flow_id = 3;
inline bool DropFlowExpr::_internal_has_flow_id() const {
  return this != internal_default_instance() && _impl_.flow_id_ != nullptr;
}
inline bool DropFlowExpr::has_flow_id() const {
  return _internal_has_flow_id();
}
inline void DropFlowExpr::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
inline const ::greptime::v1::FlowId& DropFlowExpr::_internal_flow_id() const {
  const ::greptime::v1::FlowId* p = _impl_.flow_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::FlowId&>(
      ::greptime::v1::_FlowId_default_instance_);
}
inline const ::greptime::v1::FlowId& DropFlowExpr::flow_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.flow_id)
  return _internal_flow_id();
}
inline void DropFlowExpr::unsafe_arena_set_allocated_flow_id(
    ::greptime::v1::FlowId* flow_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  _impl_.flow_id_ = flow_id;
  if (flow_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropFlowExpr.flow_id)
}
inline ::greptime::v1::FlowId* DropFlowExpr::release_flow_id() {
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::FlowId* DropFlowExpr::unsafe_arena_release_flow_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropFlowExpr.flow_id)
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::FlowId* DropFlowExpr::_internal_mutable_flow_id() {
  
  if (_impl_.flow_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::FlowId>(GetArenaForAllocation());
    _impl_.flow_id_ = p;
  }
  return _impl_.flow_id_;
}
inline ::greptime::v1::FlowId* DropFlowExpr::mutable_flow_id() {
  ::greptime::v1::FlowId* _msg = _internal_mutable_flow_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropFlowExpr.flow_id)
  return _msg;
}
inline void DropFlowExpr::set_allocated_flow_id(::greptime::v1::FlowId* flow_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flow_id_;
  }
  if (flow_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flow_id);
    if (message_arena != submessage_arena) {
      flow_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flow_id_ = flow_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropFlowExpr.flow_id)
}

// bool drop_if_exists = 5;
inline void DropFlowExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropFlowExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropFlowExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropFlowExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropFlowExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropFlowExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// CreateViewExpr

// string catalog_name = 1;
inline void CreateViewExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.catalog_name)
}
inline std::string* CreateViewExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.catalog_name)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateViewExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateViewExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateViewExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.schema_name)
}
inline std::string* CreateViewExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.schema_name)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateViewExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateViewExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.schema_name)
}

// string view_name = 3;
inline void CreateViewExpr::clear_view_name() {
  _impl_.view_name_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::view_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.view_name)
  return _internal_view_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_view_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.view_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.view_name)
}
inline std::string* CreateViewExpr::mutable_view_name() {
  std::string* _s = _internal_mutable_view_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.view_name)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_view_name() const {
  return _impl_.view_name_.Get();
}
inline void CreateViewExpr::_internal_set_view_name(const std::string& value) {
  
  _impl_.view_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_view_name() {
  
  return _impl_.view_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_view_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.view_name)
  return _impl_.view_name_.Release();
}
inline void CreateViewExpr::set_allocated_view_name(std::string* view_name) {
  if (view_name != nullptr) {
    
  } else {
    
  }
  _impl_.view_name_.SetAllocated(view_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_name_.IsDefault()) {
    _impl_.view_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.view_name)
}

// bytes logical_plan = 4;
inline void CreateViewExpr::clear_logical_plan() {
  _impl_.logical_plan_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::logical_plan() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.logical_plan)
  return _internal_logical_plan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_logical_plan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logical_plan_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.logical_plan)
}
inline std::string* CreateViewExpr::mutable_logical_plan() {
  std::string* _s = _internal_mutable_logical_plan();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.logical_plan)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_logical_plan() const {
  return _impl_.logical_plan_.Get();
}
inline void CreateViewExpr::_internal_set_logical_plan(const std::string& value) {
  
  _impl_.logical_plan_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_logical_plan() {
  
  return _impl_.logical_plan_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_logical_plan() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.logical_plan)
  return _impl_.logical_plan_.Release();
}
inline void CreateViewExpr::set_allocated_logical_plan(std::string* logical_plan) {
  if (logical_plan != nullptr) {
    
  } else {
    
  }
  _impl_.logical_plan_.SetAllocated(logical_plan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logical_plan_.IsDefault()) {
    _impl_.logical_plan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.logical_plan)
}

// bool create_if_not_exists = 5;
inline void CreateViewExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateViewExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateViewExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateViewExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateViewExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.create_if_not_exists)
}

// bool or_replace = 6;
inline void CreateViewExpr::clear_or_replace() {
  _impl_.or_replace_ = false;
}
inline bool CreateViewExpr::_internal_or_replace() const {
  return _impl_.or_replace_;
}
inline bool CreateViewExpr::or_replace() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.or_replace)
  return _internal_or_replace();
}
inline void CreateViewExpr::_internal_set_or_replace(bool value) {
  
  _impl_.or_replace_ = value;
}
inline void CreateViewExpr::set_or_replace(bool value) {
  _internal_set_or_replace(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.or_replace)
}

// repeated .greptime.v1.TableName table_names = 7;
inline int CreateViewExpr::_internal_table_names_size() const {
  return _impl_.table_names_.size();
}
inline int CreateViewExpr::table_names_size() const {
  return _internal_table_names_size();
}
inline ::greptime::v1::TableName* CreateViewExpr::mutable_table_names(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.table_names)
  return _impl_.table_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
CreateViewExpr::mutable_table_names() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateViewExpr.table_names)
  return &_impl_.table_names_;
}
inline const ::greptime::v1::TableName& CreateViewExpr::_internal_table_names(int index) const {
  return _impl_.table_names_.Get(index);
}
inline const ::greptime::v1::TableName& CreateViewExpr::table_names(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.table_names)
  return _internal_table_names(index);
}
inline ::greptime::v1::TableName* CreateViewExpr::_internal_add_table_names() {
  return _impl_.table_names_.Add();
}
inline ::greptime::v1::TableName* CreateViewExpr::add_table_names() {
  ::greptime::v1::TableName* _add = _internal_add_table_names();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.table_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
CreateViewExpr::table_names() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateViewExpr.table_names)
  return _impl_.table_names_;
}

// repeated string columns = 8;
inline int CreateViewExpr::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int CreateViewExpr::columns_size() const {
  return _internal_columns_size();
}
inline void CreateViewExpr::clear_columns() {
  _impl_.columns_.Clear();
}
inline std::string* CreateViewExpr::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateViewExpr.columns)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const std::string& CreateViewExpr::columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.columns)
  return _internal_columns(index);
}
inline std::string* CreateViewExpr::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.columns)
  return _impl_.columns_.Mutable(index);
}
inline void CreateViewExpr::set_columns(int index, const std::string& value) {
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::set_columns(int index, std::string&& value) {
  _impl_.columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::set_columns(int index, const char* value, size_t size) {
  _impl_.columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateViewExpr.columns)
}
inline std::string* CreateViewExpr::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline void CreateViewExpr::add_columns(const std::string& value) {
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::add_columns(std::string&& value) {
  _impl_.columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::add_columns(const char* value, size_t size) {
  _impl_.columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateViewExpr.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateViewExpr::columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateViewExpr.columns)
  return _impl_.columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateViewExpr::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateViewExpr.columns)
  return &_impl_.columns_;
}

// repeated string plan_columns = 9;
inline int CreateViewExpr::_internal_plan_columns_size() const {
  return _impl_.plan_columns_.size();
}
inline int CreateViewExpr::plan_columns_size() const {
  return _internal_plan_columns_size();
}
inline void CreateViewExpr::clear_plan_columns() {
  _impl_.plan_columns_.Clear();
}
inline std::string* CreateViewExpr::add_plan_columns() {
  std::string* _s = _internal_add_plan_columns();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateViewExpr.plan_columns)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_plan_columns(int index) const {
  return _impl_.plan_columns_.Get(index);
}
inline const std::string& CreateViewExpr::plan_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.plan_columns)
  return _internal_plan_columns(index);
}
inline std::string* CreateViewExpr::mutable_plan_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.plan_columns)
  return _impl_.plan_columns_.Mutable(index);
}
inline void CreateViewExpr::set_plan_columns(int index, const std::string& value) {
  _impl_.plan_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::set_plan_columns(int index, std::string&& value) {
  _impl_.plan_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::set_plan_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.plan_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::set_plan_columns(int index, const char* value, size_t size) {
  _impl_.plan_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateViewExpr.plan_columns)
}
inline std::string* CreateViewExpr::_internal_add_plan_columns() {
  return _impl_.plan_columns_.Add();
}
inline void CreateViewExpr::add_plan_columns(const std::string& value) {
  _impl_.plan_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::add_plan_columns(std::string&& value) {
  _impl_.plan_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::add_plan_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.plan_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::add_plan_columns(const char* value, size_t size) {
  _impl_.plan_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateViewExpr.plan_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateViewExpr::plan_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateViewExpr.plan_columns)
  return _impl_.plan_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateViewExpr::mutable_plan_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateViewExpr.plan_columns)
  return &_impl_.plan_columns_;
}

// string definition = 10;
inline void CreateViewExpr::clear_definition() {
  _impl_.definition_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::definition() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.definition)
  return _internal_definition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_definition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.definition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.definition)
}
inline std::string* CreateViewExpr::mutable_definition() {
  std::string* _s = _internal_mutable_definition();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.definition)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_definition() const {
  return _impl_.definition_.Get();
}
inline void CreateViewExpr::_internal_set_definition(const std::string& value) {
  
  _impl_.definition_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_definition() {
  
  return _impl_.definition_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_definition() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.definition)
  return _impl_.definition_.Release();
}
inline void CreateViewExpr::set_allocated_definition(std::string* definition) {
  if (definition != nullptr) {
    
  } else {
    
  }
  _impl_.definition_.SetAllocated(definition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.definition_.IsDefault()) {
    _impl_.definition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.definition)
}

// -------------------------------------------------------------------

// DropViewExpr

// string catalog_name = 1;
inline void DropViewExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropViewExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropViewExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.catalog_name)
}
inline std::string* DropViewExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.catalog_name)
  return _s;
}
inline const std::string& DropViewExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropViewExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropViewExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropViewExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropViewExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.catalog_name)
}

// string schema_name = 2;
inline void DropViewExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropViewExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropViewExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.schema_name)
}
inline std::string* DropViewExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.schema_name)
  return _s;
}
inline const std::string& DropViewExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropViewExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropViewExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropViewExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropViewExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.schema_name)
}

// string view_name = 3;
inline void DropViewExpr::clear_view_name() {
  _impl_.view_name_.ClearToEmpty();
}
inline const std::string& DropViewExpr::view_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.view_name)
  return _internal_view_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropViewExpr::set_view_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.view_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.view_name)
}
inline std::string* DropViewExpr::mutable_view_name() {
  std::string* _s = _internal_mutable_view_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.view_name)
  return _s;
}
inline const std::string& DropViewExpr::_internal_view_name() const {
  return _impl_.view_name_.Get();
}
inline void DropViewExpr::_internal_set_view_name(const std::string& value) {
  
  _impl_.view_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropViewExpr::_internal_mutable_view_name() {
  
  return _impl_.view_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropViewExpr::release_view_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.view_name)
  return _impl_.view_name_.Release();
}
inline void DropViewExpr::set_allocated_view_name(std::string* view_name) {
  if (view_name != nullptr) {
    
  } else {
    
  }
  _impl_.view_name_.SetAllocated(view_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_name_.IsDefault()) {
    _impl_.view_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.view_name)
}

// .greptime.v1.TableId view_id = 4;
inline bool DropViewExpr::_internal_has_view_id() const {
  return this != internal_default_instance() && _impl_.view_id_ != nullptr;
}
inline bool DropViewExpr::has_view_id() const {
  return _internal_has_view_id();
}
inline void DropViewExpr::clear_view_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.view_id_ != nullptr) {
    delete _impl_.view_id_;
  }
  _impl_.view_id_ = nullptr;
}
inline const ::greptime::v1::TableId& DropViewExpr::_internal_view_id() const {
  const ::greptime::v1::TableId* p = _impl_.view_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& DropViewExpr::view_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.view_id)
  return _internal_view_id();
}
inline void DropViewExpr::unsafe_arena_set_allocated_view_id(
    ::greptime::v1::TableId* view_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_id_);
  }
  _impl_.view_id_ = view_id;
  if (view_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropViewExpr.view_id)
}
inline ::greptime::v1::TableId* DropViewExpr::release_view_id() {
  
  ::greptime::v1::TableId* temp = _impl_.view_id_;
  _impl_.view_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* DropViewExpr::unsafe_arena_release_view_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.view_id)
  
  ::greptime::v1::TableId* temp = _impl_.view_id_;
  _impl_.view_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* DropViewExpr::_internal_mutable_view_id() {
  
  if (_impl_.view_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.view_id_ = p;
  }
  return _impl_.view_id_;
}
inline ::greptime::v1::TableId* DropViewExpr::mutable_view_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_view_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.view_id)
  return _msg;
}
inline void DropViewExpr::set_allocated_view_id(::greptime::v1::TableId* view_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.view_id_;
  }
  if (view_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_id);
    if (message_arena != submessage_arena) {
      view_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.view_id_ = view_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.view_id)
}

// bool drop_if_exists = 5;
inline void DropViewExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropViewExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropViewExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropViewExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropViewExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateTableExpr

// string catalog_name = 1;
inline void CreateTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.catalog_name)
}
inline std::string* CreateTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.catalog_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.schema_name)
}
inline std::string* CreateTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.schema_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.schema_name)
}

// string table_name = 3;
inline void CreateTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.table_name)
}
inline std::string* CreateTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.table_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void CreateTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void CreateTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.table_name)
}

// string desc = 4;
inline void CreateTableExpr::clear_desc() {
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::desc() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_desc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.desc)
}
inline std::string* CreateTableExpr::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.desc)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_desc() const {
  return _impl_.desc_.Get();
}
inline void CreateTableExpr::_internal_set_desc(const std::string& value) {
  
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_desc() {
  
  return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_desc() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.desc)
  return _impl_.desc_.Release();
}
inline void CreateTableExpr::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_.IsDefault()) {
    _impl_.desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.desc)
}

// repeated .greptime.v1.ColumnDef column_defs = 5;
inline int CreateTableExpr::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int CreateTableExpr::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void CreateTableExpr::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >*
CreateTableExpr::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.column_defs)
  return &_impl_.column_defs_;
}
inline const ::greptime::v1::ColumnDef& CreateTableExpr::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::greptime::v1::ColumnDef& CreateTableExpr::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.column_defs)
  return _internal_column_defs(index);
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::add_column_defs() {
  ::greptime::v1::ColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >&
CreateTableExpr::column_defs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.column_defs)
  return _impl_.column_defs_;
}

// string time_index = 6;
inline void CreateTableExpr::clear_time_index() {
  _impl_.time_index_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::time_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.time_index)
  return _internal_time_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_time_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.time_index)
}
inline std::string* CreateTableExpr::mutable_time_index() {
  std::string* _s = _internal_mutable_time_index();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.time_index)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_time_index() const {
  return _impl_.time_index_.Get();
}
inline void CreateTableExpr::_internal_set_time_index(const std::string& value) {
  
  _impl_.time_index_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_time_index() {
  
  return _impl_.time_index_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_time_index() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.time_index)
  return _impl_.time_index_.Release();
}
inline void CreateTableExpr::set_allocated_time_index(std::string* time_index) {
  if (time_index != nullptr) {
    
  } else {
    
  }
  _impl_.time_index_.SetAllocated(time_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_index_.IsDefault()) {
    _impl_.time_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.time_index)
}

// repeated string primary_keys = 7;
inline int CreateTableExpr::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int CreateTableExpr::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void CreateTableExpr::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* CreateTableExpr::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateTableExpr.primary_keys)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& CreateTableExpr::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* CreateTableExpr::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void CreateTableExpr::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateTableExpr.primary_keys)
}
inline std::string* CreateTableExpr::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void CreateTableExpr::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateTableExpr.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateTableExpr::primary_keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateTableExpr::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.primary_keys)
  return &_impl_.primary_keys_;
}

// bool create_if_not_exists = 8;
inline void CreateTableExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateTableExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateTableExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateTableExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateTableExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.create_if_not_exists)
}

// map<string, string> table_options = 9;
inline int CreateTableExpr::_internal_table_options_size() const {
  return _impl_.table_options_.size();
}
inline int CreateTableExpr::table_options_size() const {
  return _internal_table_options_size();
}
inline void CreateTableExpr::clear_table_options() {
  _impl_.table_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableExpr::_internal_table_options() const {
  return _impl_.table_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableExpr::table_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateTableExpr.table_options)
  return _internal_table_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableExpr::_internal_mutable_table_options() {
  return _impl_.table_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableExpr::mutable_table_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateTableExpr.table_options)
  return _internal_mutable_table_options();
}

// .greptime.v1.TableId table_id = 10;
inline bool CreateTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool CreateTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void CreateTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& CreateTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& CreateTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.table_id)
  return _internal_table_id();
}
inline void CreateTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateTableExpr.table_id)
}
inline ::greptime::v1::TableId* CreateTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* CreateTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* CreateTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* CreateTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.table_id)
  return _msg;
}
inline void CreateTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.table_id)
}

// string engine = 12;
inline void CreateTableExpr::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.engine)
}
inline std::string* CreateTableExpr::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.engine)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void CreateTableExpr::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.engine)
  return _impl_.engine_.Release();
}
inline void CreateTableExpr::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.engine)
}

// -------------------------------------------------------------------

// AlterTableExpr

// string catalog_name = 1;
inline void AlterTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& AlterTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterTableExpr.catalog_name)
}
inline std::string* AlterTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.catalog_name)
  return _s;
}
inline const std::string& AlterTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void AlterTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void AlterTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterTableExpr.catalog_name)
}

// string schema_name = 2;
inline void AlterTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& AlterTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterTableExpr.schema_name)
}
inline std::string* AlterTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.schema_name)
  return _s;
}
inline const std::string& AlterTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void AlterTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void AlterTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterTableExpr.schema_name)
}

// string table_name = 3;
inline void AlterTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& AlterTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterTableExpr.table_name)
}
inline std::string* AlterTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.table_name)
  return _s;
}
inline const std::string& AlterTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void AlterTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void AlterTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterTableExpr.table_name)
}

// .greptime.v1.AddColumns add_columns = 4;
inline bool AlterTableExpr::_internal_has_add_columns() const {
  return kind_case() == kAddColumns;
}
inline bool AlterTableExpr::has_add_columns() const {
  return _internal_has_add_columns();
}
inline void AlterTableExpr::set_has_add_columns() {
  _impl_._oneof_case_[0] = kAddColumns;
}
inline void AlterTableExpr::clear_add_columns() {
  if (_internal_has_add_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.add_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::AddColumns* AlterTableExpr::release_add_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::AddColumns* temp = _impl_.kind_.add_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AddColumns& AlterTableExpr::_internal_add_columns() const {
  return _internal_has_add_columns()
      ? *_impl_.kind_.add_columns_
      : reinterpret_cast< ::greptime::v1::AddColumns&>(::greptime::v1::_AddColumns_default_instance_);
}
inline const ::greptime::v1::AddColumns& AlterTableExpr::add_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.add_columns)
  return _internal_add_columns();
}
inline ::greptime::v1::AddColumns* AlterTableExpr::unsafe_arena_release_add_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::AddColumns* temp = _impl_.kind_.add_columns_;
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_add_columns(::greptime::v1::AddColumns* add_columns) {
  clear_kind();
  if (add_columns) {
    set_has_add_columns();
    _impl_.kind_.add_columns_ = add_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.add_columns)
}
inline ::greptime::v1::AddColumns* AlterTableExpr::_internal_mutable_add_columns() {
  if (!_internal_has_add_columns()) {
    clear_kind();
    set_has_add_columns();
    _impl_.kind_.add_columns_ = CreateMaybeMessage< ::greptime::v1::AddColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.add_columns_;
}
inline ::greptime::v1::AddColumns* AlterTableExpr::mutable_add_columns() {
  ::greptime::v1::AddColumns* _msg = _internal_mutable_add_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.add_columns)
  return _msg;
}

// .greptime.v1.DropColumns drop_columns = 5;
inline bool AlterTableExpr::_internal_has_drop_columns() const {
  return kind_case() == kDropColumns;
}
inline bool AlterTableExpr::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void AlterTableExpr::set_has_drop_columns() {
  _impl_._oneof_case_[0] = kDropColumns;
}
inline void AlterTableExpr::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.drop_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::DropColumns* AlterTableExpr::release_drop_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::DropColumns* temp = _impl_.kind_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropColumns& AlterTableExpr::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *_impl_.kind_.drop_columns_
      : reinterpret_cast< ::greptime::v1::DropColumns&>(::greptime::v1::_DropColumns_default_instance_);
}
inline const ::greptime::v1::DropColumns& AlterTableExpr::drop_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.drop_columns)
  return _internal_drop_columns();
}
inline ::greptime::v1::DropColumns* AlterTableExpr::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::DropColumns* temp = _impl_.kind_.drop_columns_;
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_drop_columns(::greptime::v1::DropColumns* drop_columns) {
  clear_kind();
  if (drop_columns) {
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.drop_columns)
}
inline ::greptime::v1::DropColumns* AlterTableExpr::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_kind();
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = CreateMaybeMessage< ::greptime::v1::DropColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.drop_columns_;
}
inline ::greptime::v1::DropColumns* AlterTableExpr::mutable_drop_columns() {
  ::greptime::v1::DropColumns* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.drop_columns)
  return _msg;
}

// .greptime.v1.RenameTable rename_table = 6;
inline bool AlterTableExpr::_internal_has_rename_table() const {
  return kind_case() == kRenameTable;
}
inline bool AlterTableExpr::has_rename_table() const {
  return _internal_has_rename_table();
}
inline void AlterTableExpr::set_has_rename_table() {
  _impl_._oneof_case_[0] = kRenameTable;
}
inline void AlterTableExpr::clear_rename_table() {
  if (_internal_has_rename_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.rename_table_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::RenameTable* AlterTableExpr::release_rename_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.rename_table)
  if (_internal_has_rename_table()) {
    clear_has_kind();
    ::greptime::v1::RenameTable* temp = _impl_.kind_.rename_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.rename_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::RenameTable& AlterTableExpr::_internal_rename_table() const {
  return _internal_has_rename_table()
      ? *_impl_.kind_.rename_table_
      : reinterpret_cast< ::greptime::v1::RenameTable&>(::greptime::v1::_RenameTable_default_instance_);
}
inline const ::greptime::v1::RenameTable& AlterTableExpr::rename_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.rename_table)
  return _internal_rename_table();
}
inline ::greptime::v1::RenameTable* AlterTableExpr::unsafe_arena_release_rename_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.rename_table)
  if (_internal_has_rename_table()) {
    clear_has_kind();
    ::greptime::v1::RenameTable* temp = _impl_.kind_.rename_table_;
    _impl_.kind_.rename_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_rename_table(::greptime::v1::RenameTable* rename_table) {
  clear_kind();
  if (rename_table) {
    set_has_rename_table();
    _impl_.kind_.rename_table_ = rename_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.rename_table)
}
inline ::greptime::v1::RenameTable* AlterTableExpr::_internal_mutable_rename_table() {
  if (!_internal_has_rename_table()) {
    clear_kind();
    set_has_rename_table();
    _impl_.kind_.rename_table_ = CreateMaybeMessage< ::greptime::v1::RenameTable >(GetArenaForAllocation());
  }
  return _impl_.kind_.rename_table_;
}
inline ::greptime::v1::RenameTable* AlterTableExpr::mutable_rename_table() {
  ::greptime::v1::RenameTable* _msg = _internal_mutable_rename_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.rename_table)
  return _msg;
}

// .greptime.v1.ModifyColumnTypes modify_column_types = 7;
inline bool AlterTableExpr::_internal_has_modify_column_types() const {
  return kind_case() == kModifyColumnTypes;
}
inline bool AlterTableExpr::has_modify_column_types() const {
  return _internal_has_modify_column_types();
}
inline void AlterTableExpr::set_has_modify_column_types() {
  _impl_._oneof_case_[0] = kModifyColumnTypes;
}
inline void AlterTableExpr::clear_modify_column_types() {
  if (_internal_has_modify_column_types()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.modify_column_types_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::ModifyColumnTypes* AlterTableExpr::release_modify_column_types() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.modify_column_types)
  if (_internal_has_modify_column_types()) {
    clear_has_kind();
    ::greptime::v1::ModifyColumnTypes* temp = _impl_.kind_.modify_column_types_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.modify_column_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::ModifyColumnTypes& AlterTableExpr::_internal_modify_column_types() const {
  return _internal_has_modify_column_types()
      ? *_impl_.kind_.modify_column_types_
      : reinterpret_cast< ::greptime::v1::ModifyColumnTypes&>(::greptime::v1::_ModifyColumnTypes_default_instance_);
}
inline const ::greptime::v1::ModifyColumnTypes& AlterTableExpr::modify_column_types() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.modify_column_types)
  return _internal_modify_column_types();
}
inline ::greptime::v1::ModifyColumnTypes* AlterTableExpr::unsafe_arena_release_modify_column_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.modify_column_types)
  if (_internal_has_modify_column_types()) {
    clear_has_kind();
    ::greptime::v1::ModifyColumnTypes* temp = _impl_.kind_.modify_column_types_;
    _impl_.kind_.modify_column_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_modify_column_types(::greptime::v1::ModifyColumnTypes* modify_column_types) {
  clear_kind();
  if (modify_column_types) {
    set_has_modify_column_types();
    _impl_.kind_.modify_column_types_ = modify_column_types;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.modify_column_types)
}
inline ::greptime::v1::ModifyColumnTypes* AlterTableExpr::_internal_mutable_modify_column_types() {
  if (!_internal_has_modify_column_types()) {
    clear_kind();
    set_has_modify_column_types();
    _impl_.kind_.modify_column_types_ = CreateMaybeMessage< ::greptime::v1::ModifyColumnTypes >(GetArenaForAllocation());
  }
  return _impl_.kind_.modify_column_types_;
}
inline ::greptime::v1::ModifyColumnTypes* AlterTableExpr::mutable_modify_column_types() {
  ::greptime::v1::ModifyColumnTypes* _msg = _internal_mutable_modify_column_types();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.modify_column_types)
  return _msg;
}

// .greptime.v1.SetTableOptions set_table_options = 8;
inline bool AlterTableExpr::_internal_has_set_table_options() const {
  return kind_case() == kSetTableOptions;
}
inline bool AlterTableExpr::has_set_table_options() const {
  return _internal_has_set_table_options();
}
inline void AlterTableExpr::set_has_set_table_options() {
  _impl_._oneof_case_[0] = kSetTableOptions;
}
inline void AlterTableExpr::clear_set_table_options() {
  if (_internal_has_set_table_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.set_table_options_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::SetTableOptions* AlterTableExpr::release_set_table_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.set_table_options)
  if (_internal_has_set_table_options()) {
    clear_has_kind();
    ::greptime::v1::SetTableOptions* temp = _impl_.kind_.set_table_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.set_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetTableOptions& AlterTableExpr::_internal_set_table_options() const {
  return _internal_has_set_table_options()
      ? *_impl_.kind_.set_table_options_
      : reinterpret_cast< ::greptime::v1::SetTableOptions&>(::greptime::v1::_SetTableOptions_default_instance_);
}
inline const ::greptime::v1::SetTableOptions& AlterTableExpr::set_table_options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.set_table_options)
  return _internal_set_table_options();
}
inline ::greptime::v1::SetTableOptions* AlterTableExpr::unsafe_arena_release_set_table_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.set_table_options)
  if (_internal_has_set_table_options()) {
    clear_has_kind();
    ::greptime::v1::SetTableOptions* temp = _impl_.kind_.set_table_options_;
    _impl_.kind_.set_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_set_table_options(::greptime::v1::SetTableOptions* set_table_options) {
  clear_kind();
  if (set_table_options) {
    set_has_set_table_options();
    _impl_.kind_.set_table_options_ = set_table_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.set_table_options)
}
inline ::greptime::v1::SetTableOptions* AlterTableExpr::_internal_mutable_set_table_options() {
  if (!_internal_has_set_table_options()) {
    clear_kind();
    set_has_set_table_options();
    _impl_.kind_.set_table_options_ = CreateMaybeMessage< ::greptime::v1::SetTableOptions >(GetArenaForAllocation());
  }
  return _impl_.kind_.set_table_options_;
}
inline ::greptime::v1::SetTableOptions* AlterTableExpr::mutable_set_table_options() {
  ::greptime::v1::SetTableOptions* _msg = _internal_mutable_set_table_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.set_table_options)
  return _msg;
}

// .greptime.v1.UnsetTableOptions unset_table_options = 11;
inline bool AlterTableExpr::_internal_has_unset_table_options() const {
  return kind_case() == kUnsetTableOptions;
}
inline bool AlterTableExpr::has_unset_table_options() const {
  return _internal_has_unset_table_options();
}
inline void AlterTableExpr::set_has_unset_table_options() {
  _impl_._oneof_case_[0] = kUnsetTableOptions;
}
inline void AlterTableExpr::clear_unset_table_options() {
  if (_internal_has_unset_table_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.unset_table_options_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::UnsetTableOptions* AlterTableExpr::release_unset_table_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.unset_table_options)
  if (_internal_has_unset_table_options()) {
    clear_has_kind();
    ::greptime::v1::UnsetTableOptions* temp = _impl_.kind_.unset_table_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unset_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetTableOptions& AlterTableExpr::_internal_unset_table_options() const {
  return _internal_has_unset_table_options()
      ? *_impl_.kind_.unset_table_options_
      : reinterpret_cast< ::greptime::v1::UnsetTableOptions&>(::greptime::v1::_UnsetTableOptions_default_instance_);
}
inline const ::greptime::v1::UnsetTableOptions& AlterTableExpr::unset_table_options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.unset_table_options)
  return _internal_unset_table_options();
}
inline ::greptime::v1::UnsetTableOptions* AlterTableExpr::unsafe_arena_release_unset_table_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.unset_table_options)
  if (_internal_has_unset_table_options()) {
    clear_has_kind();
    ::greptime::v1::UnsetTableOptions* temp = _impl_.kind_.unset_table_options_;
    _impl_.kind_.unset_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_unset_table_options(::greptime::v1::UnsetTableOptions* unset_table_options) {
  clear_kind();
  if (unset_table_options) {
    set_has_unset_table_options();
    _impl_.kind_.unset_table_options_ = unset_table_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.unset_table_options)
}
inline ::greptime::v1::UnsetTableOptions* AlterTableExpr::_internal_mutable_unset_table_options() {
  if (!_internal_has_unset_table_options()) {
    clear_kind();
    set_has_unset_table_options();
    _impl_.kind_.unset_table_options_ = CreateMaybeMessage< ::greptime::v1::UnsetTableOptions >(GetArenaForAllocation());
  }
  return _impl_.kind_.unset_table_options_;
}
inline ::greptime::v1::UnsetTableOptions* AlterTableExpr::mutable_unset_table_options() {
  ::greptime::v1::UnsetTableOptions* _msg = _internal_mutable_unset_table_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.unset_table_options)
  return _msg;
}

// .greptime.v1.SetIndex set_index = 12;
inline bool AlterTableExpr::_internal_has_set_index() const {
  return kind_case() == kSetIndex;
}
inline bool AlterTableExpr::has_set_index() const {
  return _internal_has_set_index();
}
inline void AlterTableExpr::set_has_set_index() {
  _impl_._oneof_case_[0] = kSetIndex;
}
inline void AlterTableExpr::clear_set_index() {
  if (_internal_has_set_index()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.set_index_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::SetIndex* AlterTableExpr::release_set_index() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.set_index)
  if (_internal_has_set_index()) {
    clear_has_kind();
    ::greptime::v1::SetIndex* temp = _impl_.kind_.set_index_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.set_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetIndex& AlterTableExpr::_internal_set_index() const {
  return _internal_has_set_index()
      ? *_impl_.kind_.set_index_
      : reinterpret_cast< ::greptime::v1::SetIndex&>(::greptime::v1::_SetIndex_default_instance_);
}
inline const ::greptime::v1::SetIndex& AlterTableExpr::set_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.set_index)
  return _internal_set_index();
}
inline ::greptime::v1::SetIndex* AlterTableExpr::unsafe_arena_release_set_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.set_index)
  if (_internal_has_set_index()) {
    clear_has_kind();
    ::greptime::v1::SetIndex* temp = _impl_.kind_.set_index_;
    _impl_.kind_.set_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_set_index(::greptime::v1::SetIndex* set_index) {
  clear_kind();
  if (set_index) {
    set_has_set_index();
    _impl_.kind_.set_index_ = set_index;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.set_index)
}
inline ::greptime::v1::SetIndex* AlterTableExpr::_internal_mutable_set_index() {
  if (!_internal_has_set_index()) {
    clear_kind();
    set_has_set_index();
    _impl_.kind_.set_index_ = CreateMaybeMessage< ::greptime::v1::SetIndex >(GetArenaForAllocation());
  }
  return _impl_.kind_.set_index_;
}
inline ::greptime::v1::SetIndex* AlterTableExpr::mutable_set_index() {
  ::greptime::v1::SetIndex* _msg = _internal_mutable_set_index();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.set_index)
  return _msg;
}

// .greptime.v1.UnsetIndex unset_index = 13;
inline bool AlterTableExpr::_internal_has_unset_index() const {
  return kind_case() == kUnsetIndex;
}
inline bool AlterTableExpr::has_unset_index() const {
  return _internal_has_unset_index();
}
inline void AlterTableExpr::set_has_unset_index() {
  _impl_._oneof_case_[0] = kUnsetIndex;
}
inline void AlterTableExpr::clear_unset_index() {
  if (_internal_has_unset_index()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.unset_index_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::UnsetIndex* AlterTableExpr::release_unset_index() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.unset_index)
  if (_internal_has_unset_index()) {
    clear_has_kind();
    ::greptime::v1::UnsetIndex* temp = _impl_.kind_.unset_index_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unset_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetIndex& AlterTableExpr::_internal_unset_index() const {
  return _internal_has_unset_index()
      ? *_impl_.kind_.unset_index_
      : reinterpret_cast< ::greptime::v1::UnsetIndex&>(::greptime::v1::_UnsetIndex_default_instance_);
}
inline const ::greptime::v1::UnsetIndex& AlterTableExpr::unset_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.unset_index)
  return _internal_unset_index();
}
inline ::greptime::v1::UnsetIndex* AlterTableExpr::unsafe_arena_release_unset_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.unset_index)
  if (_internal_has_unset_index()) {
    clear_has_kind();
    ::greptime::v1::UnsetIndex* temp = _impl_.kind_.unset_index_;
    _impl_.kind_.unset_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_unset_index(::greptime::v1::UnsetIndex* unset_index) {
  clear_kind();
  if (unset_index) {
    set_has_unset_index();
    _impl_.kind_.unset_index_ = unset_index;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.unset_index)
}
inline ::greptime::v1::UnsetIndex* AlterTableExpr::_internal_mutable_unset_index() {
  if (!_internal_has_unset_index()) {
    clear_kind();
    set_has_unset_index();
    _impl_.kind_.unset_index_ = CreateMaybeMessage< ::greptime::v1::UnsetIndex >(GetArenaForAllocation());
  }
  return _impl_.kind_.unset_index_;
}
inline ::greptime::v1::UnsetIndex* AlterTableExpr::mutable_unset_index() {
  ::greptime::v1::UnsetIndex* _msg = _internal_mutable_unset_index();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.unset_index)
  return _msg;
}

// .greptime.v1.DropDefaults drop_defaults = 14;
inline bool AlterTableExpr::_internal_has_drop_defaults() const {
  return kind_case() == kDropDefaults;
}
inline bool AlterTableExpr::has_drop_defaults() const {
  return _internal_has_drop_defaults();
}
inline void AlterTableExpr::set_has_drop_defaults() {
  _impl_._oneof_case_[0] = kDropDefaults;
}
inline void AlterTableExpr::clear_drop_defaults() {
  if (_internal_has_drop_defaults()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.drop_defaults_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::DropDefaults* AlterTableExpr::release_drop_defaults() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.drop_defaults)
  if (_internal_has_drop_defaults()) {
    clear_has_kind();
    ::greptime::v1::DropDefaults* temp = _impl_.kind_.drop_defaults_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.drop_defaults_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropDefaults& AlterTableExpr::_internal_drop_defaults() const {
  return _internal_has_drop_defaults()
      ? *_impl_.kind_.drop_defaults_
      : reinterpret_cast< ::greptime::v1::DropDefaults&>(::greptime::v1::_DropDefaults_default_instance_);
}
inline const ::greptime::v1::DropDefaults& AlterTableExpr::drop_defaults() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.drop_defaults)
  return _internal_drop_defaults();
}
inline ::greptime::v1::DropDefaults* AlterTableExpr::unsafe_arena_release_drop_defaults() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.drop_defaults)
  if (_internal_has_drop_defaults()) {
    clear_has_kind();
    ::greptime::v1::DropDefaults* temp = _impl_.kind_.drop_defaults_;
    _impl_.kind_.drop_defaults_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_drop_defaults(::greptime::v1::DropDefaults* drop_defaults) {
  clear_kind();
  if (drop_defaults) {
    set_has_drop_defaults();
    _impl_.kind_.drop_defaults_ = drop_defaults;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.drop_defaults)
}
inline ::greptime::v1::DropDefaults* AlterTableExpr::_internal_mutable_drop_defaults() {
  if (!_internal_has_drop_defaults()) {
    clear_kind();
    set_has_drop_defaults();
    _impl_.kind_.drop_defaults_ = CreateMaybeMessage< ::greptime::v1::DropDefaults >(GetArenaForAllocation());
  }
  return _impl_.kind_.drop_defaults_;
}
inline ::greptime::v1::DropDefaults* AlterTableExpr::mutable_drop_defaults() {
  ::greptime::v1::DropDefaults* _msg = _internal_mutable_drop_defaults();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.drop_defaults)
  return _msg;
}

// .greptime.v1.SetIndexes set_indexes = 15;
inline bool AlterTableExpr::_internal_has_set_indexes() const {
  return kind_case() == kSetIndexes;
}
inline bool AlterTableExpr::has_set_indexes() const {
  return _internal_has_set_indexes();
}
inline void AlterTableExpr::set_has_set_indexes() {
  _impl_._oneof_case_[0] = kSetIndexes;
}
inline void AlterTableExpr::clear_set_indexes() {
  if (_internal_has_set_indexes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.set_indexes_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::SetIndexes* AlterTableExpr::release_set_indexes() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.set_indexes)
  if (_internal_has_set_indexes()) {
    clear_has_kind();
    ::greptime::v1::SetIndexes* temp = _impl_.kind_.set_indexes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.set_indexes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetIndexes& AlterTableExpr::_internal_set_indexes() const {
  return _internal_has_set_indexes()
      ? *_impl_.kind_.set_indexes_
      : reinterpret_cast< ::greptime::v1::SetIndexes&>(::greptime::v1::_SetIndexes_default_instance_);
}
inline const ::greptime::v1::SetIndexes& AlterTableExpr::set_indexes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.set_indexes)
  return _internal_set_indexes();
}
inline ::greptime::v1::SetIndexes* AlterTableExpr::unsafe_arena_release_set_indexes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.set_indexes)
  if (_internal_has_set_indexes()) {
    clear_has_kind();
    ::greptime::v1::SetIndexes* temp = _impl_.kind_.set_indexes_;
    _impl_.kind_.set_indexes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_set_indexes(::greptime::v1::SetIndexes* set_indexes) {
  clear_kind();
  if (set_indexes) {
    set_has_set_indexes();
    _impl_.kind_.set_indexes_ = set_indexes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.set_indexes)
}
inline ::greptime::v1::SetIndexes* AlterTableExpr::_internal_mutable_set_indexes() {
  if (!_internal_has_set_indexes()) {
    clear_kind();
    set_has_set_indexes();
    _impl_.kind_.set_indexes_ = CreateMaybeMessage< ::greptime::v1::SetIndexes >(GetArenaForAllocation());
  }
  return _impl_.kind_.set_indexes_;
}
inline ::greptime::v1::SetIndexes* AlterTableExpr::mutable_set_indexes() {
  ::greptime::v1::SetIndexes* _msg = _internal_mutable_set_indexes();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.set_indexes)
  return _msg;
}

// .greptime.v1.UnsetIndexes unset_indexes = 16;
inline bool AlterTableExpr::_internal_has_unset_indexes() const {
  return kind_case() == kUnsetIndexes;
}
inline bool AlterTableExpr::has_unset_indexes() const {
  return _internal_has_unset_indexes();
}
inline void AlterTableExpr::set_has_unset_indexes() {
  _impl_._oneof_case_[0] = kUnsetIndexes;
}
inline void AlterTableExpr::clear_unset_indexes() {
  if (_internal_has_unset_indexes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.unset_indexes_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::UnsetIndexes* AlterTableExpr::release_unset_indexes() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterTableExpr.unset_indexes)
  if (_internal_has_unset_indexes()) {
    clear_has_kind();
    ::greptime::v1::UnsetIndexes* temp = _impl_.kind_.unset_indexes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unset_indexes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetIndexes& AlterTableExpr::_internal_unset_indexes() const {
  return _internal_has_unset_indexes()
      ? *_impl_.kind_.unset_indexes_
      : reinterpret_cast< ::greptime::v1::UnsetIndexes&>(::greptime::v1::_UnsetIndexes_default_instance_);
}
inline const ::greptime::v1::UnsetIndexes& AlterTableExpr::unset_indexes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterTableExpr.unset_indexes)
  return _internal_unset_indexes();
}
inline ::greptime::v1::UnsetIndexes* AlterTableExpr::unsafe_arena_release_unset_indexes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterTableExpr.unset_indexes)
  if (_internal_has_unset_indexes()) {
    clear_has_kind();
    ::greptime::v1::UnsetIndexes* temp = _impl_.kind_.unset_indexes_;
    _impl_.kind_.unset_indexes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterTableExpr::unsafe_arena_set_allocated_unset_indexes(::greptime::v1::UnsetIndexes* unset_indexes) {
  clear_kind();
  if (unset_indexes) {
    set_has_unset_indexes();
    _impl_.kind_.unset_indexes_ = unset_indexes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterTableExpr.unset_indexes)
}
inline ::greptime::v1::UnsetIndexes* AlterTableExpr::_internal_mutable_unset_indexes() {
  if (!_internal_has_unset_indexes()) {
    clear_kind();
    set_has_unset_indexes();
    _impl_.kind_.unset_indexes_ = CreateMaybeMessage< ::greptime::v1::UnsetIndexes >(GetArenaForAllocation());
  }
  return _impl_.kind_.unset_indexes_;
}
inline ::greptime::v1::UnsetIndexes* AlterTableExpr::mutable_unset_indexes() {
  ::greptime::v1::UnsetIndexes* _msg = _internal_mutable_unset_indexes();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterTableExpr.unset_indexes)
  return _msg;
}

inline bool AlterTableExpr::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AlterTableExpr::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline AlterTableExpr::KindCase AlterTableExpr::kind_case() const {
  return AlterTableExpr::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DropDefault

// string column_name = 1;
inline void DropDefault::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& DropDefault::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDefault.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDefault::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropDefault.column_name)
}
inline std::string* DropDefault::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropDefault.column_name)
  return _s;
}
inline const std::string& DropDefault::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void DropDefault::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDefault::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDefault::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropDefault.column_name)
  return _impl_.column_name_.Release();
}
inline void DropDefault::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropDefault.column_name)
}

// -------------------------------------------------------------------

// SetIndexes

// repeated .greptime.v1.SetIndex set_indexes = 1;
inline int SetIndexes::_internal_set_indexes_size() const {
  return _impl_.set_indexes_.size();
}
inline int SetIndexes::set_indexes_size() const {
  return _internal_set_indexes_size();
}
inline void SetIndexes::clear_set_indexes() {
  _impl_.set_indexes_.Clear();
}
inline ::greptime::v1::SetIndex* SetIndexes::mutable_set_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetIndexes.set_indexes)
  return _impl_.set_indexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::SetIndex >*
SetIndexes::mutable_set_indexes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.SetIndexes.set_indexes)
  return &_impl_.set_indexes_;
}
inline const ::greptime::v1::SetIndex& SetIndexes::_internal_set_indexes(int index) const {
  return _impl_.set_indexes_.Get(index);
}
inline const ::greptime::v1::SetIndex& SetIndexes::set_indexes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetIndexes.set_indexes)
  return _internal_set_indexes(index);
}
inline ::greptime::v1::SetIndex* SetIndexes::_internal_add_set_indexes() {
  return _impl_.set_indexes_.Add();
}
inline ::greptime::v1::SetIndex* SetIndexes::add_set_indexes() {
  ::greptime::v1::SetIndex* _add = _internal_add_set_indexes();
  // @@protoc_insertion_point(field_add:greptime.v1.SetIndexes.set_indexes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::SetIndex >&
SetIndexes::set_indexes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.SetIndexes.set_indexes)
  return _impl_.set_indexes_;
}

// -------------------------------------------------------------------

// UnsetIndexes

// repeated .greptime.v1.UnsetIndex unset_indexes = 1;
inline int UnsetIndexes::_internal_unset_indexes_size() const {
  return _impl_.unset_indexes_.size();
}
inline int UnsetIndexes::unset_indexes_size() const {
  return _internal_unset_indexes_size();
}
inline void UnsetIndexes::clear_unset_indexes() {
  _impl_.unset_indexes_.Clear();
}
inline ::greptime::v1::UnsetIndex* UnsetIndexes::mutable_unset_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetIndexes.unset_indexes)
  return _impl_.unset_indexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::UnsetIndex >*
UnsetIndexes::mutable_unset_indexes() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.UnsetIndexes.unset_indexes)
  return &_impl_.unset_indexes_;
}
inline const ::greptime::v1::UnsetIndex& UnsetIndexes::_internal_unset_indexes(int index) const {
  return _impl_.unset_indexes_.Get(index);
}
inline const ::greptime::v1::UnsetIndex& UnsetIndexes::unset_indexes(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetIndexes.unset_indexes)
  return _internal_unset_indexes(index);
}
inline ::greptime::v1::UnsetIndex* UnsetIndexes::_internal_add_unset_indexes() {
  return _impl_.unset_indexes_.Add();
}
inline ::greptime::v1::UnsetIndex* UnsetIndexes::add_unset_indexes() {
  ::greptime::v1::UnsetIndex* _add = _internal_add_unset_indexes();
  // @@protoc_insertion_point(field_add:greptime.v1.UnsetIndexes.unset_indexes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::UnsetIndex >&
UnsetIndexes::unset_indexes() const {
  // @@protoc_insertion_point(field_list:greptime.v1.UnsetIndexes.unset_indexes)
  return _impl_.unset_indexes_;
}

// -------------------------------------------------------------------

// SetIndex

// .greptime.v1.SetFulltext fulltext = 1;
inline bool SetIndex::_internal_has_fulltext() const {
  return options_case() == kFulltext;
}
inline bool SetIndex::has_fulltext() const {
  return _internal_has_fulltext();
}
inline void SetIndex::set_has_fulltext() {
  _impl_._oneof_case_[0] = kFulltext;
}
inline void SetIndex::clear_fulltext() {
  if (_internal_has_fulltext()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.fulltext_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::SetFulltext* SetIndex::release_fulltext() {
  // @@protoc_insertion_point(field_release:greptime.v1.SetIndex.fulltext)
  if (_internal_has_fulltext()) {
    clear_has_options();
    ::greptime::v1::SetFulltext* temp = _impl_.options_.fulltext_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.fulltext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetFulltext& SetIndex::_internal_fulltext() const {
  return _internal_has_fulltext()
      ? *_impl_.options_.fulltext_
      : reinterpret_cast< ::greptime::v1::SetFulltext&>(::greptime::v1::_SetFulltext_default_instance_);
}
inline const ::greptime::v1::SetFulltext& SetIndex::fulltext() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetIndex.fulltext)
  return _internal_fulltext();
}
inline ::greptime::v1::SetFulltext* SetIndex::unsafe_arena_release_fulltext() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.SetIndex.fulltext)
  if (_internal_has_fulltext()) {
    clear_has_options();
    ::greptime::v1::SetFulltext* temp = _impl_.options_.fulltext_;
    _impl_.options_.fulltext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SetIndex::unsafe_arena_set_allocated_fulltext(::greptime::v1::SetFulltext* fulltext) {
  clear_options();
  if (fulltext) {
    set_has_fulltext();
    _impl_.options_.fulltext_ = fulltext;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.SetIndex.fulltext)
}
inline ::greptime::v1::SetFulltext* SetIndex::_internal_mutable_fulltext() {
  if (!_internal_has_fulltext()) {
    clear_options();
    set_has_fulltext();
    _impl_.options_.fulltext_ = CreateMaybeMessage< ::greptime::v1::SetFulltext >(GetArenaForAllocation());
  }
  return _impl_.options_.fulltext_;
}
inline ::greptime::v1::SetFulltext* SetIndex::mutable_fulltext() {
  ::greptime::v1::SetFulltext* _msg = _internal_mutable_fulltext();
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetIndex.fulltext)
  return _msg;
}

// .greptime.v1.SetInverted inverted = 2;
inline bool SetIndex::_internal_has_inverted() const {
  return options_case() == kInverted;
}
inline bool SetIndex::has_inverted() const {
  return _internal_has_inverted();
}
inline void SetIndex::set_has_inverted() {
  _impl_._oneof_case_[0] = kInverted;
}
inline void SetIndex::clear_inverted() {
  if (_internal_has_inverted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.inverted_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::SetInverted* SetIndex::release_inverted() {
  // @@protoc_insertion_point(field_release:greptime.v1.SetIndex.inverted)
  if (_internal_has_inverted()) {
    clear_has_options();
    ::greptime::v1::SetInverted* temp = _impl_.options_.inverted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.inverted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetInverted& SetIndex::_internal_inverted() const {
  return _internal_has_inverted()
      ? *_impl_.options_.inverted_
      : reinterpret_cast< ::greptime::v1::SetInverted&>(::greptime::v1::_SetInverted_default_instance_);
}
inline const ::greptime::v1::SetInverted& SetIndex::inverted() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetIndex.inverted)
  return _internal_inverted();
}
inline ::greptime::v1::SetInverted* SetIndex::unsafe_arena_release_inverted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.SetIndex.inverted)
  if (_internal_has_inverted()) {
    clear_has_options();
    ::greptime::v1::SetInverted* temp = _impl_.options_.inverted_;
    _impl_.options_.inverted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SetIndex::unsafe_arena_set_allocated_inverted(::greptime::v1::SetInverted* inverted) {
  clear_options();
  if (inverted) {
    set_has_inverted();
    _impl_.options_.inverted_ = inverted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.SetIndex.inverted)
}
inline ::greptime::v1::SetInverted* SetIndex::_internal_mutable_inverted() {
  if (!_internal_has_inverted()) {
    clear_options();
    set_has_inverted();
    _impl_.options_.inverted_ = CreateMaybeMessage< ::greptime::v1::SetInverted >(GetArenaForAllocation());
  }
  return _impl_.options_.inverted_;
}
inline ::greptime::v1::SetInverted* SetIndex::mutable_inverted() {
  ::greptime::v1::SetInverted* _msg = _internal_mutable_inverted();
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetIndex.inverted)
  return _msg;
}

// .greptime.v1.SetSkipping skipping = 3;
inline bool SetIndex::_internal_has_skipping() const {
  return options_case() == kSkipping;
}
inline bool SetIndex::has_skipping() const {
  return _internal_has_skipping();
}
inline void SetIndex::set_has_skipping() {
  _impl_._oneof_case_[0] = kSkipping;
}
inline void SetIndex::clear_skipping() {
  if (_internal_has_skipping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.skipping_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::SetSkipping* SetIndex::release_skipping() {
  // @@protoc_insertion_point(field_release:greptime.v1.SetIndex.skipping)
  if (_internal_has_skipping()) {
    clear_has_options();
    ::greptime::v1::SetSkipping* temp = _impl_.options_.skipping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.skipping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetSkipping& SetIndex::_internal_skipping() const {
  return _internal_has_skipping()
      ? *_impl_.options_.skipping_
      : reinterpret_cast< ::greptime::v1::SetSkipping&>(::greptime::v1::_SetSkipping_default_instance_);
}
inline const ::greptime::v1::SetSkipping& SetIndex::skipping() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetIndex.skipping)
  return _internal_skipping();
}
inline ::greptime::v1::SetSkipping* SetIndex::unsafe_arena_release_skipping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.SetIndex.skipping)
  if (_internal_has_skipping()) {
    clear_has_options();
    ::greptime::v1::SetSkipping* temp = _impl_.options_.skipping_;
    _impl_.options_.skipping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SetIndex::unsafe_arena_set_allocated_skipping(::greptime::v1::SetSkipping* skipping) {
  clear_options();
  if (skipping) {
    set_has_skipping();
    _impl_.options_.skipping_ = skipping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.SetIndex.skipping)
}
inline ::greptime::v1::SetSkipping* SetIndex::_internal_mutable_skipping() {
  if (!_internal_has_skipping()) {
    clear_options();
    set_has_skipping();
    _impl_.options_.skipping_ = CreateMaybeMessage< ::greptime::v1::SetSkipping >(GetArenaForAllocation());
  }
  return _impl_.options_.skipping_;
}
inline ::greptime::v1::SetSkipping* SetIndex::mutable_skipping() {
  ::greptime::v1::SetSkipping* _msg = _internal_mutable_skipping();
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetIndex.skipping)
  return _msg;
}

inline bool SetIndex::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void SetIndex::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline SetIndex::OptionsCase SetIndex::options_case() const {
  return SetIndex::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnsetIndex

// .greptime.v1.UnsetFulltext fulltext = 1;
inline bool UnsetIndex::_internal_has_fulltext() const {
  return options_case() == kFulltext;
}
inline bool UnsetIndex::has_fulltext() const {
  return _internal_has_fulltext();
}
inline void UnsetIndex::set_has_fulltext() {
  _impl_._oneof_case_[0] = kFulltext;
}
inline void UnsetIndex::clear_fulltext() {
  if (_internal_has_fulltext()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.fulltext_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::UnsetFulltext* UnsetIndex::release_fulltext() {
  // @@protoc_insertion_point(field_release:greptime.v1.UnsetIndex.fulltext)
  if (_internal_has_fulltext()) {
    clear_has_options();
    ::greptime::v1::UnsetFulltext* temp = _impl_.options_.fulltext_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.fulltext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetFulltext& UnsetIndex::_internal_fulltext() const {
  return _internal_has_fulltext()
      ? *_impl_.options_.fulltext_
      : reinterpret_cast< ::greptime::v1::UnsetFulltext&>(::greptime::v1::_UnsetFulltext_default_instance_);
}
inline const ::greptime::v1::UnsetFulltext& UnsetIndex::fulltext() const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetIndex.fulltext)
  return _internal_fulltext();
}
inline ::greptime::v1::UnsetFulltext* UnsetIndex::unsafe_arena_release_fulltext() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.UnsetIndex.fulltext)
  if (_internal_has_fulltext()) {
    clear_has_options();
    ::greptime::v1::UnsetFulltext* temp = _impl_.options_.fulltext_;
    _impl_.options_.fulltext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UnsetIndex::unsafe_arena_set_allocated_fulltext(::greptime::v1::UnsetFulltext* fulltext) {
  clear_options();
  if (fulltext) {
    set_has_fulltext();
    _impl_.options_.fulltext_ = fulltext;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.UnsetIndex.fulltext)
}
inline ::greptime::v1::UnsetFulltext* UnsetIndex::_internal_mutable_fulltext() {
  if (!_internal_has_fulltext()) {
    clear_options();
    set_has_fulltext();
    _impl_.options_.fulltext_ = CreateMaybeMessage< ::greptime::v1::UnsetFulltext >(GetArenaForAllocation());
  }
  return _impl_.options_.fulltext_;
}
inline ::greptime::v1::UnsetFulltext* UnsetIndex::mutable_fulltext() {
  ::greptime::v1::UnsetFulltext* _msg = _internal_mutable_fulltext();
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetIndex.fulltext)
  return _msg;
}

// .greptime.v1.UnsetInverted inverted = 2;
inline bool UnsetIndex::_internal_has_inverted() const {
  return options_case() == kInverted;
}
inline bool UnsetIndex::has_inverted() const {
  return _internal_has_inverted();
}
inline void UnsetIndex::set_has_inverted() {
  _impl_._oneof_case_[0] = kInverted;
}
inline void UnsetIndex::clear_inverted() {
  if (_internal_has_inverted()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.inverted_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::UnsetInverted* UnsetIndex::release_inverted() {
  // @@protoc_insertion_point(field_release:greptime.v1.UnsetIndex.inverted)
  if (_internal_has_inverted()) {
    clear_has_options();
    ::greptime::v1::UnsetInverted* temp = _impl_.options_.inverted_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.inverted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetInverted& UnsetIndex::_internal_inverted() const {
  return _internal_has_inverted()
      ? *_impl_.options_.inverted_
      : reinterpret_cast< ::greptime::v1::UnsetInverted&>(::greptime::v1::_UnsetInverted_default_instance_);
}
inline const ::greptime::v1::UnsetInverted& UnsetIndex::inverted() const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetIndex.inverted)
  return _internal_inverted();
}
inline ::greptime::v1::UnsetInverted* UnsetIndex::unsafe_arena_release_inverted() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.UnsetIndex.inverted)
  if (_internal_has_inverted()) {
    clear_has_options();
    ::greptime::v1::UnsetInverted* temp = _impl_.options_.inverted_;
    _impl_.options_.inverted_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UnsetIndex::unsafe_arena_set_allocated_inverted(::greptime::v1::UnsetInverted* inverted) {
  clear_options();
  if (inverted) {
    set_has_inverted();
    _impl_.options_.inverted_ = inverted;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.UnsetIndex.inverted)
}
inline ::greptime::v1::UnsetInverted* UnsetIndex::_internal_mutable_inverted() {
  if (!_internal_has_inverted()) {
    clear_options();
    set_has_inverted();
    _impl_.options_.inverted_ = CreateMaybeMessage< ::greptime::v1::UnsetInverted >(GetArenaForAllocation());
  }
  return _impl_.options_.inverted_;
}
inline ::greptime::v1::UnsetInverted* UnsetIndex::mutable_inverted() {
  ::greptime::v1::UnsetInverted* _msg = _internal_mutable_inverted();
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetIndex.inverted)
  return _msg;
}

// .greptime.v1.UnsetSkipping skipping = 3;
inline bool UnsetIndex::_internal_has_skipping() const {
  return options_case() == kSkipping;
}
inline bool UnsetIndex::has_skipping() const {
  return _internal_has_skipping();
}
inline void UnsetIndex::set_has_skipping() {
  _impl_._oneof_case_[0] = kSkipping;
}
inline void UnsetIndex::clear_skipping() {
  if (_internal_has_skipping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.skipping_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::UnsetSkipping* UnsetIndex::release_skipping() {
  // @@protoc_insertion_point(field_release:greptime.v1.UnsetIndex.skipping)
  if (_internal_has_skipping()) {
    clear_has_options();
    ::greptime::v1::UnsetSkipping* temp = _impl_.options_.skipping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.skipping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetSkipping& UnsetIndex::_internal_skipping() const {
  return _internal_has_skipping()
      ? *_impl_.options_.skipping_
      : reinterpret_cast< ::greptime::v1::UnsetSkipping&>(::greptime::v1::_UnsetSkipping_default_instance_);
}
inline const ::greptime::v1::UnsetSkipping& UnsetIndex::skipping() const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetIndex.skipping)
  return _internal_skipping();
}
inline ::greptime::v1::UnsetSkipping* UnsetIndex::unsafe_arena_release_skipping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.UnsetIndex.skipping)
  if (_internal_has_skipping()) {
    clear_has_options();
    ::greptime::v1::UnsetSkipping* temp = _impl_.options_.skipping_;
    _impl_.options_.skipping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UnsetIndex::unsafe_arena_set_allocated_skipping(::greptime::v1::UnsetSkipping* skipping) {
  clear_options();
  if (skipping) {
    set_has_skipping();
    _impl_.options_.skipping_ = skipping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.UnsetIndex.skipping)
}
inline ::greptime::v1::UnsetSkipping* UnsetIndex::_internal_mutable_skipping() {
  if (!_internal_has_skipping()) {
    clear_options();
    set_has_skipping();
    _impl_.options_.skipping_ = CreateMaybeMessage< ::greptime::v1::UnsetSkipping >(GetArenaForAllocation());
  }
  return _impl_.options_.skipping_;
}
inline ::greptime::v1::UnsetSkipping* UnsetIndex::mutable_skipping() {
  ::greptime::v1::UnsetSkipping* _msg = _internal_mutable_skipping();
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetIndex.skipping)
  return _msg;
}

inline bool UnsetIndex::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void UnsetIndex::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline UnsetIndex::OptionsCase UnsetIndex::options_case() const {
  return UnsetIndex::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DropTableExpr

// string catalog_name = 1;
inline void DropTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.catalog_name)
}
inline std::string* DropTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.catalog_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.catalog_name)
}

// string schema_name = 2;
inline void DropTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.schema_name)
}
inline std::string* DropTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.schema_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.schema_name)
}

// string table_name = 3;
inline void DropTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.table_name)
}
inline std::string* DropTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.table_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DropTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void DropTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.table_name)
}

// .greptime.v1.TableId table_id = 4;
inline bool DropTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool DropTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void DropTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& DropTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& DropTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.table_id)
  return _internal_table_id();
}
inline void DropTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropTableExpr.table_id)
}
inline ::greptime::v1::TableId* DropTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* DropTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* DropTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* DropTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.table_id)
  return _msg;
}
inline void DropTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.table_id)
}

// bool drop_if_exists = 5;
inline void DropTableExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropTableExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropTableExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropTableExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropTableExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateDatabaseExpr

// string catalog_name = 1;
inline void CreateDatabaseExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateDatabaseExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.catalog_name)
}
inline std::string* CreateDatabaseExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateDatabaseExpr.catalog_name)
  return _s;
}
inline const std::string& CreateDatabaseExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateDatabaseExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateDatabaseExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateDatabaseExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateDatabaseExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateDatabaseExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateDatabaseExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.schema_name)
}
inline std::string* CreateDatabaseExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateDatabaseExpr.schema_name)
  return _s;
}
inline const std::string& CreateDatabaseExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateDatabaseExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateDatabaseExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateDatabaseExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateDatabaseExpr.schema_name)
}

// bool create_if_not_exists = 3;
inline void CreateDatabaseExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateDatabaseExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateDatabaseExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateDatabaseExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateDatabaseExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.create_if_not_exists)
}

// map<string, string> options = 4;
inline int CreateDatabaseExpr::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int CreateDatabaseExpr::options_size() const {
  return _internal_options_size();
}
inline void CreateDatabaseExpr::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateDatabaseExpr::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateDatabaseExpr::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateDatabaseExpr.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateDatabaseExpr::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateDatabaseExpr::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateDatabaseExpr.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// TruncateTableExpr

// string catalog_name = 1;
inline void TruncateTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.catalog_name)
}
inline std::string* TruncateTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.catalog_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void TruncateTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void TruncateTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.catalog_name)
}

// string schema_name = 2;
inline void TruncateTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.schema_name)
}
inline std::string* TruncateTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.schema_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TruncateTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void TruncateTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.schema_name)
}

// string table_name = 3;
inline void TruncateTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.table_name)
}
inline std::string* TruncateTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.table_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TruncateTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void TruncateTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.table_name)
}

// .greptime.v1.TableId table_id = 4;
inline bool TruncateTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool TruncateTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void TruncateTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& TruncateTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& TruncateTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.table_id)
  return _internal_table_id();
}
inline void TruncateTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.TruncateTableExpr.table_id)
}
inline ::greptime::v1::TableId* TruncateTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* TruncateTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* TruncateTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* TruncateTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.table_id)
  return _msg;
}
inline void TruncateTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.table_id)
}

// -------------------------------------------------------------------

// DropDatabaseExpr

// string catalog_name = 1;
inline void DropDatabaseExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropDatabaseExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDatabaseExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDatabaseExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropDatabaseExpr.catalog_name)
}
inline std::string* DropDatabaseExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropDatabaseExpr.catalog_name)
  return _s;
}
inline const std::string& DropDatabaseExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropDatabaseExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropDatabaseExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropDatabaseExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropDatabaseExpr.catalog_name)
}

// string schema_name = 2;
inline void DropDatabaseExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropDatabaseExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDatabaseExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDatabaseExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropDatabaseExpr.schema_name)
}
inline std::string* DropDatabaseExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropDatabaseExpr.schema_name)
  return _s;
}
inline const std::string& DropDatabaseExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropDatabaseExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropDatabaseExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropDatabaseExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropDatabaseExpr.schema_name)
}

// bool drop_if_exists = 3;
inline void DropDatabaseExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropDatabaseExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropDatabaseExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDatabaseExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropDatabaseExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropDatabaseExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropDatabaseExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// AddColumns

// repeated .greptime.v1.AddColumn add_columns = 1;
inline int AddColumns::_internal_add_columns_size() const {
  return _impl_.add_columns_.size();
}
inline int AddColumns::add_columns_size() const {
  return _internal_add_columns_size();
}
inline void AddColumns::clear_add_columns() {
  _impl_.add_columns_.Clear();
}
inline ::greptime::v1::AddColumn* AddColumns::mutable_add_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumns.add_columns)
  return _impl_.add_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >*
AddColumns::mutable_add_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.AddColumns.add_columns)
  return &_impl_.add_columns_;
}
inline const ::greptime::v1::AddColumn& AddColumns::_internal_add_columns(int index) const {
  return _impl_.add_columns_.Get(index);
}
inline const ::greptime::v1::AddColumn& AddColumns::add_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumns.add_columns)
  return _internal_add_columns(index);
}
inline ::greptime::v1::AddColumn* AddColumns::_internal_add_add_columns() {
  return _impl_.add_columns_.Add();
}
inline ::greptime::v1::AddColumn* AddColumns::add_add_columns() {
  ::greptime::v1::AddColumn* _add = _internal_add_add_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.AddColumns.add_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >&
AddColumns::add_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.AddColumns.add_columns)
  return _impl_.add_columns_;
}

// -------------------------------------------------------------------

// DropDefaults

// repeated .greptime.v1.DropDefault drop_defaults = 1;
inline int DropDefaults::_internal_drop_defaults_size() const {
  return _impl_.drop_defaults_.size();
}
inline int DropDefaults::drop_defaults_size() const {
  return _internal_drop_defaults_size();
}
inline void DropDefaults::clear_drop_defaults() {
  _impl_.drop_defaults_.Clear();
}
inline ::greptime::v1::DropDefault* DropDefaults::mutable_drop_defaults(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropDefaults.drop_defaults)
  return _impl_.drop_defaults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropDefault >*
DropDefaults::mutable_drop_defaults() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.DropDefaults.drop_defaults)
  return &_impl_.drop_defaults_;
}
inline const ::greptime::v1::DropDefault& DropDefaults::_internal_drop_defaults(int index) const {
  return _impl_.drop_defaults_.Get(index);
}
inline const ::greptime::v1::DropDefault& DropDefaults::drop_defaults(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDefaults.drop_defaults)
  return _internal_drop_defaults(index);
}
inline ::greptime::v1::DropDefault* DropDefaults::_internal_add_drop_defaults() {
  return _impl_.drop_defaults_.Add();
}
inline ::greptime::v1::DropDefault* DropDefaults::add_drop_defaults() {
  ::greptime::v1::DropDefault* _add = _internal_add_drop_defaults();
  // @@protoc_insertion_point(field_add:greptime.v1.DropDefaults.drop_defaults)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropDefault >&
DropDefaults::drop_defaults() const {
  // @@protoc_insertion_point(field_list:greptime.v1.DropDefaults.drop_defaults)
  return _impl_.drop_defaults_;
}

// -------------------------------------------------------------------

// DropColumns

// repeated .greptime.v1.DropColumn drop_columns = 1;
inline int DropColumns::_internal_drop_columns_size() const {
  return _impl_.drop_columns_.size();
}
inline int DropColumns::drop_columns_size() const {
  return _internal_drop_columns_size();
}
inline void DropColumns::clear_drop_columns() {
  _impl_.drop_columns_.Clear();
}
inline ::greptime::v1::DropColumn* DropColumns::mutable_drop_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropColumns.drop_columns)
  return _impl_.drop_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >*
DropColumns::mutable_drop_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.DropColumns.drop_columns)
  return &_impl_.drop_columns_;
}
inline const ::greptime::v1::DropColumn& DropColumns::_internal_drop_columns(int index) const {
  return _impl_.drop_columns_.Get(index);
}
inline const ::greptime::v1::DropColumn& DropColumns::drop_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropColumns.drop_columns)
  return _internal_drop_columns(index);
}
inline ::greptime::v1::DropColumn* DropColumns::_internal_add_drop_columns() {
  return _impl_.drop_columns_.Add();
}
inline ::greptime::v1::DropColumn* DropColumns::add_drop_columns() {
  ::greptime::v1::DropColumn* _add = _internal_add_drop_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.DropColumns.drop_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >&
DropColumns::drop_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.DropColumns.drop_columns)
  return _impl_.drop_columns_;
}

// -------------------------------------------------------------------

// ModifyColumnTypes

// repeated .greptime.v1.ModifyColumnType modify_column_types = 1;
inline int ModifyColumnTypes::_internal_modify_column_types_size() const {
  return _impl_.modify_column_types_.size();
}
inline int ModifyColumnTypes::modify_column_types_size() const {
  return _internal_modify_column_types_size();
}
inline void ModifyColumnTypes::clear_modify_column_types() {
  _impl_.modify_column_types_.Clear();
}
inline ::greptime::v1::ModifyColumnType* ModifyColumnTypes::mutable_modify_column_types(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.ModifyColumnTypes.modify_column_types)
  return _impl_.modify_column_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ModifyColumnType >*
ModifyColumnTypes::mutable_modify_column_types() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.ModifyColumnTypes.modify_column_types)
  return &_impl_.modify_column_types_;
}
inline const ::greptime::v1::ModifyColumnType& ModifyColumnTypes::_internal_modify_column_types(int index) const {
  return _impl_.modify_column_types_.Get(index);
}
inline const ::greptime::v1::ModifyColumnType& ModifyColumnTypes::modify_column_types(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.ModifyColumnTypes.modify_column_types)
  return _internal_modify_column_types(index);
}
inline ::greptime::v1::ModifyColumnType* ModifyColumnTypes::_internal_add_modify_column_types() {
  return _impl_.modify_column_types_.Add();
}
inline ::greptime::v1::ModifyColumnType* ModifyColumnTypes::add_modify_column_types() {
  ::greptime::v1::ModifyColumnType* _add = _internal_add_modify_column_types();
  // @@protoc_insertion_point(field_add:greptime.v1.ModifyColumnTypes.modify_column_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ModifyColumnType >&
ModifyColumnTypes::modify_column_types() const {
  // @@protoc_insertion_point(field_list:greptime.v1.ModifyColumnTypes.modify_column_types)
  return _impl_.modify_column_types_;
}

// -------------------------------------------------------------------

// RenameTable

// string new_table_name = 1;
inline void RenameTable::clear_new_table_name() {
  _impl_.new_table_name_.ClearToEmpty();
}
inline const std::string& RenameTable::new_table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RenameTable.new_table_name)
  return _internal_new_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameTable::set_new_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RenameTable.new_table_name)
}
inline std::string* RenameTable::mutable_new_table_name() {
  std::string* _s = _internal_mutable_new_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RenameTable.new_table_name)
  return _s;
}
inline const std::string& RenameTable::_internal_new_table_name() const {
  return _impl_.new_table_name_.Get();
}
inline void RenameTable::_internal_set_new_table_name(const std::string& value) {
  
  _impl_.new_table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameTable::_internal_mutable_new_table_name() {
  
  return _impl_.new_table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameTable::release_new_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.RenameTable.new_table_name)
  return _impl_.new_table_name_.Release();
}
inline void RenameTable::set_allocated_new_table_name(std::string* new_table_name) {
  if (new_table_name != nullptr) {
    
  } else {
    
  }
  _impl_.new_table_name_.SetAllocated(new_table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_table_name_.IsDefault()) {
    _impl_.new_table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RenameTable.new_table_name)
}

// -------------------------------------------------------------------

// AddColumn

// .greptime.v1.ColumnDef column_def = 1;
inline bool AddColumn::_internal_has_column_def() const {
  return this != internal_default_instance() && _impl_.column_def_ != nullptr;
}
inline bool AddColumn::has_column_def() const {
  return _internal_has_column_def();
}
inline void AddColumn::clear_column_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_def_ != nullptr) {
    delete _impl_.column_def_;
  }
  _impl_.column_def_ = nullptr;
}
inline const ::greptime::v1::ColumnDef& AddColumn::_internal_column_def() const {
  const ::greptime::v1::ColumnDef* p = _impl_.column_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDef&>(
      ::greptime::v1::_ColumnDef_default_instance_);
}
inline const ::greptime::v1::ColumnDef& AddColumn::column_def() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.column_def)
  return _internal_column_def();
}
inline void AddColumn::unsafe_arena_set_allocated_column_def(
    ::greptime::v1::ColumnDef* column_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  _impl_.column_def_ = column_def;
  if (column_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AddColumn.column_def)
}
inline ::greptime::v1::ColumnDef* AddColumn::release_column_def() {
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDef* AddColumn::unsafe_arena_release_column_def() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumn.column_def)
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDef* AddColumn::_internal_mutable_column_def() {
  
  if (_impl_.column_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDef>(GetArenaForAllocation());
    _impl_.column_def_ = p;
  }
  return _impl_.column_def_;
}
inline ::greptime::v1::ColumnDef* AddColumn::mutable_column_def() {
  ::greptime::v1::ColumnDef* _msg = _internal_mutable_column_def();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumn.column_def)
  return _msg;
}
inline void AddColumn::set_allocated_column_def(::greptime::v1::ColumnDef* column_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_def_;
  }
  if (column_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_def);
    if (message_arena != submessage_arena) {
      column_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_def_ = column_def;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumn.column_def)
}

// .greptime.v1.AddColumnLocation location = 3;
inline bool AddColumn::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AddColumn::has_location() const {
  return _internal_has_location();
}
inline void AddColumn::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::_internal_location() const {
  const ::greptime::v1::AddColumnLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AddColumnLocation&>(
      ::greptime::v1::_AddColumnLocation_default_instance_);
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::location() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.location)
  return _internal_location();
}
inline void AddColumn::unsafe_arena_set_allocated_location(
    ::greptime::v1::AddColumnLocation* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AddColumn.location)
}
inline ::greptime::v1::AddColumnLocation* AddColumn::release_location() {
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumn.location)
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AddColumnLocation>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::mutable_location() {
  ::greptime::v1::AddColumnLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumn.location)
  return _msg;
}
inline void AddColumn::set_allocated_location(::greptime::v1::AddColumnLocation* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumn.location)
}

// bool add_if_not_exists = 4;
inline void AddColumn::clear_add_if_not_exists() {
  _impl_.add_if_not_exists_ = false;
}
inline bool AddColumn::_internal_add_if_not_exists() const {
  return _impl_.add_if_not_exists_;
}
inline bool AddColumn::add_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.add_if_not_exists)
  return _internal_add_if_not_exists();
}
inline void AddColumn::_internal_set_add_if_not_exists(bool value) {
  
  _impl_.add_if_not_exists_ = value;
}
inline void AddColumn::set_add_if_not_exists(bool value) {
  _internal_set_add_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumn.add_if_not_exists)
}

// -------------------------------------------------------------------

// ModifyColumnType

// string column_name = 1;
inline void ModifyColumnType::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& ModifyColumnType::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ModifyColumnType.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModifyColumnType::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ModifyColumnType.column_name)
}
inline std::string* ModifyColumnType::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ModifyColumnType.column_name)
  return _s;
}
inline const std::string& ModifyColumnType::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void ModifyColumnType::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModifyColumnType::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModifyColumnType::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.ModifyColumnType.column_name)
  return _impl_.column_name_.Release();
}
inline void ModifyColumnType::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ModifyColumnType.column_name)
}

// .greptime.v1.ColumnDataType target_type = 2;
inline void ModifyColumnType::clear_target_type() {
  _impl_.target_type_ = 0;
}
inline ::greptime::v1::ColumnDataType ModifyColumnType::_internal_target_type() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.target_type_);
}
inline ::greptime::v1::ColumnDataType ModifyColumnType::target_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ModifyColumnType.target_type)
  return _internal_target_type();
}
inline void ModifyColumnType::_internal_set_target_type(::greptime::v1::ColumnDataType value) {
  
  _impl_.target_type_ = value;
}
inline void ModifyColumnType::set_target_type(::greptime::v1::ColumnDataType value) {
  _internal_set_target_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ModifyColumnType.target_type)
}

// .greptime.v1.ColumnDataTypeExtension target_type_extension = 3;
inline bool ModifyColumnType::_internal_has_target_type_extension() const {
  return this != internal_default_instance() && _impl_.target_type_extension_ != nullptr;
}
inline bool ModifyColumnType::has_target_type_extension() const {
  return _internal_has_target_type_extension();
}
inline const ::greptime::v1::ColumnDataTypeExtension& ModifyColumnType::_internal_target_type_extension() const {
  const ::greptime::v1::ColumnDataTypeExtension* p = _impl_.target_type_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDataTypeExtension&>(
      ::greptime::v1::_ColumnDataTypeExtension_default_instance_);
}
inline const ::greptime::v1::ColumnDataTypeExtension& ModifyColumnType::target_type_extension() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ModifyColumnType.target_type_extension)
  return _internal_target_type_extension();
}
inline void ModifyColumnType::unsafe_arena_set_allocated_target_type_extension(
    ::greptime::v1::ColumnDataTypeExtension* target_type_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_type_extension_);
  }
  _impl_.target_type_extension_ = target_type_extension;
  if (target_type_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ModifyColumnType.target_type_extension)
}
inline ::greptime::v1::ColumnDataTypeExtension* ModifyColumnType::release_target_type_extension() {
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.target_type_extension_;
  _impl_.target_type_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ModifyColumnType::unsafe_arena_release_target_type_extension() {
  // @@protoc_insertion_point(field_release:greptime.v1.ModifyColumnType.target_type_extension)
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.target_type_extension_;
  _impl_.target_type_extension_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ModifyColumnType::_internal_mutable_target_type_extension() {
  
  if (_impl_.target_type_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(GetArenaForAllocation());
    _impl_.target_type_extension_ = p;
  }
  return _impl_.target_type_extension_;
}
inline ::greptime::v1::ColumnDataTypeExtension* ModifyColumnType::mutable_target_type_extension() {
  ::greptime::v1::ColumnDataTypeExtension* _msg = _internal_mutable_target_type_extension();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ModifyColumnType.target_type_extension)
  return _msg;
}
inline void ModifyColumnType::set_allocated_target_type_extension(::greptime::v1::ColumnDataTypeExtension* target_type_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_type_extension_);
  }
  if (target_type_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_type_extension));
    if (message_arena != submessage_arena) {
      target_type_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_type_extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_type_extension_ = target_type_extension;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ModifyColumnType.target_type_extension)
}

// -------------------------------------------------------------------

// Option

// string key = 1;
inline void Option::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Option::key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Option.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Option::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Option.key)
}
inline std::string* Option::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Option.key)
  return _s;
}
inline const std::string& Option::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Option::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Option::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Option::release_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.Option.key)
  return _impl_.key_.Release();
}
inline void Option::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Option.key)
}

// string value = 2;
inline void Option::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Option::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Option.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Option::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Option.value)
}
inline std::string* Option::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Option.value)
  return _s;
}
inline const std::string& Option::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Option::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Option::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Option::release_value() {
  // @@protoc_insertion_point(field_release:greptime.v1.Option.value)
  return _impl_.value_.Release();
}
inline void Option::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Option.value)
}

// -------------------------------------------------------------------

// SetTableOptions

// repeated .greptime.v1.Option table_options = 1;
inline int SetTableOptions::_internal_table_options_size() const {
  return _impl_.table_options_.size();
}
inline int SetTableOptions::table_options_size() const {
  return _internal_table_options_size();
}
inline void SetTableOptions::clear_table_options() {
  _impl_.table_options_.Clear();
}
inline ::greptime::v1::Option* SetTableOptions::mutable_table_options(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetTableOptions.table_options)
  return _impl_.table_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >*
SetTableOptions::mutable_table_options() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.SetTableOptions.table_options)
  return &_impl_.table_options_;
}
inline const ::greptime::v1::Option& SetTableOptions::_internal_table_options(int index) const {
  return _impl_.table_options_.Get(index);
}
inline const ::greptime::v1::Option& SetTableOptions::table_options(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetTableOptions.table_options)
  return _internal_table_options(index);
}
inline ::greptime::v1::Option* SetTableOptions::_internal_add_table_options() {
  return _impl_.table_options_.Add();
}
inline ::greptime::v1::Option* SetTableOptions::add_table_options() {
  ::greptime::v1::Option* _add = _internal_add_table_options();
  // @@protoc_insertion_point(field_add:greptime.v1.SetTableOptions.table_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >&
SetTableOptions::table_options() const {
  // @@protoc_insertion_point(field_list:greptime.v1.SetTableOptions.table_options)
  return _impl_.table_options_;
}

// -------------------------------------------------------------------

// UnsetTableOptions

// repeated string keys = 1;
inline int UnsetTableOptions::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int UnsetTableOptions::keys_size() const {
  return _internal_keys_size();
}
inline void UnsetTableOptions::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* UnsetTableOptions::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.UnsetTableOptions.keys)
  return _s;
}
inline const std::string& UnsetTableOptions::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& UnsetTableOptions::keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetTableOptions.keys)
  return _internal_keys(index);
}
inline std::string* UnsetTableOptions::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetTableOptions.keys)
  return _impl_.keys_.Mutable(index);
}
inline void UnsetTableOptions::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetTableOptions.keys)
}
inline void UnsetTableOptions::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetTableOptions.keys)
}
inline void UnsetTableOptions::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.UnsetTableOptions.keys)
}
inline void UnsetTableOptions::set_keys(int index, const char* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.UnsetTableOptions.keys)
}
inline std::string* UnsetTableOptions::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void UnsetTableOptions::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.UnsetTableOptions.keys)
}
inline void UnsetTableOptions::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.UnsetTableOptions.keys)
}
inline void UnsetTableOptions::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.UnsetTableOptions.keys)
}
inline void UnsetTableOptions::add_keys(const char* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.UnsetTableOptions.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnsetTableOptions::keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.UnsetTableOptions.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnsetTableOptions::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.UnsetTableOptions.keys)
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// DropColumn

// string name = 1;
inline void DropColumn::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DropColumn::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropColumn.name)
}
inline std::string* DropColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropColumn.name)
  return _s;
}
inline const std::string& DropColumn::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DropColumn::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropColumn::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropColumn::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropColumn.name)
  return _impl_.name_.Release();
}
inline void DropColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropColumn.name)
}

// -------------------------------------------------------------------

// TableId

// uint32 id = 1;
inline void TableId::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t TableId::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t TableId::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableId.id)
  return _internal_id();
}
inline void TableId::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void TableId::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.TableId.id)
}

// -------------------------------------------------------------------

// FlowId

// uint32 id = 1;
inline void FlowId::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t FlowId::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t FlowId::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.FlowId.id)
  return _internal_id();
}
inline void FlowId::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void FlowId::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.FlowId.id)
}

// -------------------------------------------------------------------

// ColumnDef

// string name = 1;
inline void ColumnDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDef::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.name)
}
inline std::string* ColumnDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.name)
  return _s;
}
inline const std::string& ColumnDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.name)
  return _impl_.name_.Release();
}
inline void ColumnDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.name)
}

// .greptime.v1.ColumnDataType data_type = 2;
inline void ColumnDef::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::greptime::v1::ColumnDataType ColumnDef::_internal_data_type() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.data_type_);
}
inline ::greptime::v1::ColumnDataType ColumnDef::data_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.data_type)
  return _internal_data_type();
}
inline void ColumnDef::_internal_set_data_type(::greptime::v1::ColumnDataType value) {
  
  _impl_.data_type_ = value;
}
inline void ColumnDef::set_data_type(::greptime::v1::ColumnDataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.data_type)
}

// bool is_nullable = 3;
inline void ColumnDef::clear_is_nullable() {
  _impl_.is_nullable_ = false;
}
inline bool ColumnDef::_internal_is_nullable() const {
  return _impl_.is_nullable_;
}
inline bool ColumnDef::is_nullable() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.is_nullable)
  return _internal_is_nullable();
}
inline void ColumnDef::_internal_set_is_nullable(bool value) {
  
  _impl_.is_nullable_ = value;
}
inline void ColumnDef::set_is_nullable(bool value) {
  _internal_set_is_nullable(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.is_nullable)
}

// bytes default_constraint = 4;
inline void ColumnDef::clear_default_constraint() {
  _impl_.default_constraint_.ClearToEmpty();
}
inline const std::string& ColumnDef::default_constraint() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.default_constraint)
  return _internal_default_constraint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_default_constraint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_constraint_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.default_constraint)
}
inline std::string* ColumnDef::mutable_default_constraint() {
  std::string* _s = _internal_mutable_default_constraint();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.default_constraint)
  return _s;
}
inline const std::string& ColumnDef::_internal_default_constraint() const {
  return _impl_.default_constraint_.Get();
}
inline void ColumnDef::_internal_set_default_constraint(const std::string& value) {
  
  _impl_.default_constraint_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_default_constraint() {
  
  return _impl_.default_constraint_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_default_constraint() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.default_constraint)
  return _impl_.default_constraint_.Release();
}
inline void ColumnDef::set_allocated_default_constraint(std::string* default_constraint) {
  if (default_constraint != nullptr) {
    
  } else {
    
  }
  _impl_.default_constraint_.SetAllocated(default_constraint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_constraint_.IsDefault()) {
    _impl_.default_constraint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.default_constraint)
}

// .greptime.v1.SemanticType semantic_type = 5;
inline void ColumnDef::clear_semantic_type() {
  _impl_.semantic_type_ = 0;
}
inline ::greptime::v1::SemanticType ColumnDef::_internal_semantic_type() const {
  return static_cast< ::greptime::v1::SemanticType >(_impl_.semantic_type_);
}
inline ::greptime::v1::SemanticType ColumnDef::semantic_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.semantic_type)
  return _internal_semantic_type();
}
inline void ColumnDef::_internal_set_semantic_type(::greptime::v1::SemanticType value) {
  
  _impl_.semantic_type_ = value;
}
inline void ColumnDef::set_semantic_type(::greptime::v1::SemanticType value) {
  _internal_set_semantic_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.semantic_type)
}

// string comment = 6;
inline void ColumnDef::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& ColumnDef::comment() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.comment)
}
inline std::string* ColumnDef::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.comment)
  return _s;
}
inline const std::string& ColumnDef::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void ColumnDef::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_comment() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.comment)
  return _impl_.comment_.Release();
}
inline void ColumnDef::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.comment)
}

// .greptime.v1.ColumnDataTypeExtension datatype_extension = 7;
inline bool ColumnDef::_internal_has_datatype_extension() const {
  return this != internal_default_instance() && _impl_.datatype_extension_ != nullptr;
}
inline bool ColumnDef::has_datatype_extension() const {
  return _internal_has_datatype_extension();
}
inline const ::greptime::v1::ColumnDataTypeExtension& ColumnDef::_internal_datatype_extension() const {
  const ::greptime::v1::ColumnDataTypeExtension* p = _impl_.datatype_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDataTypeExtension&>(
      ::greptime::v1::_ColumnDataTypeExtension_default_instance_);
}
inline const ::greptime::v1::ColumnDataTypeExtension& ColumnDef::datatype_extension() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.datatype_extension)
  return _internal_datatype_extension();
}
inline void ColumnDef::unsafe_arena_set_allocated_datatype_extension(
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_extension_);
  }
  _impl_.datatype_extension_ = datatype_extension;
  if (datatype_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDef.datatype_extension)
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::release_datatype_extension() {
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::unsafe_arena_release_datatype_extension() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.datatype_extension)
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::_internal_mutable_datatype_extension() {
  
  if (_impl_.datatype_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(GetArenaForAllocation());
    _impl_.datatype_extension_ = p;
  }
  return _impl_.datatype_extension_;
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::mutable_datatype_extension() {
  ::greptime::v1::ColumnDataTypeExtension* _msg = _internal_mutable_datatype_extension();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.datatype_extension)
  return _msg;
}
inline void ColumnDef::set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_extension_);
  }
  if (datatype_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datatype_extension));
    if (message_arena != submessage_arena) {
      datatype_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datatype_extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datatype_extension_ = datatype_extension;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.datatype_extension)
}

// .greptime.v1.ColumnOptions options = 8;
inline bool ColumnDef::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool ColumnDef::has_options() const {
  return _internal_has_options();
}
inline const ::greptime::v1::ColumnOptions& ColumnDef::_internal_options() const {
  const ::greptime::v1::ColumnOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnOptions&>(
      ::greptime::v1::_ColumnOptions_default_instance_);
}
inline const ::greptime::v1::ColumnOptions& ColumnDef::options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.options)
  return _internal_options();
}
inline void ColumnDef::unsafe_arena_set_allocated_options(
    ::greptime::v1::ColumnOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDef.options)
}
inline ::greptime::v1::ColumnOptions* ColumnDef::release_options() {
  
  ::greptime::v1::ColumnOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnOptions* ColumnDef::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.options)
  
  ::greptime::v1::ColumnOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnOptions* ColumnDef::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::greptime::v1::ColumnOptions* ColumnDef::mutable_options() {
  ::greptime::v1::ColumnOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.options)
  return _msg;
}
inline void ColumnDef::set_allocated_options(::greptime::v1::ColumnOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.options)
}

// -------------------------------------------------------------------

// AddColumnLocation

// .greptime.v1.AddColumnLocation.LocationType location_type = 1;
inline void AddColumnLocation::clear_location_type() {
  _impl_.location_type_ = 0;
}
inline ::greptime::v1::AddColumnLocation_LocationType AddColumnLocation::_internal_location_type() const {
  return static_cast< ::greptime::v1::AddColumnLocation_LocationType >(_impl_.location_type_);
}
inline ::greptime::v1::AddColumnLocation_LocationType AddColumnLocation::location_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumnLocation.location_type)
  return _internal_location_type();
}
inline void AddColumnLocation::_internal_set_location_type(::greptime::v1::AddColumnLocation_LocationType value) {
  
  _impl_.location_type_ = value;
}
inline void AddColumnLocation::set_location_type(::greptime::v1::AddColumnLocation_LocationType value) {
  _internal_set_location_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumnLocation.location_type)
}

// string after_column_name = 2;
inline void AddColumnLocation::clear_after_column_name() {
  _impl_.after_column_name_.ClearToEmpty();
}
inline const std::string& AddColumnLocation::after_column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumnLocation.after_column_name)
  return _internal_after_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddColumnLocation::set_after_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.after_column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumnLocation.after_column_name)
}
inline std::string* AddColumnLocation::mutable_after_column_name() {
  std::string* _s = _internal_mutable_after_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumnLocation.after_column_name)
  return _s;
}
inline const std::string& AddColumnLocation::_internal_after_column_name() const {
  return _impl_.after_column_name_.Get();
}
inline void AddColumnLocation::_internal_set_after_column_name(const std::string& value) {
  
  _impl_.after_column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddColumnLocation::_internal_mutable_after_column_name() {
  
  return _impl_.after_column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddColumnLocation::release_after_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumnLocation.after_column_name)
  return _impl_.after_column_name_.Release();
}
inline void AddColumnLocation::set_allocated_after_column_name(std::string* after_column_name) {
  if (after_column_name != nullptr) {
    
  } else {
    
  }
  _impl_.after_column_name_.SetAllocated(after_column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.after_column_name_.IsDefault()) {
    _impl_.after_column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumnLocation.after_column_name)
}

// -------------------------------------------------------------------

// SetFulltext

// string column_name = 1;
inline void SetFulltext::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& SetFulltext::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetFulltext::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.column_name)
}
inline std::string* SetFulltext::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetFulltext.column_name)
  return _s;
}
inline const std::string& SetFulltext::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void SetFulltext::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetFulltext::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetFulltext::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.SetFulltext.column_name)
  return _impl_.column_name_.Release();
}
inline void SetFulltext::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.SetFulltext.column_name)
}

// bool enable = 2;
inline void SetFulltext::clear_enable() {
  _impl_.enable_ = false;
}
inline bool SetFulltext::_internal_enable() const {
  return _impl_.enable_;
}
inline bool SetFulltext::enable() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.enable)
  return _internal_enable();
}
inline void SetFulltext::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void SetFulltext::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.enable)
}

// .greptime.v1.Analyzer analyzer = 3;
inline void SetFulltext::clear_analyzer() {
  _impl_.analyzer_ = 0;
}
inline ::greptime::v1::Analyzer SetFulltext::_internal_analyzer() const {
  return static_cast< ::greptime::v1::Analyzer >(_impl_.analyzer_);
}
inline ::greptime::v1::Analyzer SetFulltext::analyzer() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.analyzer)
  return _internal_analyzer();
}
inline void SetFulltext::_internal_set_analyzer(::greptime::v1::Analyzer value) {
  
  _impl_.analyzer_ = value;
}
inline void SetFulltext::set_analyzer(::greptime::v1::Analyzer value) {
  _internal_set_analyzer(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.analyzer)
}

// bool case_sensitive = 4;
inline void SetFulltext::clear_case_sensitive() {
  _impl_.case_sensitive_ = false;
}
inline bool SetFulltext::_internal_case_sensitive() const {
  return _impl_.case_sensitive_;
}
inline bool SetFulltext::case_sensitive() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.case_sensitive)
  return _internal_case_sensitive();
}
inline void SetFulltext::_internal_set_case_sensitive(bool value) {
  
  _impl_.case_sensitive_ = value;
}
inline void SetFulltext::set_case_sensitive(bool value) {
  _internal_set_case_sensitive(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.case_sensitive)
}

// .greptime.v1.FulltextBackend backend = 5;
inline void SetFulltext::clear_backend() {
  _impl_.backend_ = 0;
}
inline ::greptime::v1::FulltextBackend SetFulltext::_internal_backend() const {
  return static_cast< ::greptime::v1::FulltextBackend >(_impl_.backend_);
}
inline ::greptime::v1::FulltextBackend SetFulltext::backend() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.backend)
  return _internal_backend();
}
inline void SetFulltext::_internal_set_backend(::greptime::v1::FulltextBackend value) {
  
  _impl_.backend_ = value;
}
inline void SetFulltext::set_backend(::greptime::v1::FulltextBackend value) {
  _internal_set_backend(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.backend)
}

// uint64 granularity = 6;
inline void SetFulltext::clear_granularity() {
  _impl_.granularity_ = uint64_t{0u};
}
inline uint64_t SetFulltext::_internal_granularity() const {
  return _impl_.granularity_;
}
inline uint64_t SetFulltext::granularity() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.granularity)
  return _internal_granularity();
}
inline void SetFulltext::_internal_set_granularity(uint64_t value) {
  
  _impl_.granularity_ = value;
}
inline void SetFulltext::set_granularity(uint64_t value) {
  _internal_set_granularity(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.granularity)
}

// double false_positive_rate = 7;
inline void SetFulltext::clear_false_positive_rate() {
  _impl_.false_positive_rate_ = 0;
}
inline double SetFulltext::_internal_false_positive_rate() const {
  return _impl_.false_positive_rate_;
}
inline double SetFulltext::false_positive_rate() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetFulltext.false_positive_rate)
  return _internal_false_positive_rate();
}
inline void SetFulltext::_internal_set_false_positive_rate(double value) {
  
  _impl_.false_positive_rate_ = value;
}
inline void SetFulltext::set_false_positive_rate(double value) {
  _internal_set_false_positive_rate(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetFulltext.false_positive_rate)
}

// -------------------------------------------------------------------

// UnsetFulltext

// string column_name = 1;
inline void UnsetFulltext::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& UnsetFulltext::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetFulltext.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsetFulltext::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetFulltext.column_name)
}
inline std::string* UnsetFulltext::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetFulltext.column_name)
  return _s;
}
inline const std::string& UnsetFulltext::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void UnsetFulltext::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsetFulltext::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsetFulltext::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.UnsetFulltext.column_name)
  return _impl_.column_name_.Release();
}
inline void UnsetFulltext::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.UnsetFulltext.column_name)
}

// -------------------------------------------------------------------

// SetInverted

// string column_name = 1;
inline void SetInverted::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& SetInverted::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetInverted.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetInverted::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.SetInverted.column_name)
}
inline std::string* SetInverted::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetInverted.column_name)
  return _s;
}
inline const std::string& SetInverted::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void SetInverted::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetInverted::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetInverted::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.SetInverted.column_name)
  return _impl_.column_name_.Release();
}
inline void SetInverted::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.SetInverted.column_name)
}

// -------------------------------------------------------------------

// UnsetInverted

// string column_name = 1;
inline void UnsetInverted::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& UnsetInverted::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetInverted.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsetInverted::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetInverted.column_name)
}
inline std::string* UnsetInverted::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetInverted.column_name)
  return _s;
}
inline const std::string& UnsetInverted::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void UnsetInverted::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsetInverted::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsetInverted::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.UnsetInverted.column_name)
  return _impl_.column_name_.Release();
}
inline void UnsetInverted::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.UnsetInverted.column_name)
}

// -------------------------------------------------------------------

// SetSkipping

// string column_name = 1;
inline void SetSkipping::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& SetSkipping::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetSkipping.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSkipping::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.SetSkipping.column_name)
}
inline std::string* SetSkipping::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetSkipping.column_name)
  return _s;
}
inline const std::string& SetSkipping::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void SetSkipping::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSkipping::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSkipping::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.SetSkipping.column_name)
  return _impl_.column_name_.Release();
}
inline void SetSkipping::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.SetSkipping.column_name)
}

// bool enable = 2;
inline void SetSkipping::clear_enable() {
  _impl_.enable_ = false;
}
inline bool SetSkipping::_internal_enable() const {
  return _impl_.enable_;
}
inline bool SetSkipping::enable() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetSkipping.enable)
  return _internal_enable();
}
inline void SetSkipping::_internal_set_enable(bool value) {
  
  _impl_.enable_ = value;
}
inline void SetSkipping::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetSkipping.enable)
}

// uint64 granularity = 3;
inline void SetSkipping::clear_granularity() {
  _impl_.granularity_ = uint64_t{0u};
}
inline uint64_t SetSkipping::_internal_granularity() const {
  return _impl_.granularity_;
}
inline uint64_t SetSkipping::granularity() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetSkipping.granularity)
  return _internal_granularity();
}
inline void SetSkipping::_internal_set_granularity(uint64_t value) {
  
  _impl_.granularity_ = value;
}
inline void SetSkipping::set_granularity(uint64_t value) {
  _internal_set_granularity(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetSkipping.granularity)
}

// .greptime.v1.SkippingIndexType skipping_index_type = 4;
inline void SetSkipping::clear_skipping_index_type() {
  _impl_.skipping_index_type_ = 0;
}
inline ::greptime::v1::SkippingIndexType SetSkipping::_internal_skipping_index_type() const {
  return static_cast< ::greptime::v1::SkippingIndexType >(_impl_.skipping_index_type_);
}
inline ::greptime::v1::SkippingIndexType SetSkipping::skipping_index_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetSkipping.skipping_index_type)
  return _internal_skipping_index_type();
}
inline void SetSkipping::_internal_set_skipping_index_type(::greptime::v1::SkippingIndexType value) {
  
  _impl_.skipping_index_type_ = value;
}
inline void SetSkipping::set_skipping_index_type(::greptime::v1::SkippingIndexType value) {
  _internal_set_skipping_index_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetSkipping.skipping_index_type)
}

// double false_positive_rate = 5;
inline void SetSkipping::clear_false_positive_rate() {
  _impl_.false_positive_rate_ = 0;
}
inline double SetSkipping::_internal_false_positive_rate() const {
  return _impl_.false_positive_rate_;
}
inline double SetSkipping::false_positive_rate() const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetSkipping.false_positive_rate)
  return _internal_false_positive_rate();
}
inline void SetSkipping::_internal_set_false_positive_rate(double value) {
  
  _impl_.false_positive_rate_ = value;
}
inline void SetSkipping::set_false_positive_rate(double value) {
  _internal_set_false_positive_rate(value);
  // @@protoc_insertion_point(field_set:greptime.v1.SetSkipping.false_positive_rate)
}

// -------------------------------------------------------------------

// UnsetSkipping

// string column_name = 1;
inline void UnsetSkipping::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& UnsetSkipping::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetSkipping.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsetSkipping::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetSkipping.column_name)
}
inline std::string* UnsetSkipping::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetSkipping.column_name)
  return _s;
}
inline const std::string& UnsetSkipping::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void UnsetSkipping::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UnsetSkipping::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UnsetSkipping::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.UnsetSkipping.column_name)
  return _impl_.column_name_.Release();
}
inline void UnsetSkipping::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.UnsetSkipping.column_name)
}

// -------------------------------------------------------------------

// AlterDatabaseExpr

// string catalog_name = 1;
inline void AlterDatabaseExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& AlterDatabaseExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterDatabaseExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterDatabaseExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterDatabaseExpr.catalog_name)
}
inline std::string* AlterDatabaseExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterDatabaseExpr.catalog_name)
  return _s;
}
inline const std::string& AlterDatabaseExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void AlterDatabaseExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterDatabaseExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterDatabaseExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterDatabaseExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void AlterDatabaseExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterDatabaseExpr.catalog_name)
}

// string schema_name = 2;
inline void AlterDatabaseExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& AlterDatabaseExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterDatabaseExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterDatabaseExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterDatabaseExpr.schema_name)
}
inline std::string* AlterDatabaseExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterDatabaseExpr.schema_name)
  return _s;
}
inline const std::string& AlterDatabaseExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void AlterDatabaseExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterDatabaseExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterDatabaseExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterDatabaseExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void AlterDatabaseExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterDatabaseExpr.schema_name)
}

// .greptime.v1.SetDatabaseOptions set_database_options = 3;
inline bool AlterDatabaseExpr::_internal_has_set_database_options() const {
  return kind_case() == kSetDatabaseOptions;
}
inline bool AlterDatabaseExpr::has_set_database_options() const {
  return _internal_has_set_database_options();
}
inline void AlterDatabaseExpr::set_has_set_database_options() {
  _impl_._oneof_case_[0] = kSetDatabaseOptions;
}
inline void AlterDatabaseExpr::clear_set_database_options() {
  if (_internal_has_set_database_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.set_database_options_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::SetDatabaseOptions* AlterDatabaseExpr::release_set_database_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterDatabaseExpr.set_database_options)
  if (_internal_has_set_database_options()) {
    clear_has_kind();
    ::greptime::v1::SetDatabaseOptions* temp = _impl_.kind_.set_database_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.set_database_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::SetDatabaseOptions& AlterDatabaseExpr::_internal_set_database_options() const {
  return _internal_has_set_database_options()
      ? *_impl_.kind_.set_database_options_
      : reinterpret_cast< ::greptime::v1::SetDatabaseOptions&>(::greptime::v1::_SetDatabaseOptions_default_instance_);
}
inline const ::greptime::v1::SetDatabaseOptions& AlterDatabaseExpr::set_database_options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterDatabaseExpr.set_database_options)
  return _internal_set_database_options();
}
inline ::greptime::v1::SetDatabaseOptions* AlterDatabaseExpr::unsafe_arena_release_set_database_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterDatabaseExpr.set_database_options)
  if (_internal_has_set_database_options()) {
    clear_has_kind();
    ::greptime::v1::SetDatabaseOptions* temp = _impl_.kind_.set_database_options_;
    _impl_.kind_.set_database_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterDatabaseExpr::unsafe_arena_set_allocated_set_database_options(::greptime::v1::SetDatabaseOptions* set_database_options) {
  clear_kind();
  if (set_database_options) {
    set_has_set_database_options();
    _impl_.kind_.set_database_options_ = set_database_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterDatabaseExpr.set_database_options)
}
inline ::greptime::v1::SetDatabaseOptions* AlterDatabaseExpr::_internal_mutable_set_database_options() {
  if (!_internal_has_set_database_options()) {
    clear_kind();
    set_has_set_database_options();
    _impl_.kind_.set_database_options_ = CreateMaybeMessage< ::greptime::v1::SetDatabaseOptions >(GetArenaForAllocation());
  }
  return _impl_.kind_.set_database_options_;
}
inline ::greptime::v1::SetDatabaseOptions* AlterDatabaseExpr::mutable_set_database_options() {
  ::greptime::v1::SetDatabaseOptions* _msg = _internal_mutable_set_database_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterDatabaseExpr.set_database_options)
  return _msg;
}

// .greptime.v1.UnsetDatabaseOptions unset_database_options = 4;
inline bool AlterDatabaseExpr::_internal_has_unset_database_options() const {
  return kind_case() == kUnsetDatabaseOptions;
}
inline bool AlterDatabaseExpr::has_unset_database_options() const {
  return _internal_has_unset_database_options();
}
inline void AlterDatabaseExpr::set_has_unset_database_options() {
  _impl_._oneof_case_[0] = kUnsetDatabaseOptions;
}
inline void AlterDatabaseExpr::clear_unset_database_options() {
  if (_internal_has_unset_database_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.unset_database_options_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::UnsetDatabaseOptions* AlterDatabaseExpr::release_unset_database_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterDatabaseExpr.unset_database_options)
  if (_internal_has_unset_database_options()) {
    clear_has_kind();
    ::greptime::v1::UnsetDatabaseOptions* temp = _impl_.kind_.unset_database_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unset_database_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::UnsetDatabaseOptions& AlterDatabaseExpr::_internal_unset_database_options() const {
  return _internal_has_unset_database_options()
      ? *_impl_.kind_.unset_database_options_
      : reinterpret_cast< ::greptime::v1::UnsetDatabaseOptions&>(::greptime::v1::_UnsetDatabaseOptions_default_instance_);
}
inline const ::greptime::v1::UnsetDatabaseOptions& AlterDatabaseExpr::unset_database_options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterDatabaseExpr.unset_database_options)
  return _internal_unset_database_options();
}
inline ::greptime::v1::UnsetDatabaseOptions* AlterDatabaseExpr::unsafe_arena_release_unset_database_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterDatabaseExpr.unset_database_options)
  if (_internal_has_unset_database_options()) {
    clear_has_kind();
    ::greptime::v1::UnsetDatabaseOptions* temp = _impl_.kind_.unset_database_options_;
    _impl_.kind_.unset_database_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterDatabaseExpr::unsafe_arena_set_allocated_unset_database_options(::greptime::v1::UnsetDatabaseOptions* unset_database_options) {
  clear_kind();
  if (unset_database_options) {
    set_has_unset_database_options();
    _impl_.kind_.unset_database_options_ = unset_database_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterDatabaseExpr.unset_database_options)
}
inline ::greptime::v1::UnsetDatabaseOptions* AlterDatabaseExpr::_internal_mutable_unset_database_options() {
  if (!_internal_has_unset_database_options()) {
    clear_kind();
    set_has_unset_database_options();
    _impl_.kind_.unset_database_options_ = CreateMaybeMessage< ::greptime::v1::UnsetDatabaseOptions >(GetArenaForAllocation());
  }
  return _impl_.kind_.unset_database_options_;
}
inline ::greptime::v1::UnsetDatabaseOptions* AlterDatabaseExpr::mutable_unset_database_options() {
  ::greptime::v1::UnsetDatabaseOptions* _msg = _internal_mutable_unset_database_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterDatabaseExpr.unset_database_options)
  return _msg;
}

inline bool AlterDatabaseExpr::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AlterDatabaseExpr::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline AlterDatabaseExpr::KindCase AlterDatabaseExpr::kind_case() const {
  return AlterDatabaseExpr::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetDatabaseOptions

// repeated .greptime.v1.Option set_database_options = 1;
inline int SetDatabaseOptions::_internal_set_database_options_size() const {
  return _impl_.set_database_options_.size();
}
inline int SetDatabaseOptions::set_database_options_size() const {
  return _internal_set_database_options_size();
}
inline void SetDatabaseOptions::clear_set_database_options() {
  _impl_.set_database_options_.Clear();
}
inline ::greptime::v1::Option* SetDatabaseOptions::mutable_set_database_options(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.SetDatabaseOptions.set_database_options)
  return _impl_.set_database_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >*
SetDatabaseOptions::mutable_set_database_options() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.SetDatabaseOptions.set_database_options)
  return &_impl_.set_database_options_;
}
inline const ::greptime::v1::Option& SetDatabaseOptions::_internal_set_database_options(int index) const {
  return _impl_.set_database_options_.Get(index);
}
inline const ::greptime::v1::Option& SetDatabaseOptions::set_database_options(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.SetDatabaseOptions.set_database_options)
  return _internal_set_database_options(index);
}
inline ::greptime::v1::Option* SetDatabaseOptions::_internal_add_set_database_options() {
  return _impl_.set_database_options_.Add();
}
inline ::greptime::v1::Option* SetDatabaseOptions::add_set_database_options() {
  ::greptime::v1::Option* _add = _internal_add_set_database_options();
  // @@protoc_insertion_point(field_add:greptime.v1.SetDatabaseOptions.set_database_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::Option >&
SetDatabaseOptions::set_database_options() const {
  // @@protoc_insertion_point(field_list:greptime.v1.SetDatabaseOptions.set_database_options)
  return _impl_.set_database_options_;
}

// -------------------------------------------------------------------

// UnsetDatabaseOptions

// repeated string keys = 1;
inline int UnsetDatabaseOptions::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int UnsetDatabaseOptions::keys_size() const {
  return _internal_keys_size();
}
inline void UnsetDatabaseOptions::clear_keys() {
  _impl_.keys_.Clear();
}
inline std::string* UnsetDatabaseOptions::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.UnsetDatabaseOptions.keys)
  return _s;
}
inline const std::string& UnsetDatabaseOptions::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const std::string& UnsetDatabaseOptions::keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.UnsetDatabaseOptions.keys)
  return _internal_keys(index);
}
inline std::string* UnsetDatabaseOptions::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.UnsetDatabaseOptions.keys)
  return _impl_.keys_.Mutable(index);
}
inline void UnsetDatabaseOptions::set_keys(int index, const std::string& value) {
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetDatabaseOptions.keys)
}
inline void UnsetDatabaseOptions::set_keys(int index, std::string&& value) {
  _impl_.keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.UnsetDatabaseOptions.keys)
}
inline void UnsetDatabaseOptions::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.UnsetDatabaseOptions.keys)
}
inline void UnsetDatabaseOptions::set_keys(int index, const char* value, size_t size) {
  _impl_.keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.UnsetDatabaseOptions.keys)
}
inline std::string* UnsetDatabaseOptions::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline void UnsetDatabaseOptions::add_keys(const std::string& value) {
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.UnsetDatabaseOptions.keys)
}
inline void UnsetDatabaseOptions::add_keys(std::string&& value) {
  _impl_.keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.UnsetDatabaseOptions.keys)
}
inline void UnsetDatabaseOptions::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.UnsetDatabaseOptions.keys)
}
inline void UnsetDatabaseOptions::add_keys(const char* value, size_t size) {
  _impl_.keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.UnsetDatabaseOptions.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnsetDatabaseOptions::keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.UnsetDatabaseOptions.keys)
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnsetDatabaseOptions::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.UnsetDatabaseOptions.keys)
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateTriggerExpr

// string catalog_name = 1;
inline void CreateTriggerExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateTriggerExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTriggerExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTriggerExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTriggerExpr.catalog_name)
}
inline std::string* CreateTriggerExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTriggerExpr.catalog_name)
  return _s;
}
inline const std::string& CreateTriggerExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateTriggerExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTriggerExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTriggerExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTriggerExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateTriggerExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTriggerExpr.catalog_name)
}

// string trigger_name = 2;
inline void CreateTriggerExpr::clear_trigger_name() {
  _impl_.trigger_name_.ClearToEmpty();
}
inline const std::string& CreateTriggerExpr::trigger_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTriggerExpr.trigger_name)
  return _internal_trigger_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTriggerExpr::set_trigger_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTriggerExpr.trigger_name)
}
inline std::string* CreateTriggerExpr::mutable_trigger_name() {
  std::string* _s = _internal_mutable_trigger_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTriggerExpr.trigger_name)
  return _s;
}
inline const std::string& CreateTriggerExpr::_internal_trigger_name() const {
  return _impl_.trigger_name_.Get();
}
inline void CreateTriggerExpr::_internal_set_trigger_name(const std::string& value) {
  
  _impl_.trigger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTriggerExpr::_internal_mutable_trigger_name() {
  
  return _impl_.trigger_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTriggerExpr::release_trigger_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTriggerExpr.trigger_name)
  return _impl_.trigger_name_.Release();
}
inline void CreateTriggerExpr::set_allocated_trigger_name(std::string* trigger_name) {
  if (trigger_name != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_name_.SetAllocated(trigger_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_name_.IsDefault()) {
    _impl_.trigger_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTriggerExpr.trigger_name)
}

// bool create_if_not_exists = 3;
inline void CreateTriggerExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateTriggerExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateTriggerExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTriggerExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateTriggerExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateTriggerExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTriggerExpr.create_if_not_exists)
}

// string sql = 4;
inline void CreateTriggerExpr::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& CreateTriggerExpr::sql() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTriggerExpr.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTriggerExpr::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTriggerExpr.sql)
}
inline std::string* CreateTriggerExpr::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTriggerExpr.sql)
  return _s;
}
inline const std::string& CreateTriggerExpr::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void CreateTriggerExpr::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTriggerExpr::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTriggerExpr::release_sql() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTriggerExpr.sql)
  return _impl_.sql_.Release();
}
inline void CreateTriggerExpr::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTriggerExpr.sql)
}

// repeated .greptime.v1.NotifyChannel channels = 5;
inline int CreateTriggerExpr::_internal_channels_size() const {
  return _impl_.channels_.size();
}
inline int CreateTriggerExpr::channels_size() const {
  return _internal_channels_size();
}
inline void CreateTriggerExpr::clear_channels() {
  _impl_.channels_.Clear();
}
inline ::greptime::v1::NotifyChannel* CreateTriggerExpr::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTriggerExpr.channels)
  return _impl_.channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::NotifyChannel >*
CreateTriggerExpr::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTriggerExpr.channels)
  return &_impl_.channels_;
}
inline const ::greptime::v1::NotifyChannel& CreateTriggerExpr::_internal_channels(int index) const {
  return _impl_.channels_.Get(index);
}
inline const ::greptime::v1::NotifyChannel& CreateTriggerExpr::channels(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTriggerExpr.channels)
  return _internal_channels(index);
}
inline ::greptime::v1::NotifyChannel* CreateTriggerExpr::_internal_add_channels() {
  return _impl_.channels_.Add();
}
inline ::greptime::v1::NotifyChannel* CreateTriggerExpr::add_channels() {
  ::greptime::v1::NotifyChannel* _add = _internal_add_channels();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTriggerExpr.channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::NotifyChannel >&
CreateTriggerExpr::channels() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTriggerExpr.channels)
  return _impl_.channels_;
}

// map<string, string> labels = 6;
inline int CreateTriggerExpr::_internal_labels_size() const {
  return _impl_.labels_.size();
}
inline int CreateTriggerExpr::labels_size() const {
  return _internal_labels_size();
}
inline void CreateTriggerExpr::clear_labels() {
  _impl_.labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTriggerExpr::_internal_labels() const {
  return _impl_.labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTriggerExpr::labels() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateTriggerExpr.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTriggerExpr::_internal_mutable_labels() {
  return _impl_.labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTriggerExpr::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateTriggerExpr.labels)
  return _internal_mutable_labels();
}

// map<string, string> annotations = 7;
inline int CreateTriggerExpr::_internal_annotations_size() const {
  return _impl_.annotations_.size();
}
inline int CreateTriggerExpr::annotations_size() const {
  return _internal_annotations_size();
}
inline void CreateTriggerExpr::clear_annotations() {
  _impl_.annotations_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTriggerExpr::_internal_annotations() const {
  return _impl_.annotations_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTriggerExpr::annotations() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateTriggerExpr.annotations)
  return _internal_annotations();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTriggerExpr::_internal_mutable_annotations() {
  return _impl_.annotations_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTriggerExpr::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateTriggerExpr.annotations)
  return _internal_mutable_annotations();
}

// uint64 interval = 8;
inline void CreateTriggerExpr::clear_interval() {
  _impl_.interval_ = uint64_t{0u};
}
inline uint64_t CreateTriggerExpr::_internal_interval() const {
  return _impl_.interval_;
}
inline uint64_t CreateTriggerExpr::interval() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTriggerExpr.interval)
  return _internal_interval();
}
inline void CreateTriggerExpr::_internal_set_interval(uint64_t value) {
  
  _impl_.interval_ = value;
}
inline void CreateTriggerExpr::set_interval(uint64_t value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTriggerExpr.interval)
}

// -------------------------------------------------------------------

// NotifyChannel

// string name = 1;
inline void NotifyChannel::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NotifyChannel::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.NotifyChannel.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NotifyChannel::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.NotifyChannel.name)
}
inline std::string* NotifyChannel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.NotifyChannel.name)
  return _s;
}
inline const std::string& NotifyChannel::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NotifyChannel::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NotifyChannel::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NotifyChannel::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.NotifyChannel.name)
  return _impl_.name_.Release();
}
inline void NotifyChannel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.NotifyChannel.name)
}

// .greptime.v1.WebhookOptions webhook = 2;
inline bool NotifyChannel::_internal_has_webhook() const {
  return channel_type_case() == kWebhook;
}
inline bool NotifyChannel::has_webhook() const {
  return _internal_has_webhook();
}
inline void NotifyChannel::set_has_webhook() {
  _impl_._oneof_case_[0] = kWebhook;
}
inline void NotifyChannel::clear_webhook() {
  if (_internal_has_webhook()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.channel_type_.webhook_;
    }
    clear_has_channel_type();
  }
}
inline ::greptime::v1::WebhookOptions* NotifyChannel::release_webhook() {
  // @@protoc_insertion_point(field_release:greptime.v1.NotifyChannel.webhook)
  if (_internal_has_webhook()) {
    clear_has_channel_type();
    ::greptime::v1::WebhookOptions* temp = _impl_.channel_type_.webhook_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.channel_type_.webhook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::WebhookOptions& NotifyChannel::_internal_webhook() const {
  return _internal_has_webhook()
      ? *_impl_.channel_type_.webhook_
      : reinterpret_cast< ::greptime::v1::WebhookOptions&>(::greptime::v1::_WebhookOptions_default_instance_);
}
inline const ::greptime::v1::WebhookOptions& NotifyChannel::webhook() const {
  // @@protoc_insertion_point(field_get:greptime.v1.NotifyChannel.webhook)
  return _internal_webhook();
}
inline ::greptime::v1::WebhookOptions* NotifyChannel::unsafe_arena_release_webhook() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.NotifyChannel.webhook)
  if (_internal_has_webhook()) {
    clear_has_channel_type();
    ::greptime::v1::WebhookOptions* temp = _impl_.channel_type_.webhook_;
    _impl_.channel_type_.webhook_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NotifyChannel::unsafe_arena_set_allocated_webhook(::greptime::v1::WebhookOptions* webhook) {
  clear_channel_type();
  if (webhook) {
    set_has_webhook();
    _impl_.channel_type_.webhook_ = webhook;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.NotifyChannel.webhook)
}
inline ::greptime::v1::WebhookOptions* NotifyChannel::_internal_mutable_webhook() {
  if (!_internal_has_webhook()) {
    clear_channel_type();
    set_has_webhook();
    _impl_.channel_type_.webhook_ = CreateMaybeMessage< ::greptime::v1::WebhookOptions >(GetArenaForAllocation());
  }
  return _impl_.channel_type_.webhook_;
}
inline ::greptime::v1::WebhookOptions* NotifyChannel::mutable_webhook() {
  ::greptime::v1::WebhookOptions* _msg = _internal_mutable_webhook();
  // @@protoc_insertion_point(field_mutable:greptime.v1.NotifyChannel.webhook)
  return _msg;
}

inline bool NotifyChannel::has_channel_type() const {
  return channel_type_case() != CHANNEL_TYPE_NOT_SET;
}
inline void NotifyChannel::clear_has_channel_type() {
  _impl_._oneof_case_[0] = CHANNEL_TYPE_NOT_SET;
}
inline NotifyChannel::ChannelTypeCase NotifyChannel::channel_type_case() const {
  return NotifyChannel::ChannelTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WebhookOptions

// string url = 1;
inline void WebhookOptions::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& WebhookOptions::url() const {
  // @@protoc_insertion_point(field_get:greptime.v1.WebhookOptions.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebhookOptions::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.WebhookOptions.url)
}
inline std::string* WebhookOptions::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:greptime.v1.WebhookOptions.url)
  return _s;
}
inline const std::string& WebhookOptions::_internal_url() const {
  return _impl_.url_.Get();
}
inline void WebhookOptions::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebhookOptions::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebhookOptions::release_url() {
  // @@protoc_insertion_point(field_release:greptime.v1.WebhookOptions.url)
  return _impl_.url_.Release();
}
inline void WebhookOptions::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.WebhookOptions.url)
}

// map<string, string> opts = 2;
inline int WebhookOptions::_internal_opts_size() const {
  return _impl_.opts_.size();
}
inline int WebhookOptions::opts_size() const {
  return _internal_opts_size();
}
inline void WebhookOptions::clear_opts() {
  _impl_.opts_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WebhookOptions::_internal_opts() const {
  return _impl_.opts_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WebhookOptions::opts() const {
  // @@protoc_insertion_point(field_map:greptime.v1.WebhookOptions.opts)
  return _internal_opts();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WebhookOptions::_internal_mutable_opts() {
  return _impl_.opts_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WebhookOptions::mutable_opts() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.WebhookOptions.opts)
  return _internal_mutable_opts();
}

// -------------------------------------------------------------------

// DropTriggerExpr

// string catalog_name = 1;
inline void DropTriggerExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropTriggerExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTriggerExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTriggerExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTriggerExpr.catalog_name)
}
inline std::string* DropTriggerExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTriggerExpr.catalog_name)
  return _s;
}
inline const std::string& DropTriggerExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropTriggerExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTriggerExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTriggerExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTriggerExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropTriggerExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTriggerExpr.catalog_name)
}

// string trigger_name = 2;
inline void DropTriggerExpr::clear_trigger_name() {
  _impl_.trigger_name_.ClearToEmpty();
}
inline const std::string& DropTriggerExpr::trigger_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTriggerExpr.trigger_name)
  return _internal_trigger_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTriggerExpr::set_trigger_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.trigger_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTriggerExpr.trigger_name)
}
inline std::string* DropTriggerExpr::mutable_trigger_name() {
  std::string* _s = _internal_mutable_trigger_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTriggerExpr.trigger_name)
  return _s;
}
inline const std::string& DropTriggerExpr::_internal_trigger_name() const {
  return _impl_.trigger_name_.Get();
}
inline void DropTriggerExpr::_internal_set_trigger_name(const std::string& value) {
  
  _impl_.trigger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTriggerExpr::_internal_mutable_trigger_name() {
  
  return _impl_.trigger_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTriggerExpr::release_trigger_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTriggerExpr.trigger_name)
  return _impl_.trigger_name_.Release();
}
inline void DropTriggerExpr::set_allocated_trigger_name(std::string* trigger_name) {
  if (trigger_name != nullptr) {
    
  } else {
    
  }
  _impl_.trigger_name_.SetAllocated(trigger_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trigger_name_.IsDefault()) {
    _impl_.trigger_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTriggerExpr.trigger_name)
}

// bool drop_if_exists = 3;
inline void DropTriggerExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropTriggerExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropTriggerExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTriggerExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropTriggerExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropTriggerExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropTriggerExpr.drop_if_exists)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::AddColumnLocation_LocationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::AddColumnLocation_LocationType>() {
  return ::greptime::v1::AddColumnLocation_LocationType_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::Analyzer> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::Analyzer>() {
  return ::greptime::v1::Analyzer_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::FulltextBackend> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::FulltextBackend>() {
  return ::greptime::v1::FulltextBackend_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::SkippingIndexType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::SkippingIndexType>() {
  return ::greptime::v1::SkippingIndexType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto
