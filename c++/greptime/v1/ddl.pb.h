// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/ddl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fddl_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fddl_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fddl_2eproto;
namespace greptime {
namespace v1 {
class AddColumn;
struct AddColumnDefaultTypeInternal;
extern AddColumnDefaultTypeInternal _AddColumn_default_instance_;
class AddColumnLocation;
struct AddColumnLocationDefaultTypeInternal;
extern AddColumnLocationDefaultTypeInternal _AddColumnLocation_default_instance_;
class AddColumns;
struct AddColumnsDefaultTypeInternal;
extern AddColumnsDefaultTypeInternal _AddColumns_default_instance_;
class AlterExpr;
struct AlterExprDefaultTypeInternal;
extern AlterExprDefaultTypeInternal _AlterExpr_default_instance_;
class ChangeColumnType;
struct ChangeColumnTypeDefaultTypeInternal;
extern ChangeColumnTypeDefaultTypeInternal _ChangeColumnType_default_instance_;
class ChangeColumnTypes;
struct ChangeColumnTypesDefaultTypeInternal;
extern ChangeColumnTypesDefaultTypeInternal _ChangeColumnTypes_default_instance_;
class ChangeTableOptions;
struct ChangeTableOptionsDefaultTypeInternal;
extern ChangeTableOptionsDefaultTypeInternal _ChangeTableOptions_default_instance_;
class ColumnDef;
struct ColumnDefDefaultTypeInternal;
extern ColumnDefDefaultTypeInternal _ColumnDef_default_instance_;
class CreateDatabaseExpr;
struct CreateDatabaseExprDefaultTypeInternal;
extern CreateDatabaseExprDefaultTypeInternal _CreateDatabaseExpr_default_instance_;
class CreateDatabaseExpr_OptionsEntry_DoNotUse;
struct CreateDatabaseExpr_OptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateDatabaseExpr_OptionsEntry_DoNotUseDefaultTypeInternal _CreateDatabaseExpr_OptionsEntry_DoNotUse_default_instance_;
class CreateFlowExpr;
struct CreateFlowExprDefaultTypeInternal;
extern CreateFlowExprDefaultTypeInternal _CreateFlowExpr_default_instance_;
class CreateFlowExpr_FlowOptionsEntry_DoNotUse;
struct CreateFlowExpr_FlowOptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateFlowExpr_FlowOptionsEntry_DoNotUseDefaultTypeInternal _CreateFlowExpr_FlowOptionsEntry_DoNotUse_default_instance_;
class CreateTableExpr;
struct CreateTableExprDefaultTypeInternal;
extern CreateTableExprDefaultTypeInternal _CreateTableExpr_default_instance_;
class CreateTableExpr_TableOptionsEntry_DoNotUse;
struct CreateTableExpr_TableOptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateTableExpr_TableOptionsEntry_DoNotUseDefaultTypeInternal _CreateTableExpr_TableOptionsEntry_DoNotUse_default_instance_;
class CreateViewExpr;
struct CreateViewExprDefaultTypeInternal;
extern CreateViewExprDefaultTypeInternal _CreateViewExpr_default_instance_;
class DdlRequest;
struct DdlRequestDefaultTypeInternal;
extern DdlRequestDefaultTypeInternal _DdlRequest_default_instance_;
class DropColumn;
struct DropColumnDefaultTypeInternal;
extern DropColumnDefaultTypeInternal _DropColumn_default_instance_;
class DropColumns;
struct DropColumnsDefaultTypeInternal;
extern DropColumnsDefaultTypeInternal _DropColumns_default_instance_;
class DropDatabaseExpr;
struct DropDatabaseExprDefaultTypeInternal;
extern DropDatabaseExprDefaultTypeInternal _DropDatabaseExpr_default_instance_;
class DropFlowExpr;
struct DropFlowExprDefaultTypeInternal;
extern DropFlowExprDefaultTypeInternal _DropFlowExpr_default_instance_;
class DropTableExpr;
struct DropTableExprDefaultTypeInternal;
extern DropTableExprDefaultTypeInternal _DropTableExpr_default_instance_;
class DropViewExpr;
struct DropViewExprDefaultTypeInternal;
extern DropViewExprDefaultTypeInternal _DropViewExpr_default_instance_;
class FlowId;
struct FlowIdDefaultTypeInternal;
extern FlowIdDefaultTypeInternal _FlowId_default_instance_;
class RenameTable;
struct RenameTableDefaultTypeInternal;
extern RenameTableDefaultTypeInternal _RenameTable_default_instance_;
class TableId;
struct TableIdDefaultTypeInternal;
extern TableIdDefaultTypeInternal _TableId_default_instance_;
class TruncateTableExpr;
struct TruncateTableExprDefaultTypeInternal;
extern TruncateTableExprDefaultTypeInternal _TruncateTableExpr_default_instance_;
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::AddColumn* Arena::CreateMaybeMessage<::greptime::v1::AddColumn>(Arena*);
template<> ::greptime::v1::AddColumnLocation* Arena::CreateMaybeMessage<::greptime::v1::AddColumnLocation>(Arena*);
template<> ::greptime::v1::AddColumns* Arena::CreateMaybeMessage<::greptime::v1::AddColumns>(Arena*);
template<> ::greptime::v1::AlterExpr* Arena::CreateMaybeMessage<::greptime::v1::AlterExpr>(Arena*);
template<> ::greptime::v1::ChangeColumnType* Arena::CreateMaybeMessage<::greptime::v1::ChangeColumnType>(Arena*);
template<> ::greptime::v1::ChangeColumnTypes* Arena::CreateMaybeMessage<::greptime::v1::ChangeColumnTypes>(Arena*);
template<> ::greptime::v1::ChangeTableOptions* Arena::CreateMaybeMessage<::greptime::v1::ChangeTableOptions>(Arena*);
template<> ::greptime::v1::ColumnDef* Arena::CreateMaybeMessage<::greptime::v1::ColumnDef>(Arena*);
template<> ::greptime::v1::CreateDatabaseExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateDatabaseExpr>(Arena*);
template<> ::greptime::v1::CreateDatabaseExpr_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateDatabaseExpr_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateFlowExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateFlowExpr>(Arena*);
template<> ::greptime::v1::CreateFlowExpr_FlowOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateFlowExpr_FlowOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateTableExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateTableExpr>(Arena*);
template<> ::greptime::v1::CreateTableExpr_TableOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::CreateTableExpr_TableOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::CreateViewExpr* Arena::CreateMaybeMessage<::greptime::v1::CreateViewExpr>(Arena*);
template<> ::greptime::v1::DdlRequest* Arena::CreateMaybeMessage<::greptime::v1::DdlRequest>(Arena*);
template<> ::greptime::v1::DropColumn* Arena::CreateMaybeMessage<::greptime::v1::DropColumn>(Arena*);
template<> ::greptime::v1::DropColumns* Arena::CreateMaybeMessage<::greptime::v1::DropColumns>(Arena*);
template<> ::greptime::v1::DropDatabaseExpr* Arena::CreateMaybeMessage<::greptime::v1::DropDatabaseExpr>(Arena*);
template<> ::greptime::v1::DropFlowExpr* Arena::CreateMaybeMessage<::greptime::v1::DropFlowExpr>(Arena*);
template<> ::greptime::v1::DropTableExpr* Arena::CreateMaybeMessage<::greptime::v1::DropTableExpr>(Arena*);
template<> ::greptime::v1::DropViewExpr* Arena::CreateMaybeMessage<::greptime::v1::DropViewExpr>(Arena*);
template<> ::greptime::v1::FlowId* Arena::CreateMaybeMessage<::greptime::v1::FlowId>(Arena*);
template<> ::greptime::v1::RenameTable* Arena::CreateMaybeMessage<::greptime::v1::RenameTable>(Arena*);
template<> ::greptime::v1::TableId* Arena::CreateMaybeMessage<::greptime::v1::TableId>(Arena*);
template<> ::greptime::v1::TruncateTableExpr* Arena::CreateMaybeMessage<::greptime::v1::TruncateTableExpr>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {

enum AddColumnLocation_LocationType : int {
  AddColumnLocation_LocationType_FIRST = 0,
  AddColumnLocation_LocationType_AFTER = 1,
  AddColumnLocation_LocationType_AddColumnLocation_LocationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddColumnLocation_LocationType_AddColumnLocation_LocationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddColumnLocation_LocationType_IsValid(int value);
constexpr AddColumnLocation_LocationType AddColumnLocation_LocationType_LocationType_MIN = AddColumnLocation_LocationType_FIRST;
constexpr AddColumnLocation_LocationType AddColumnLocation_LocationType_LocationType_MAX = AddColumnLocation_LocationType_AFTER;
constexpr int AddColumnLocation_LocationType_LocationType_ARRAYSIZE = AddColumnLocation_LocationType_LocationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddColumnLocation_LocationType_descriptor();
template<typename T>
inline const std::string& AddColumnLocation_LocationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddColumnLocation_LocationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddColumnLocation_LocationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddColumnLocation_LocationType_descriptor(), enum_t_value);
}
inline bool AddColumnLocation_LocationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddColumnLocation_LocationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddColumnLocation_LocationType>(
    AddColumnLocation_LocationType_descriptor(), name, value);
}
// ===================================================================

class DdlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DdlRequest) */ {
 public:
  inline DdlRequest() : DdlRequest(nullptr) {}
  ~DdlRequest() override;
  explicit PROTOBUF_CONSTEXPR DdlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlRequest(const DdlRequest& from);
  DdlRequest(DdlRequest&& from) noexcept
    : DdlRequest() {
    *this = ::std::move(from);
  }

  inline DdlRequest& operator=(const DdlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlRequest& operator=(DdlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ExprCase {
    kCreateDatabase = 1,
    kCreateTable = 2,
    kAlter = 3,
    kDropTable = 4,
    kTruncateTable = 7,
    kCreateFlow = 8,
    kDropFlow = 9,
    kCreateView = 10,
    kDropView = 11,
    EXPR_NOT_SET = 0,
  };

  static inline const DdlRequest* internal_default_instance() {
    return reinterpret_cast<const DdlRequest*>(
               &_DdlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DdlRequest& a, DdlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DdlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DdlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DdlRequest& from) {
    DdlRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DdlRequest";
  }
  protected:
  explicit DdlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateDatabaseFieldNumber = 1,
    kCreateTableFieldNumber = 2,
    kAlterFieldNumber = 3,
    kDropTableFieldNumber = 4,
    kTruncateTableFieldNumber = 7,
    kCreateFlowFieldNumber = 8,
    kDropFlowFieldNumber = 9,
    kCreateViewFieldNumber = 10,
    kDropViewFieldNumber = 11,
  };
  // .greptime.v1.CreateDatabaseExpr create_database = 1;
  bool has_create_database() const;
  private:
  bool _internal_has_create_database() const;
  public:
  void clear_create_database();
  const ::greptime::v1::CreateDatabaseExpr& create_database() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateDatabaseExpr* release_create_database();
  ::greptime::v1::CreateDatabaseExpr* mutable_create_database();
  void set_allocated_create_database(::greptime::v1::CreateDatabaseExpr* create_database);
  private:
  const ::greptime::v1::CreateDatabaseExpr& _internal_create_database() const;
  ::greptime::v1::CreateDatabaseExpr* _internal_mutable_create_database();
  public:
  void unsafe_arena_set_allocated_create_database(
      ::greptime::v1::CreateDatabaseExpr* create_database);
  ::greptime::v1::CreateDatabaseExpr* unsafe_arena_release_create_database();

  // .greptime.v1.CreateTableExpr create_table = 2;
  bool has_create_table() const;
  private:
  bool _internal_has_create_table() const;
  public:
  void clear_create_table();
  const ::greptime::v1::CreateTableExpr& create_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateTableExpr* release_create_table();
  ::greptime::v1::CreateTableExpr* mutable_create_table();
  void set_allocated_create_table(::greptime::v1::CreateTableExpr* create_table);
  private:
  const ::greptime::v1::CreateTableExpr& _internal_create_table() const;
  ::greptime::v1::CreateTableExpr* _internal_mutable_create_table();
  public:
  void unsafe_arena_set_allocated_create_table(
      ::greptime::v1::CreateTableExpr* create_table);
  ::greptime::v1::CreateTableExpr* unsafe_arena_release_create_table();

  // .greptime.v1.AlterExpr alter = 3;
  bool has_alter() const;
  private:
  bool _internal_has_alter() const;
  public:
  void clear_alter();
  const ::greptime::v1::AlterExpr& alter() const;
  PROTOBUF_NODISCARD ::greptime::v1::AlterExpr* release_alter();
  ::greptime::v1::AlterExpr* mutable_alter();
  void set_allocated_alter(::greptime::v1::AlterExpr* alter);
  private:
  const ::greptime::v1::AlterExpr& _internal_alter() const;
  ::greptime::v1::AlterExpr* _internal_mutable_alter();
  public:
  void unsafe_arena_set_allocated_alter(
      ::greptime::v1::AlterExpr* alter);
  ::greptime::v1::AlterExpr* unsafe_arena_release_alter();

  // .greptime.v1.DropTableExpr drop_table = 4;
  bool has_drop_table() const;
  private:
  bool _internal_has_drop_table() const;
  public:
  void clear_drop_table();
  const ::greptime::v1::DropTableExpr& drop_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropTableExpr* release_drop_table();
  ::greptime::v1::DropTableExpr* mutable_drop_table();
  void set_allocated_drop_table(::greptime::v1::DropTableExpr* drop_table);
  private:
  const ::greptime::v1::DropTableExpr& _internal_drop_table() const;
  ::greptime::v1::DropTableExpr* _internal_mutable_drop_table();
  public:
  void unsafe_arena_set_allocated_drop_table(
      ::greptime::v1::DropTableExpr* drop_table);
  ::greptime::v1::DropTableExpr* unsafe_arena_release_drop_table();

  // .greptime.v1.TruncateTableExpr truncate_table = 7;
  bool has_truncate_table() const;
  private:
  bool _internal_has_truncate_table() const;
  public:
  void clear_truncate_table();
  const ::greptime::v1::TruncateTableExpr& truncate_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::TruncateTableExpr* release_truncate_table();
  ::greptime::v1::TruncateTableExpr* mutable_truncate_table();
  void set_allocated_truncate_table(::greptime::v1::TruncateTableExpr* truncate_table);
  private:
  const ::greptime::v1::TruncateTableExpr& _internal_truncate_table() const;
  ::greptime::v1::TruncateTableExpr* _internal_mutable_truncate_table();
  public:
  void unsafe_arena_set_allocated_truncate_table(
      ::greptime::v1::TruncateTableExpr* truncate_table);
  ::greptime::v1::TruncateTableExpr* unsafe_arena_release_truncate_table();

  // .greptime.v1.CreateFlowExpr create_flow = 8;
  bool has_create_flow() const;
  private:
  bool _internal_has_create_flow() const;
  public:
  void clear_create_flow();
  const ::greptime::v1::CreateFlowExpr& create_flow() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateFlowExpr* release_create_flow();
  ::greptime::v1::CreateFlowExpr* mutable_create_flow();
  void set_allocated_create_flow(::greptime::v1::CreateFlowExpr* create_flow);
  private:
  const ::greptime::v1::CreateFlowExpr& _internal_create_flow() const;
  ::greptime::v1::CreateFlowExpr* _internal_mutable_create_flow();
  public:
  void unsafe_arena_set_allocated_create_flow(
      ::greptime::v1::CreateFlowExpr* create_flow);
  ::greptime::v1::CreateFlowExpr* unsafe_arena_release_create_flow();

  // .greptime.v1.DropFlowExpr drop_flow = 9;
  bool has_drop_flow() const;
  private:
  bool _internal_has_drop_flow() const;
  public:
  void clear_drop_flow();
  const ::greptime::v1::DropFlowExpr& drop_flow() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropFlowExpr* release_drop_flow();
  ::greptime::v1::DropFlowExpr* mutable_drop_flow();
  void set_allocated_drop_flow(::greptime::v1::DropFlowExpr* drop_flow);
  private:
  const ::greptime::v1::DropFlowExpr& _internal_drop_flow() const;
  ::greptime::v1::DropFlowExpr* _internal_mutable_drop_flow();
  public:
  void unsafe_arena_set_allocated_drop_flow(
      ::greptime::v1::DropFlowExpr* drop_flow);
  ::greptime::v1::DropFlowExpr* unsafe_arena_release_drop_flow();

  // .greptime.v1.CreateViewExpr create_view = 10;
  bool has_create_view() const;
  private:
  bool _internal_has_create_view() const;
  public:
  void clear_create_view();
  const ::greptime::v1::CreateViewExpr& create_view() const;
  PROTOBUF_NODISCARD ::greptime::v1::CreateViewExpr* release_create_view();
  ::greptime::v1::CreateViewExpr* mutable_create_view();
  void set_allocated_create_view(::greptime::v1::CreateViewExpr* create_view);
  private:
  const ::greptime::v1::CreateViewExpr& _internal_create_view() const;
  ::greptime::v1::CreateViewExpr* _internal_mutable_create_view();
  public:
  void unsafe_arena_set_allocated_create_view(
      ::greptime::v1::CreateViewExpr* create_view);
  ::greptime::v1::CreateViewExpr* unsafe_arena_release_create_view();

  // .greptime.v1.DropViewExpr drop_view = 11;
  bool has_drop_view() const;
  private:
  bool _internal_has_drop_view() const;
  public:
  void clear_drop_view();
  const ::greptime::v1::DropViewExpr& drop_view() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropViewExpr* release_drop_view();
  ::greptime::v1::DropViewExpr* mutable_drop_view();
  void set_allocated_drop_view(::greptime::v1::DropViewExpr* drop_view);
  private:
  const ::greptime::v1::DropViewExpr& _internal_drop_view() const;
  ::greptime::v1::DropViewExpr* _internal_mutable_drop_view();
  public:
  void unsafe_arena_set_allocated_drop_view(
      ::greptime::v1::DropViewExpr* drop_view);
  ::greptime::v1::DropViewExpr* unsafe_arena_release_drop_view();

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.DdlRequest)
 private:
  class _Internal;
  void set_has_create_database();
  void set_has_create_table();
  void set_has_alter();
  void set_has_drop_table();
  void set_has_truncate_table();
  void set_has_create_flow();
  void set_has_drop_flow();
  void set_has_create_view();
  void set_has_drop_view();

  inline bool has_expr() const;
  inline void clear_has_expr();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ExprUnion {
      constexpr ExprUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::CreateDatabaseExpr* create_database_;
      ::greptime::v1::CreateTableExpr* create_table_;
      ::greptime::v1::AlterExpr* alter_;
      ::greptime::v1::DropTableExpr* drop_table_;
      ::greptime::v1::TruncateTableExpr* truncate_table_;
      ::greptime::v1::CreateFlowExpr* create_flow_;
      ::greptime::v1::DropFlowExpr* drop_flow_;
      ::greptime::v1::CreateViewExpr* create_view_;
      ::greptime::v1::DropViewExpr* drop_view_;
    } expr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateFlowExpr_FlowOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateFlowExpr_FlowOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateFlowExpr_FlowOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateFlowExpr_FlowOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateFlowExpr_FlowOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateFlowExpr_FlowOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateFlowExpr_FlowOptionsEntry_DoNotUse& other);
  static const CreateFlowExpr_FlowOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateFlowExpr_FlowOptionsEntry_DoNotUse*>(&_CreateFlowExpr_FlowOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateFlowExpr.FlowOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateFlowExpr.FlowOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateFlowExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateFlowExpr) */ {
 public:
  inline CreateFlowExpr() : CreateFlowExpr(nullptr) {}
  ~CreateFlowExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateFlowExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFlowExpr(const CreateFlowExpr& from);
  CreateFlowExpr(CreateFlowExpr&& from) noexcept
    : CreateFlowExpr() {
    *this = ::std::move(from);
  }

  inline CreateFlowExpr& operator=(const CreateFlowExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFlowExpr& operator=(CreateFlowExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFlowExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFlowExpr* internal_default_instance() {
    return reinterpret_cast<const CreateFlowExpr*>(
               &_CreateFlowExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateFlowExpr& a, CreateFlowExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFlowExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFlowExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFlowExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFlowExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFlowExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateFlowExpr& from) {
    CreateFlowExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFlowExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateFlowExpr";
  }
  protected:
  explicit CreateFlowExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSourceTableNamesFieldNumber = 3,
    kFlowOptionsFieldNumber = 10,
    kCatalogNameFieldNumber = 1,
    kFlowNameFieldNumber = 2,
    kCommentFieldNumber = 8,
    kSqlFieldNumber = 9,
    kSinkTableNameFieldNumber = 4,
    kExpireAfterFieldNumber = 7,
    kOrReplaceFieldNumber = 5,
    kCreateIfNotExistsFieldNumber = 6,
  };
  // repeated .greptime.v1.TableName source_table_names = 3;
  int source_table_names_size() const;
  private:
  int _internal_source_table_names_size() const;
  public:
  void clear_source_table_names();
  ::greptime::v1::TableName* mutable_source_table_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
      mutable_source_table_names();
  private:
  const ::greptime::v1::TableName& _internal_source_table_names(int index) const;
  ::greptime::v1::TableName* _internal_add_source_table_names();
  public:
  const ::greptime::v1::TableName& source_table_names(int index) const;
  ::greptime::v1::TableName* add_source_table_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
      source_table_names() const;

  // map<string, string> flow_options = 10;
  int flow_options_size() const;
  private:
  int _internal_flow_options_size() const;
  public:
  void clear_flow_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_flow_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_flow_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      flow_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_flow_options();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string flow_name = 2;
  void clear_flow_name();
  const std::string& flow_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flow_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flow_name();
  PROTOBUF_NODISCARD std::string* release_flow_name();
  void set_allocated_flow_name(std::string* flow_name);
  private:
  const std::string& _internal_flow_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_name(const std::string& value);
  std::string* _internal_mutable_flow_name();
  public:

  // string comment = 8;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string sql = 9;
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // .greptime.v1.TableName sink_table_name = 4;
  bool has_sink_table_name() const;
  private:
  bool _internal_has_sink_table_name() const;
  public:
  void clear_sink_table_name();
  const ::greptime::v1::TableName& sink_table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableName* release_sink_table_name();
  ::greptime::v1::TableName* mutable_sink_table_name();
  void set_allocated_sink_table_name(::greptime::v1::TableName* sink_table_name);
  private:
  const ::greptime::v1::TableName& _internal_sink_table_name() const;
  ::greptime::v1::TableName* _internal_mutable_sink_table_name();
  public:
  void unsafe_arena_set_allocated_sink_table_name(
      ::greptime::v1::TableName* sink_table_name);
  ::greptime::v1::TableName* unsafe_arena_release_sink_table_name();

  // .greptime.v1.ExpireAfter expire_after = 7;
  bool has_expire_after() const;
  private:
  bool _internal_has_expire_after() const;
  public:
  void clear_expire_after();
  const ::greptime::v1::ExpireAfter& expire_after() const;
  PROTOBUF_NODISCARD ::greptime::v1::ExpireAfter* release_expire_after();
  ::greptime::v1::ExpireAfter* mutable_expire_after();
  void set_allocated_expire_after(::greptime::v1::ExpireAfter* expire_after);
  private:
  const ::greptime::v1::ExpireAfter& _internal_expire_after() const;
  ::greptime::v1::ExpireAfter* _internal_mutable_expire_after();
  public:
  void unsafe_arena_set_allocated_expire_after(
      ::greptime::v1::ExpireAfter* expire_after);
  ::greptime::v1::ExpireAfter* unsafe_arena_release_expire_after();

  // bool or_replace = 5;
  void clear_or_replace();
  bool or_replace() const;
  void set_or_replace(bool value);
  private:
  bool _internal_or_replace() const;
  void _internal_set_or_replace(bool value);
  public:

  // bool create_if_not_exists = 6;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateFlowExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName > source_table_names_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateFlowExpr_FlowOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> flow_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::greptime::v1::TableName* sink_table_name_;
    ::greptime::v1::ExpireAfter* expire_after_;
    bool or_replace_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropFlowExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropFlowExpr) */ {
 public:
  inline DropFlowExpr() : DropFlowExpr(nullptr) {}
  ~DropFlowExpr() override;
  explicit PROTOBUF_CONSTEXPR DropFlowExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropFlowExpr(const DropFlowExpr& from);
  DropFlowExpr(DropFlowExpr&& from) noexcept
    : DropFlowExpr() {
    *this = ::std::move(from);
  }

  inline DropFlowExpr& operator=(const DropFlowExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropFlowExpr& operator=(DropFlowExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropFlowExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropFlowExpr* internal_default_instance() {
    return reinterpret_cast<const DropFlowExpr*>(
               &_DropFlowExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DropFlowExpr& a, DropFlowExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropFlowExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropFlowExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropFlowExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropFlowExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropFlowExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropFlowExpr& from) {
    DropFlowExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropFlowExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropFlowExpr";
  }
  protected:
  explicit DropFlowExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kFlowNameFieldNumber = 2,
    kFlowIdFieldNumber = 3,
    kDropIfExistsFieldNumber = 5,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string flow_name = 2;
  void clear_flow_name();
  const std::string& flow_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flow_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flow_name();
  PROTOBUF_NODISCARD std::string* release_flow_name();
  void set_allocated_flow_name(std::string* flow_name);
  private:
  const std::string& _internal_flow_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flow_name(const std::string& value);
  std::string* _internal_mutable_flow_name();
  public:

  // .greptime.v1.FlowId flow_id = 3;
  bool has_flow_id() const;
  private:
  bool _internal_has_flow_id() const;
  public:
  void clear_flow_id();
  const ::greptime::v1::FlowId& flow_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::FlowId* release_flow_id();
  ::greptime::v1::FlowId* mutable_flow_id();
  void set_allocated_flow_id(::greptime::v1::FlowId* flow_id);
  private:
  const ::greptime::v1::FlowId& _internal_flow_id() const;
  ::greptime::v1::FlowId* _internal_mutable_flow_id();
  public:
  void unsafe_arena_set_allocated_flow_id(
      ::greptime::v1::FlowId* flow_id);
  ::greptime::v1::FlowId* unsafe_arena_release_flow_id();

  // bool drop_if_exists = 5;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropFlowExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flow_name_;
    ::greptime::v1::FlowId* flow_id_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateViewExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateViewExpr) */ {
 public:
  inline CreateViewExpr() : CreateViewExpr(nullptr) {}
  ~CreateViewExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateViewExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateViewExpr(const CreateViewExpr& from);
  CreateViewExpr(CreateViewExpr&& from) noexcept
    : CreateViewExpr() {
    *this = ::std::move(from);
  }

  inline CreateViewExpr& operator=(const CreateViewExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateViewExpr& operator=(CreateViewExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateViewExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateViewExpr* internal_default_instance() {
    return reinterpret_cast<const CreateViewExpr*>(
               &_CreateViewExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateViewExpr& a, CreateViewExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateViewExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateViewExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateViewExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateViewExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateViewExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateViewExpr& from) {
    CreateViewExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateViewExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateViewExpr";
  }
  protected:
  explicit CreateViewExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNamesFieldNumber = 7,
    kColumnsFieldNumber = 8,
    kPlanColumnsFieldNumber = 9,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kViewNameFieldNumber = 3,
    kLogicalPlanFieldNumber = 4,
    kDefinitionFieldNumber = 10,
    kCreateIfNotExistsFieldNumber = 5,
    kOrReplaceFieldNumber = 6,
  };
  // repeated .greptime.v1.TableName table_names = 7;
  int table_names_size() const;
  private:
  int _internal_table_names_size() const;
  public:
  void clear_table_names();
  ::greptime::v1::TableName* mutable_table_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
      mutable_table_names();
  private:
  const ::greptime::v1::TableName& _internal_table_names(int index) const;
  ::greptime::v1::TableName* _internal_add_table_names();
  public:
  const ::greptime::v1::TableName& table_names(int index) const;
  ::greptime::v1::TableName* add_table_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
      table_names() const;

  // repeated string columns = 8;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // repeated string plan_columns = 9;
  int plan_columns_size() const;
  private:
  int _internal_plan_columns_size() const;
  public:
  void clear_plan_columns();
  const std::string& plan_columns(int index) const;
  std::string* mutable_plan_columns(int index);
  void set_plan_columns(int index, const std::string& value);
  void set_plan_columns(int index, std::string&& value);
  void set_plan_columns(int index, const char* value);
  void set_plan_columns(int index, const char* value, size_t size);
  std::string* add_plan_columns();
  void add_plan_columns(const std::string& value);
  void add_plan_columns(std::string&& value);
  void add_plan_columns(const char* value);
  void add_plan_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& plan_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_plan_columns();
  private:
  const std::string& _internal_plan_columns(int index) const;
  std::string* _internal_add_plan_columns();
  public:

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string view_name = 3;
  void clear_view_name();
  const std::string& view_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_name();
  PROTOBUF_NODISCARD std::string* release_view_name();
  void set_allocated_view_name(std::string* view_name);
  private:
  const std::string& _internal_view_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_name(const std::string& value);
  std::string* _internal_mutable_view_name();
  public:

  // bytes logical_plan = 4;
  void clear_logical_plan();
  const std::string& logical_plan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_plan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_plan();
  PROTOBUF_NODISCARD std::string* release_logical_plan();
  void set_allocated_logical_plan(std::string* logical_plan);
  private:
  const std::string& _internal_logical_plan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_plan(const std::string& value);
  std::string* _internal_mutable_logical_plan();
  public:

  // string definition = 10;
  void clear_definition();
  const std::string& definition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_definition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_definition();
  PROTOBUF_NODISCARD std::string* release_definition();
  void set_allocated_definition(std::string* definition);
  private:
  const std::string& _internal_definition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_definition(const std::string& value);
  std::string* _internal_mutable_definition();
  public:

  // bool create_if_not_exists = 5;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // bool or_replace = 6;
  void clear_or_replace();
  bool or_replace() const;
  void set_or_replace(bool value);
  private:
  bool _internal_or_replace() const;
  void _internal_set_or_replace(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateViewExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName > table_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> plan_columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_plan_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr definition_;
    bool create_if_not_exists_;
    bool or_replace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropViewExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropViewExpr) */ {
 public:
  inline DropViewExpr() : DropViewExpr(nullptr) {}
  ~DropViewExpr() override;
  explicit PROTOBUF_CONSTEXPR DropViewExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropViewExpr(const DropViewExpr& from);
  DropViewExpr(DropViewExpr&& from) noexcept
    : DropViewExpr() {
    *this = ::std::move(from);
  }

  inline DropViewExpr& operator=(const DropViewExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropViewExpr& operator=(DropViewExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropViewExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropViewExpr* internal_default_instance() {
    return reinterpret_cast<const DropViewExpr*>(
               &_DropViewExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DropViewExpr& a, DropViewExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropViewExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropViewExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropViewExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropViewExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropViewExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropViewExpr& from) {
    DropViewExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropViewExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropViewExpr";
  }
  protected:
  explicit DropViewExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kViewNameFieldNumber = 3,
    kViewIdFieldNumber = 4,
    kDropIfExistsFieldNumber = 5,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string view_name = 3;
  void clear_view_name();
  const std::string& view_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_name();
  PROTOBUF_NODISCARD std::string* release_view_name();
  void set_allocated_view_name(std::string* view_name);
  private:
  const std::string& _internal_view_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_name(const std::string& value);
  std::string* _internal_mutable_view_name();
  public:

  // .greptime.v1.TableId view_id = 4;
  bool has_view_id() const;
  private:
  bool _internal_has_view_id() const;
  public:
  void clear_view_id();
  const ::greptime::v1::TableId& view_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_view_id();
  ::greptime::v1::TableId* mutable_view_id();
  void set_allocated_view_id(::greptime::v1::TableId* view_id);
  private:
  const ::greptime::v1::TableId& _internal_view_id() const;
  ::greptime::v1::TableId* _internal_mutable_view_id();
  public:
  void unsafe_arena_set_allocated_view_id(
      ::greptime::v1::TableId* view_id);
  ::greptime::v1::TableId* unsafe_arena_release_view_id();

  // bool drop_if_exists = 5;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropViewExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_name_;
    ::greptime::v1::TableId* view_id_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateTableExpr_TableOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableExpr_TableOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateTableExpr_TableOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateTableExpr_TableOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateTableExpr_TableOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateTableExpr_TableOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateTableExpr_TableOptionsEntry_DoNotUse& other);
  static const CreateTableExpr_TableOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateTableExpr_TableOptionsEntry_DoNotUse*>(&_CreateTableExpr_TableOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTableExpr.TableOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateTableExpr.TableOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateTableExpr) */ {
 public:
  inline CreateTableExpr() : CreateTableExpr(nullptr) {}
  ~CreateTableExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableExpr(const CreateTableExpr& from);
  CreateTableExpr(CreateTableExpr&& from) noexcept
    : CreateTableExpr() {
    *this = ::std::move(from);
  }

  inline CreateTableExpr& operator=(const CreateTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableExpr& operator=(CreateTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableExpr* internal_default_instance() {
    return reinterpret_cast<const CreateTableExpr*>(
               &_CreateTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateTableExpr& a, CreateTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableExpr& from) {
    CreateTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateTableExpr";
  }
  protected:
  explicit CreateTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 5,
    kPrimaryKeysFieldNumber = 7,
    kTableOptionsFieldNumber = 9,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kDescFieldNumber = 4,
    kTimeIndexFieldNumber = 6,
    kEngineFieldNumber = 12,
    kTableIdFieldNumber = 10,
    kCreateIfNotExistsFieldNumber = 8,
  };
  // repeated .greptime.v1.ColumnDef column_defs = 5;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::greptime::v1::ColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >*
      mutable_column_defs();
  private:
  const ::greptime::v1::ColumnDef& _internal_column_defs(int index) const;
  ::greptime::v1::ColumnDef* _internal_add_column_defs();
  public:
  const ::greptime::v1::ColumnDef& column_defs(int index) const;
  ::greptime::v1::ColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >&
      column_defs() const;

  // repeated string primary_keys = 7;
  int primary_keys_size() const;
  private:
  int _internal_primary_keys_size() const;
  public:
  void clear_primary_keys();
  const std::string& primary_keys(int index) const;
  std::string* mutable_primary_keys(int index);
  void set_primary_keys(int index, const std::string& value);
  void set_primary_keys(int index, std::string&& value);
  void set_primary_keys(int index, const char* value);
  void set_primary_keys(int index, const char* value, size_t size);
  std::string* add_primary_keys();
  void add_primary_keys(const std::string& value);
  void add_primary_keys(std::string&& value);
  void add_primary_keys(const char* value);
  void add_primary_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& primary_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_primary_keys();
  private:
  const std::string& _internal_primary_keys(int index) const;
  std::string* _internal_add_primary_keys();
  public:

  // map<string, string> table_options = 9;
  int table_options_size() const;
  private:
  int _internal_table_options_size() const;
  public:
  void clear_table_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_table_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_table_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      table_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_table_options();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string desc = 4;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // string time_index = 6;
  void clear_time_index();
  const std::string& time_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_index();
  PROTOBUF_NODISCARD std::string* release_time_index();
  void set_allocated_time_index(std::string* time_index);
  private:
  const std::string& _internal_time_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_index(const std::string& value);
  std::string* _internal_mutable_time_index();
  public:

  // string engine = 12;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // .greptime.v1.TableId table_id = 10;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // bool create_if_not_exists = 8;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> primary_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateTableExpr_TableOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> table_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_index_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::greptime::v1::TableId* table_id_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AlterExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AlterExpr) */ {
 public:
  inline AlterExpr() : AlterExpr(nullptr) {}
  ~AlterExpr() override;
  explicit PROTOBUF_CONSTEXPR AlterExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterExpr(const AlterExpr& from);
  AlterExpr(AlterExpr&& from) noexcept
    : AlterExpr() {
    *this = ::std::move(from);
  }

  inline AlterExpr& operator=(const AlterExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterExpr& operator=(AlterExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterExpr& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kAddColumns = 4,
    kDropColumns = 5,
    kRenameTable = 6,
    kChangeColumnTypes = 7,
    kChangeTableOptions = 8,
    KIND_NOT_SET = 0,
  };

  static inline const AlterExpr* internal_default_instance() {
    return reinterpret_cast<const AlterExpr*>(
               &_AlterExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AlterExpr& a, AlterExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterExpr& from) {
    AlterExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AlterExpr";
  }
  protected:
  explicit AlterExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kAddColumnsFieldNumber = 4,
    kDropColumnsFieldNumber = 5,
    kRenameTableFieldNumber = 6,
    kChangeColumnTypesFieldNumber = 7,
    kChangeTableOptionsFieldNumber = 8,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.AddColumns add_columns = 4;
  bool has_add_columns() const;
  private:
  bool _internal_has_add_columns() const;
  public:
  void clear_add_columns();
  const ::greptime::v1::AddColumns& add_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumns* release_add_columns();
  ::greptime::v1::AddColumns* mutable_add_columns();
  void set_allocated_add_columns(::greptime::v1::AddColumns* add_columns);
  private:
  const ::greptime::v1::AddColumns& _internal_add_columns() const;
  ::greptime::v1::AddColumns* _internal_mutable_add_columns();
  public:
  void unsafe_arena_set_allocated_add_columns(
      ::greptime::v1::AddColumns* add_columns);
  ::greptime::v1::AddColumns* unsafe_arena_release_add_columns();

  // .greptime.v1.DropColumns drop_columns = 5;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::greptime::v1::DropColumns& drop_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::DropColumns* release_drop_columns();
  ::greptime::v1::DropColumns* mutable_drop_columns();
  void set_allocated_drop_columns(::greptime::v1::DropColumns* drop_columns);
  private:
  const ::greptime::v1::DropColumns& _internal_drop_columns() const;
  ::greptime::v1::DropColumns* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::greptime::v1::DropColumns* drop_columns);
  ::greptime::v1::DropColumns* unsafe_arena_release_drop_columns();

  // .greptime.v1.RenameTable rename_table = 6;
  bool has_rename_table() const;
  private:
  bool _internal_has_rename_table() const;
  public:
  void clear_rename_table();
  const ::greptime::v1::RenameTable& rename_table() const;
  PROTOBUF_NODISCARD ::greptime::v1::RenameTable* release_rename_table();
  ::greptime::v1::RenameTable* mutable_rename_table();
  void set_allocated_rename_table(::greptime::v1::RenameTable* rename_table);
  private:
  const ::greptime::v1::RenameTable& _internal_rename_table() const;
  ::greptime::v1::RenameTable* _internal_mutable_rename_table();
  public:
  void unsafe_arena_set_allocated_rename_table(
      ::greptime::v1::RenameTable* rename_table);
  ::greptime::v1::RenameTable* unsafe_arena_release_rename_table();

  // .greptime.v1.ChangeColumnTypes change_column_types = 7;
  bool has_change_column_types() const;
  private:
  bool _internal_has_change_column_types() const;
  public:
  void clear_change_column_types();
  const ::greptime::v1::ChangeColumnTypes& change_column_types() const;
  PROTOBUF_NODISCARD ::greptime::v1::ChangeColumnTypes* release_change_column_types();
  ::greptime::v1::ChangeColumnTypes* mutable_change_column_types();
  void set_allocated_change_column_types(::greptime::v1::ChangeColumnTypes* change_column_types);
  private:
  const ::greptime::v1::ChangeColumnTypes& _internal_change_column_types() const;
  ::greptime::v1::ChangeColumnTypes* _internal_mutable_change_column_types();
  public:
  void unsafe_arena_set_allocated_change_column_types(
      ::greptime::v1::ChangeColumnTypes* change_column_types);
  ::greptime::v1::ChangeColumnTypes* unsafe_arena_release_change_column_types();

  // .greptime.v1.ChangeTableOptions change_table_options = 8;
  bool has_change_table_options() const;
  private:
  bool _internal_has_change_table_options() const;
  public:
  void clear_change_table_options();
  const ::greptime::v1::ChangeTableOptions& change_table_options() const;
  PROTOBUF_NODISCARD ::greptime::v1::ChangeTableOptions* release_change_table_options();
  ::greptime::v1::ChangeTableOptions* mutable_change_table_options();
  void set_allocated_change_table_options(::greptime::v1::ChangeTableOptions* change_table_options);
  private:
  const ::greptime::v1::ChangeTableOptions& _internal_change_table_options() const;
  ::greptime::v1::ChangeTableOptions* _internal_mutable_change_table_options();
  public:
  void unsafe_arena_set_allocated_change_table_options(
      ::greptime::v1::ChangeTableOptions* change_table_options);
  ::greptime::v1::ChangeTableOptions* unsafe_arena_release_change_table_options();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.AlterExpr)
 private:
  class _Internal;
  void set_has_add_columns();
  void set_has_drop_columns();
  void set_has_rename_table();
  void set_has_change_column_types();
  void set_has_change_table_options();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::AddColumns* add_columns_;
      ::greptime::v1::DropColumns* drop_columns_;
      ::greptime::v1::RenameTable* rename_table_;
      ::greptime::v1::ChangeColumnTypes* change_column_types_;
      ::greptime::v1::ChangeTableOptions* change_table_options_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropTableExpr) */ {
 public:
  inline DropTableExpr() : DropTableExpr(nullptr) {}
  ~DropTableExpr() override;
  explicit PROTOBUF_CONSTEXPR DropTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTableExpr(const DropTableExpr& from);
  DropTableExpr(DropTableExpr&& from) noexcept
    : DropTableExpr() {
    *this = ::std::move(from);
  }

  inline DropTableExpr& operator=(const DropTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTableExpr& operator=(DropTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTableExpr* internal_default_instance() {
    return reinterpret_cast<const DropTableExpr*>(
               &_DropTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DropTableExpr& a, DropTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTableExpr& from) {
    DropTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropTableExpr";
  }
  protected:
  explicit DropTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
    kDropIfExistsFieldNumber = 5,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.TableId table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // bool drop_if_exists = 5;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::greptime::v1::TableId* table_id_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class CreateDatabaseExpr_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateDatabaseExpr_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateDatabaseExpr_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateDatabaseExpr_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateDatabaseExpr_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateDatabaseExpr_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateDatabaseExpr_OptionsEntry_DoNotUse& other);
  static const CreateDatabaseExpr_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateDatabaseExpr_OptionsEntry_DoNotUse*>(&_CreateDatabaseExpr_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateDatabaseExpr.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.CreateDatabaseExpr.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};

// -------------------------------------------------------------------

class CreateDatabaseExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.CreateDatabaseExpr) */ {
 public:
  inline CreateDatabaseExpr() : CreateDatabaseExpr(nullptr) {}
  ~CreateDatabaseExpr() override;
  explicit PROTOBUF_CONSTEXPR CreateDatabaseExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatabaseExpr(const CreateDatabaseExpr& from);
  CreateDatabaseExpr(CreateDatabaseExpr&& from) noexcept
    : CreateDatabaseExpr() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseExpr& operator=(const CreateDatabaseExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatabaseExpr& operator=(CreateDatabaseExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatabaseExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatabaseExpr* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseExpr*>(
               &_CreateDatabaseExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateDatabaseExpr& a, CreateDatabaseExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatabaseExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatabaseExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatabaseExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatabaseExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDatabaseExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDatabaseExpr& from) {
    CreateDatabaseExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatabaseExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.CreateDatabaseExpr";
  }
  protected:
  explicit CreateDatabaseExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kCreateIfNotExistsFieldNumber = 3,
  };
  // map<string, string> options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // bool create_if_not_exists = 3;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.CreateDatabaseExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateDatabaseExpr_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class TruncateTableExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TruncateTableExpr) */ {
 public:
  inline TruncateTableExpr() : TruncateTableExpr(nullptr) {}
  ~TruncateTableExpr() override;
  explicit PROTOBUF_CONSTEXPR TruncateTableExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateTableExpr(const TruncateTableExpr& from);
  TruncateTableExpr(TruncateTableExpr&& from) noexcept
    : TruncateTableExpr() {
    *this = ::std::move(from);
  }

  inline TruncateTableExpr& operator=(const TruncateTableExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateTableExpr& operator=(TruncateTableExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateTableExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const TruncateTableExpr* internal_default_instance() {
    return reinterpret_cast<const TruncateTableExpr*>(
               &_TruncateTableExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TruncateTableExpr& a, TruncateTableExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateTableExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateTableExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TruncateTableExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TruncateTableExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateTableExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TruncateTableExpr& from) {
    TruncateTableExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateTableExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TruncateTableExpr";
  }
  protected:
  explicit TruncateTableExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .greptime.v1.TableId table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::greptime::v1::TableId& table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_table_id();
  ::greptime::v1::TableId* mutable_table_id();
  void set_allocated_table_id(::greptime::v1::TableId* table_id);
  private:
  const ::greptime::v1::TableId& _internal_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::greptime::v1::TableId* table_id);
  ::greptime::v1::TableId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.TruncateTableExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::greptime::v1::TableId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropDatabaseExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropDatabaseExpr) */ {
 public:
  inline DropDatabaseExpr() : DropDatabaseExpr(nullptr) {}
  ~DropDatabaseExpr() override;
  explicit PROTOBUF_CONSTEXPR DropDatabaseExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropDatabaseExpr(const DropDatabaseExpr& from);
  DropDatabaseExpr(DropDatabaseExpr&& from) noexcept
    : DropDatabaseExpr() {
    *this = ::std::move(from);
  }

  inline DropDatabaseExpr& operator=(const DropDatabaseExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropDatabaseExpr& operator=(DropDatabaseExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropDatabaseExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropDatabaseExpr* internal_default_instance() {
    return reinterpret_cast<const DropDatabaseExpr*>(
               &_DropDatabaseExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DropDatabaseExpr& a, DropDatabaseExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(DropDatabaseExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropDatabaseExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropDatabaseExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropDatabaseExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropDatabaseExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropDatabaseExpr& from) {
    DropDatabaseExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropDatabaseExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropDatabaseExpr";
  }
  protected:
  explicit DropDatabaseExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kDropIfExistsFieldNumber = 3,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // bool drop_if_exists = 3;
  void clear_drop_if_exists();
  bool drop_if_exists() const;
  void set_drop_if_exists(bool value);
  private:
  bool _internal_drop_if_exists() const;
  void _internal_set_drop_if_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropDatabaseExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    bool drop_if_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumns) */ {
 public:
  inline AddColumns() : AddColumns(nullptr) {}
  ~AddColumns() override;
  explicit PROTOBUF_CONSTEXPR AddColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumns(const AddColumns& from);
  AddColumns(AddColumns&& from) noexcept
    : AddColumns() {
    *this = ::std::move(from);
  }

  inline AddColumns& operator=(const AddColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumns& operator=(AddColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumns* internal_default_instance() {
    return reinterpret_cast<const AddColumns*>(
               &_AddColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AddColumns& a, AddColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumns& from) {
    AddColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumns";
  }
  protected:
  explicit AddColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.AddColumn add_columns = 1;
  int add_columns_size() const;
  private:
  int _internal_add_columns_size() const;
  public:
  void clear_add_columns();
  ::greptime::v1::AddColumn* mutable_add_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >*
      mutable_add_columns();
  private:
  const ::greptime::v1::AddColumn& _internal_add_columns(int index) const;
  ::greptime::v1::AddColumn* _internal_add_add_columns();
  public:
  const ::greptime::v1::AddColumn& add_columns(int index) const;
  ::greptime::v1::AddColumn* add_add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >&
      add_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn > add_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropColumns) */ {
 public:
  inline DropColumns() : DropColumns(nullptr) {}
  ~DropColumns() override;
  explicit PROTOBUF_CONSTEXPR DropColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumns(const DropColumns& from);
  DropColumns(DropColumns&& from) noexcept
    : DropColumns() {
    *this = ::std::move(from);
  }

  inline DropColumns& operator=(const DropColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumns& operator=(DropColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumns* internal_default_instance() {
    return reinterpret_cast<const DropColumns*>(
               &_DropColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DropColumns& a, DropColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumns& from) {
    DropColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropColumns";
  }
  protected:
  explicit DropColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.DropColumn drop_columns = 1;
  int drop_columns_size() const;
  private:
  int _internal_drop_columns_size() const;
  public:
  void clear_drop_columns();
  ::greptime::v1::DropColumn* mutable_drop_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >*
      mutable_drop_columns();
  private:
  const ::greptime::v1::DropColumn& _internal_drop_columns(int index) const;
  ::greptime::v1::DropColumn* _internal_add_drop_columns();
  public:
  const ::greptime::v1::DropColumn& drop_columns(int index) const;
  ::greptime::v1::DropColumn* add_drop_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >&
      drop_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.DropColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn > drop_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ChangeColumnTypes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ChangeColumnTypes) */ {
 public:
  inline ChangeColumnTypes() : ChangeColumnTypes(nullptr) {}
  ~ChangeColumnTypes() override;
  explicit PROTOBUF_CONSTEXPR ChangeColumnTypes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeColumnTypes(const ChangeColumnTypes& from);
  ChangeColumnTypes(ChangeColumnTypes&& from) noexcept
    : ChangeColumnTypes() {
    *this = ::std::move(from);
  }

  inline ChangeColumnTypes& operator=(const ChangeColumnTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeColumnTypes& operator=(ChangeColumnTypes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeColumnTypes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeColumnTypes* internal_default_instance() {
    return reinterpret_cast<const ChangeColumnTypes*>(
               &_ChangeColumnTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChangeColumnTypes& a, ChangeColumnTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeColumnTypes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeColumnTypes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeColumnTypes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeColumnTypes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeColumnTypes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeColumnTypes& from) {
    ChangeColumnTypes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeColumnTypes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ChangeColumnTypes";
  }
  protected:
  explicit ChangeColumnTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeColumnTypesFieldNumber = 1,
  };
  // repeated .greptime.v1.ChangeColumnType change_column_types = 1;
  int change_column_types_size() const;
  private:
  int _internal_change_column_types_size() const;
  public:
  void clear_change_column_types();
  ::greptime::v1::ChangeColumnType* mutable_change_column_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ChangeColumnType >*
      mutable_change_column_types();
  private:
  const ::greptime::v1::ChangeColumnType& _internal_change_column_types(int index) const;
  ::greptime::v1::ChangeColumnType* _internal_add_change_column_types();
  public:
  const ::greptime::v1::ChangeColumnType& change_column_types(int index) const;
  ::greptime::v1::ChangeColumnType* add_change_column_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ChangeColumnType >&
      change_column_types() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.ChangeColumnTypes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ChangeColumnType > change_column_types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class RenameTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.RenameTable) */ {
 public:
  inline RenameTable() : RenameTable(nullptr) {}
  ~RenameTable() override;
  explicit PROTOBUF_CONSTEXPR RenameTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameTable(const RenameTable& from);
  RenameTable(RenameTable&& from) noexcept
    : RenameTable() {
    *this = ::std::move(from);
  }

  inline RenameTable& operator=(const RenameTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameTable& operator=(RenameTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameTable* internal_default_instance() {
    return reinterpret_cast<const RenameTable*>(
               &_RenameTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RenameTable& a, RenameTable& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameTable& from) {
    RenameTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.RenameTable";
  }
  protected:
  explicit RenameTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewTableNameFieldNumber = 1,
  };
  // string new_table_name = 1;
  void clear_new_table_name();
  const std::string& new_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_table_name();
  PROTOBUF_NODISCARD std::string* release_new_table_name();
  void set_allocated_new_table_name(std::string* new_table_name);
  private:
  const std::string& _internal_new_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_table_name(const std::string& value);
  std::string* _internal_mutable_new_table_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.RenameTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumn) */ {
 public:
  inline AddColumn() : AddColumn(nullptr) {}
  ~AddColumn() override;
  explicit PROTOBUF_CONSTEXPR AddColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumn(const AddColumn& from);
  AddColumn(AddColumn&& from) noexcept
    : AddColumn() {
    *this = ::std::move(from);
  }

  inline AddColumn& operator=(const AddColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumn& operator=(AddColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumn* internal_default_instance() {
    return reinterpret_cast<const AddColumn*>(
               &_AddColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AddColumn& a, AddColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumn& from) {
    AddColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumn";
  }
  protected:
  explicit AddColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefFieldNumber = 1,
    kLocationFieldNumber = 3,
  };
  // .greptime.v1.ColumnDef column_def = 1;
  bool has_column_def() const;
  private:
  bool _internal_has_column_def() const;
  public:
  void clear_column_def();
  const ::greptime::v1::ColumnDef& column_def() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDef* release_column_def();
  ::greptime::v1::ColumnDef* mutable_column_def();
  void set_allocated_column_def(::greptime::v1::ColumnDef* column_def);
  private:
  const ::greptime::v1::ColumnDef& _internal_column_def() const;
  ::greptime::v1::ColumnDef* _internal_mutable_column_def();
  public:
  void unsafe_arena_set_allocated_column_def(
      ::greptime::v1::ColumnDef* column_def);
  ::greptime::v1::ColumnDef* unsafe_arena_release_column_def();

  // .greptime.v1.AddColumnLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::greptime::v1::AddColumnLocation& location() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumnLocation* release_location();
  ::greptime::v1::AddColumnLocation* mutable_location();
  void set_allocated_location(::greptime::v1::AddColumnLocation* location);
  private:
  const ::greptime::v1::AddColumnLocation& _internal_location() const;
  ::greptime::v1::AddColumnLocation* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::greptime::v1::AddColumnLocation* location);
  ::greptime::v1::AddColumnLocation* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::ColumnDef* column_def_;
    ::greptime::v1::AddColumnLocation* location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ChangeColumnType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ChangeColumnType) */ {
 public:
  inline ChangeColumnType() : ChangeColumnType(nullptr) {}
  ~ChangeColumnType() override;
  explicit PROTOBUF_CONSTEXPR ChangeColumnType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeColumnType(const ChangeColumnType& from);
  ChangeColumnType(ChangeColumnType&& from) noexcept
    : ChangeColumnType() {
    *this = ::std::move(from);
  }

  inline ChangeColumnType& operator=(const ChangeColumnType& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeColumnType& operator=(ChangeColumnType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeColumnType& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeColumnType* internal_default_instance() {
    return reinterpret_cast<const ChangeColumnType*>(
               &_ChangeColumnType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ChangeColumnType& a, ChangeColumnType& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeColumnType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeColumnType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeColumnType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeColumnType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeColumnType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeColumnType& from) {
    ChangeColumnType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeColumnType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ChangeColumnType";
  }
  protected:
  explicit ChangeColumnType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kTargetTypeExtensionFieldNumber = 3,
    kTargetTypeFieldNumber = 2,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .greptime.v1.ColumnDataTypeExtension target_type_extension = 3;
  bool has_target_type_extension() const;
  private:
  bool _internal_has_target_type_extension() const;
  public:
  void clear_target_type_extension();
  const ::greptime::v1::ColumnDataTypeExtension& target_type_extension() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDataTypeExtension* release_target_type_extension();
  ::greptime::v1::ColumnDataTypeExtension* mutable_target_type_extension();
  void set_allocated_target_type_extension(::greptime::v1::ColumnDataTypeExtension* target_type_extension);
  private:
  const ::greptime::v1::ColumnDataTypeExtension& _internal_target_type_extension() const;
  ::greptime::v1::ColumnDataTypeExtension* _internal_mutable_target_type_extension();
  public:
  void unsafe_arena_set_allocated_target_type_extension(
      ::greptime::v1::ColumnDataTypeExtension* target_type_extension);
  ::greptime::v1::ColumnDataTypeExtension* unsafe_arena_release_target_type_extension();

  // .greptime.v1.ColumnDataType target_type = 2;
  void clear_target_type();
  ::greptime::v1::ColumnDataType target_type() const;
  void set_target_type(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_target_type() const;
  void _internal_set_target_type(::greptime::v1::ColumnDataType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ChangeColumnType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    ::greptime::v1::ColumnDataTypeExtension* target_type_extension_;
    int target_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ChangeTableOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ChangeTableOptions) */ {
 public:
  inline ChangeTableOptions() : ChangeTableOptions(nullptr) {}
  ~ChangeTableOptions() override;
  explicit PROTOBUF_CONSTEXPR ChangeTableOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeTableOptions(const ChangeTableOptions& from);
  ChangeTableOptions(ChangeTableOptions&& from) noexcept
    : ChangeTableOptions() {
    *this = ::std::move(from);
  }

  inline ChangeTableOptions& operator=(const ChangeTableOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeTableOptions& operator=(ChangeTableOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeTableOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeTableOptions* internal_default_instance() {
    return reinterpret_cast<const ChangeTableOptions*>(
               &_ChangeTableOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ChangeTableOptions& a, ChangeTableOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeTableOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeTableOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeTableOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeTableOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeTableOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeTableOptions& from) {
    ChangeTableOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeTableOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ChangeTableOptions";
  }
  protected:
  explicit ChangeTableOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ChangeTableOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class DropColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DropColumn) */ {
 public:
  inline DropColumn() : DropColumn(nullptr) {}
  ~DropColumn() override;
  explicit PROTOBUF_CONSTEXPR DropColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumn(const DropColumn& from);
  DropColumn(DropColumn&& from) noexcept
    : DropColumn() {
    *this = ::std::move(from);
  }

  inline DropColumn& operator=(const DropColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumn& operator=(DropColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumn* internal_default_instance() {
    return reinterpret_cast<const DropColumn*>(
               &_DropColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DropColumn& a, DropColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumn& from) {
    DropColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DropColumn";
  }
  protected:
  explicit DropColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DropColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class TableId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TableId) */ {
 public:
  inline TableId() : TableId(nullptr) {}
  ~TableId() override;
  explicit PROTOBUF_CONSTEXPR TableId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableId(const TableId& from);
  TableId(TableId&& from) noexcept
    : TableId() {
    *this = ::std::move(from);
  }

  inline TableId& operator=(const TableId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableId& operator=(TableId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableId* internal_default_instance() {
    return reinterpret_cast<const TableId*>(
               &_TableId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TableId& a, TableId& b) {
    a.Swap(&b);
  }
  inline void Swap(TableId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableId& from) {
    TableId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TableId";
  }
  protected:
  explicit TableId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TableId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class FlowId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.FlowId) */ {
 public:
  inline FlowId() : FlowId(nullptr) {}
  ~FlowId() override;
  explicit PROTOBUF_CONSTEXPR FlowId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowId(const FlowId& from);
  FlowId(FlowId&& from) noexcept
    : FlowId() {
    *this = ::std::move(from);
  }

  inline FlowId& operator=(const FlowId& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowId& operator=(FlowId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowId& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowId* internal_default_instance() {
    return reinterpret_cast<const FlowId*>(
               &_FlowId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(FlowId& a, FlowId& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowId& from) {
    FlowId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.FlowId";
  }
  protected:
  explicit FlowId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.FlowId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class ColumnDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnDef) */ {
 public:
  inline ColumnDef() : ColumnDef(nullptr) {}
  ~ColumnDef() override;
  explicit PROTOBUF_CONSTEXPR ColumnDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDef(const ColumnDef& from);
  ColumnDef(ColumnDef&& from) noexcept
    : ColumnDef() {
    *this = ::std::move(from);
  }

  inline ColumnDef& operator=(const ColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDef& operator=(ColumnDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDef* internal_default_instance() {
    return reinterpret_cast<const ColumnDef*>(
               &_ColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ColumnDef& a, ColumnDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDef& from) {
    ColumnDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnDef";
  }
  protected:
  explicit ColumnDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultConstraintFieldNumber = 4,
    kCommentFieldNumber = 6,
    kDatatypeExtensionFieldNumber = 7,
    kOptionsFieldNumber = 8,
    kDataTypeFieldNumber = 2,
    kIsNullableFieldNumber = 3,
    kSemanticTypeFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes default_constraint = 4;
  void clear_default_constraint();
  const std::string& default_constraint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_constraint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_constraint();
  PROTOBUF_NODISCARD std::string* release_default_constraint();
  void set_allocated_default_constraint(std::string* default_constraint);
  private:
  const std::string& _internal_default_constraint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_constraint(const std::string& value);
  std::string* _internal_mutable_default_constraint();
  public:

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // .greptime.v1.ColumnDataTypeExtension datatype_extension = 7;
  bool has_datatype_extension() const;
  private:
  bool _internal_has_datatype_extension() const;
  public:
  void clear_datatype_extension();
  const ::greptime::v1::ColumnDataTypeExtension& datatype_extension() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDataTypeExtension* release_datatype_extension();
  ::greptime::v1::ColumnDataTypeExtension* mutable_datatype_extension();
  void set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  private:
  const ::greptime::v1::ColumnDataTypeExtension& _internal_datatype_extension() const;
  ::greptime::v1::ColumnDataTypeExtension* _internal_mutable_datatype_extension();
  public:
  void unsafe_arena_set_allocated_datatype_extension(
      ::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  ::greptime::v1::ColumnDataTypeExtension* unsafe_arena_release_datatype_extension();

  // .greptime.v1.ColumnOptions options = 8;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::greptime::v1::ColumnOptions& options() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnOptions* release_options();
  ::greptime::v1::ColumnOptions* mutable_options();
  void set_allocated_options(::greptime::v1::ColumnOptions* options);
  private:
  const ::greptime::v1::ColumnOptions& _internal_options() const;
  ::greptime::v1::ColumnOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::greptime::v1::ColumnOptions* options);
  ::greptime::v1::ColumnOptions* unsafe_arena_release_options();

  // .greptime.v1.ColumnDataType data_type = 2;
  void clear_data_type();
  ::greptime::v1::ColumnDataType data_type() const;
  void set_data_type(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_data_type() const;
  void _internal_set_data_type(::greptime::v1::ColumnDataType value);
  public:

  // bool is_nullable = 3;
  void clear_is_nullable();
  bool is_nullable() const;
  void set_is_nullable(bool value);
  private:
  bool _internal_is_nullable() const;
  void _internal_set_is_nullable(bool value);
  public:

  // .greptime.v1.SemanticType semantic_type = 5;
  void clear_semantic_type();
  ::greptime::v1::SemanticType semantic_type() const;
  void set_semantic_type(::greptime::v1::SemanticType value);
  private:
  ::greptime::v1::SemanticType _internal_semantic_type() const;
  void _internal_set_semantic_type(::greptime::v1::SemanticType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_constraint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension_;
    ::greptime::v1::ColumnOptions* options_;
    int data_type_;
    bool is_nullable_;
    int semantic_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// -------------------------------------------------------------------

class AddColumnLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AddColumnLocation) */ {
 public:
  inline AddColumnLocation() : AddColumnLocation(nullptr) {}
  ~AddColumnLocation() override;
  explicit PROTOBUF_CONSTEXPR AddColumnLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumnLocation(const AddColumnLocation& from);
  AddColumnLocation(AddColumnLocation&& from) noexcept
    : AddColumnLocation() {
    *this = ::std::move(from);
  }

  inline AddColumnLocation& operator=(const AddColumnLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumnLocation& operator=(AddColumnLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumnLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumnLocation* internal_default_instance() {
    return reinterpret_cast<const AddColumnLocation*>(
               &_AddColumnLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AddColumnLocation& a, AddColumnLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumnLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumnLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumnLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumnLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumnLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumnLocation& from) {
    AddColumnLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumnLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AddColumnLocation";
  }
  protected:
  explicit AddColumnLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AddColumnLocation_LocationType LocationType;
  static constexpr LocationType FIRST =
    AddColumnLocation_LocationType_FIRST;
  static constexpr LocationType AFTER =
    AddColumnLocation_LocationType_AFTER;
  static inline bool LocationType_IsValid(int value) {
    return AddColumnLocation_LocationType_IsValid(value);
  }
  static constexpr LocationType LocationType_MIN =
    AddColumnLocation_LocationType_LocationType_MIN;
  static constexpr LocationType LocationType_MAX =
    AddColumnLocation_LocationType_LocationType_MAX;
  static constexpr int LocationType_ARRAYSIZE =
    AddColumnLocation_LocationType_LocationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocationType_descriptor() {
    return AddColumnLocation_LocationType_descriptor();
  }
  template<typename T>
  static inline const std::string& LocationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocationType_Name.");
    return AddColumnLocation_LocationType_Name(enum_t_value);
  }
  static inline bool LocationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocationType* value) {
    return AddColumnLocation_LocationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAfterColumnNameFieldNumber = 2,
    kLocationTypeFieldNumber = 1,
  };
  // string after_column_name = 2;
  void clear_after_column_name();
  const std::string& after_column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_after_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_after_column_name();
  PROTOBUF_NODISCARD std::string* release_after_column_name();
  void set_allocated_after_column_name(std::string* after_column_name);
  private:
  const std::string& _internal_after_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_after_column_name(const std::string& value);
  std::string* _internal_mutable_after_column_name();
  public:

  // .greptime.v1.AddColumnLocation.LocationType location_type = 1;
  void clear_location_type();
  ::greptime::v1::AddColumnLocation_LocationType location_type() const;
  void set_location_type(::greptime::v1::AddColumnLocation_LocationType value);
  private:
  ::greptime::v1::AddColumnLocation_LocationType _internal_location_type() const;
  void _internal_set_location_type(::greptime::v1::AddColumnLocation_LocationType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.AddColumnLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr after_column_name_;
    int location_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fddl_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DdlRequest

// .greptime.v1.CreateDatabaseExpr create_database = 1;
inline bool DdlRequest::_internal_has_create_database() const {
  return expr_case() == kCreateDatabase;
}
inline bool DdlRequest::has_create_database() const {
  return _internal_has_create_database();
}
inline void DdlRequest::set_has_create_database() {
  _impl_._oneof_case_[0] = kCreateDatabase;
}
inline void DdlRequest::clear_create_database() {
  if (_internal_has_create_database()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_database_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::release_create_database() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_database)
  if (_internal_has_create_database()) {
    clear_has_expr();
    ::greptime::v1::CreateDatabaseExpr* temp = _impl_.expr_.create_database_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateDatabaseExpr& DdlRequest::_internal_create_database() const {
  return _internal_has_create_database()
      ? *_impl_.expr_.create_database_
      : reinterpret_cast< ::greptime::v1::CreateDatabaseExpr&>(::greptime::v1::_CreateDatabaseExpr_default_instance_);
}
inline const ::greptime::v1::CreateDatabaseExpr& DdlRequest::create_database() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_database)
  return _internal_create_database();
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::unsafe_arena_release_create_database() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_database)
  if (_internal_has_create_database()) {
    clear_has_expr();
    ::greptime::v1::CreateDatabaseExpr* temp = _impl_.expr_.create_database_;
    _impl_.expr_.create_database_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_database(::greptime::v1::CreateDatabaseExpr* create_database) {
  clear_expr();
  if (create_database) {
    set_has_create_database();
    _impl_.expr_.create_database_ = create_database;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_database)
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::_internal_mutable_create_database() {
  if (!_internal_has_create_database()) {
    clear_expr();
    set_has_create_database();
    _impl_.expr_.create_database_ = CreateMaybeMessage< ::greptime::v1::CreateDatabaseExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_database_;
}
inline ::greptime::v1::CreateDatabaseExpr* DdlRequest::mutable_create_database() {
  ::greptime::v1::CreateDatabaseExpr* _msg = _internal_mutable_create_database();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_database)
  return _msg;
}

// .greptime.v1.CreateTableExpr create_table = 2;
inline bool DdlRequest::_internal_has_create_table() const {
  return expr_case() == kCreateTable;
}
inline bool DdlRequest::has_create_table() const {
  return _internal_has_create_table();
}
inline void DdlRequest::set_has_create_table() {
  _impl_._oneof_case_[0] = kCreateTable;
}
inline void DdlRequest::clear_create_table() {
  if (_internal_has_create_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::release_create_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_table)
  if (_internal_has_create_table()) {
    clear_has_expr();
    ::greptime::v1::CreateTableExpr* temp = _impl_.expr_.create_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateTableExpr& DdlRequest::_internal_create_table() const {
  return _internal_has_create_table()
      ? *_impl_.expr_.create_table_
      : reinterpret_cast< ::greptime::v1::CreateTableExpr&>(::greptime::v1::_CreateTableExpr_default_instance_);
}
inline const ::greptime::v1::CreateTableExpr& DdlRequest::create_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_table)
  return _internal_create_table();
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::unsafe_arena_release_create_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_table)
  if (_internal_has_create_table()) {
    clear_has_expr();
    ::greptime::v1::CreateTableExpr* temp = _impl_.expr_.create_table_;
    _impl_.expr_.create_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_table(::greptime::v1::CreateTableExpr* create_table) {
  clear_expr();
  if (create_table) {
    set_has_create_table();
    _impl_.expr_.create_table_ = create_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_table)
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::_internal_mutable_create_table() {
  if (!_internal_has_create_table()) {
    clear_expr();
    set_has_create_table();
    _impl_.expr_.create_table_ = CreateMaybeMessage< ::greptime::v1::CreateTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_table_;
}
inline ::greptime::v1::CreateTableExpr* DdlRequest::mutable_create_table() {
  ::greptime::v1::CreateTableExpr* _msg = _internal_mutable_create_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_table)
  return _msg;
}

// .greptime.v1.AlterExpr alter = 3;
inline bool DdlRequest::_internal_has_alter() const {
  return expr_case() == kAlter;
}
inline bool DdlRequest::has_alter() const {
  return _internal_has_alter();
}
inline void DdlRequest::set_has_alter() {
  _impl_._oneof_case_[0] = kAlter;
}
inline void DdlRequest::clear_alter() {
  if (_internal_has_alter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.alter_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::AlterExpr* DdlRequest::release_alter() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.alter)
  if (_internal_has_alter()) {
    clear_has_expr();
    ::greptime::v1::AlterExpr* temp = _impl_.expr_.alter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AlterExpr& DdlRequest::_internal_alter() const {
  return _internal_has_alter()
      ? *_impl_.expr_.alter_
      : reinterpret_cast< ::greptime::v1::AlterExpr&>(::greptime::v1::_AlterExpr_default_instance_);
}
inline const ::greptime::v1::AlterExpr& DdlRequest::alter() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.alter)
  return _internal_alter();
}
inline ::greptime::v1::AlterExpr* DdlRequest::unsafe_arena_release_alter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.alter)
  if (_internal_has_alter()) {
    clear_has_expr();
    ::greptime::v1::AlterExpr* temp = _impl_.expr_.alter_;
    _impl_.expr_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_alter(::greptime::v1::AlterExpr* alter) {
  clear_expr();
  if (alter) {
    set_has_alter();
    _impl_.expr_.alter_ = alter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.alter)
}
inline ::greptime::v1::AlterExpr* DdlRequest::_internal_mutable_alter() {
  if (!_internal_has_alter()) {
    clear_expr();
    set_has_alter();
    _impl_.expr_.alter_ = CreateMaybeMessage< ::greptime::v1::AlterExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.alter_;
}
inline ::greptime::v1::AlterExpr* DdlRequest::mutable_alter() {
  ::greptime::v1::AlterExpr* _msg = _internal_mutable_alter();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.alter)
  return _msg;
}

// .greptime.v1.DropTableExpr drop_table = 4;
inline bool DdlRequest::_internal_has_drop_table() const {
  return expr_case() == kDropTable;
}
inline bool DdlRequest::has_drop_table() const {
  return _internal_has_drop_table();
}
inline void DdlRequest::set_has_drop_table() {
  _impl_._oneof_case_[0] = kDropTable;
}
inline void DdlRequest::clear_drop_table() {
  if (_internal_has_drop_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropTableExpr* DdlRequest::release_drop_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_table)
  if (_internal_has_drop_table()) {
    clear_has_expr();
    ::greptime::v1::DropTableExpr* temp = _impl_.expr_.drop_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropTableExpr& DdlRequest::_internal_drop_table() const {
  return _internal_has_drop_table()
      ? *_impl_.expr_.drop_table_
      : reinterpret_cast< ::greptime::v1::DropTableExpr&>(::greptime::v1::_DropTableExpr_default_instance_);
}
inline const ::greptime::v1::DropTableExpr& DdlRequest::drop_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_table)
  return _internal_drop_table();
}
inline ::greptime::v1::DropTableExpr* DdlRequest::unsafe_arena_release_drop_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_table)
  if (_internal_has_drop_table()) {
    clear_has_expr();
    ::greptime::v1::DropTableExpr* temp = _impl_.expr_.drop_table_;
    _impl_.expr_.drop_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_table(::greptime::v1::DropTableExpr* drop_table) {
  clear_expr();
  if (drop_table) {
    set_has_drop_table();
    _impl_.expr_.drop_table_ = drop_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_table)
}
inline ::greptime::v1::DropTableExpr* DdlRequest::_internal_mutable_drop_table() {
  if (!_internal_has_drop_table()) {
    clear_expr();
    set_has_drop_table();
    _impl_.expr_.drop_table_ = CreateMaybeMessage< ::greptime::v1::DropTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_table_;
}
inline ::greptime::v1::DropTableExpr* DdlRequest::mutable_drop_table() {
  ::greptime::v1::DropTableExpr* _msg = _internal_mutable_drop_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_table)
  return _msg;
}

// .greptime.v1.TruncateTableExpr truncate_table = 7;
inline bool DdlRequest::_internal_has_truncate_table() const {
  return expr_case() == kTruncateTable;
}
inline bool DdlRequest::has_truncate_table() const {
  return _internal_has_truncate_table();
}
inline void DdlRequest::set_has_truncate_table() {
  _impl_._oneof_case_[0] = kTruncateTable;
}
inline void DdlRequest::clear_truncate_table() {
  if (_internal_has_truncate_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.truncate_table_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::release_truncate_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.truncate_table)
  if (_internal_has_truncate_table()) {
    clear_has_expr();
    ::greptime::v1::TruncateTableExpr* temp = _impl_.expr_.truncate_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.truncate_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::TruncateTableExpr& DdlRequest::_internal_truncate_table() const {
  return _internal_has_truncate_table()
      ? *_impl_.expr_.truncate_table_
      : reinterpret_cast< ::greptime::v1::TruncateTableExpr&>(::greptime::v1::_TruncateTableExpr_default_instance_);
}
inline const ::greptime::v1::TruncateTableExpr& DdlRequest::truncate_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.truncate_table)
  return _internal_truncate_table();
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::unsafe_arena_release_truncate_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.truncate_table)
  if (_internal_has_truncate_table()) {
    clear_has_expr();
    ::greptime::v1::TruncateTableExpr* temp = _impl_.expr_.truncate_table_;
    _impl_.expr_.truncate_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_truncate_table(::greptime::v1::TruncateTableExpr* truncate_table) {
  clear_expr();
  if (truncate_table) {
    set_has_truncate_table();
    _impl_.expr_.truncate_table_ = truncate_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.truncate_table)
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::_internal_mutable_truncate_table() {
  if (!_internal_has_truncate_table()) {
    clear_expr();
    set_has_truncate_table();
    _impl_.expr_.truncate_table_ = CreateMaybeMessage< ::greptime::v1::TruncateTableExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.truncate_table_;
}
inline ::greptime::v1::TruncateTableExpr* DdlRequest::mutable_truncate_table() {
  ::greptime::v1::TruncateTableExpr* _msg = _internal_mutable_truncate_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.truncate_table)
  return _msg;
}

// .greptime.v1.CreateFlowExpr create_flow = 8;
inline bool DdlRequest::_internal_has_create_flow() const {
  return expr_case() == kCreateFlow;
}
inline bool DdlRequest::has_create_flow() const {
  return _internal_has_create_flow();
}
inline void DdlRequest::set_has_create_flow() {
  _impl_._oneof_case_[0] = kCreateFlow;
}
inline void DdlRequest::clear_create_flow() {
  if (_internal_has_create_flow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_flow_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::release_create_flow() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_flow)
  if (_internal_has_create_flow()) {
    clear_has_expr();
    ::greptime::v1::CreateFlowExpr* temp = _impl_.expr_.create_flow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateFlowExpr& DdlRequest::_internal_create_flow() const {
  return _internal_has_create_flow()
      ? *_impl_.expr_.create_flow_
      : reinterpret_cast< ::greptime::v1::CreateFlowExpr&>(::greptime::v1::_CreateFlowExpr_default_instance_);
}
inline const ::greptime::v1::CreateFlowExpr& DdlRequest::create_flow() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_flow)
  return _internal_create_flow();
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::unsafe_arena_release_create_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_flow)
  if (_internal_has_create_flow()) {
    clear_has_expr();
    ::greptime::v1::CreateFlowExpr* temp = _impl_.expr_.create_flow_;
    _impl_.expr_.create_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_flow(::greptime::v1::CreateFlowExpr* create_flow) {
  clear_expr();
  if (create_flow) {
    set_has_create_flow();
    _impl_.expr_.create_flow_ = create_flow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_flow)
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::_internal_mutable_create_flow() {
  if (!_internal_has_create_flow()) {
    clear_expr();
    set_has_create_flow();
    _impl_.expr_.create_flow_ = CreateMaybeMessage< ::greptime::v1::CreateFlowExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_flow_;
}
inline ::greptime::v1::CreateFlowExpr* DdlRequest::mutable_create_flow() {
  ::greptime::v1::CreateFlowExpr* _msg = _internal_mutable_create_flow();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_flow)
  return _msg;
}

// .greptime.v1.DropFlowExpr drop_flow = 9;
inline bool DdlRequest::_internal_has_drop_flow() const {
  return expr_case() == kDropFlow;
}
inline bool DdlRequest::has_drop_flow() const {
  return _internal_has_drop_flow();
}
inline void DdlRequest::set_has_drop_flow() {
  _impl_._oneof_case_[0] = kDropFlow;
}
inline void DdlRequest::clear_drop_flow() {
  if (_internal_has_drop_flow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_flow_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::release_drop_flow() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_flow)
  if (_internal_has_drop_flow()) {
    clear_has_expr();
    ::greptime::v1::DropFlowExpr* temp = _impl_.expr_.drop_flow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropFlowExpr& DdlRequest::_internal_drop_flow() const {
  return _internal_has_drop_flow()
      ? *_impl_.expr_.drop_flow_
      : reinterpret_cast< ::greptime::v1::DropFlowExpr&>(::greptime::v1::_DropFlowExpr_default_instance_);
}
inline const ::greptime::v1::DropFlowExpr& DdlRequest::drop_flow() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_flow)
  return _internal_drop_flow();
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::unsafe_arena_release_drop_flow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_flow)
  if (_internal_has_drop_flow()) {
    clear_has_expr();
    ::greptime::v1::DropFlowExpr* temp = _impl_.expr_.drop_flow_;
    _impl_.expr_.drop_flow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_flow(::greptime::v1::DropFlowExpr* drop_flow) {
  clear_expr();
  if (drop_flow) {
    set_has_drop_flow();
    _impl_.expr_.drop_flow_ = drop_flow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_flow)
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::_internal_mutable_drop_flow() {
  if (!_internal_has_drop_flow()) {
    clear_expr();
    set_has_drop_flow();
    _impl_.expr_.drop_flow_ = CreateMaybeMessage< ::greptime::v1::DropFlowExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_flow_;
}
inline ::greptime::v1::DropFlowExpr* DdlRequest::mutable_drop_flow() {
  ::greptime::v1::DropFlowExpr* _msg = _internal_mutable_drop_flow();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_flow)
  return _msg;
}

// .greptime.v1.CreateViewExpr create_view = 10;
inline bool DdlRequest::_internal_has_create_view() const {
  return expr_case() == kCreateView;
}
inline bool DdlRequest::has_create_view() const {
  return _internal_has_create_view();
}
inline void DdlRequest::set_has_create_view() {
  _impl_._oneof_case_[0] = kCreateView;
}
inline void DdlRequest::clear_create_view() {
  if (_internal_has_create_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.create_view_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::release_create_view() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.create_view)
  if (_internal_has_create_view()) {
    clear_has_expr();
    ::greptime::v1::CreateViewExpr* temp = _impl_.expr_.create_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.create_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::CreateViewExpr& DdlRequest::_internal_create_view() const {
  return _internal_has_create_view()
      ? *_impl_.expr_.create_view_
      : reinterpret_cast< ::greptime::v1::CreateViewExpr&>(::greptime::v1::_CreateViewExpr_default_instance_);
}
inline const ::greptime::v1::CreateViewExpr& DdlRequest::create_view() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.create_view)
  return _internal_create_view();
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::unsafe_arena_release_create_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.create_view)
  if (_internal_has_create_view()) {
    clear_has_expr();
    ::greptime::v1::CreateViewExpr* temp = _impl_.expr_.create_view_;
    _impl_.expr_.create_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_create_view(::greptime::v1::CreateViewExpr* create_view) {
  clear_expr();
  if (create_view) {
    set_has_create_view();
    _impl_.expr_.create_view_ = create_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.create_view)
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::_internal_mutable_create_view() {
  if (!_internal_has_create_view()) {
    clear_expr();
    set_has_create_view();
    _impl_.expr_.create_view_ = CreateMaybeMessage< ::greptime::v1::CreateViewExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.create_view_;
}
inline ::greptime::v1::CreateViewExpr* DdlRequest::mutable_create_view() {
  ::greptime::v1::CreateViewExpr* _msg = _internal_mutable_create_view();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.create_view)
  return _msg;
}

// .greptime.v1.DropViewExpr drop_view = 11;
inline bool DdlRequest::_internal_has_drop_view() const {
  return expr_case() == kDropView;
}
inline bool DdlRequest::has_drop_view() const {
  return _internal_has_drop_view();
}
inline void DdlRequest::set_has_drop_view() {
  _impl_._oneof_case_[0] = kDropView;
}
inline void DdlRequest::clear_drop_view() {
  if (_internal_has_drop_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.expr_.drop_view_;
    }
    clear_has_expr();
  }
}
inline ::greptime::v1::DropViewExpr* DdlRequest::release_drop_view() {
  // @@protoc_insertion_point(field_release:greptime.v1.DdlRequest.drop_view)
  if (_internal_has_drop_view()) {
    clear_has_expr();
    ::greptime::v1::DropViewExpr* temp = _impl_.expr_.drop_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.drop_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropViewExpr& DdlRequest::_internal_drop_view() const {
  return _internal_has_drop_view()
      ? *_impl_.expr_.drop_view_
      : reinterpret_cast< ::greptime::v1::DropViewExpr&>(::greptime::v1::_DropViewExpr_default_instance_);
}
inline const ::greptime::v1::DropViewExpr& DdlRequest::drop_view() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DdlRequest.drop_view)
  return _internal_drop_view();
}
inline ::greptime::v1::DropViewExpr* DdlRequest::unsafe_arena_release_drop_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.DdlRequest.drop_view)
  if (_internal_has_drop_view()) {
    clear_has_expr();
    ::greptime::v1::DropViewExpr* temp = _impl_.expr_.drop_view_;
    _impl_.expr_.drop_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DdlRequest::unsafe_arena_set_allocated_drop_view(::greptime::v1::DropViewExpr* drop_view) {
  clear_expr();
  if (drop_view) {
    set_has_drop_view();
    _impl_.expr_.drop_view_ = drop_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DdlRequest.drop_view)
}
inline ::greptime::v1::DropViewExpr* DdlRequest::_internal_mutable_drop_view() {
  if (!_internal_has_drop_view()) {
    clear_expr();
    set_has_drop_view();
    _impl_.expr_.drop_view_ = CreateMaybeMessage< ::greptime::v1::DropViewExpr >(GetArenaForAllocation());
  }
  return _impl_.expr_.drop_view_;
}
inline ::greptime::v1::DropViewExpr* DdlRequest::mutable_drop_view() {
  ::greptime::v1::DropViewExpr* _msg = _internal_mutable_drop_view();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DdlRequest.drop_view)
  return _msg;
}

inline bool DdlRequest::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void DdlRequest::clear_has_expr() {
  _impl_._oneof_case_[0] = EXPR_NOT_SET;
}
inline DdlRequest::ExprCase DdlRequest::expr_case() const {
  return DdlRequest::ExprCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateFlowExpr

// string catalog_name = 1;
inline void CreateFlowExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.catalog_name)
}
inline std::string* CreateFlowExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.catalog_name)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateFlowExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateFlowExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.catalog_name)
}

// string flow_name = 2;
inline void CreateFlowExpr::clear_flow_name() {
  _impl_.flow_name_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::flow_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.flow_name)
  return _internal_flow_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_flow_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flow_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.flow_name)
}
inline std::string* CreateFlowExpr::mutable_flow_name() {
  std::string* _s = _internal_mutable_flow_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.flow_name)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_flow_name() const {
  return _impl_.flow_name_.Get();
}
inline void CreateFlowExpr::_internal_set_flow_name(const std::string& value) {
  
  _impl_.flow_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_flow_name() {
  
  return _impl_.flow_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_flow_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.flow_name)
  return _impl_.flow_name_.Release();
}
inline void CreateFlowExpr::set_allocated_flow_name(std::string* flow_name) {
  if (flow_name != nullptr) {
    
  } else {
    
  }
  _impl_.flow_name_.SetAllocated(flow_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flow_name_.IsDefault()) {
    _impl_.flow_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.flow_name)
}

// repeated .greptime.v1.TableName source_table_names = 3;
inline int CreateFlowExpr::_internal_source_table_names_size() const {
  return _impl_.source_table_names_.size();
}
inline int CreateFlowExpr::source_table_names_size() const {
  return _internal_source_table_names_size();
}
inline ::greptime::v1::TableName* CreateFlowExpr::mutable_source_table_names(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.source_table_names)
  return _impl_.source_table_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
CreateFlowExpr::mutable_source_table_names() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateFlowExpr.source_table_names)
  return &_impl_.source_table_names_;
}
inline const ::greptime::v1::TableName& CreateFlowExpr::_internal_source_table_names(int index) const {
  return _impl_.source_table_names_.Get(index);
}
inline const ::greptime::v1::TableName& CreateFlowExpr::source_table_names(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.source_table_names)
  return _internal_source_table_names(index);
}
inline ::greptime::v1::TableName* CreateFlowExpr::_internal_add_source_table_names() {
  return _impl_.source_table_names_.Add();
}
inline ::greptime::v1::TableName* CreateFlowExpr::add_source_table_names() {
  ::greptime::v1::TableName* _add = _internal_add_source_table_names();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateFlowExpr.source_table_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
CreateFlowExpr::source_table_names() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateFlowExpr.source_table_names)
  return _impl_.source_table_names_;
}

// .greptime.v1.TableName sink_table_name = 4;
inline bool CreateFlowExpr::_internal_has_sink_table_name() const {
  return this != internal_default_instance() && _impl_.sink_table_name_ != nullptr;
}
inline bool CreateFlowExpr::has_sink_table_name() const {
  return _internal_has_sink_table_name();
}
inline const ::greptime::v1::TableName& CreateFlowExpr::_internal_sink_table_name() const {
  const ::greptime::v1::TableName* p = _impl_.sink_table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableName&>(
      ::greptime::v1::_TableName_default_instance_);
}
inline const ::greptime::v1::TableName& CreateFlowExpr::sink_table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.sink_table_name)
  return _internal_sink_table_name();
}
inline void CreateFlowExpr::unsafe_arena_set_allocated_sink_table_name(
    ::greptime::v1::TableName* sink_table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_table_name_);
  }
  _impl_.sink_table_name_ = sink_table_name;
  if (sink_table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateFlowExpr.sink_table_name)
}
inline ::greptime::v1::TableName* CreateFlowExpr::release_sink_table_name() {
  
  ::greptime::v1::TableName* temp = _impl_.sink_table_name_;
  _impl_.sink_table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableName* CreateFlowExpr::unsafe_arena_release_sink_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.sink_table_name)
  
  ::greptime::v1::TableName* temp = _impl_.sink_table_name_;
  _impl_.sink_table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableName* CreateFlowExpr::_internal_mutable_sink_table_name() {
  
  if (_impl_.sink_table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableName>(GetArenaForAllocation());
    _impl_.sink_table_name_ = p;
  }
  return _impl_.sink_table_name_;
}
inline ::greptime::v1::TableName* CreateFlowExpr::mutable_sink_table_name() {
  ::greptime::v1::TableName* _msg = _internal_mutable_sink_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.sink_table_name)
  return _msg;
}
inline void CreateFlowExpr::set_allocated_sink_table_name(::greptime::v1::TableName* sink_table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_table_name_);
  }
  if (sink_table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sink_table_name));
    if (message_arena != submessage_arena) {
      sink_table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sink_table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sink_table_name_ = sink_table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.sink_table_name)
}

// bool or_replace = 5;
inline void CreateFlowExpr::clear_or_replace() {
  _impl_.or_replace_ = false;
}
inline bool CreateFlowExpr::_internal_or_replace() const {
  return _impl_.or_replace_;
}
inline bool CreateFlowExpr::or_replace() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.or_replace)
  return _internal_or_replace();
}
inline void CreateFlowExpr::_internal_set_or_replace(bool value) {
  
  _impl_.or_replace_ = value;
}
inline void CreateFlowExpr::set_or_replace(bool value) {
  _internal_set_or_replace(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.or_replace)
}

// bool create_if_not_exists = 6;
inline void CreateFlowExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateFlowExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateFlowExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateFlowExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateFlowExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.create_if_not_exists)
}

// .greptime.v1.ExpireAfter expire_after = 7;
inline bool CreateFlowExpr::_internal_has_expire_after() const {
  return this != internal_default_instance() && _impl_.expire_after_ != nullptr;
}
inline bool CreateFlowExpr::has_expire_after() const {
  return _internal_has_expire_after();
}
inline const ::greptime::v1::ExpireAfter& CreateFlowExpr::_internal_expire_after() const {
  const ::greptime::v1::ExpireAfter* p = _impl_.expire_after_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ExpireAfter&>(
      ::greptime::v1::_ExpireAfter_default_instance_);
}
inline const ::greptime::v1::ExpireAfter& CreateFlowExpr::expire_after() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.expire_after)
  return _internal_expire_after();
}
inline void CreateFlowExpr::unsafe_arena_set_allocated_expire_after(
    ::greptime::v1::ExpireAfter* expire_after) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_after_);
  }
  _impl_.expire_after_ = expire_after;
  if (expire_after) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateFlowExpr.expire_after)
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::release_expire_after() {
  
  ::greptime::v1::ExpireAfter* temp = _impl_.expire_after_;
  _impl_.expire_after_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::unsafe_arena_release_expire_after() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.expire_after)
  
  ::greptime::v1::ExpireAfter* temp = _impl_.expire_after_;
  _impl_.expire_after_ = nullptr;
  return temp;
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::_internal_mutable_expire_after() {
  
  if (_impl_.expire_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ExpireAfter>(GetArenaForAllocation());
    _impl_.expire_after_ = p;
  }
  return _impl_.expire_after_;
}
inline ::greptime::v1::ExpireAfter* CreateFlowExpr::mutable_expire_after() {
  ::greptime::v1::ExpireAfter* _msg = _internal_mutable_expire_after();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.expire_after)
  return _msg;
}
inline void CreateFlowExpr::set_allocated_expire_after(::greptime::v1::ExpireAfter* expire_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_after_);
  }
  if (expire_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_after));
    if (message_arena != submessage_arena) {
      expire_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire_after, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expire_after_ = expire_after;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.expire_after)
}

// string comment = 8;
inline void CreateFlowExpr::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::comment() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.comment)
}
inline std::string* CreateFlowExpr::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.comment)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void CreateFlowExpr::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_comment() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.comment)
  return _impl_.comment_.Release();
}
inline void CreateFlowExpr::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.comment)
}

// string sql = 9;
inline void CreateFlowExpr::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& CreateFlowExpr::sql() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateFlowExpr.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFlowExpr::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateFlowExpr.sql)
}
inline std::string* CreateFlowExpr::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateFlowExpr.sql)
  return _s;
}
inline const std::string& CreateFlowExpr::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void CreateFlowExpr::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateFlowExpr::release_sql() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateFlowExpr.sql)
  return _impl_.sql_.Release();
}
inline void CreateFlowExpr::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateFlowExpr.sql)
}

// map<string, string> flow_options = 10;
inline int CreateFlowExpr::_internal_flow_options_size() const {
  return _impl_.flow_options_.size();
}
inline int CreateFlowExpr::flow_options_size() const {
  return _internal_flow_options_size();
}
inline void CreateFlowExpr::clear_flow_options() {
  _impl_.flow_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateFlowExpr::_internal_flow_options() const {
  return _impl_.flow_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateFlowExpr::flow_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateFlowExpr.flow_options)
  return _internal_flow_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateFlowExpr::_internal_mutable_flow_options() {
  return _impl_.flow_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateFlowExpr::mutable_flow_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateFlowExpr.flow_options)
  return _internal_mutable_flow_options();
}

// -------------------------------------------------------------------

// DropFlowExpr

// string catalog_name = 1;
inline void DropFlowExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropFlowExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropFlowExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropFlowExpr.catalog_name)
}
inline std::string* DropFlowExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropFlowExpr.catalog_name)
  return _s;
}
inline const std::string& DropFlowExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropFlowExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropFlowExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropFlowExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropFlowExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropFlowExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropFlowExpr.catalog_name)
}

// string flow_name = 2;
inline void DropFlowExpr::clear_flow_name() {
  _impl_.flow_name_.ClearToEmpty();
}
inline const std::string& DropFlowExpr::flow_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.flow_name)
  return _internal_flow_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropFlowExpr::set_flow_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flow_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropFlowExpr.flow_name)
}
inline std::string* DropFlowExpr::mutable_flow_name() {
  std::string* _s = _internal_mutable_flow_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropFlowExpr.flow_name)
  return _s;
}
inline const std::string& DropFlowExpr::_internal_flow_name() const {
  return _impl_.flow_name_.Get();
}
inline void DropFlowExpr::_internal_set_flow_name(const std::string& value) {
  
  _impl_.flow_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropFlowExpr::_internal_mutable_flow_name() {
  
  return _impl_.flow_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropFlowExpr::release_flow_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropFlowExpr.flow_name)
  return _impl_.flow_name_.Release();
}
inline void DropFlowExpr::set_allocated_flow_name(std::string* flow_name) {
  if (flow_name != nullptr) {
    
  } else {
    
  }
  _impl_.flow_name_.SetAllocated(flow_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flow_name_.IsDefault()) {
    _impl_.flow_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropFlowExpr.flow_name)
}

// .greptime.v1.FlowId flow_id = 3;
inline bool DropFlowExpr::_internal_has_flow_id() const {
  return this != internal_default_instance() && _impl_.flow_id_ != nullptr;
}
inline bool DropFlowExpr::has_flow_id() const {
  return _internal_has_flow_id();
}
inline void DropFlowExpr::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
inline const ::greptime::v1::FlowId& DropFlowExpr::_internal_flow_id() const {
  const ::greptime::v1::FlowId* p = _impl_.flow_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::FlowId&>(
      ::greptime::v1::_FlowId_default_instance_);
}
inline const ::greptime::v1::FlowId& DropFlowExpr::flow_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.flow_id)
  return _internal_flow_id();
}
inline void DropFlowExpr::unsafe_arena_set_allocated_flow_id(
    ::greptime::v1::FlowId* flow_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  _impl_.flow_id_ = flow_id;
  if (flow_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropFlowExpr.flow_id)
}
inline ::greptime::v1::FlowId* DropFlowExpr::release_flow_id() {
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::FlowId* DropFlowExpr::unsafe_arena_release_flow_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropFlowExpr.flow_id)
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::FlowId* DropFlowExpr::_internal_mutable_flow_id() {
  
  if (_impl_.flow_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::FlowId>(GetArenaForAllocation());
    _impl_.flow_id_ = p;
  }
  return _impl_.flow_id_;
}
inline ::greptime::v1::FlowId* DropFlowExpr::mutable_flow_id() {
  ::greptime::v1::FlowId* _msg = _internal_mutable_flow_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropFlowExpr.flow_id)
  return _msg;
}
inline void DropFlowExpr::set_allocated_flow_id(::greptime::v1::FlowId* flow_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.flow_id_;
  }
  if (flow_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flow_id);
    if (message_arena != submessage_arena) {
      flow_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flow_id_ = flow_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropFlowExpr.flow_id)
}

// bool drop_if_exists = 5;
inline void DropFlowExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropFlowExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropFlowExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropFlowExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropFlowExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropFlowExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropFlowExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// CreateViewExpr

// string catalog_name = 1;
inline void CreateViewExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.catalog_name)
}
inline std::string* CreateViewExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.catalog_name)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateViewExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateViewExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateViewExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.schema_name)
}
inline std::string* CreateViewExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.schema_name)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateViewExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateViewExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.schema_name)
}

// string view_name = 3;
inline void CreateViewExpr::clear_view_name() {
  _impl_.view_name_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::view_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.view_name)
  return _internal_view_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_view_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.view_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.view_name)
}
inline std::string* CreateViewExpr::mutable_view_name() {
  std::string* _s = _internal_mutable_view_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.view_name)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_view_name() const {
  return _impl_.view_name_.Get();
}
inline void CreateViewExpr::_internal_set_view_name(const std::string& value) {
  
  _impl_.view_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_view_name() {
  
  return _impl_.view_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_view_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.view_name)
  return _impl_.view_name_.Release();
}
inline void CreateViewExpr::set_allocated_view_name(std::string* view_name) {
  if (view_name != nullptr) {
    
  } else {
    
  }
  _impl_.view_name_.SetAllocated(view_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_name_.IsDefault()) {
    _impl_.view_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.view_name)
}

// bytes logical_plan = 4;
inline void CreateViewExpr::clear_logical_plan() {
  _impl_.logical_plan_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::logical_plan() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.logical_plan)
  return _internal_logical_plan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_logical_plan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logical_plan_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.logical_plan)
}
inline std::string* CreateViewExpr::mutable_logical_plan() {
  std::string* _s = _internal_mutable_logical_plan();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.logical_plan)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_logical_plan() const {
  return _impl_.logical_plan_.Get();
}
inline void CreateViewExpr::_internal_set_logical_plan(const std::string& value) {
  
  _impl_.logical_plan_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_logical_plan() {
  
  return _impl_.logical_plan_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_logical_plan() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.logical_plan)
  return _impl_.logical_plan_.Release();
}
inline void CreateViewExpr::set_allocated_logical_plan(std::string* logical_plan) {
  if (logical_plan != nullptr) {
    
  } else {
    
  }
  _impl_.logical_plan_.SetAllocated(logical_plan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logical_plan_.IsDefault()) {
    _impl_.logical_plan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.logical_plan)
}

// bool create_if_not_exists = 5;
inline void CreateViewExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateViewExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateViewExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateViewExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateViewExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.create_if_not_exists)
}

// bool or_replace = 6;
inline void CreateViewExpr::clear_or_replace() {
  _impl_.or_replace_ = false;
}
inline bool CreateViewExpr::_internal_or_replace() const {
  return _impl_.or_replace_;
}
inline bool CreateViewExpr::or_replace() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.or_replace)
  return _internal_or_replace();
}
inline void CreateViewExpr::_internal_set_or_replace(bool value) {
  
  _impl_.or_replace_ = value;
}
inline void CreateViewExpr::set_or_replace(bool value) {
  _internal_set_or_replace(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.or_replace)
}

// repeated .greptime.v1.TableName table_names = 7;
inline int CreateViewExpr::_internal_table_names_size() const {
  return _impl_.table_names_.size();
}
inline int CreateViewExpr::table_names_size() const {
  return _internal_table_names_size();
}
inline ::greptime::v1::TableName* CreateViewExpr::mutable_table_names(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.table_names)
  return _impl_.table_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >*
CreateViewExpr::mutable_table_names() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateViewExpr.table_names)
  return &_impl_.table_names_;
}
inline const ::greptime::v1::TableName& CreateViewExpr::_internal_table_names(int index) const {
  return _impl_.table_names_.Get(index);
}
inline const ::greptime::v1::TableName& CreateViewExpr::table_names(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.table_names)
  return _internal_table_names(index);
}
inline ::greptime::v1::TableName* CreateViewExpr::_internal_add_table_names() {
  return _impl_.table_names_.Add();
}
inline ::greptime::v1::TableName* CreateViewExpr::add_table_names() {
  ::greptime::v1::TableName* _add = _internal_add_table_names();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.table_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableName >&
CreateViewExpr::table_names() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateViewExpr.table_names)
  return _impl_.table_names_;
}

// repeated string columns = 8;
inline int CreateViewExpr::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int CreateViewExpr::columns_size() const {
  return _internal_columns_size();
}
inline void CreateViewExpr::clear_columns() {
  _impl_.columns_.Clear();
}
inline std::string* CreateViewExpr::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateViewExpr.columns)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const std::string& CreateViewExpr::columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.columns)
  return _internal_columns(index);
}
inline std::string* CreateViewExpr::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.columns)
  return _impl_.columns_.Mutable(index);
}
inline void CreateViewExpr::set_columns(int index, const std::string& value) {
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::set_columns(int index, std::string&& value) {
  _impl_.columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::set_columns(int index, const char* value, size_t size) {
  _impl_.columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateViewExpr.columns)
}
inline std::string* CreateViewExpr::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline void CreateViewExpr::add_columns(const std::string& value) {
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::add_columns(std::string&& value) {
  _impl_.columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateViewExpr.columns)
}
inline void CreateViewExpr::add_columns(const char* value, size_t size) {
  _impl_.columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateViewExpr.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateViewExpr::columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateViewExpr.columns)
  return _impl_.columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateViewExpr::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateViewExpr.columns)
  return &_impl_.columns_;
}

// repeated string plan_columns = 9;
inline int CreateViewExpr::_internal_plan_columns_size() const {
  return _impl_.plan_columns_.size();
}
inline int CreateViewExpr::plan_columns_size() const {
  return _internal_plan_columns_size();
}
inline void CreateViewExpr::clear_plan_columns() {
  _impl_.plan_columns_.Clear();
}
inline std::string* CreateViewExpr::add_plan_columns() {
  std::string* _s = _internal_add_plan_columns();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateViewExpr.plan_columns)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_plan_columns(int index) const {
  return _impl_.plan_columns_.Get(index);
}
inline const std::string& CreateViewExpr::plan_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.plan_columns)
  return _internal_plan_columns(index);
}
inline std::string* CreateViewExpr::mutable_plan_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.plan_columns)
  return _impl_.plan_columns_.Mutable(index);
}
inline void CreateViewExpr::set_plan_columns(int index, const std::string& value) {
  _impl_.plan_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::set_plan_columns(int index, std::string&& value) {
  _impl_.plan_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::set_plan_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.plan_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::set_plan_columns(int index, const char* value, size_t size) {
  _impl_.plan_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateViewExpr.plan_columns)
}
inline std::string* CreateViewExpr::_internal_add_plan_columns() {
  return _impl_.plan_columns_.Add();
}
inline void CreateViewExpr::add_plan_columns(const std::string& value) {
  _impl_.plan_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::add_plan_columns(std::string&& value) {
  _impl_.plan_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::add_plan_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.plan_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateViewExpr.plan_columns)
}
inline void CreateViewExpr::add_plan_columns(const char* value, size_t size) {
  _impl_.plan_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateViewExpr.plan_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateViewExpr::plan_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateViewExpr.plan_columns)
  return _impl_.plan_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateViewExpr::mutable_plan_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateViewExpr.plan_columns)
  return &_impl_.plan_columns_;
}

// string definition = 10;
inline void CreateViewExpr::clear_definition() {
  _impl_.definition_.ClearToEmpty();
}
inline const std::string& CreateViewExpr::definition() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateViewExpr.definition)
  return _internal_definition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateViewExpr::set_definition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.definition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateViewExpr.definition)
}
inline std::string* CreateViewExpr::mutable_definition() {
  std::string* _s = _internal_mutable_definition();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateViewExpr.definition)
  return _s;
}
inline const std::string& CreateViewExpr::_internal_definition() const {
  return _impl_.definition_.Get();
}
inline void CreateViewExpr::_internal_set_definition(const std::string& value) {
  
  _impl_.definition_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateViewExpr::_internal_mutable_definition() {
  
  return _impl_.definition_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateViewExpr::release_definition() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateViewExpr.definition)
  return _impl_.definition_.Release();
}
inline void CreateViewExpr::set_allocated_definition(std::string* definition) {
  if (definition != nullptr) {
    
  } else {
    
  }
  _impl_.definition_.SetAllocated(definition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.definition_.IsDefault()) {
    _impl_.definition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateViewExpr.definition)
}

// -------------------------------------------------------------------

// DropViewExpr

// string catalog_name = 1;
inline void DropViewExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropViewExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropViewExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.catalog_name)
}
inline std::string* DropViewExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.catalog_name)
  return _s;
}
inline const std::string& DropViewExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropViewExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropViewExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropViewExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropViewExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.catalog_name)
}

// string schema_name = 2;
inline void DropViewExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropViewExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropViewExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.schema_name)
}
inline std::string* DropViewExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.schema_name)
  return _s;
}
inline const std::string& DropViewExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropViewExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropViewExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropViewExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropViewExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.schema_name)
}

// string view_name = 3;
inline void DropViewExpr::clear_view_name() {
  _impl_.view_name_.ClearToEmpty();
}
inline const std::string& DropViewExpr::view_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.view_name)
  return _internal_view_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropViewExpr::set_view_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.view_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.view_name)
}
inline std::string* DropViewExpr::mutable_view_name() {
  std::string* _s = _internal_mutable_view_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.view_name)
  return _s;
}
inline const std::string& DropViewExpr::_internal_view_name() const {
  return _impl_.view_name_.Get();
}
inline void DropViewExpr::_internal_set_view_name(const std::string& value) {
  
  _impl_.view_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropViewExpr::_internal_mutable_view_name() {
  
  return _impl_.view_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropViewExpr::release_view_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.view_name)
  return _impl_.view_name_.Release();
}
inline void DropViewExpr::set_allocated_view_name(std::string* view_name) {
  if (view_name != nullptr) {
    
  } else {
    
  }
  _impl_.view_name_.SetAllocated(view_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.view_name_.IsDefault()) {
    _impl_.view_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.view_name)
}

// .greptime.v1.TableId view_id = 4;
inline bool DropViewExpr::_internal_has_view_id() const {
  return this != internal_default_instance() && _impl_.view_id_ != nullptr;
}
inline bool DropViewExpr::has_view_id() const {
  return _internal_has_view_id();
}
inline void DropViewExpr::clear_view_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.view_id_ != nullptr) {
    delete _impl_.view_id_;
  }
  _impl_.view_id_ = nullptr;
}
inline const ::greptime::v1::TableId& DropViewExpr::_internal_view_id() const {
  const ::greptime::v1::TableId* p = _impl_.view_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& DropViewExpr::view_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.view_id)
  return _internal_view_id();
}
inline void DropViewExpr::unsafe_arena_set_allocated_view_id(
    ::greptime::v1::TableId* view_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_id_);
  }
  _impl_.view_id_ = view_id;
  if (view_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropViewExpr.view_id)
}
inline ::greptime::v1::TableId* DropViewExpr::release_view_id() {
  
  ::greptime::v1::TableId* temp = _impl_.view_id_;
  _impl_.view_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* DropViewExpr::unsafe_arena_release_view_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropViewExpr.view_id)
  
  ::greptime::v1::TableId* temp = _impl_.view_id_;
  _impl_.view_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* DropViewExpr::_internal_mutable_view_id() {
  
  if (_impl_.view_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.view_id_ = p;
  }
  return _impl_.view_id_;
}
inline ::greptime::v1::TableId* DropViewExpr::mutable_view_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_view_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropViewExpr.view_id)
  return _msg;
}
inline void DropViewExpr::set_allocated_view_id(::greptime::v1::TableId* view_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.view_id_;
  }
  if (view_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_id);
    if (message_arena != submessage_arena) {
      view_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.view_id_ = view_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropViewExpr.view_id)
}

// bool drop_if_exists = 5;
inline void DropViewExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropViewExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropViewExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropViewExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropViewExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropViewExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropViewExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateTableExpr

// string catalog_name = 1;
inline void CreateTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.catalog_name)
}
inline std::string* CreateTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.catalog_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.schema_name)
}
inline std::string* CreateTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.schema_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.schema_name)
}

// string table_name = 3;
inline void CreateTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.table_name)
}
inline std::string* CreateTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.table_name)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void CreateTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void CreateTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.table_name)
}

// string desc = 4;
inline void CreateTableExpr::clear_desc() {
  _impl_.desc_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::desc() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_desc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.desc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.desc)
}
inline std::string* CreateTableExpr::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.desc)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_desc() const {
  return _impl_.desc_.Get();
}
inline void CreateTableExpr::_internal_set_desc(const std::string& value) {
  
  _impl_.desc_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_desc() {
  
  return _impl_.desc_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_desc() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.desc)
  return _impl_.desc_.Release();
}
inline void CreateTableExpr::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  _impl_.desc_.SetAllocated(desc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.desc_.IsDefault()) {
    _impl_.desc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.desc)
}

// repeated .greptime.v1.ColumnDef column_defs = 5;
inline int CreateTableExpr::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int CreateTableExpr::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void CreateTableExpr::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >*
CreateTableExpr::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.column_defs)
  return &_impl_.column_defs_;
}
inline const ::greptime::v1::ColumnDef& CreateTableExpr::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::greptime::v1::ColumnDef& CreateTableExpr::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.column_defs)
  return _internal_column_defs(index);
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::greptime::v1::ColumnDef* CreateTableExpr::add_column_defs() {
  ::greptime::v1::ColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ColumnDef >&
CreateTableExpr::column_defs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.column_defs)
  return _impl_.column_defs_;
}

// string time_index = 6;
inline void CreateTableExpr::clear_time_index() {
  _impl_.time_index_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::time_index() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.time_index)
  return _internal_time_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_time_index(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_index_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.time_index)
}
inline std::string* CreateTableExpr::mutable_time_index() {
  std::string* _s = _internal_mutable_time_index();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.time_index)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_time_index() const {
  return _impl_.time_index_.Get();
}
inline void CreateTableExpr::_internal_set_time_index(const std::string& value) {
  
  _impl_.time_index_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_time_index() {
  
  return _impl_.time_index_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_time_index() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.time_index)
  return _impl_.time_index_.Release();
}
inline void CreateTableExpr::set_allocated_time_index(std::string* time_index) {
  if (time_index != nullptr) {
    
  } else {
    
  }
  _impl_.time_index_.SetAllocated(time_index, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_index_.IsDefault()) {
    _impl_.time_index_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.time_index)
}

// repeated string primary_keys = 7;
inline int CreateTableExpr::_internal_primary_keys_size() const {
  return _impl_.primary_keys_.size();
}
inline int CreateTableExpr::primary_keys_size() const {
  return _internal_primary_keys_size();
}
inline void CreateTableExpr::clear_primary_keys() {
  _impl_.primary_keys_.Clear();
}
inline std::string* CreateTableExpr::add_primary_keys() {
  std::string* _s = _internal_add_primary_keys();
  // @@protoc_insertion_point(field_add_mutable:greptime.v1.CreateTableExpr.primary_keys)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_primary_keys(int index) const {
  return _impl_.primary_keys_.Get(index);
}
inline const std::string& CreateTableExpr::primary_keys(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.primary_keys)
  return _internal_primary_keys(index);
}
inline std::string* CreateTableExpr::mutable_primary_keys(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.primary_keys)
  return _impl_.primary_keys_.Mutable(index);
}
inline void CreateTableExpr::set_primary_keys(int index, const std::string& value) {
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, std::string&& value) {
  _impl_.primary_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::set_primary_keys(int index, const char* value, size_t size) {
  _impl_.primary_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:greptime.v1.CreateTableExpr.primary_keys)
}
inline std::string* CreateTableExpr::_internal_add_primary_keys() {
  return _impl_.primary_keys_.Add();
}
inline void CreateTableExpr::add_primary_keys(const std::string& value) {
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(std::string&& value) {
  _impl_.primary_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.primary_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:greptime.v1.CreateTableExpr.primary_keys)
}
inline void CreateTableExpr::add_primary_keys(const char* value, size_t size) {
  _impl_.primary_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:greptime.v1.CreateTableExpr.primary_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateTableExpr::primary_keys() const {
  // @@protoc_insertion_point(field_list:greptime.v1.CreateTableExpr.primary_keys)
  return _impl_.primary_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateTableExpr::mutable_primary_keys() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.CreateTableExpr.primary_keys)
  return &_impl_.primary_keys_;
}

// bool create_if_not_exists = 8;
inline void CreateTableExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateTableExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateTableExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateTableExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateTableExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.create_if_not_exists)
}

// map<string, string> table_options = 9;
inline int CreateTableExpr::_internal_table_options_size() const {
  return _impl_.table_options_.size();
}
inline int CreateTableExpr::table_options_size() const {
  return _internal_table_options_size();
}
inline void CreateTableExpr::clear_table_options() {
  _impl_.table_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableExpr::_internal_table_options() const {
  return _impl_.table_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateTableExpr::table_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateTableExpr.table_options)
  return _internal_table_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableExpr::_internal_mutable_table_options() {
  return _impl_.table_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateTableExpr::mutable_table_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateTableExpr.table_options)
  return _internal_mutable_table_options();
}

// .greptime.v1.TableId table_id = 10;
inline bool CreateTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool CreateTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void CreateTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& CreateTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& CreateTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.table_id)
  return _internal_table_id();
}
inline void CreateTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.CreateTableExpr.table_id)
}
inline ::greptime::v1::TableId* CreateTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* CreateTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* CreateTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* CreateTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.table_id)
  return _msg;
}
inline void CreateTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.table_id)
}

// string engine = 12;
inline void CreateTableExpr::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& CreateTableExpr::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateTableExpr.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableExpr::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateTableExpr.engine)
}
inline std::string* CreateTableExpr::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateTableExpr.engine)
  return _s;
}
inline const std::string& CreateTableExpr::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void CreateTableExpr::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableExpr::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableExpr::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateTableExpr.engine)
  return _impl_.engine_.Release();
}
inline void CreateTableExpr::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateTableExpr.engine)
}

// -------------------------------------------------------------------

// AlterExpr

// string catalog_name = 1;
inline void AlterExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& AlterExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterExpr.catalog_name)
}
inline std::string* AlterExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.catalog_name)
  return _s;
}
inline const std::string& AlterExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void AlterExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void AlterExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterExpr.catalog_name)
}

// string schema_name = 2;
inline void AlterExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& AlterExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterExpr.schema_name)
}
inline std::string* AlterExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.schema_name)
  return _s;
}
inline const std::string& AlterExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void AlterExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void AlterExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterExpr.schema_name)
}

// string table_name = 3;
inline void AlterExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& AlterExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AlterExpr.table_name)
}
inline std::string* AlterExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.table_name)
  return _s;
}
inline const std::string& AlterExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void AlterExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlterExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlterExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void AlterExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AlterExpr.table_name)
}

// .greptime.v1.AddColumns add_columns = 4;
inline bool AlterExpr::_internal_has_add_columns() const {
  return kind_case() == kAddColumns;
}
inline bool AlterExpr::has_add_columns() const {
  return _internal_has_add_columns();
}
inline void AlterExpr::set_has_add_columns() {
  _impl_._oneof_case_[0] = kAddColumns;
}
inline void AlterExpr::clear_add_columns() {
  if (_internal_has_add_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.add_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::AddColumns* AlterExpr::release_add_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::AddColumns* temp = _impl_.kind_.add_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::AddColumns& AlterExpr::_internal_add_columns() const {
  return _internal_has_add_columns()
      ? *_impl_.kind_.add_columns_
      : reinterpret_cast< ::greptime::v1::AddColumns&>(::greptime::v1::_AddColumns_default_instance_);
}
inline const ::greptime::v1::AddColumns& AlterExpr::add_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.add_columns)
  return _internal_add_columns();
}
inline ::greptime::v1::AddColumns* AlterExpr::unsafe_arena_release_add_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::AddColumns* temp = _impl_.kind_.add_columns_;
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_add_columns(::greptime::v1::AddColumns* add_columns) {
  clear_kind();
  if (add_columns) {
    set_has_add_columns();
    _impl_.kind_.add_columns_ = add_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.add_columns)
}
inline ::greptime::v1::AddColumns* AlterExpr::_internal_mutable_add_columns() {
  if (!_internal_has_add_columns()) {
    clear_kind();
    set_has_add_columns();
    _impl_.kind_.add_columns_ = CreateMaybeMessage< ::greptime::v1::AddColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.add_columns_;
}
inline ::greptime::v1::AddColumns* AlterExpr::mutable_add_columns() {
  ::greptime::v1::AddColumns* _msg = _internal_mutable_add_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.add_columns)
  return _msg;
}

// .greptime.v1.DropColumns drop_columns = 5;
inline bool AlterExpr::_internal_has_drop_columns() const {
  return kind_case() == kDropColumns;
}
inline bool AlterExpr::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void AlterExpr::set_has_drop_columns() {
  _impl_._oneof_case_[0] = kDropColumns;
}
inline void AlterExpr::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.drop_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::DropColumns* AlterExpr::release_drop_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::DropColumns* temp = _impl_.kind_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DropColumns& AlterExpr::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *_impl_.kind_.drop_columns_
      : reinterpret_cast< ::greptime::v1::DropColumns&>(::greptime::v1::_DropColumns_default_instance_);
}
inline const ::greptime::v1::DropColumns& AlterExpr::drop_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.drop_columns)
  return _internal_drop_columns();
}
inline ::greptime::v1::DropColumns* AlterExpr::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::DropColumns* temp = _impl_.kind_.drop_columns_;
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_drop_columns(::greptime::v1::DropColumns* drop_columns) {
  clear_kind();
  if (drop_columns) {
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.drop_columns)
}
inline ::greptime::v1::DropColumns* AlterExpr::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_kind();
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = CreateMaybeMessage< ::greptime::v1::DropColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.drop_columns_;
}
inline ::greptime::v1::DropColumns* AlterExpr::mutable_drop_columns() {
  ::greptime::v1::DropColumns* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.drop_columns)
  return _msg;
}

// .greptime.v1.RenameTable rename_table = 6;
inline bool AlterExpr::_internal_has_rename_table() const {
  return kind_case() == kRenameTable;
}
inline bool AlterExpr::has_rename_table() const {
  return _internal_has_rename_table();
}
inline void AlterExpr::set_has_rename_table() {
  _impl_._oneof_case_[0] = kRenameTable;
}
inline void AlterExpr::clear_rename_table() {
  if (_internal_has_rename_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.rename_table_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::RenameTable* AlterExpr::release_rename_table() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.rename_table)
  if (_internal_has_rename_table()) {
    clear_has_kind();
    ::greptime::v1::RenameTable* temp = _impl_.kind_.rename_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.rename_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::RenameTable& AlterExpr::_internal_rename_table() const {
  return _internal_has_rename_table()
      ? *_impl_.kind_.rename_table_
      : reinterpret_cast< ::greptime::v1::RenameTable&>(::greptime::v1::_RenameTable_default_instance_);
}
inline const ::greptime::v1::RenameTable& AlterExpr::rename_table() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.rename_table)
  return _internal_rename_table();
}
inline ::greptime::v1::RenameTable* AlterExpr::unsafe_arena_release_rename_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.rename_table)
  if (_internal_has_rename_table()) {
    clear_has_kind();
    ::greptime::v1::RenameTable* temp = _impl_.kind_.rename_table_;
    _impl_.kind_.rename_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_rename_table(::greptime::v1::RenameTable* rename_table) {
  clear_kind();
  if (rename_table) {
    set_has_rename_table();
    _impl_.kind_.rename_table_ = rename_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.rename_table)
}
inline ::greptime::v1::RenameTable* AlterExpr::_internal_mutable_rename_table() {
  if (!_internal_has_rename_table()) {
    clear_kind();
    set_has_rename_table();
    _impl_.kind_.rename_table_ = CreateMaybeMessage< ::greptime::v1::RenameTable >(GetArenaForAllocation());
  }
  return _impl_.kind_.rename_table_;
}
inline ::greptime::v1::RenameTable* AlterExpr::mutable_rename_table() {
  ::greptime::v1::RenameTable* _msg = _internal_mutable_rename_table();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.rename_table)
  return _msg;
}

// .greptime.v1.ChangeColumnTypes change_column_types = 7;
inline bool AlterExpr::_internal_has_change_column_types() const {
  return kind_case() == kChangeColumnTypes;
}
inline bool AlterExpr::has_change_column_types() const {
  return _internal_has_change_column_types();
}
inline void AlterExpr::set_has_change_column_types() {
  _impl_._oneof_case_[0] = kChangeColumnTypes;
}
inline void AlterExpr::clear_change_column_types() {
  if (_internal_has_change_column_types()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.change_column_types_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::ChangeColumnTypes* AlterExpr::release_change_column_types() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.change_column_types)
  if (_internal_has_change_column_types()) {
    clear_has_kind();
    ::greptime::v1::ChangeColumnTypes* temp = _impl_.kind_.change_column_types_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.change_column_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::ChangeColumnTypes& AlterExpr::_internal_change_column_types() const {
  return _internal_has_change_column_types()
      ? *_impl_.kind_.change_column_types_
      : reinterpret_cast< ::greptime::v1::ChangeColumnTypes&>(::greptime::v1::_ChangeColumnTypes_default_instance_);
}
inline const ::greptime::v1::ChangeColumnTypes& AlterExpr::change_column_types() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.change_column_types)
  return _internal_change_column_types();
}
inline ::greptime::v1::ChangeColumnTypes* AlterExpr::unsafe_arena_release_change_column_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.change_column_types)
  if (_internal_has_change_column_types()) {
    clear_has_kind();
    ::greptime::v1::ChangeColumnTypes* temp = _impl_.kind_.change_column_types_;
    _impl_.kind_.change_column_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_change_column_types(::greptime::v1::ChangeColumnTypes* change_column_types) {
  clear_kind();
  if (change_column_types) {
    set_has_change_column_types();
    _impl_.kind_.change_column_types_ = change_column_types;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.change_column_types)
}
inline ::greptime::v1::ChangeColumnTypes* AlterExpr::_internal_mutable_change_column_types() {
  if (!_internal_has_change_column_types()) {
    clear_kind();
    set_has_change_column_types();
    _impl_.kind_.change_column_types_ = CreateMaybeMessage< ::greptime::v1::ChangeColumnTypes >(GetArenaForAllocation());
  }
  return _impl_.kind_.change_column_types_;
}
inline ::greptime::v1::ChangeColumnTypes* AlterExpr::mutable_change_column_types() {
  ::greptime::v1::ChangeColumnTypes* _msg = _internal_mutable_change_column_types();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.change_column_types)
  return _msg;
}

// .greptime.v1.ChangeTableOptions change_table_options = 8;
inline bool AlterExpr::_internal_has_change_table_options() const {
  return kind_case() == kChangeTableOptions;
}
inline bool AlterExpr::has_change_table_options() const {
  return _internal_has_change_table_options();
}
inline void AlterExpr::set_has_change_table_options() {
  _impl_._oneof_case_[0] = kChangeTableOptions;
}
inline void AlterExpr::clear_change_table_options() {
  if (_internal_has_change_table_options()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.change_table_options_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::ChangeTableOptions* AlterExpr::release_change_table_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.AlterExpr.change_table_options)
  if (_internal_has_change_table_options()) {
    clear_has_kind();
    ::greptime::v1::ChangeTableOptions* temp = _impl_.kind_.change_table_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.change_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::ChangeTableOptions& AlterExpr::_internal_change_table_options() const {
  return _internal_has_change_table_options()
      ? *_impl_.kind_.change_table_options_
      : reinterpret_cast< ::greptime::v1::ChangeTableOptions&>(::greptime::v1::_ChangeTableOptions_default_instance_);
}
inline const ::greptime::v1::ChangeTableOptions& AlterExpr::change_table_options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AlterExpr.change_table_options)
  return _internal_change_table_options();
}
inline ::greptime::v1::ChangeTableOptions* AlterExpr::unsafe_arena_release_change_table_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AlterExpr.change_table_options)
  if (_internal_has_change_table_options()) {
    clear_has_kind();
    ::greptime::v1::ChangeTableOptions* temp = _impl_.kind_.change_table_options_;
    _impl_.kind_.change_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterExpr::unsafe_arena_set_allocated_change_table_options(::greptime::v1::ChangeTableOptions* change_table_options) {
  clear_kind();
  if (change_table_options) {
    set_has_change_table_options();
    _impl_.kind_.change_table_options_ = change_table_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AlterExpr.change_table_options)
}
inline ::greptime::v1::ChangeTableOptions* AlterExpr::_internal_mutable_change_table_options() {
  if (!_internal_has_change_table_options()) {
    clear_kind();
    set_has_change_table_options();
    _impl_.kind_.change_table_options_ = CreateMaybeMessage< ::greptime::v1::ChangeTableOptions >(GetArenaForAllocation());
  }
  return _impl_.kind_.change_table_options_;
}
inline ::greptime::v1::ChangeTableOptions* AlterExpr::mutable_change_table_options() {
  ::greptime::v1::ChangeTableOptions* _msg = _internal_mutable_change_table_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AlterExpr.change_table_options)
  return _msg;
}

inline bool AlterExpr::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AlterExpr::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline AlterExpr::KindCase AlterExpr::kind_case() const {
  return AlterExpr::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DropTableExpr

// string catalog_name = 1;
inline void DropTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.catalog_name)
}
inline std::string* DropTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.catalog_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.catalog_name)
}

// string schema_name = 2;
inline void DropTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.schema_name)
}
inline std::string* DropTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.schema_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.schema_name)
}

// string table_name = 3;
inline void DropTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DropTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.table_name)
}
inline std::string* DropTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.table_name)
  return _s;
}
inline const std::string& DropTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DropTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void DropTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.table_name)
}

// .greptime.v1.TableId table_id = 4;
inline bool DropTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool DropTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void DropTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& DropTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& DropTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.table_id)
  return _internal_table_id();
}
inline void DropTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.DropTableExpr.table_id)
}
inline ::greptime::v1::TableId* DropTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* DropTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* DropTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* DropTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropTableExpr.table_id)
  return _msg;
}
inline void DropTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropTableExpr.table_id)
}

// bool drop_if_exists = 5;
inline void DropTableExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropTableExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropTableExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropTableExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropTableExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropTableExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropTableExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateDatabaseExpr

// string catalog_name = 1;
inline void CreateDatabaseExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& CreateDatabaseExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.catalog_name)
}
inline std::string* CreateDatabaseExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateDatabaseExpr.catalog_name)
  return _s;
}
inline const std::string& CreateDatabaseExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CreateDatabaseExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateDatabaseExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void CreateDatabaseExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateDatabaseExpr.catalog_name)
}

// string schema_name = 2;
inline void CreateDatabaseExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateDatabaseExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.schema_name)
}
inline std::string* CreateDatabaseExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.CreateDatabaseExpr.schema_name)
  return _s;
}
inline const std::string& CreateDatabaseExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateDatabaseExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.CreateDatabaseExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateDatabaseExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.CreateDatabaseExpr.schema_name)
}

// bool create_if_not_exists = 3;
inline void CreateDatabaseExpr::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateDatabaseExpr::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateDatabaseExpr::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.CreateDatabaseExpr.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateDatabaseExpr::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateDatabaseExpr::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.CreateDatabaseExpr.create_if_not_exists)
}

// map<string, string> options = 4;
inline int CreateDatabaseExpr::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int CreateDatabaseExpr::options_size() const {
  return _internal_options_size();
}
inline void CreateDatabaseExpr::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateDatabaseExpr::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateDatabaseExpr::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.CreateDatabaseExpr.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateDatabaseExpr::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateDatabaseExpr::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.CreateDatabaseExpr.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// TruncateTableExpr

// string catalog_name = 1;
inline void TruncateTableExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.catalog_name)
}
inline std::string* TruncateTableExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.catalog_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void TruncateTableExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void TruncateTableExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.catalog_name)
}

// string schema_name = 2;
inline void TruncateTableExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.schema_name)
}
inline std::string* TruncateTableExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.schema_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TruncateTableExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void TruncateTableExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.schema_name)
}

// string table_name = 3;
inline void TruncateTableExpr::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& TruncateTableExpr::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TruncateTableExpr::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TruncateTableExpr.table_name)
}
inline std::string* TruncateTableExpr::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.table_name)
  return _s;
}
inline const std::string& TruncateTableExpr::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TruncateTableExpr::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TruncateTableExpr::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.table_name)
  return _impl_.table_name_.Release();
}
inline void TruncateTableExpr::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.table_name)
}

// .greptime.v1.TableId table_id = 4;
inline bool TruncateTableExpr::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool TruncateTableExpr::has_table_id() const {
  return _internal_has_table_id();
}
inline void TruncateTableExpr::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::greptime::v1::TableId& TruncateTableExpr::_internal_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& TruncateTableExpr::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TruncateTableExpr.table_id)
  return _internal_table_id();
}
inline void TruncateTableExpr::unsafe_arena_set_allocated_table_id(
    ::greptime::v1::TableId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.TruncateTableExpr.table_id)
}
inline ::greptime::v1::TableId* TruncateTableExpr::release_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* TruncateTableExpr::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.TruncateTableExpr.table_id)
  
  ::greptime::v1::TableId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* TruncateTableExpr::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::greptime::v1::TableId* TruncateTableExpr::mutable_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TruncateTableExpr.table_id)
  return _msg;
}
inline void TruncateTableExpr::set_allocated_table_id(::greptime::v1::TableId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TruncateTableExpr.table_id)
}

// -------------------------------------------------------------------

// DropDatabaseExpr

// string catalog_name = 1;
inline void DropDatabaseExpr::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& DropDatabaseExpr::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDatabaseExpr.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDatabaseExpr::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropDatabaseExpr.catalog_name)
}
inline std::string* DropDatabaseExpr::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropDatabaseExpr.catalog_name)
  return _s;
}
inline const std::string& DropDatabaseExpr::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void DropDatabaseExpr::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropDatabaseExpr.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void DropDatabaseExpr::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropDatabaseExpr.catalog_name)
}

// string schema_name = 2;
inline void DropDatabaseExpr::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& DropDatabaseExpr::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDatabaseExpr.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDatabaseExpr::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropDatabaseExpr.schema_name)
}
inline std::string* DropDatabaseExpr::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropDatabaseExpr.schema_name)
  return _s;
}
inline const std::string& DropDatabaseExpr::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void DropDatabaseExpr::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDatabaseExpr::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropDatabaseExpr.schema_name)
  return _impl_.schema_name_.Release();
}
inline void DropDatabaseExpr::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropDatabaseExpr.schema_name)
}

// bool drop_if_exists = 3;
inline void DropDatabaseExpr::clear_drop_if_exists() {
  _impl_.drop_if_exists_ = false;
}
inline bool DropDatabaseExpr::_internal_drop_if_exists() const {
  return _impl_.drop_if_exists_;
}
inline bool DropDatabaseExpr::drop_if_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropDatabaseExpr.drop_if_exists)
  return _internal_drop_if_exists();
}
inline void DropDatabaseExpr::_internal_set_drop_if_exists(bool value) {
  
  _impl_.drop_if_exists_ = value;
}
inline void DropDatabaseExpr::set_drop_if_exists(bool value) {
  _internal_set_drop_if_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DropDatabaseExpr.drop_if_exists)
}

// -------------------------------------------------------------------

// AddColumns

// repeated .greptime.v1.AddColumn add_columns = 1;
inline int AddColumns::_internal_add_columns_size() const {
  return _impl_.add_columns_.size();
}
inline int AddColumns::add_columns_size() const {
  return _internal_add_columns_size();
}
inline void AddColumns::clear_add_columns() {
  _impl_.add_columns_.Clear();
}
inline ::greptime::v1::AddColumn* AddColumns::mutable_add_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumns.add_columns)
  return _impl_.add_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >*
AddColumns::mutable_add_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.AddColumns.add_columns)
  return &_impl_.add_columns_;
}
inline const ::greptime::v1::AddColumn& AddColumns::_internal_add_columns(int index) const {
  return _impl_.add_columns_.Get(index);
}
inline const ::greptime::v1::AddColumn& AddColumns::add_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumns.add_columns)
  return _internal_add_columns(index);
}
inline ::greptime::v1::AddColumn* AddColumns::_internal_add_add_columns() {
  return _impl_.add_columns_.Add();
}
inline ::greptime::v1::AddColumn* AddColumns::add_add_columns() {
  ::greptime::v1::AddColumn* _add = _internal_add_add_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.AddColumns.add_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::AddColumn >&
AddColumns::add_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.AddColumns.add_columns)
  return _impl_.add_columns_;
}

// -------------------------------------------------------------------

// DropColumns

// repeated .greptime.v1.DropColumn drop_columns = 1;
inline int DropColumns::_internal_drop_columns_size() const {
  return _impl_.drop_columns_.size();
}
inline int DropColumns::drop_columns_size() const {
  return _internal_drop_columns_size();
}
inline void DropColumns::clear_drop_columns() {
  _impl_.drop_columns_.Clear();
}
inline ::greptime::v1::DropColumn* DropColumns::mutable_drop_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropColumns.drop_columns)
  return _impl_.drop_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >*
DropColumns::mutable_drop_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.DropColumns.drop_columns)
  return &_impl_.drop_columns_;
}
inline const ::greptime::v1::DropColumn& DropColumns::_internal_drop_columns(int index) const {
  return _impl_.drop_columns_.Get(index);
}
inline const ::greptime::v1::DropColumn& DropColumns::drop_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropColumns.drop_columns)
  return _internal_drop_columns(index);
}
inline ::greptime::v1::DropColumn* DropColumns::_internal_add_drop_columns() {
  return _impl_.drop_columns_.Add();
}
inline ::greptime::v1::DropColumn* DropColumns::add_drop_columns() {
  ::greptime::v1::DropColumn* _add = _internal_add_drop_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.DropColumns.drop_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::DropColumn >&
DropColumns::drop_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.DropColumns.drop_columns)
  return _impl_.drop_columns_;
}

// -------------------------------------------------------------------

// ChangeColumnTypes

// repeated .greptime.v1.ChangeColumnType change_column_types = 1;
inline int ChangeColumnTypes::_internal_change_column_types_size() const {
  return _impl_.change_column_types_.size();
}
inline int ChangeColumnTypes::change_column_types_size() const {
  return _internal_change_column_types_size();
}
inline void ChangeColumnTypes::clear_change_column_types() {
  _impl_.change_column_types_.Clear();
}
inline ::greptime::v1::ChangeColumnType* ChangeColumnTypes::mutable_change_column_types(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.ChangeColumnTypes.change_column_types)
  return _impl_.change_column_types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ChangeColumnType >*
ChangeColumnTypes::mutable_change_column_types() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.ChangeColumnTypes.change_column_types)
  return &_impl_.change_column_types_;
}
inline const ::greptime::v1::ChangeColumnType& ChangeColumnTypes::_internal_change_column_types(int index) const {
  return _impl_.change_column_types_.Get(index);
}
inline const ::greptime::v1::ChangeColumnType& ChangeColumnTypes::change_column_types(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.ChangeColumnTypes.change_column_types)
  return _internal_change_column_types(index);
}
inline ::greptime::v1::ChangeColumnType* ChangeColumnTypes::_internal_add_change_column_types() {
  return _impl_.change_column_types_.Add();
}
inline ::greptime::v1::ChangeColumnType* ChangeColumnTypes::add_change_column_types() {
  ::greptime::v1::ChangeColumnType* _add = _internal_add_change_column_types();
  // @@protoc_insertion_point(field_add:greptime.v1.ChangeColumnTypes.change_column_types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::ChangeColumnType >&
ChangeColumnTypes::change_column_types() const {
  // @@protoc_insertion_point(field_list:greptime.v1.ChangeColumnTypes.change_column_types)
  return _impl_.change_column_types_;
}

// -------------------------------------------------------------------

// RenameTable

// string new_table_name = 1;
inline void RenameTable::clear_new_table_name() {
  _impl_.new_table_name_.ClearToEmpty();
}
inline const std::string& RenameTable::new_table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RenameTable.new_table_name)
  return _internal_new_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameTable::set_new_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RenameTable.new_table_name)
}
inline std::string* RenameTable::mutable_new_table_name() {
  std::string* _s = _internal_mutable_new_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RenameTable.new_table_name)
  return _s;
}
inline const std::string& RenameTable::_internal_new_table_name() const {
  return _impl_.new_table_name_.Get();
}
inline void RenameTable::_internal_set_new_table_name(const std::string& value) {
  
  _impl_.new_table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameTable::_internal_mutable_new_table_name() {
  
  return _impl_.new_table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameTable::release_new_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.RenameTable.new_table_name)
  return _impl_.new_table_name_.Release();
}
inline void RenameTable::set_allocated_new_table_name(std::string* new_table_name) {
  if (new_table_name != nullptr) {
    
  } else {
    
  }
  _impl_.new_table_name_.SetAllocated(new_table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_table_name_.IsDefault()) {
    _impl_.new_table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RenameTable.new_table_name)
}

// -------------------------------------------------------------------

// AddColumn

// .greptime.v1.ColumnDef column_def = 1;
inline bool AddColumn::_internal_has_column_def() const {
  return this != internal_default_instance() && _impl_.column_def_ != nullptr;
}
inline bool AddColumn::has_column_def() const {
  return _internal_has_column_def();
}
inline void AddColumn::clear_column_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_def_ != nullptr) {
    delete _impl_.column_def_;
  }
  _impl_.column_def_ = nullptr;
}
inline const ::greptime::v1::ColumnDef& AddColumn::_internal_column_def() const {
  const ::greptime::v1::ColumnDef* p = _impl_.column_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDef&>(
      ::greptime::v1::_ColumnDef_default_instance_);
}
inline const ::greptime::v1::ColumnDef& AddColumn::column_def() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.column_def)
  return _internal_column_def();
}
inline void AddColumn::unsafe_arena_set_allocated_column_def(
    ::greptime::v1::ColumnDef* column_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  _impl_.column_def_ = column_def;
  if (column_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AddColumn.column_def)
}
inline ::greptime::v1::ColumnDef* AddColumn::release_column_def() {
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDef* AddColumn::unsafe_arena_release_column_def() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumn.column_def)
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDef* AddColumn::_internal_mutable_column_def() {
  
  if (_impl_.column_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDef>(GetArenaForAllocation());
    _impl_.column_def_ = p;
  }
  return _impl_.column_def_;
}
inline ::greptime::v1::ColumnDef* AddColumn::mutable_column_def() {
  ::greptime::v1::ColumnDef* _msg = _internal_mutable_column_def();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumn.column_def)
  return _msg;
}
inline void AddColumn::set_allocated_column_def(::greptime::v1::ColumnDef* column_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_def_;
  }
  if (column_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_def);
    if (message_arena != submessage_arena) {
      column_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_def_ = column_def;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumn.column_def)
}

// .greptime.v1.AddColumnLocation location = 3;
inline bool AddColumn::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AddColumn::has_location() const {
  return _internal_has_location();
}
inline void AddColumn::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::_internal_location() const {
  const ::greptime::v1::AddColumnLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AddColumnLocation&>(
      ::greptime::v1::_AddColumnLocation_default_instance_);
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::location() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumn.location)
  return _internal_location();
}
inline void AddColumn::unsafe_arena_set_allocated_location(
    ::greptime::v1::AddColumnLocation* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AddColumn.location)
}
inline ::greptime::v1::AddColumnLocation* AddColumn::release_location() {
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumn.location)
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AddColumnLocation>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::mutable_location() {
  ::greptime::v1::AddColumnLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumn.location)
  return _msg;
}
inline void AddColumn::set_allocated_location(::greptime::v1::AddColumnLocation* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumn.location)
}

// -------------------------------------------------------------------

// ChangeColumnType

// string column_name = 1;
inline void ChangeColumnType::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& ChangeColumnType::column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ChangeColumnType.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeColumnType::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ChangeColumnType.column_name)
}
inline std::string* ChangeColumnType::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ChangeColumnType.column_name)
  return _s;
}
inline const std::string& ChangeColumnType::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void ChangeColumnType::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeColumnType::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeColumnType::release_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.ChangeColumnType.column_name)
  return _impl_.column_name_.Release();
}
inline void ChangeColumnType::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ChangeColumnType.column_name)
}

// .greptime.v1.ColumnDataType target_type = 2;
inline void ChangeColumnType::clear_target_type() {
  _impl_.target_type_ = 0;
}
inline ::greptime::v1::ColumnDataType ChangeColumnType::_internal_target_type() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.target_type_);
}
inline ::greptime::v1::ColumnDataType ChangeColumnType::target_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ChangeColumnType.target_type)
  return _internal_target_type();
}
inline void ChangeColumnType::_internal_set_target_type(::greptime::v1::ColumnDataType value) {
  
  _impl_.target_type_ = value;
}
inline void ChangeColumnType::set_target_type(::greptime::v1::ColumnDataType value) {
  _internal_set_target_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ChangeColumnType.target_type)
}

// .greptime.v1.ColumnDataTypeExtension target_type_extension = 3;
inline bool ChangeColumnType::_internal_has_target_type_extension() const {
  return this != internal_default_instance() && _impl_.target_type_extension_ != nullptr;
}
inline bool ChangeColumnType::has_target_type_extension() const {
  return _internal_has_target_type_extension();
}
inline const ::greptime::v1::ColumnDataTypeExtension& ChangeColumnType::_internal_target_type_extension() const {
  const ::greptime::v1::ColumnDataTypeExtension* p = _impl_.target_type_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDataTypeExtension&>(
      ::greptime::v1::_ColumnDataTypeExtension_default_instance_);
}
inline const ::greptime::v1::ColumnDataTypeExtension& ChangeColumnType::target_type_extension() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ChangeColumnType.target_type_extension)
  return _internal_target_type_extension();
}
inline void ChangeColumnType::unsafe_arena_set_allocated_target_type_extension(
    ::greptime::v1::ColumnDataTypeExtension* target_type_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_type_extension_);
  }
  _impl_.target_type_extension_ = target_type_extension;
  if (target_type_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ChangeColumnType.target_type_extension)
}
inline ::greptime::v1::ColumnDataTypeExtension* ChangeColumnType::release_target_type_extension() {
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.target_type_extension_;
  _impl_.target_type_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ChangeColumnType::unsafe_arena_release_target_type_extension() {
  // @@protoc_insertion_point(field_release:greptime.v1.ChangeColumnType.target_type_extension)
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.target_type_extension_;
  _impl_.target_type_extension_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ChangeColumnType::_internal_mutable_target_type_extension() {
  
  if (_impl_.target_type_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(GetArenaForAllocation());
    _impl_.target_type_extension_ = p;
  }
  return _impl_.target_type_extension_;
}
inline ::greptime::v1::ColumnDataTypeExtension* ChangeColumnType::mutable_target_type_extension() {
  ::greptime::v1::ColumnDataTypeExtension* _msg = _internal_mutable_target_type_extension();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ChangeColumnType.target_type_extension)
  return _msg;
}
inline void ChangeColumnType::set_allocated_target_type_extension(::greptime::v1::ColumnDataTypeExtension* target_type_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_type_extension_);
  }
  if (target_type_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_type_extension));
    if (message_arena != submessage_arena) {
      target_type_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_type_extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_type_extension_ = target_type_extension;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ChangeColumnType.target_type_extension)
}

// -------------------------------------------------------------------

// ChangeTableOptions

// string key = 1;
inline void ChangeTableOptions::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ChangeTableOptions::key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ChangeTableOptions.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeTableOptions::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ChangeTableOptions.key)
}
inline std::string* ChangeTableOptions::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ChangeTableOptions.key)
  return _s;
}
inline const std::string& ChangeTableOptions::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ChangeTableOptions::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeTableOptions::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeTableOptions::release_key() {
  // @@protoc_insertion_point(field_release:greptime.v1.ChangeTableOptions.key)
  return _impl_.key_.Release();
}
inline void ChangeTableOptions::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ChangeTableOptions.key)
}

// string value = 2;
inline void ChangeTableOptions::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ChangeTableOptions::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ChangeTableOptions.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeTableOptions::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ChangeTableOptions.value)
}
inline std::string* ChangeTableOptions::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ChangeTableOptions.value)
  return _s;
}
inline const std::string& ChangeTableOptions::_internal_value() const {
  return _impl_.value_.Get();
}
inline void ChangeTableOptions::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeTableOptions::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeTableOptions::release_value() {
  // @@protoc_insertion_point(field_release:greptime.v1.ChangeTableOptions.value)
  return _impl_.value_.Release();
}
inline void ChangeTableOptions::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ChangeTableOptions.value)
}

// -------------------------------------------------------------------

// DropColumn

// string name = 1;
inline void DropColumn::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DropColumn::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DropColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.DropColumn.name)
}
inline std::string* DropColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.DropColumn.name)
  return _s;
}
inline const std::string& DropColumn::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DropColumn::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropColumn::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropColumn::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.DropColumn.name)
  return _impl_.name_.Release();
}
inline void DropColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.DropColumn.name)
}

// -------------------------------------------------------------------

// TableId

// uint32 id = 1;
inline void TableId::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t TableId::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t TableId::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableId.id)
  return _internal_id();
}
inline void TableId::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void TableId::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.TableId.id)
}

// -------------------------------------------------------------------

// FlowId

// uint32 id = 1;
inline void FlowId::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t FlowId::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t FlowId::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.FlowId.id)
  return _internal_id();
}
inline void FlowId::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void FlowId::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.FlowId.id)
}

// -------------------------------------------------------------------

// ColumnDef

// string name = 1;
inline void ColumnDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDef::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.name)
}
inline std::string* ColumnDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.name)
  return _s;
}
inline const std::string& ColumnDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.name)
  return _impl_.name_.Release();
}
inline void ColumnDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.name)
}

// .greptime.v1.ColumnDataType data_type = 2;
inline void ColumnDef::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline ::greptime::v1::ColumnDataType ColumnDef::_internal_data_type() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.data_type_);
}
inline ::greptime::v1::ColumnDataType ColumnDef::data_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.data_type)
  return _internal_data_type();
}
inline void ColumnDef::_internal_set_data_type(::greptime::v1::ColumnDataType value) {
  
  _impl_.data_type_ = value;
}
inline void ColumnDef::set_data_type(::greptime::v1::ColumnDataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.data_type)
}

// bool is_nullable = 3;
inline void ColumnDef::clear_is_nullable() {
  _impl_.is_nullable_ = false;
}
inline bool ColumnDef::_internal_is_nullable() const {
  return _impl_.is_nullable_;
}
inline bool ColumnDef::is_nullable() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.is_nullable)
  return _internal_is_nullable();
}
inline void ColumnDef::_internal_set_is_nullable(bool value) {
  
  _impl_.is_nullable_ = value;
}
inline void ColumnDef::set_is_nullable(bool value) {
  _internal_set_is_nullable(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.is_nullable)
}

// bytes default_constraint = 4;
inline void ColumnDef::clear_default_constraint() {
  _impl_.default_constraint_.ClearToEmpty();
}
inline const std::string& ColumnDef::default_constraint() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.default_constraint)
  return _internal_default_constraint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_default_constraint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_constraint_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.default_constraint)
}
inline std::string* ColumnDef::mutable_default_constraint() {
  std::string* _s = _internal_mutable_default_constraint();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.default_constraint)
  return _s;
}
inline const std::string& ColumnDef::_internal_default_constraint() const {
  return _impl_.default_constraint_.Get();
}
inline void ColumnDef::_internal_set_default_constraint(const std::string& value) {
  
  _impl_.default_constraint_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_default_constraint() {
  
  return _impl_.default_constraint_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_default_constraint() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.default_constraint)
  return _impl_.default_constraint_.Release();
}
inline void ColumnDef::set_allocated_default_constraint(std::string* default_constraint) {
  if (default_constraint != nullptr) {
    
  } else {
    
  }
  _impl_.default_constraint_.SetAllocated(default_constraint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_constraint_.IsDefault()) {
    _impl_.default_constraint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.default_constraint)
}

// .greptime.v1.SemanticType semantic_type = 5;
inline void ColumnDef::clear_semantic_type() {
  _impl_.semantic_type_ = 0;
}
inline ::greptime::v1::SemanticType ColumnDef::_internal_semantic_type() const {
  return static_cast< ::greptime::v1::SemanticType >(_impl_.semantic_type_);
}
inline ::greptime::v1::SemanticType ColumnDef::semantic_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.semantic_type)
  return _internal_semantic_type();
}
inline void ColumnDef::_internal_set_semantic_type(::greptime::v1::SemanticType value) {
  
  _impl_.semantic_type_ = value;
}
inline void ColumnDef::set_semantic_type(::greptime::v1::SemanticType value) {
  _internal_set_semantic_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.semantic_type)
}

// string comment = 6;
inline void ColumnDef::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& ColumnDef::comment() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDef.comment)
}
inline std::string* ColumnDef::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.comment)
  return _s;
}
inline const std::string& ColumnDef::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void ColumnDef::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_comment() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.comment)
  return _impl_.comment_.Release();
}
inline void ColumnDef::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.comment)
}

// .greptime.v1.ColumnDataTypeExtension datatype_extension = 7;
inline bool ColumnDef::_internal_has_datatype_extension() const {
  return this != internal_default_instance() && _impl_.datatype_extension_ != nullptr;
}
inline bool ColumnDef::has_datatype_extension() const {
  return _internal_has_datatype_extension();
}
inline const ::greptime::v1::ColumnDataTypeExtension& ColumnDef::_internal_datatype_extension() const {
  const ::greptime::v1::ColumnDataTypeExtension* p = _impl_.datatype_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDataTypeExtension&>(
      ::greptime::v1::_ColumnDataTypeExtension_default_instance_);
}
inline const ::greptime::v1::ColumnDataTypeExtension& ColumnDef::datatype_extension() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.datatype_extension)
  return _internal_datatype_extension();
}
inline void ColumnDef::unsafe_arena_set_allocated_datatype_extension(
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_extension_);
  }
  _impl_.datatype_extension_ = datatype_extension;
  if (datatype_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDef.datatype_extension)
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::release_datatype_extension() {
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::unsafe_arena_release_datatype_extension() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.datatype_extension)
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::_internal_mutable_datatype_extension() {
  
  if (_impl_.datatype_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(GetArenaForAllocation());
    _impl_.datatype_extension_ = p;
  }
  return _impl_.datatype_extension_;
}
inline ::greptime::v1::ColumnDataTypeExtension* ColumnDef::mutable_datatype_extension() {
  ::greptime::v1::ColumnDataTypeExtension* _msg = _internal_mutable_datatype_extension();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.datatype_extension)
  return _msg;
}
inline void ColumnDef::set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_extension_);
  }
  if (datatype_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datatype_extension));
    if (message_arena != submessage_arena) {
      datatype_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datatype_extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datatype_extension_ = datatype_extension;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.datatype_extension)
}

// .greptime.v1.ColumnOptions options = 8;
inline bool ColumnDef::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool ColumnDef::has_options() const {
  return _internal_has_options();
}
inline const ::greptime::v1::ColumnOptions& ColumnDef::_internal_options() const {
  const ::greptime::v1::ColumnOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnOptions&>(
      ::greptime::v1::_ColumnOptions_default_instance_);
}
inline const ::greptime::v1::ColumnOptions& ColumnDef::options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDef.options)
  return _internal_options();
}
inline void ColumnDef::unsafe_arena_set_allocated_options(
    ::greptime::v1::ColumnOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDef.options)
}
inline ::greptime::v1::ColumnOptions* ColumnDef::release_options() {
  
  ::greptime::v1::ColumnOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnOptions* ColumnDef::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDef.options)
  
  ::greptime::v1::ColumnOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnOptions* ColumnDef::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnOptions>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::greptime::v1::ColumnOptions* ColumnDef::mutable_options() {
  ::greptime::v1::ColumnOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDef.options)
  return _msg;
}
inline void ColumnDef::set_allocated_options(::greptime::v1::ColumnOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options));
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDef.options)
}

// -------------------------------------------------------------------

// AddColumnLocation

// .greptime.v1.AddColumnLocation.LocationType location_type = 1;
inline void AddColumnLocation::clear_location_type() {
  _impl_.location_type_ = 0;
}
inline ::greptime::v1::AddColumnLocation_LocationType AddColumnLocation::_internal_location_type() const {
  return static_cast< ::greptime::v1::AddColumnLocation_LocationType >(_impl_.location_type_);
}
inline ::greptime::v1::AddColumnLocation_LocationType AddColumnLocation::location_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumnLocation.location_type)
  return _internal_location_type();
}
inline void AddColumnLocation::_internal_set_location_type(::greptime::v1::AddColumnLocation_LocationType value) {
  
  _impl_.location_type_ = value;
}
inline void AddColumnLocation::set_location_type(::greptime::v1::AddColumnLocation_LocationType value) {
  _internal_set_location_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumnLocation.location_type)
}

// string after_column_name = 2;
inline void AddColumnLocation::clear_after_column_name() {
  _impl_.after_column_name_.ClearToEmpty();
}
inline const std::string& AddColumnLocation::after_column_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AddColumnLocation.after_column_name)
  return _internal_after_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddColumnLocation::set_after_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.after_column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.AddColumnLocation.after_column_name)
}
inline std::string* AddColumnLocation::mutable_after_column_name() {
  std::string* _s = _internal_mutable_after_column_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AddColumnLocation.after_column_name)
  return _s;
}
inline const std::string& AddColumnLocation::_internal_after_column_name() const {
  return _impl_.after_column_name_.Get();
}
inline void AddColumnLocation::_internal_set_after_column_name(const std::string& value) {
  
  _impl_.after_column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddColumnLocation::_internal_mutable_after_column_name() {
  
  return _impl_.after_column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddColumnLocation::release_after_column_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.AddColumnLocation.after_column_name)
  return _impl_.after_column_name_.Release();
}
inline void AddColumnLocation::set_allocated_after_column_name(std::string* after_column_name) {
  if (after_column_name != nullptr) {
    
  } else {
    
  }
  _impl_.after_column_name_.SetAllocated(after_column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.after_column_name_.IsDefault()) {
    _impl_.after_column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AddColumnLocation.after_column_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::AddColumnLocation_LocationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::AddColumnLocation_LocationType>() {
  return ::greptime::v1::AddColumnLocation_LocationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fddl_2eproto
