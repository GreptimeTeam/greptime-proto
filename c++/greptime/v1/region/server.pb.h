// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/region/server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fregion_2fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fregion_2fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
#include "greptime/v1/row.pb.h"
#include "greptime/v1/ddl.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fregion_2fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fregion_2fserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fregion_2fserver_2eproto;
namespace greptime {
namespace v1 {
namespace region {
class AddColumn;
struct AddColumnDefaultTypeInternal;
extern AddColumnDefaultTypeInternal _AddColumn_default_instance_;
class AddColumns;
struct AddColumnsDefaultTypeInternal;
extern AddColumnsDefaultTypeInternal _AddColumns_default_instance_;
class AlterRequest;
struct AlterRequestDefaultTypeInternal;
extern AlterRequestDefaultTypeInternal _AlterRequest_default_instance_;
class AlterRequests;
struct AlterRequestsDefaultTypeInternal;
extern AlterRequestsDefaultTypeInternal _AlterRequests_default_instance_;
class CloseRequest;
struct CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class CompactRequest;
struct CompactRequestDefaultTypeInternal;
extern CompactRequestDefaultTypeInternal _CompactRequest_default_instance_;
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateRequest_OptionsEntry_DoNotUse;
struct CreateRequest_OptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateRequest_OptionsEntry_DoNotUseDefaultTypeInternal _CreateRequest_OptionsEntry_DoNotUse_default_instance_;
class CreateRequests;
struct CreateRequestsDefaultTypeInternal;
extern CreateRequestsDefaultTypeInternal _CreateRequests_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteRequests;
struct DeleteRequestsDefaultTypeInternal;
extern DeleteRequestsDefaultTypeInternal _DeleteRequests_default_instance_;
class DropColumn;
struct DropColumnDefaultTypeInternal;
extern DropColumnDefaultTypeInternal _DropColumn_default_instance_;
class DropColumns;
struct DropColumnsDefaultTypeInternal;
extern DropColumnsDefaultTypeInternal _DropColumns_default_instance_;
class DropRequest;
struct DropRequestDefaultTypeInternal;
extern DropRequestDefaultTypeInternal _DropRequest_default_instance_;
class DropRequests;
struct DropRequestsDefaultTypeInternal;
extern DropRequestsDefaultTypeInternal _DropRequests_default_instance_;
class FlushRequest;
struct FlushRequestDefaultTypeInternal;
extern FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertRequests;
struct InsertRequestsDefaultTypeInternal;
extern InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
class OpenRequest;
struct OpenRequestDefaultTypeInternal;
extern OpenRequestDefaultTypeInternal _OpenRequest_default_instance_;
class OpenRequest_OptionsEntry_DoNotUse;
struct OpenRequest_OptionsEntry_DoNotUseDefaultTypeInternal;
extern OpenRequest_OptionsEntry_DoNotUseDefaultTypeInternal _OpenRequest_OptionsEntry_DoNotUse_default_instance_;
class QueryRequest;
struct QueryRequestDefaultTypeInternal;
extern QueryRequestDefaultTypeInternal _QueryRequest_default_instance_;
class RegionColumnDef;
struct RegionColumnDefDefaultTypeInternal;
extern RegionColumnDefDefaultTypeInternal _RegionColumnDef_default_instance_;
class RegionRequest;
struct RegionRequestDefaultTypeInternal;
extern RegionRequestDefaultTypeInternal _RegionRequest_default_instance_;
class RegionRequestHeader;
struct RegionRequestHeaderDefaultTypeInternal;
extern RegionRequestHeaderDefaultTypeInternal _RegionRequestHeader_default_instance_;
class RegionRequestHeader_TracingContextEntry_DoNotUse;
struct RegionRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal;
extern RegionRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _RegionRequestHeader_TracingContextEntry_DoNotUse_default_instance_;
class RegionResponse;
struct RegionResponseDefaultTypeInternal;
extern RegionResponseDefaultTypeInternal _RegionResponse_default_instance_;
class RegionResponse_ExtensionsEntry_DoNotUse;
struct RegionResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern RegionResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal _RegionResponse_ExtensionsEntry_DoNotUse_default_instance_;
class Regular;
struct RegularDefaultTypeInternal;
extern RegularDefaultTypeInternal _Regular_default_instance_;
class StrictWindow;
struct StrictWindowDefaultTypeInternal;
extern StrictWindowDefaultTypeInternal _StrictWindow_default_instance_;
class TruncateRequest;
struct TruncateRequestDefaultTypeInternal;
extern TruncateRequestDefaultTypeInternal _TruncateRequest_default_instance_;
}  // namespace region
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::region::AddColumn* Arena::CreateMaybeMessage<::greptime::v1::region::AddColumn>(Arena*);
template<> ::greptime::v1::region::AddColumns* Arena::CreateMaybeMessage<::greptime::v1::region::AddColumns>(Arena*);
template<> ::greptime::v1::region::AlterRequest* Arena::CreateMaybeMessage<::greptime::v1::region::AlterRequest>(Arena*);
template<> ::greptime::v1::region::AlterRequests* Arena::CreateMaybeMessage<::greptime::v1::region::AlterRequests>(Arena*);
template<> ::greptime::v1::region::CloseRequest* Arena::CreateMaybeMessage<::greptime::v1::region::CloseRequest>(Arena*);
template<> ::greptime::v1::region::CompactRequest* Arena::CreateMaybeMessage<::greptime::v1::region::CompactRequest>(Arena*);
template<> ::greptime::v1::region::CreateRequest* Arena::CreateMaybeMessage<::greptime::v1::region::CreateRequest>(Arena*);
template<> ::greptime::v1::region::CreateRequest_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::region::CreateRequest_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::region::CreateRequests* Arena::CreateMaybeMessage<::greptime::v1::region::CreateRequests>(Arena*);
template<> ::greptime::v1::region::DeleteRequest* Arena::CreateMaybeMessage<::greptime::v1::region::DeleteRequest>(Arena*);
template<> ::greptime::v1::region::DeleteRequests* Arena::CreateMaybeMessage<::greptime::v1::region::DeleteRequests>(Arena*);
template<> ::greptime::v1::region::DropColumn* Arena::CreateMaybeMessage<::greptime::v1::region::DropColumn>(Arena*);
template<> ::greptime::v1::region::DropColumns* Arena::CreateMaybeMessage<::greptime::v1::region::DropColumns>(Arena*);
template<> ::greptime::v1::region::DropRequest* Arena::CreateMaybeMessage<::greptime::v1::region::DropRequest>(Arena*);
template<> ::greptime::v1::region::DropRequests* Arena::CreateMaybeMessage<::greptime::v1::region::DropRequests>(Arena*);
template<> ::greptime::v1::region::FlushRequest* Arena::CreateMaybeMessage<::greptime::v1::region::FlushRequest>(Arena*);
template<> ::greptime::v1::region::InsertRequest* Arena::CreateMaybeMessage<::greptime::v1::region::InsertRequest>(Arena*);
template<> ::greptime::v1::region::InsertRequests* Arena::CreateMaybeMessage<::greptime::v1::region::InsertRequests>(Arena*);
template<> ::greptime::v1::region::OpenRequest* Arena::CreateMaybeMessage<::greptime::v1::region::OpenRequest>(Arena*);
template<> ::greptime::v1::region::OpenRequest_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::region::OpenRequest_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::region::QueryRequest* Arena::CreateMaybeMessage<::greptime::v1::region::QueryRequest>(Arena*);
template<> ::greptime::v1::region::RegionColumnDef* Arena::CreateMaybeMessage<::greptime::v1::region::RegionColumnDef>(Arena*);
template<> ::greptime::v1::region::RegionRequest* Arena::CreateMaybeMessage<::greptime::v1::region::RegionRequest>(Arena*);
template<> ::greptime::v1::region::RegionRequestHeader* Arena::CreateMaybeMessage<::greptime::v1::region::RegionRequestHeader>(Arena*);
template<> ::greptime::v1::region::RegionRequestHeader_TracingContextEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::region::RegionRequestHeader_TracingContextEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::region::RegionResponse* Arena::CreateMaybeMessage<::greptime::v1::region::RegionResponse>(Arena*);
template<> ::greptime::v1::region::RegionResponse_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::region::RegionResponse_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::region::Regular* Arena::CreateMaybeMessage<::greptime::v1::region::Regular>(Arena*);
template<> ::greptime::v1::region::StrictWindow* Arena::CreateMaybeMessage<::greptime::v1::region::StrictWindow>(Arena*);
template<> ::greptime::v1::region::TruncateRequest* Arena::CreateMaybeMessage<::greptime::v1::region::TruncateRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace region {

// ===================================================================

class RegionRequestHeader_TracingContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionRequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionRequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RegionRequestHeader_TracingContextEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RegionRequestHeader_TracingContextEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RegionRequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RegionRequestHeader_TracingContextEntry_DoNotUse& other);
  static const RegionRequestHeader_TracingContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RegionRequestHeader_TracingContextEntry_DoNotUse*>(&_RegionRequestHeader_TracingContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.RegionRequestHeader.TracingContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.RegionRequestHeader.TracingContextEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};

// -------------------------------------------------------------------

class RegionRequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionRequestHeader) */ {
 public:
  inline RegionRequestHeader() : RegionRequestHeader(nullptr) {}
  ~RegionRequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RegionRequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRequestHeader(const RegionRequestHeader& from);
  RegionRequestHeader(RegionRequestHeader&& from) noexcept
    : RegionRequestHeader() {
    *this = ::std::move(from);
  }

  inline RegionRequestHeader& operator=(const RegionRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRequestHeader& operator=(RegionRequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRequestHeader* internal_default_instance() {
    return reinterpret_cast<const RegionRequestHeader*>(
               &_RegionRequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegionRequestHeader& a, RegionRequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRequestHeader& from) {
    RegionRequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionRequestHeader";
  }
  protected:
  explicit RegionRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTracingContextFieldNumber = 5,
    kDbnameFieldNumber = 3,
    kQueryContextFieldNumber = 6,
  };
  // map<string, string> tracing_context = 5;
  int tracing_context_size() const;
  private:
  int _internal_tracing_context_size() const;
  public:
  void clear_tracing_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tracing_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tracing_context();

  // string dbname = 3;
  void clear_dbname();
  const std::string& dbname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* dbname);
  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(const std::string& value);
  std::string* _internal_mutable_dbname();
  public:

  // .greptime.v1.QueryContext query_context = 6;
  bool has_query_context() const;
  private:
  bool _internal_has_query_context() const;
  public:
  void clear_query_context();
  const ::greptime::v1::QueryContext& query_context() const;
  PROTOBUF_NODISCARD ::greptime::v1::QueryContext* release_query_context();
  ::greptime::v1::QueryContext* mutable_query_context();
  void set_allocated_query_context(::greptime::v1::QueryContext* query_context);
  private:
  const ::greptime::v1::QueryContext& _internal_query_context() const;
  ::greptime::v1::QueryContext* _internal_mutable_query_context();
  public:
  void unsafe_arena_set_allocated_query_context(
      ::greptime::v1::QueryContext* query_context);
  ::greptime::v1::QueryContext* unsafe_arena_release_query_context();

  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionRequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RegionRequestHeader_TracingContextEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tracing_context_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
    ::greptime::v1::QueryContext* query_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RegionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionRequest) */ {
 public:
  inline RegionRequest() : RegionRequest(nullptr) {}
  ~RegionRequest() override;
  explicit PROTOBUF_CONSTEXPR RegionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRequest(const RegionRequest& from);
  RegionRequest(RegionRequest&& from) noexcept
    : RegionRequest() {
    *this = ::std::move(from);
  }

  inline RegionRequest& operator=(const RegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRequest& operator=(RegionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kInserts = 3,
    kDeletes = 4,
    kCreate = 5,
    kDrop = 6,
    kOpen = 7,
    kClose = 8,
    kAlter = 9,
    kFlush = 10,
    kCompact = 11,
    kTruncate = 12,
    kCreates = 13,
    kDrops = 14,
    kAlters = 15,
    BODY_NOT_SET = 0,
  };

  static inline const RegionRequest* internal_default_instance() {
    return reinterpret_cast<const RegionRequest*>(
               &_RegionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegionRequest& a, RegionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRequest& from) {
    RegionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionRequest";
  }
  protected:
  explicit RegionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kInsertsFieldNumber = 3,
    kDeletesFieldNumber = 4,
    kCreateFieldNumber = 5,
    kDropFieldNumber = 6,
    kOpenFieldNumber = 7,
    kCloseFieldNumber = 8,
    kAlterFieldNumber = 9,
    kFlushFieldNumber = 10,
    kCompactFieldNumber = 11,
    kTruncateFieldNumber = 12,
    kCreatesFieldNumber = 13,
    kDropsFieldNumber = 14,
    kAltersFieldNumber = 15,
  };
  // .greptime.v1.region.RegionRequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::region::RegionRequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::RegionRequestHeader* release_header();
  ::greptime::v1::region::RegionRequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::region::RegionRequestHeader* header);
  private:
  const ::greptime::v1::region::RegionRequestHeader& _internal_header() const;
  ::greptime::v1::region::RegionRequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::region::RegionRequestHeader* header);
  ::greptime::v1::region::RegionRequestHeader* unsafe_arena_release_header();

  // .greptime.v1.region.InsertRequests inserts = 3;
  bool has_inserts() const;
  private:
  bool _internal_has_inserts() const;
  public:
  void clear_inserts();
  const ::greptime::v1::region::InsertRequests& inserts() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::InsertRequests* release_inserts();
  ::greptime::v1::region::InsertRequests* mutable_inserts();
  void set_allocated_inserts(::greptime::v1::region::InsertRequests* inserts);
  private:
  const ::greptime::v1::region::InsertRequests& _internal_inserts() const;
  ::greptime::v1::region::InsertRequests* _internal_mutable_inserts();
  public:
  void unsafe_arena_set_allocated_inserts(
      ::greptime::v1::region::InsertRequests* inserts);
  ::greptime::v1::region::InsertRequests* unsafe_arena_release_inserts();

  // .greptime.v1.region.DeleteRequests deletes = 4;
  bool has_deletes() const;
  private:
  bool _internal_has_deletes() const;
  public:
  void clear_deletes();
  const ::greptime::v1::region::DeleteRequests& deletes() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DeleteRequests* release_deletes();
  ::greptime::v1::region::DeleteRequests* mutable_deletes();
  void set_allocated_deletes(::greptime::v1::region::DeleteRequests* deletes);
  private:
  const ::greptime::v1::region::DeleteRequests& _internal_deletes() const;
  ::greptime::v1::region::DeleteRequests* _internal_mutable_deletes();
  public:
  void unsafe_arena_set_allocated_deletes(
      ::greptime::v1::region::DeleteRequests* deletes);
  ::greptime::v1::region::DeleteRequests* unsafe_arena_release_deletes();

  // .greptime.v1.region.CreateRequest create = 5;
  bool has_create() const;
  private:
  bool _internal_has_create() const;
  public:
  void clear_create();
  const ::greptime::v1::region::CreateRequest& create() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CreateRequest* release_create();
  ::greptime::v1::region::CreateRequest* mutable_create();
  void set_allocated_create(::greptime::v1::region::CreateRequest* create);
  private:
  const ::greptime::v1::region::CreateRequest& _internal_create() const;
  ::greptime::v1::region::CreateRequest* _internal_mutable_create();
  public:
  void unsafe_arena_set_allocated_create(
      ::greptime::v1::region::CreateRequest* create);
  ::greptime::v1::region::CreateRequest* unsafe_arena_release_create();

  // .greptime.v1.region.DropRequest drop = 6;
  bool has_drop() const;
  private:
  bool _internal_has_drop() const;
  public:
  void clear_drop();
  const ::greptime::v1::region::DropRequest& drop() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DropRequest* release_drop();
  ::greptime::v1::region::DropRequest* mutable_drop();
  void set_allocated_drop(::greptime::v1::region::DropRequest* drop);
  private:
  const ::greptime::v1::region::DropRequest& _internal_drop() const;
  ::greptime::v1::region::DropRequest* _internal_mutable_drop();
  public:
  void unsafe_arena_set_allocated_drop(
      ::greptime::v1::region::DropRequest* drop);
  ::greptime::v1::region::DropRequest* unsafe_arena_release_drop();

  // .greptime.v1.region.OpenRequest open = 7;
  bool has_open() const;
  private:
  bool _internal_has_open() const;
  public:
  void clear_open();
  const ::greptime::v1::region::OpenRequest& open() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::OpenRequest* release_open();
  ::greptime::v1::region::OpenRequest* mutable_open();
  void set_allocated_open(::greptime::v1::region::OpenRequest* open);
  private:
  const ::greptime::v1::region::OpenRequest& _internal_open() const;
  ::greptime::v1::region::OpenRequest* _internal_mutable_open();
  public:
  void unsafe_arena_set_allocated_open(
      ::greptime::v1::region::OpenRequest* open);
  ::greptime::v1::region::OpenRequest* unsafe_arena_release_open();

  // .greptime.v1.region.CloseRequest close = 8;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::greptime::v1::region::CloseRequest& close() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CloseRequest* release_close();
  ::greptime::v1::region::CloseRequest* mutable_close();
  void set_allocated_close(::greptime::v1::region::CloseRequest* close);
  private:
  const ::greptime::v1::region::CloseRequest& _internal_close() const;
  ::greptime::v1::region::CloseRequest* _internal_mutable_close();
  public:
  void unsafe_arena_set_allocated_close(
      ::greptime::v1::region::CloseRequest* close);
  ::greptime::v1::region::CloseRequest* unsafe_arena_release_close();

  // .greptime.v1.region.AlterRequest alter = 9;
  bool has_alter() const;
  private:
  bool _internal_has_alter() const;
  public:
  void clear_alter();
  const ::greptime::v1::region::AlterRequest& alter() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::AlterRequest* release_alter();
  ::greptime::v1::region::AlterRequest* mutable_alter();
  void set_allocated_alter(::greptime::v1::region::AlterRequest* alter);
  private:
  const ::greptime::v1::region::AlterRequest& _internal_alter() const;
  ::greptime::v1::region::AlterRequest* _internal_mutable_alter();
  public:
  void unsafe_arena_set_allocated_alter(
      ::greptime::v1::region::AlterRequest* alter);
  ::greptime::v1::region::AlterRequest* unsafe_arena_release_alter();

  // .greptime.v1.region.FlushRequest flush = 10;
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;
  public:
  void clear_flush();
  const ::greptime::v1::region::FlushRequest& flush() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::FlushRequest* release_flush();
  ::greptime::v1::region::FlushRequest* mutable_flush();
  void set_allocated_flush(::greptime::v1::region::FlushRequest* flush);
  private:
  const ::greptime::v1::region::FlushRequest& _internal_flush() const;
  ::greptime::v1::region::FlushRequest* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::greptime::v1::region::FlushRequest* flush);
  ::greptime::v1::region::FlushRequest* unsafe_arena_release_flush();

  // .greptime.v1.region.CompactRequest compact = 11;
  bool has_compact() const;
  private:
  bool _internal_has_compact() const;
  public:
  void clear_compact();
  const ::greptime::v1::region::CompactRequest& compact() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CompactRequest* release_compact();
  ::greptime::v1::region::CompactRequest* mutable_compact();
  void set_allocated_compact(::greptime::v1::region::CompactRequest* compact);
  private:
  const ::greptime::v1::region::CompactRequest& _internal_compact() const;
  ::greptime::v1::region::CompactRequest* _internal_mutable_compact();
  public:
  void unsafe_arena_set_allocated_compact(
      ::greptime::v1::region::CompactRequest* compact);
  ::greptime::v1::region::CompactRequest* unsafe_arena_release_compact();

  // .greptime.v1.region.TruncateRequest truncate = 12;
  bool has_truncate() const;
  private:
  bool _internal_has_truncate() const;
  public:
  void clear_truncate();
  const ::greptime::v1::region::TruncateRequest& truncate() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::TruncateRequest* release_truncate();
  ::greptime::v1::region::TruncateRequest* mutable_truncate();
  void set_allocated_truncate(::greptime::v1::region::TruncateRequest* truncate);
  private:
  const ::greptime::v1::region::TruncateRequest& _internal_truncate() const;
  ::greptime::v1::region::TruncateRequest* _internal_mutable_truncate();
  public:
  void unsafe_arena_set_allocated_truncate(
      ::greptime::v1::region::TruncateRequest* truncate);
  ::greptime::v1::region::TruncateRequest* unsafe_arena_release_truncate();

  // .greptime.v1.region.CreateRequests creates = 13;
  bool has_creates() const;
  private:
  bool _internal_has_creates() const;
  public:
  void clear_creates();
  const ::greptime::v1::region::CreateRequests& creates() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CreateRequests* release_creates();
  ::greptime::v1::region::CreateRequests* mutable_creates();
  void set_allocated_creates(::greptime::v1::region::CreateRequests* creates);
  private:
  const ::greptime::v1::region::CreateRequests& _internal_creates() const;
  ::greptime::v1::region::CreateRequests* _internal_mutable_creates();
  public:
  void unsafe_arena_set_allocated_creates(
      ::greptime::v1::region::CreateRequests* creates);
  ::greptime::v1::region::CreateRequests* unsafe_arena_release_creates();

  // .greptime.v1.region.DropRequests drops = 14;
  bool has_drops() const;
  private:
  bool _internal_has_drops() const;
  public:
  void clear_drops();
  const ::greptime::v1::region::DropRequests& drops() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DropRequests* release_drops();
  ::greptime::v1::region::DropRequests* mutable_drops();
  void set_allocated_drops(::greptime::v1::region::DropRequests* drops);
  private:
  const ::greptime::v1::region::DropRequests& _internal_drops() const;
  ::greptime::v1::region::DropRequests* _internal_mutable_drops();
  public:
  void unsafe_arena_set_allocated_drops(
      ::greptime::v1::region::DropRequests* drops);
  ::greptime::v1::region::DropRequests* unsafe_arena_release_drops();

  // .greptime.v1.region.AlterRequests alters = 15;
  bool has_alters() const;
  private:
  bool _internal_has_alters() const;
  public:
  void clear_alters();
  const ::greptime::v1::region::AlterRequests& alters() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::AlterRequests* release_alters();
  ::greptime::v1::region::AlterRequests* mutable_alters();
  void set_allocated_alters(::greptime::v1::region::AlterRequests* alters);
  private:
  const ::greptime::v1::region::AlterRequests& _internal_alters() const;
  ::greptime::v1::region::AlterRequests* _internal_mutable_alters();
  public:
  void unsafe_arena_set_allocated_alters(
      ::greptime::v1::region::AlterRequests* alters);
  ::greptime::v1::region::AlterRequests* unsafe_arena_release_alters();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionRequest)
 private:
  class _Internal;
  void set_has_inserts();
  void set_has_deletes();
  void set_has_create();
  void set_has_drop();
  void set_has_open();
  void set_has_close();
  void set_has_alter();
  void set_has_flush();
  void set_has_compact();
  void set_has_truncate();
  void set_has_creates();
  void set_has_drops();
  void set_has_alters();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::region::RegionRequestHeader* header_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::region::InsertRequests* inserts_;
      ::greptime::v1::region::DeleteRequests* deletes_;
      ::greptime::v1::region::CreateRequest* create_;
      ::greptime::v1::region::DropRequest* drop_;
      ::greptime::v1::region::OpenRequest* open_;
      ::greptime::v1::region::CloseRequest* close_;
      ::greptime::v1::region::AlterRequest* alter_;
      ::greptime::v1::region::FlushRequest* flush_;
      ::greptime::v1::region::CompactRequest* compact_;
      ::greptime::v1::region::TruncateRequest* truncate_;
      ::greptime::v1::region::CreateRequests* creates_;
      ::greptime::v1::region::DropRequests* drops_;
      ::greptime::v1::region::AlterRequests* alters_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RegionResponse_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionResponse_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegionResponse_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  RegionResponse_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RegionResponse_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RegionResponse_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RegionResponse_ExtensionsEntry_DoNotUse& other);
  static const RegionResponse_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RegionResponse_ExtensionsEntry_DoNotUse*>(&_RegionResponse_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.RegionResponse.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};

// -------------------------------------------------------------------

class RegionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionResponse) */ {
 public:
  inline RegionResponse() : RegionResponse(nullptr) {}
  ~RegionResponse() override;
  explicit PROTOBUF_CONSTEXPR RegionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionResponse(const RegionResponse& from);
  RegionResponse(RegionResponse&& from) noexcept
    : RegionResponse() {
    *this = ::std::move(from);
  }

  inline RegionResponse& operator=(const RegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionResponse& operator=(RegionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionResponse* internal_default_instance() {
    return reinterpret_cast<const RegionResponse*>(
               &_RegionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegionResponse& a, RegionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionResponse& from) {
    RegionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionResponse";
  }
  protected:
  explicit RegionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kAffectedRowsFieldNumber = 2,
  };
  // map<string, bytes> extensions = 3;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extensions();

  // .greptime.v1.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::ResponseHeader* release_header();
  ::greptime::v1::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::ResponseHeader* header);
  private:
  const ::greptime::v1::ResponseHeader& _internal_header() const;
  ::greptime::v1::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::ResponseHeader* header);
  ::greptime::v1::ResponseHeader* unsafe_arena_release_header();

  // uint64 affected_rows = 2;
  void clear_affected_rows();
  uint64_t affected_rows() const;
  void set_affected_rows(uint64_t value);
  private:
  uint64_t _internal_affected_rows() const;
  void _internal_set_affected_rows(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RegionResponse_ExtensionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extensions_;
    ::greptime::v1::ResponseHeader* header_;
    uint64_t affected_rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.InsertRequests) */ {
 public:
  inline InsertRequests() : InsertRequests(nullptr) {}
  ~InsertRequests() override;
  explicit PROTOBUF_CONSTEXPR InsertRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequests(const InsertRequests& from);
  InsertRequests(InsertRequests&& from) noexcept
    : InsertRequests() {
    *this = ::std::move(from);
  }

  inline InsertRequests& operator=(const InsertRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequests& operator=(InsertRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequests* internal_default_instance() {
    return reinterpret_cast<const InsertRequests*>(
               &_InsertRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InsertRequests& a, InsertRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequests& from) {
    InsertRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.InsertRequests";
  }
  protected:
  explicit InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.InsertRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::InsertRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::InsertRequest& _internal_requests(int index) const;
  ::greptime::v1::region::InsertRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::InsertRequest& requests(int index) const;
  ::greptime::v1::region::InsertRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.InsertRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DeleteRequests) */ {
 public:
  inline DeleteRequests() : DeleteRequests(nullptr) {}
  ~DeleteRequests() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequests(const DeleteRequests& from);
  DeleteRequests(DeleteRequests&& from) noexcept
    : DeleteRequests() {
    *this = ::std::move(from);
  }

  inline DeleteRequests& operator=(const DeleteRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequests& operator=(DeleteRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequests* internal_default_instance() {
    return reinterpret_cast<const DeleteRequests*>(
               &_DeleteRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteRequests& a, DeleteRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequests& from) {
    DeleteRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DeleteRequests";
  }
  protected:
  explicit DeleteRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.DeleteRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::DeleteRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::DeleteRequest& _internal_requests(int index) const;
  ::greptime::v1::region::DeleteRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::DeleteRequest& requests(int index) const;
  ::greptime::v1::region::DeleteRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DeleteRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .greptime.v1.Rows rows = 2;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  const ::greptime::v1::Rows& rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::Rows* release_rows();
  ::greptime::v1::Rows* mutable_rows();
  void set_allocated_rows(::greptime::v1::Rows* rows);
  private:
  const ::greptime::v1::Rows& _internal_rows() const;
  ::greptime::v1::Rows* _internal_mutable_rows();
  public:
  void unsafe_arena_set_allocated_rows(
      ::greptime::v1::Rows* rows);
  ::greptime::v1::Rows* unsafe_arena_release_rows();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Rows* rows_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .greptime.v1.Rows rows = 2;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  const ::greptime::v1::Rows& rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::Rows* release_rows();
  ::greptime::v1::Rows* mutable_rows();
  void set_allocated_rows(::greptime::v1::Rows* rows);
  private:
  const ::greptime::v1::Rows& _internal_rows() const;
  ::greptime::v1::Rows* _internal_mutable_rows();
  public:
  void unsafe_arena_set_allocated_rows(
      ::greptime::v1::Rows* rows);
  ::greptime::v1::Rows* unsafe_arena_release_rows();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Rows* rows_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class QueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.QueryRequest) */ {
 public:
  inline QueryRequest() : QueryRequest(nullptr) {}
  ~QueryRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRequest(const QueryRequest& from);
  QueryRequest(QueryRequest&& from) noexcept
    : QueryRequest() {
    *this = ::std::move(from);
  }

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRequest& operator=(QueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRequest*>(
               &_QueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(QueryRequest& a, QueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRequest& from) {
    QueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.QueryRequest";
  }
  protected:
  explicit QueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kRegionIdFieldNumber = 2,
  };
  // bytes plan = 3;
  void clear_plan();
  const std::string& plan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plan();
  PROTOBUF_NODISCARD std::string* release_plan();
  void set_allocated_plan(std::string* plan);
  private:
  const std::string& _internal_plan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan(const std::string& value);
  std::string* _internal_mutable_plan();
  public:

  // .greptime.v1.region.RegionRequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::region::RegionRequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::RegionRequestHeader* release_header();
  ::greptime::v1::region::RegionRequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::region::RegionRequestHeader* header);
  private:
  const ::greptime::v1::region::RegionRequestHeader& _internal_header() const;
  ::greptime::v1::region::RegionRequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::region::RegionRequestHeader* header);
  ::greptime::v1::region::RegionRequestHeader* unsafe_arena_release_header();

  // uint64 region_id = 2;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.QueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_;
    ::greptime::v1::region::RegionRequestHeader* header_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CreateRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CreateRequests) */ {
 public:
  inline CreateRequests() : CreateRequests(nullptr) {}
  ~CreateRequests() override;
  explicit PROTOBUF_CONSTEXPR CreateRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequests(const CreateRequests& from);
  CreateRequests(CreateRequests&& from) noexcept
    : CreateRequests() {
    *this = ::std::move(from);
  }

  inline CreateRequests& operator=(const CreateRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequests& operator=(CreateRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequests* internal_default_instance() {
    return reinterpret_cast<const CreateRequests*>(
               &_CreateRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateRequests& a, CreateRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRequests& from) {
    CreateRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CreateRequests";
  }
  protected:
  explicit CreateRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.CreateRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::CreateRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::CreateRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::CreateRequest& _internal_requests(int index) const;
  ::greptime::v1::region::CreateRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::CreateRequest& requests(int index) const;
  ::greptime::v1::region::CreateRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::CreateRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.CreateRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::CreateRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateRequest_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateRequest_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateRequest_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateRequest_OptionsEntry_DoNotUse& other);
  static const CreateRequest_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateRequest_OptionsEntry_DoNotUse*>(&_CreateRequest_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.CreateRequest.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.CreateRequest.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};

// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRequest& from) {
    CreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 3,
    kPrimaryKeyFieldNumber = 4,
    kOptionsFieldNumber = 6,
    kEngineFieldNumber = 2,
    kPathFieldNumber = 5,
    kRegionIdFieldNumber = 1,
  };
  // repeated .greptime.v1.region.RegionColumnDef column_defs = 3;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::greptime::v1::region::RegionColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::RegionColumnDef >*
      mutable_column_defs();
  private:
  const ::greptime::v1::region::RegionColumnDef& _internal_column_defs(int index) const;
  ::greptime::v1::region::RegionColumnDef* _internal_add_column_defs();
  public:
  const ::greptime::v1::region::RegionColumnDef& column_defs(int index) const;
  ::greptime::v1::region::RegionColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::RegionColumnDef >&
      column_defs() const;

  // repeated uint32 primary_key = 4;
  int primary_key_size() const;
  private:
  int _internal_primary_key_size() const;
  public:
  void clear_primary_key();
  private:
  uint32_t _internal_primary_key(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_primary_key() const;
  void _internal_add_primary_key(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_primary_key();
  public:
  uint32_t primary_key(int index) const;
  void set_primary_key(int index, uint32_t value);
  void add_primary_key(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      primary_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_primary_key();

  // map<string, string> options = 6;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string engine = 2;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // string path = 5;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::RegionColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > primary_key_;
    mutable std::atomic<int> _primary_key_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateRequest_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropRequests) */ {
 public:
  inline DropRequests() : DropRequests(nullptr) {}
  ~DropRequests() override;
  explicit PROTOBUF_CONSTEXPR DropRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropRequests(const DropRequests& from);
  DropRequests(DropRequests&& from) noexcept
    : DropRequests() {
    *this = ::std::move(from);
  }

  inline DropRequests& operator=(const DropRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropRequests& operator=(DropRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropRequests* internal_default_instance() {
    return reinterpret_cast<const DropRequests*>(
               &_DropRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DropRequests& a, DropRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(DropRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropRequests& from) {
    DropRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropRequests";
  }
  protected:
  explicit DropRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.DropRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::DropRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::DropRequest& _internal_requests(int index) const;
  ::greptime::v1::region::DropRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::DropRequest& requests(int index) const;
  ::greptime::v1::region::DropRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropRequest) */ {
 public:
  inline DropRequest() : DropRequest(nullptr) {}
  ~DropRequest() override;
  explicit PROTOBUF_CONSTEXPR DropRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropRequest(const DropRequest& from);
  DropRequest(DropRequest&& from) noexcept
    : DropRequest() {
    *this = ::std::move(from);
  }

  inline DropRequest& operator=(const DropRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropRequest& operator=(DropRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropRequest* internal_default_instance() {
    return reinterpret_cast<const DropRequest*>(
               &_DropRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DropRequest& a, DropRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropRequest& from) {
    DropRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropRequest";
  }
  protected:
  explicit DropRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class OpenRequest_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OpenRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OpenRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OpenRequest_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OpenRequest_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OpenRequest_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OpenRequest_OptionsEntry_DoNotUse& other);
  static const OpenRequest_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OpenRequest_OptionsEntry_DoNotUse*>(&_OpenRequest_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.OpenRequest.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.OpenRequest.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};

// -------------------------------------------------------------------

class OpenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.OpenRequest) */ {
 public:
  inline OpenRequest() : OpenRequest(nullptr) {}
  ~OpenRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenRequest(const OpenRequest& from);
  OpenRequest(OpenRequest&& from) noexcept
    : OpenRequest() {
    *this = ::std::move(from);
  }

  inline OpenRequest& operator=(const OpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenRequest& operator=(OpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenRequest* internal_default_instance() {
    return reinterpret_cast<const OpenRequest*>(
               &_OpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(OpenRequest& a, OpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenRequest& from) {
    OpenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.OpenRequest";
  }
  protected:
  explicit OpenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kEngineFieldNumber = 2,
    kPathFieldNumber = 3,
    kRegionIdFieldNumber = 1,
  };
  // map<string, string> options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string engine = 2;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.OpenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OpenRequest_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CloseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CloseRequest) */ {
 public:
  inline CloseRequest() : CloseRequest(nullptr) {}
  ~CloseRequest() override;
  explicit PROTOBUF_CONSTEXPR CloseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseRequest(const CloseRequest& from);
  CloseRequest(CloseRequest&& from) noexcept
    : CloseRequest() {
    *this = ::std::move(from);
  }

  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
               &_CloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CloseRequest& a, CloseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseRequest& from) {
    CloseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CloseRequest";
  }
  protected:
  explicit CloseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.CloseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AlterRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AlterRequests) */ {
 public:
  inline AlterRequests() : AlterRequests(nullptr) {}
  ~AlterRequests() override;
  explicit PROTOBUF_CONSTEXPR AlterRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterRequests(const AlterRequests& from);
  AlterRequests(AlterRequests&& from) noexcept
    : AlterRequests() {
    *this = ::std::move(from);
  }

  inline AlterRequests& operator=(const AlterRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterRequests& operator=(AlterRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlterRequests* internal_default_instance() {
    return reinterpret_cast<const AlterRequests*>(
               &_AlterRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AlterRequests& a, AlterRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterRequests& from) {
    AlterRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AlterRequests";
  }
  protected:
  explicit AlterRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.AlterRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::AlterRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AlterRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::AlterRequest& _internal_requests(int index) const;
  ::greptime::v1::region::AlterRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::AlterRequest& requests(int index) const;
  ::greptime::v1::region::AlterRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AlterRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.AlterRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AlterRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AlterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AlterRequest) */ {
 public:
  inline AlterRequest() : AlterRequest(nullptr) {}
  ~AlterRequest() override;
  explicit PROTOBUF_CONSTEXPR AlterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterRequest(const AlterRequest& from);
  AlterRequest(AlterRequest&& from) noexcept
    : AlterRequest() {
    *this = ::std::move(from);
  }

  inline AlterRequest& operator=(const AlterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterRequest& operator=(AlterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterRequest& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kAddColumns = 2,
    kDropColumns = 3,
    kChangeColumnTypes = 5,
    kChangeTableOptions = 6,
    KIND_NOT_SET = 0,
  };

  static inline const AlterRequest* internal_default_instance() {
    return reinterpret_cast<const AlterRequest*>(
               &_AlterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AlterRequest& a, AlterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterRequest& from) {
    AlterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AlterRequest";
  }
  protected:
  explicit AlterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kSchemaVersionFieldNumber = 4,
    kAddColumnsFieldNumber = 2,
    kDropColumnsFieldNumber = 3,
    kChangeColumnTypesFieldNumber = 5,
    kChangeTableOptionsFieldNumber = 6,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // uint64 schema_version = 4;
  void clear_schema_version();
  uint64_t schema_version() const;
  void set_schema_version(uint64_t value);
  private:
  uint64_t _internal_schema_version() const;
  void _internal_set_schema_version(uint64_t value);
  public:

  // .greptime.v1.region.AddColumns add_columns = 2;
  bool has_add_columns() const;
  private:
  bool _internal_has_add_columns() const;
  public:
  void clear_add_columns();
  const ::greptime::v1::region::AddColumns& add_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::AddColumns* release_add_columns();
  ::greptime::v1::region::AddColumns* mutable_add_columns();
  void set_allocated_add_columns(::greptime::v1::region::AddColumns* add_columns);
  private:
  const ::greptime::v1::region::AddColumns& _internal_add_columns() const;
  ::greptime::v1::region::AddColumns* _internal_mutable_add_columns();
  public:
  void unsafe_arena_set_allocated_add_columns(
      ::greptime::v1::region::AddColumns* add_columns);
  ::greptime::v1::region::AddColumns* unsafe_arena_release_add_columns();

  // .greptime.v1.region.DropColumns drop_columns = 3;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::greptime::v1::region::DropColumns& drop_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DropColumns* release_drop_columns();
  ::greptime::v1::region::DropColumns* mutable_drop_columns();
  void set_allocated_drop_columns(::greptime::v1::region::DropColumns* drop_columns);
  private:
  const ::greptime::v1::region::DropColumns& _internal_drop_columns() const;
  ::greptime::v1::region::DropColumns* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::greptime::v1::region::DropColumns* drop_columns);
  ::greptime::v1::region::DropColumns* unsafe_arena_release_drop_columns();

  // .greptime.v1.ChangeColumnTypes change_column_types = 5;
  bool has_change_column_types() const;
  private:
  bool _internal_has_change_column_types() const;
  public:
  void clear_change_column_types();
  const ::greptime::v1::ChangeColumnTypes& change_column_types() const;
  PROTOBUF_NODISCARD ::greptime::v1::ChangeColumnTypes* release_change_column_types();
  ::greptime::v1::ChangeColumnTypes* mutable_change_column_types();
  void set_allocated_change_column_types(::greptime::v1::ChangeColumnTypes* change_column_types);
  private:
  const ::greptime::v1::ChangeColumnTypes& _internal_change_column_types() const;
  ::greptime::v1::ChangeColumnTypes* _internal_mutable_change_column_types();
  public:
  void unsafe_arena_set_allocated_change_column_types(
      ::greptime::v1::ChangeColumnTypes* change_column_types);
  ::greptime::v1::ChangeColumnTypes* unsafe_arena_release_change_column_types();

  // .greptime.v1.ChangeTableOptions change_table_options = 6;
  bool has_change_table_options() const;
  private:
  bool _internal_has_change_table_options() const;
  public:
  void clear_change_table_options();
  const ::greptime::v1::ChangeTableOptions& change_table_options() const;
  PROTOBUF_NODISCARD ::greptime::v1::ChangeTableOptions* release_change_table_options();
  ::greptime::v1::ChangeTableOptions* mutable_change_table_options();
  void set_allocated_change_table_options(::greptime::v1::ChangeTableOptions* change_table_options);
  private:
  const ::greptime::v1::ChangeTableOptions& _internal_change_table_options() const;
  ::greptime::v1::ChangeTableOptions* _internal_mutable_change_table_options();
  public:
  void unsafe_arena_set_allocated_change_table_options(
      ::greptime::v1::ChangeTableOptions* change_table_options);
  ::greptime::v1::ChangeTableOptions* unsafe_arena_release_change_table_options();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.region.AlterRequest)
 private:
  class _Internal;
  void set_has_add_columns();
  void set_has_drop_columns();
  void set_has_change_column_types();
  void set_has_change_table_options();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    uint64_t schema_version_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::region::AddColumns* add_columns_;
      ::greptime::v1::region::DropColumns* drop_columns_;
      ::greptime::v1::ChangeColumnTypes* change_column_types_;
      ::greptime::v1::ChangeTableOptions* change_table_options_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AddColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AddColumns) */ {
 public:
  inline AddColumns() : AddColumns(nullptr) {}
  ~AddColumns() override;
  explicit PROTOBUF_CONSTEXPR AddColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumns(const AddColumns& from);
  AddColumns(AddColumns&& from) noexcept
    : AddColumns() {
    *this = ::std::move(from);
  }

  inline AddColumns& operator=(const AddColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumns& operator=(AddColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumns* internal_default_instance() {
    return reinterpret_cast<const AddColumns*>(
               &_AddColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AddColumns& a, AddColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumns& from) {
    AddColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AddColumns";
  }
  protected:
  explicit AddColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.AddColumn add_columns = 1;
  int add_columns_size() const;
  private:
  int _internal_add_columns_size() const;
  public:
  void clear_add_columns();
  ::greptime::v1::region::AddColumn* mutable_add_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >*
      mutable_add_columns();
  private:
  const ::greptime::v1::region::AddColumn& _internal_add_columns(int index) const;
  ::greptime::v1::region::AddColumn* _internal_add_add_columns();
  public:
  const ::greptime::v1::region::AddColumn& add_columns(int index) const;
  ::greptime::v1::region::AddColumn* add_add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >&
      add_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.AddColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn > add_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropColumns) */ {
 public:
  inline DropColumns() : DropColumns(nullptr) {}
  ~DropColumns() override;
  explicit PROTOBUF_CONSTEXPR DropColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumns(const DropColumns& from);
  DropColumns(DropColumns&& from) noexcept
    : DropColumns() {
    *this = ::std::move(from);
  }

  inline DropColumns& operator=(const DropColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumns& operator=(DropColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumns* internal_default_instance() {
    return reinterpret_cast<const DropColumns*>(
               &_DropColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DropColumns& a, DropColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumns& from) {
    DropColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropColumns";
  }
  protected:
  explicit DropColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.DropColumn drop_columns = 1;
  int drop_columns_size() const;
  private:
  int _internal_drop_columns_size() const;
  public:
  void clear_drop_columns();
  ::greptime::v1::region::DropColumn* mutable_drop_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >*
      mutable_drop_columns();
  private:
  const ::greptime::v1::region::DropColumn& _internal_drop_columns(int index) const;
  ::greptime::v1::region::DropColumn* _internal_add_drop_columns();
  public:
  const ::greptime::v1::region::DropColumn& drop_columns(int index) const;
  ::greptime::v1::region::DropColumn* add_drop_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >&
      drop_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn > drop_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AddColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AddColumn) */ {
 public:
  inline AddColumn() : AddColumn(nullptr) {}
  ~AddColumn() override;
  explicit PROTOBUF_CONSTEXPR AddColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumn(const AddColumn& from);
  AddColumn(AddColumn&& from) noexcept
    : AddColumn() {
    *this = ::std::move(from);
  }

  inline AddColumn& operator=(const AddColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumn& operator=(AddColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumn* internal_default_instance() {
    return reinterpret_cast<const AddColumn*>(
               &_AddColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AddColumn& a, AddColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumn& from) {
    AddColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AddColumn";
  }
  protected:
  explicit AddColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefFieldNumber = 1,
    kLocationFieldNumber = 3,
  };
  // .greptime.v1.region.RegionColumnDef column_def = 1;
  bool has_column_def() const;
  private:
  bool _internal_has_column_def() const;
  public:
  void clear_column_def();
  const ::greptime::v1::region::RegionColumnDef& column_def() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::RegionColumnDef* release_column_def();
  ::greptime::v1::region::RegionColumnDef* mutable_column_def();
  void set_allocated_column_def(::greptime::v1::region::RegionColumnDef* column_def);
  private:
  const ::greptime::v1::region::RegionColumnDef& _internal_column_def() const;
  ::greptime::v1::region::RegionColumnDef* _internal_mutable_column_def();
  public:
  void unsafe_arena_set_allocated_column_def(
      ::greptime::v1::region::RegionColumnDef* column_def);
  ::greptime::v1::region::RegionColumnDef* unsafe_arena_release_column_def();

  // .greptime.v1.AddColumnLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::greptime::v1::AddColumnLocation& location() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumnLocation* release_location();
  ::greptime::v1::AddColumnLocation* mutable_location();
  void set_allocated_location(::greptime::v1::AddColumnLocation* location);
  private:
  const ::greptime::v1::AddColumnLocation& _internal_location() const;
  ::greptime::v1::AddColumnLocation* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::greptime::v1::AddColumnLocation* location);
  ::greptime::v1::AddColumnLocation* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:greptime.v1.region.AddColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::region::RegionColumnDef* column_def_;
    ::greptime::v1::AddColumnLocation* location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropColumn) */ {
 public:
  inline DropColumn() : DropColumn(nullptr) {}
  ~DropColumn() override;
  explicit PROTOBUF_CONSTEXPR DropColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumn(const DropColumn& from);
  DropColumn(DropColumn&& from) noexcept
    : DropColumn() {
    *this = ::std::move(from);
  }

  inline DropColumn& operator=(const DropColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumn& operator=(DropColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumn* internal_default_instance() {
    return reinterpret_cast<const DropColumn*>(
               &_DropColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DropColumn& a, DropColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumn& from) {
    DropColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropColumn";
  }
  protected:
  explicit DropColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.FlushRequest) */ {
 public:
  inline FlushRequest() : FlushRequest(nullptr) {}
  ~FlushRequest() override;
  explicit PROTOBUF_CONSTEXPR FlushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushRequest(const FlushRequest& from);
  FlushRequest(FlushRequest&& from) noexcept
    : FlushRequest() {
    *this = ::std::move(from);
  }

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushRequest& operator=(FlushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushRequest* internal_default_instance() {
    return reinterpret_cast<const FlushRequest*>(
               &_FlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(FlushRequest& a, FlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushRequest& from) {
    FlushRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.FlushRequest";
  }
  protected:
  explicit FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.FlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class Regular final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:greptime.v1.region.Regular) */ {
 public:
  inline Regular() : Regular(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Regular(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Regular(const Regular& from);
  Regular(Regular&& from) noexcept
    : Regular() {
    *this = ::std::move(from);
  }

  inline Regular& operator=(const Regular& from) {
    CopyFrom(from);
    return *this;
  }
  inline Regular& operator=(Regular&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Regular& default_instance() {
    return *internal_default_instance();
  }
  static inline const Regular* internal_default_instance() {
    return reinterpret_cast<const Regular*>(
               &_Regular_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Regular& a, Regular& b) {
    a.Swap(&b);
  }
  inline void Swap(Regular* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Regular* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Regular* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Regular>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Regular& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Regular& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.Regular";
  }
  protected:
  explicit Regular(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:greptime.v1.region.Regular)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class StrictWindow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.StrictWindow) */ {
 public:
  inline StrictWindow() : StrictWindow(nullptr) {}
  ~StrictWindow() override;
  explicit PROTOBUF_CONSTEXPR StrictWindow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrictWindow(const StrictWindow& from);
  StrictWindow(StrictWindow&& from) noexcept
    : StrictWindow() {
    *this = ::std::move(from);
  }

  inline StrictWindow& operator=(const StrictWindow& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrictWindow& operator=(StrictWindow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrictWindow& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrictWindow* internal_default_instance() {
    return reinterpret_cast<const StrictWindow*>(
               &_StrictWindow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StrictWindow& a, StrictWindow& b) {
    a.Swap(&b);
  }
  inline void Swap(StrictWindow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrictWindow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrictWindow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrictWindow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrictWindow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrictWindow& from) {
    StrictWindow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrictWindow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.StrictWindow";
  }
  protected:
  explicit StrictWindow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowSecondsFieldNumber = 1,
  };
  // int64 window_seconds = 1;
  void clear_window_seconds();
  int64_t window_seconds() const;
  void set_window_seconds(int64_t value);
  private:
  int64_t _internal_window_seconds() const;
  void _internal_set_window_seconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.StrictWindow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t window_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CompactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CompactRequest) */ {
 public:
  inline CompactRequest() : CompactRequest(nullptr) {}
  ~CompactRequest() override;
  explicit PROTOBUF_CONSTEXPR CompactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactRequest(const CompactRequest& from);
  CompactRequest(CompactRequest&& from) noexcept
    : CompactRequest() {
    *this = ::std::move(from);
  }

  inline CompactRequest& operator=(const CompactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactRequest& operator=(CompactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OptionsCase {
    kRegular = 2,
    kStrictWindow = 3,
    OPTIONS_NOT_SET = 0,
  };

  static inline const CompactRequest* internal_default_instance() {
    return reinterpret_cast<const CompactRequest*>(
               &_CompactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CompactRequest& a, CompactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompactRequest& from) {
    CompactRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CompactRequest";
  }
  protected:
  explicit CompactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kRegularFieldNumber = 2,
    kStrictWindowFieldNumber = 3,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // .greptime.v1.region.Regular regular = 2;
  bool has_regular() const;
  private:
  bool _internal_has_regular() const;
  public:
  void clear_regular();
  const ::greptime::v1::region::Regular& regular() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::Regular* release_regular();
  ::greptime::v1::region::Regular* mutable_regular();
  void set_allocated_regular(::greptime::v1::region::Regular* regular);
  private:
  const ::greptime::v1::region::Regular& _internal_regular() const;
  ::greptime::v1::region::Regular* _internal_mutable_regular();
  public:
  void unsafe_arena_set_allocated_regular(
      ::greptime::v1::region::Regular* regular);
  ::greptime::v1::region::Regular* unsafe_arena_release_regular();

  // .greptime.v1.region.StrictWindow strict_window = 3;
  bool has_strict_window() const;
  private:
  bool _internal_has_strict_window() const;
  public:
  void clear_strict_window();
  const ::greptime::v1::region::StrictWindow& strict_window() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::StrictWindow* release_strict_window();
  ::greptime::v1::region::StrictWindow* mutable_strict_window();
  void set_allocated_strict_window(::greptime::v1::region::StrictWindow* strict_window);
  private:
  const ::greptime::v1::region::StrictWindow& _internal_strict_window() const;
  ::greptime::v1::region::StrictWindow* _internal_mutable_strict_window();
  public:
  void unsafe_arena_set_allocated_strict_window(
      ::greptime::v1::region::StrictWindow* strict_window);
  ::greptime::v1::region::StrictWindow* unsafe_arena_release_strict_window();

  void clear_options();
  OptionsCase options_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.region.CompactRequest)
 private:
  class _Internal;
  void set_has_regular();
  void set_has_strict_window();

  inline bool has_options() const;
  inline void clear_has_options();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    union OptionsUnion {
      constexpr OptionsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::region::Regular* regular_;
      ::greptime::v1::region::StrictWindow* strict_window_;
    } options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class TruncateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.TruncateRequest) */ {
 public:
  inline TruncateRequest() : TruncateRequest(nullptr) {}
  ~TruncateRequest() override;
  explicit PROTOBUF_CONSTEXPR TruncateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateRequest(const TruncateRequest& from);
  TruncateRequest(TruncateRequest&& from) noexcept
    : TruncateRequest() {
    *this = ::std::move(from);
  }

  inline TruncateRequest& operator=(const TruncateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateRequest& operator=(TruncateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TruncateRequest* internal_default_instance() {
    return reinterpret_cast<const TruncateRequest*>(
               &_TruncateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TruncateRequest& a, TruncateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TruncateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TruncateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TruncateRequest& from) {
    TruncateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.TruncateRequest";
  }
  protected:
  explicit TruncateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.TruncateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RegionColumnDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionColumnDef) */ {
 public:
  inline RegionColumnDef() : RegionColumnDef(nullptr) {}
  ~RegionColumnDef() override;
  explicit PROTOBUF_CONSTEXPR RegionColumnDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionColumnDef(const RegionColumnDef& from);
  RegionColumnDef(RegionColumnDef&& from) noexcept
    : RegionColumnDef() {
    *this = ::std::move(from);
  }

  inline RegionColumnDef& operator=(const RegionColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionColumnDef& operator=(RegionColumnDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionColumnDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionColumnDef* internal_default_instance() {
    return reinterpret_cast<const RegionColumnDef*>(
               &_RegionColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RegionColumnDef& a, RegionColumnDef& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionColumnDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionColumnDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionColumnDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionColumnDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionColumnDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionColumnDef& from) {
    RegionColumnDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionColumnDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionColumnDef";
  }
  protected:
  explicit RegionColumnDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefFieldNumber = 1,
    kColumnIdFieldNumber = 2,
  };
  // .greptime.v1.ColumnDef column_def = 1;
  bool has_column_def() const;
  private:
  bool _internal_has_column_def() const;
  public:
  void clear_column_def();
  const ::greptime::v1::ColumnDef& column_def() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDef* release_column_def();
  ::greptime::v1::ColumnDef* mutable_column_def();
  void set_allocated_column_def(::greptime::v1::ColumnDef* column_def);
  private:
  const ::greptime::v1::ColumnDef& _internal_column_def() const;
  ::greptime::v1::ColumnDef* _internal_mutable_column_def();
  public:
  void unsafe_arena_set_allocated_column_def(
      ::greptime::v1::ColumnDef* column_def);
  ::greptime::v1::ColumnDef* unsafe_arena_release_column_def();

  // uint32 column_id = 2;
  void clear_column_id();
  uint32_t column_id() const;
  void set_column_id(uint32_t value);
  private:
  uint32_t _internal_column_id() const;
  void _internal_set_column_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionColumnDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::ColumnDef* column_def_;
    uint32_t column_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RegionRequestHeader

// map<string, string> tracing_context = 5;
inline int RegionRequestHeader::_internal_tracing_context_size() const {
  return _impl_.tracing_context_.size();
}
inline int RegionRequestHeader::tracing_context_size() const {
  return _internal_tracing_context_size();
}
inline void RegionRequestHeader::clear_tracing_context() {
  _impl_.tracing_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionRequestHeader::_internal_tracing_context() const {
  return _impl_.tracing_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionRequestHeader::tracing_context() const {
  // @@protoc_insertion_point(field_map:greptime.v1.region.RegionRequestHeader.tracing_context)
  return _internal_tracing_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionRequestHeader::_internal_mutable_tracing_context() {
  return _impl_.tracing_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionRequestHeader::mutable_tracing_context() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.region.RegionRequestHeader.tracing_context)
  return _internal_mutable_tracing_context();
}

// string dbname = 3;
inline void RegionRequestHeader::clear_dbname() {
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& RegionRequestHeader::dbname() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequestHeader.dbname)
  return _internal_dbname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionRequestHeader::set_dbname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dbname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.RegionRequestHeader.dbname)
}
inline std::string* RegionRequestHeader::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequestHeader.dbname)
  return _s;
}
inline const std::string& RegionRequestHeader::_internal_dbname() const {
  return _impl_.dbname_.Get();
}
inline void RegionRequestHeader::_internal_set_dbname(const std::string& value) {
  
  _impl_.dbname_.Set(value, GetArenaForAllocation());
}
inline std::string* RegionRequestHeader::_internal_mutable_dbname() {
  
  return _impl_.dbname_.Mutable(GetArenaForAllocation());
}
inline std::string* RegionRequestHeader::release_dbname() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequestHeader.dbname)
  return _impl_.dbname_.Release();
}
inline void RegionRequestHeader::set_allocated_dbname(std::string* dbname) {
  if (dbname != nullptr) {
    
  } else {
    
  }
  _impl_.dbname_.SetAllocated(dbname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dbname_.IsDefault()) {
    _impl_.dbname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionRequestHeader.dbname)
}

// .greptime.v1.QueryContext query_context = 6;
inline bool RegionRequestHeader::_internal_has_query_context() const {
  return this != internal_default_instance() && _impl_.query_context_ != nullptr;
}
inline bool RegionRequestHeader::has_query_context() const {
  return _internal_has_query_context();
}
inline const ::greptime::v1::QueryContext& RegionRequestHeader::_internal_query_context() const {
  const ::greptime::v1::QueryContext* p = _impl_.query_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::QueryContext&>(
      ::greptime::v1::_QueryContext_default_instance_);
}
inline const ::greptime::v1::QueryContext& RegionRequestHeader::query_context() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequestHeader.query_context)
  return _internal_query_context();
}
inline void RegionRequestHeader::unsafe_arena_set_allocated_query_context(
    ::greptime::v1::QueryContext* query_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_context_);
  }
  _impl_.query_context_ = query_context;
  if (query_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequestHeader.query_context)
}
inline ::greptime::v1::QueryContext* RegionRequestHeader::release_query_context() {
  
  ::greptime::v1::QueryContext* temp = _impl_.query_context_;
  _impl_.query_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::QueryContext* RegionRequestHeader::unsafe_arena_release_query_context() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequestHeader.query_context)
  
  ::greptime::v1::QueryContext* temp = _impl_.query_context_;
  _impl_.query_context_ = nullptr;
  return temp;
}
inline ::greptime::v1::QueryContext* RegionRequestHeader::_internal_mutable_query_context() {
  
  if (_impl_.query_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::QueryContext>(GetArenaForAllocation());
    _impl_.query_context_ = p;
  }
  return _impl_.query_context_;
}
inline ::greptime::v1::QueryContext* RegionRequestHeader::mutable_query_context() {
  ::greptime::v1::QueryContext* _msg = _internal_mutable_query_context();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequestHeader.query_context)
  return _msg;
}
inline void RegionRequestHeader::set_allocated_query_context(::greptime::v1::QueryContext* query_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_context_);
  }
  if (query_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_context));
    if (message_arena != submessage_arena) {
      query_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_context_ = query_context;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionRequestHeader.query_context)
}

// -------------------------------------------------------------------

// RegionRequest

// .greptime.v1.region.RegionRequestHeader header = 1;
inline bool RegionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegionRequest::has_header() const {
  return _internal_has_header();
}
inline void RegionRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::greptime::v1::region::RegionRequestHeader& RegionRequest::_internal_header() const {
  const ::greptime::v1::region::RegionRequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::region::RegionRequestHeader&>(
      ::greptime::v1::region::_RegionRequestHeader_default_instance_);
}
inline const ::greptime::v1::region::RegionRequestHeader& RegionRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.header)
  return _internal_header();
}
inline void RegionRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::region::RegionRequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.header)
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::release_header() {
  
  ::greptime::v1::region::RegionRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.header)
  
  ::greptime::v1::region::RegionRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::region::RegionRequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::mutable_header() {
  ::greptime::v1::region::RegionRequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.header)
  return _msg;
}
inline void RegionRequest::set_allocated_header(::greptime::v1::region::RegionRequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionRequest.header)
}

// .greptime.v1.region.InsertRequests inserts = 3;
inline bool RegionRequest::_internal_has_inserts() const {
  return body_case() == kInserts;
}
inline bool RegionRequest::has_inserts() const {
  return _internal_has_inserts();
}
inline void RegionRequest::set_has_inserts() {
  _impl_._oneof_case_[0] = kInserts;
}
inline void RegionRequest::clear_inserts() {
  if (_internal_has_inserts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.inserts_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::release_inserts() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.inserts)
  if (_internal_has_inserts()) {
    clear_has_body();
    ::greptime::v1::region::InsertRequests* temp = _impl_.body_.inserts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.inserts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::InsertRequests& RegionRequest::_internal_inserts() const {
  return _internal_has_inserts()
      ? *_impl_.body_.inserts_
      : reinterpret_cast< ::greptime::v1::region::InsertRequests&>(::greptime::v1::region::_InsertRequests_default_instance_);
}
inline const ::greptime::v1::region::InsertRequests& RegionRequest::inserts() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.inserts)
  return _internal_inserts();
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::unsafe_arena_release_inserts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.inserts)
  if (_internal_has_inserts()) {
    clear_has_body();
    ::greptime::v1::region::InsertRequests* temp = _impl_.body_.inserts_;
    _impl_.body_.inserts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_inserts(::greptime::v1::region::InsertRequests* inserts) {
  clear_body();
  if (inserts) {
    set_has_inserts();
    _impl_.body_.inserts_ = inserts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.inserts)
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::_internal_mutable_inserts() {
  if (!_internal_has_inserts()) {
    clear_body();
    set_has_inserts();
    _impl_.body_.inserts_ = CreateMaybeMessage< ::greptime::v1::region::InsertRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.inserts_;
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::mutable_inserts() {
  ::greptime::v1::region::InsertRequests* _msg = _internal_mutable_inserts();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.inserts)
  return _msg;
}

// .greptime.v1.region.DeleteRequests deletes = 4;
inline bool RegionRequest::_internal_has_deletes() const {
  return body_case() == kDeletes;
}
inline bool RegionRequest::has_deletes() const {
  return _internal_has_deletes();
}
inline void RegionRequest::set_has_deletes() {
  _impl_._oneof_case_[0] = kDeletes;
}
inline void RegionRequest::clear_deletes() {
  if (_internal_has_deletes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.deletes_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::release_deletes() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.deletes)
  if (_internal_has_deletes()) {
    clear_has_body();
    ::greptime::v1::region::DeleteRequests* temp = _impl_.body_.deletes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.deletes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DeleteRequests& RegionRequest::_internal_deletes() const {
  return _internal_has_deletes()
      ? *_impl_.body_.deletes_
      : reinterpret_cast< ::greptime::v1::region::DeleteRequests&>(::greptime::v1::region::_DeleteRequests_default_instance_);
}
inline const ::greptime::v1::region::DeleteRequests& RegionRequest::deletes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.deletes)
  return _internal_deletes();
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::unsafe_arena_release_deletes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.deletes)
  if (_internal_has_deletes()) {
    clear_has_body();
    ::greptime::v1::region::DeleteRequests* temp = _impl_.body_.deletes_;
    _impl_.body_.deletes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_deletes(::greptime::v1::region::DeleteRequests* deletes) {
  clear_body();
  if (deletes) {
    set_has_deletes();
    _impl_.body_.deletes_ = deletes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.deletes)
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::_internal_mutable_deletes() {
  if (!_internal_has_deletes()) {
    clear_body();
    set_has_deletes();
    _impl_.body_.deletes_ = CreateMaybeMessage< ::greptime::v1::region::DeleteRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.deletes_;
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::mutable_deletes() {
  ::greptime::v1::region::DeleteRequests* _msg = _internal_mutable_deletes();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.deletes)
  return _msg;
}

// .greptime.v1.region.CreateRequest create = 5;
inline bool RegionRequest::_internal_has_create() const {
  return body_case() == kCreate;
}
inline bool RegionRequest::has_create() const {
  return _internal_has_create();
}
inline void RegionRequest::set_has_create() {
  _impl_._oneof_case_[0] = kCreate;
}
inline void RegionRequest::clear_create() {
  if (_internal_has_create()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.create_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::release_create() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::region::CreateRequest* temp = _impl_.body_.create_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CreateRequest& RegionRequest::_internal_create() const {
  return _internal_has_create()
      ? *_impl_.body_.create_
      : reinterpret_cast< ::greptime::v1::region::CreateRequest&>(::greptime::v1::region::_CreateRequest_default_instance_);
}
inline const ::greptime::v1::region::CreateRequest& RegionRequest::create() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.create)
  return _internal_create();
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::unsafe_arena_release_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::region::CreateRequest* temp = _impl_.body_.create_;
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_create(::greptime::v1::region::CreateRequest* create) {
  clear_body();
  if (create) {
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.create)
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::_internal_mutable_create() {
  if (!_internal_has_create()) {
    clear_body();
    set_has_create();
    _impl_.body_.create_ = CreateMaybeMessage< ::greptime::v1::region::CreateRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.create_;
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::mutable_create() {
  ::greptime::v1::region::CreateRequest* _msg = _internal_mutable_create();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.create)
  return _msg;
}

// .greptime.v1.region.DropRequest drop = 6;
inline bool RegionRequest::_internal_has_drop() const {
  return body_case() == kDrop;
}
inline bool RegionRequest::has_drop() const {
  return _internal_has_drop();
}
inline void RegionRequest::set_has_drop() {
  _impl_._oneof_case_[0] = kDrop;
}
inline void RegionRequest::clear_drop() {
  if (_internal_has_drop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.drop_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::DropRequest* RegionRequest::release_drop() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.drop)
  if (_internal_has_drop()) {
    clear_has_body();
    ::greptime::v1::region::DropRequest* temp = _impl_.body_.drop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DropRequest& RegionRequest::_internal_drop() const {
  return _internal_has_drop()
      ? *_impl_.body_.drop_
      : reinterpret_cast< ::greptime::v1::region::DropRequest&>(::greptime::v1::region::_DropRequest_default_instance_);
}
inline const ::greptime::v1::region::DropRequest& RegionRequest::drop() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.drop)
  return _internal_drop();
}
inline ::greptime::v1::region::DropRequest* RegionRequest::unsafe_arena_release_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.drop)
  if (_internal_has_drop()) {
    clear_has_body();
    ::greptime::v1::region::DropRequest* temp = _impl_.body_.drop_;
    _impl_.body_.drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_drop(::greptime::v1::region::DropRequest* drop) {
  clear_body();
  if (drop) {
    set_has_drop();
    _impl_.body_.drop_ = drop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.drop)
}
inline ::greptime::v1::region::DropRequest* RegionRequest::_internal_mutable_drop() {
  if (!_internal_has_drop()) {
    clear_body();
    set_has_drop();
    _impl_.body_.drop_ = CreateMaybeMessage< ::greptime::v1::region::DropRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.drop_;
}
inline ::greptime::v1::region::DropRequest* RegionRequest::mutable_drop() {
  ::greptime::v1::region::DropRequest* _msg = _internal_mutable_drop();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.drop)
  return _msg;
}

// .greptime.v1.region.OpenRequest open = 7;
inline bool RegionRequest::_internal_has_open() const {
  return body_case() == kOpen;
}
inline bool RegionRequest::has_open() const {
  return _internal_has_open();
}
inline void RegionRequest::set_has_open() {
  _impl_._oneof_case_[0] = kOpen;
}
inline void RegionRequest::clear_open() {
  if (_internal_has_open()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.open_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::release_open() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.open)
  if (_internal_has_open()) {
    clear_has_body();
    ::greptime::v1::region::OpenRequest* temp = _impl_.body_.open_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::OpenRequest& RegionRequest::_internal_open() const {
  return _internal_has_open()
      ? *_impl_.body_.open_
      : reinterpret_cast< ::greptime::v1::region::OpenRequest&>(::greptime::v1::region::_OpenRequest_default_instance_);
}
inline const ::greptime::v1::region::OpenRequest& RegionRequest::open() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.open)
  return _internal_open();
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::unsafe_arena_release_open() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.open)
  if (_internal_has_open()) {
    clear_has_body();
    ::greptime::v1::region::OpenRequest* temp = _impl_.body_.open_;
    _impl_.body_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_open(::greptime::v1::region::OpenRequest* open) {
  clear_body();
  if (open) {
    set_has_open();
    _impl_.body_.open_ = open;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.open)
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::_internal_mutable_open() {
  if (!_internal_has_open()) {
    clear_body();
    set_has_open();
    _impl_.body_.open_ = CreateMaybeMessage< ::greptime::v1::region::OpenRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.open_;
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::mutable_open() {
  ::greptime::v1::region::OpenRequest* _msg = _internal_mutable_open();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.open)
  return _msg;
}

// .greptime.v1.region.CloseRequest close = 8;
inline bool RegionRequest::_internal_has_close() const {
  return body_case() == kClose;
}
inline bool RegionRequest::has_close() const {
  return _internal_has_close();
}
inline void RegionRequest::set_has_close() {
  _impl_._oneof_case_[0] = kClose;
}
inline void RegionRequest::clear_close() {
  if (_internal_has_close()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.close_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::release_close() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.close)
  if (_internal_has_close()) {
    clear_has_body();
    ::greptime::v1::region::CloseRequest* temp = _impl_.body_.close_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CloseRequest& RegionRequest::_internal_close() const {
  return _internal_has_close()
      ? *_impl_.body_.close_
      : reinterpret_cast< ::greptime::v1::region::CloseRequest&>(::greptime::v1::region::_CloseRequest_default_instance_);
}
inline const ::greptime::v1::region::CloseRequest& RegionRequest::close() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.close)
  return _internal_close();
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.close)
  if (_internal_has_close()) {
    clear_has_body();
    ::greptime::v1::region::CloseRequest* temp = _impl_.body_.close_;
    _impl_.body_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_close(::greptime::v1::region::CloseRequest* close) {
  clear_body();
  if (close) {
    set_has_close();
    _impl_.body_.close_ = close;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.close)
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::_internal_mutable_close() {
  if (!_internal_has_close()) {
    clear_body();
    set_has_close();
    _impl_.body_.close_ = CreateMaybeMessage< ::greptime::v1::region::CloseRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.close_;
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::mutable_close() {
  ::greptime::v1::region::CloseRequest* _msg = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.close)
  return _msg;
}

// .greptime.v1.region.AlterRequest alter = 9;
inline bool RegionRequest::_internal_has_alter() const {
  return body_case() == kAlter;
}
inline bool RegionRequest::has_alter() const {
  return _internal_has_alter();
}
inline void RegionRequest::set_has_alter() {
  _impl_._oneof_case_[0] = kAlter;
}
inline void RegionRequest::clear_alter() {
  if (_internal_has_alter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.alter_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::release_alter() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.alter)
  if (_internal_has_alter()) {
    clear_has_body();
    ::greptime::v1::region::AlterRequest* temp = _impl_.body_.alter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::AlterRequest& RegionRequest::_internal_alter() const {
  return _internal_has_alter()
      ? *_impl_.body_.alter_
      : reinterpret_cast< ::greptime::v1::region::AlterRequest&>(::greptime::v1::region::_AlterRequest_default_instance_);
}
inline const ::greptime::v1::region::AlterRequest& RegionRequest::alter() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.alter)
  return _internal_alter();
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::unsafe_arena_release_alter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.alter)
  if (_internal_has_alter()) {
    clear_has_body();
    ::greptime::v1::region::AlterRequest* temp = _impl_.body_.alter_;
    _impl_.body_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_alter(::greptime::v1::region::AlterRequest* alter) {
  clear_body();
  if (alter) {
    set_has_alter();
    _impl_.body_.alter_ = alter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.alter)
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::_internal_mutable_alter() {
  if (!_internal_has_alter()) {
    clear_body();
    set_has_alter();
    _impl_.body_.alter_ = CreateMaybeMessage< ::greptime::v1::region::AlterRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.alter_;
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::mutable_alter() {
  ::greptime::v1::region::AlterRequest* _msg = _internal_mutable_alter();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.alter)
  return _msg;
}

// .greptime.v1.region.FlushRequest flush = 10;
inline bool RegionRequest::_internal_has_flush() const {
  return body_case() == kFlush;
}
inline bool RegionRequest::has_flush() const {
  return _internal_has_flush();
}
inline void RegionRequest::set_has_flush() {
  _impl_._oneof_case_[0] = kFlush;
}
inline void RegionRequest::clear_flush() {
  if (_internal_has_flush()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.flush_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::release_flush() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.flush)
  if (_internal_has_flush()) {
    clear_has_body();
    ::greptime::v1::region::FlushRequest* temp = _impl_.body_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::FlushRequest& RegionRequest::_internal_flush() const {
  return _internal_has_flush()
      ? *_impl_.body_.flush_
      : reinterpret_cast< ::greptime::v1::region::FlushRequest&>(::greptime::v1::region::_FlushRequest_default_instance_);
}
inline const ::greptime::v1::region::FlushRequest& RegionRequest::flush() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.flush)
  return _internal_flush();
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.flush)
  if (_internal_has_flush()) {
    clear_has_body();
    ::greptime::v1::region::FlushRequest* temp = _impl_.body_.flush_;
    _impl_.body_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_flush(::greptime::v1::region::FlushRequest* flush) {
  clear_body();
  if (flush) {
    set_has_flush();
    _impl_.body_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.flush)
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::_internal_mutable_flush() {
  if (!_internal_has_flush()) {
    clear_body();
    set_has_flush();
    _impl_.body_.flush_ = CreateMaybeMessage< ::greptime::v1::region::FlushRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.flush_;
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::mutable_flush() {
  ::greptime::v1::region::FlushRequest* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.flush)
  return _msg;
}

// .greptime.v1.region.CompactRequest compact = 11;
inline bool RegionRequest::_internal_has_compact() const {
  return body_case() == kCompact;
}
inline bool RegionRequest::has_compact() const {
  return _internal_has_compact();
}
inline void RegionRequest::set_has_compact() {
  _impl_._oneof_case_[0] = kCompact;
}
inline void RegionRequest::clear_compact() {
  if (_internal_has_compact()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.compact_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::release_compact() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.compact)
  if (_internal_has_compact()) {
    clear_has_body();
    ::greptime::v1::region::CompactRequest* temp = _impl_.body_.compact_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.compact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CompactRequest& RegionRequest::_internal_compact() const {
  return _internal_has_compact()
      ? *_impl_.body_.compact_
      : reinterpret_cast< ::greptime::v1::region::CompactRequest&>(::greptime::v1::region::_CompactRequest_default_instance_);
}
inline const ::greptime::v1::region::CompactRequest& RegionRequest::compact() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.compact)
  return _internal_compact();
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::unsafe_arena_release_compact() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.compact)
  if (_internal_has_compact()) {
    clear_has_body();
    ::greptime::v1::region::CompactRequest* temp = _impl_.body_.compact_;
    _impl_.body_.compact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_compact(::greptime::v1::region::CompactRequest* compact) {
  clear_body();
  if (compact) {
    set_has_compact();
    _impl_.body_.compact_ = compact;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.compact)
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::_internal_mutable_compact() {
  if (!_internal_has_compact()) {
    clear_body();
    set_has_compact();
    _impl_.body_.compact_ = CreateMaybeMessage< ::greptime::v1::region::CompactRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.compact_;
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::mutable_compact() {
  ::greptime::v1::region::CompactRequest* _msg = _internal_mutable_compact();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.compact)
  return _msg;
}

// .greptime.v1.region.TruncateRequest truncate = 12;
inline bool RegionRequest::_internal_has_truncate() const {
  return body_case() == kTruncate;
}
inline bool RegionRequest::has_truncate() const {
  return _internal_has_truncate();
}
inline void RegionRequest::set_has_truncate() {
  _impl_._oneof_case_[0] = kTruncate;
}
inline void RegionRequest::clear_truncate() {
  if (_internal_has_truncate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.truncate_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::TruncateRequest* RegionRequest::release_truncate() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.truncate)
  if (_internal_has_truncate()) {
    clear_has_body();
    ::greptime::v1::region::TruncateRequest* temp = _impl_.body_.truncate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.truncate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::TruncateRequest& RegionRequest::_internal_truncate() const {
  return _internal_has_truncate()
      ? *_impl_.body_.truncate_
      : reinterpret_cast< ::greptime::v1::region::TruncateRequest&>(::greptime::v1::region::_TruncateRequest_default_instance_);
}
inline const ::greptime::v1::region::TruncateRequest& RegionRequest::truncate() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.truncate)
  return _internal_truncate();
}
inline ::greptime::v1::region::TruncateRequest* RegionRequest::unsafe_arena_release_truncate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.truncate)
  if (_internal_has_truncate()) {
    clear_has_body();
    ::greptime::v1::region::TruncateRequest* temp = _impl_.body_.truncate_;
    _impl_.body_.truncate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_truncate(::greptime::v1::region::TruncateRequest* truncate) {
  clear_body();
  if (truncate) {
    set_has_truncate();
    _impl_.body_.truncate_ = truncate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.truncate)
}
inline ::greptime::v1::region::TruncateRequest* RegionRequest::_internal_mutable_truncate() {
  if (!_internal_has_truncate()) {
    clear_body();
    set_has_truncate();
    _impl_.body_.truncate_ = CreateMaybeMessage< ::greptime::v1::region::TruncateRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.truncate_;
}
inline ::greptime::v1::region::TruncateRequest* RegionRequest::mutable_truncate() {
  ::greptime::v1::region::TruncateRequest* _msg = _internal_mutable_truncate();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.truncate)
  return _msg;
}

// .greptime.v1.region.CreateRequests creates = 13;
inline bool RegionRequest::_internal_has_creates() const {
  return body_case() == kCreates;
}
inline bool RegionRequest::has_creates() const {
  return _internal_has_creates();
}
inline void RegionRequest::set_has_creates() {
  _impl_._oneof_case_[0] = kCreates;
}
inline void RegionRequest::clear_creates() {
  if (_internal_has_creates()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.creates_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CreateRequests* RegionRequest::release_creates() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.creates)
  if (_internal_has_creates()) {
    clear_has_body();
    ::greptime::v1::region::CreateRequests* temp = _impl_.body_.creates_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.creates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CreateRequests& RegionRequest::_internal_creates() const {
  return _internal_has_creates()
      ? *_impl_.body_.creates_
      : reinterpret_cast< ::greptime::v1::region::CreateRequests&>(::greptime::v1::region::_CreateRequests_default_instance_);
}
inline const ::greptime::v1::region::CreateRequests& RegionRequest::creates() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.creates)
  return _internal_creates();
}
inline ::greptime::v1::region::CreateRequests* RegionRequest::unsafe_arena_release_creates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.creates)
  if (_internal_has_creates()) {
    clear_has_body();
    ::greptime::v1::region::CreateRequests* temp = _impl_.body_.creates_;
    _impl_.body_.creates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_creates(::greptime::v1::region::CreateRequests* creates) {
  clear_body();
  if (creates) {
    set_has_creates();
    _impl_.body_.creates_ = creates;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.creates)
}
inline ::greptime::v1::region::CreateRequests* RegionRequest::_internal_mutable_creates() {
  if (!_internal_has_creates()) {
    clear_body();
    set_has_creates();
    _impl_.body_.creates_ = CreateMaybeMessage< ::greptime::v1::region::CreateRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.creates_;
}
inline ::greptime::v1::region::CreateRequests* RegionRequest::mutable_creates() {
  ::greptime::v1::region::CreateRequests* _msg = _internal_mutable_creates();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.creates)
  return _msg;
}

// .greptime.v1.region.DropRequests drops = 14;
inline bool RegionRequest::_internal_has_drops() const {
  return body_case() == kDrops;
}
inline bool RegionRequest::has_drops() const {
  return _internal_has_drops();
}
inline void RegionRequest::set_has_drops() {
  _impl_._oneof_case_[0] = kDrops;
}
inline void RegionRequest::clear_drops() {
  if (_internal_has_drops()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.drops_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::DropRequests* RegionRequest::release_drops() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.drops)
  if (_internal_has_drops()) {
    clear_has_body();
    ::greptime::v1::region::DropRequests* temp = _impl_.body_.drops_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.drops_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DropRequests& RegionRequest::_internal_drops() const {
  return _internal_has_drops()
      ? *_impl_.body_.drops_
      : reinterpret_cast< ::greptime::v1::region::DropRequests&>(::greptime::v1::region::_DropRequests_default_instance_);
}
inline const ::greptime::v1::region::DropRequests& RegionRequest::drops() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.drops)
  return _internal_drops();
}
inline ::greptime::v1::region::DropRequests* RegionRequest::unsafe_arena_release_drops() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.drops)
  if (_internal_has_drops()) {
    clear_has_body();
    ::greptime::v1::region::DropRequests* temp = _impl_.body_.drops_;
    _impl_.body_.drops_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_drops(::greptime::v1::region::DropRequests* drops) {
  clear_body();
  if (drops) {
    set_has_drops();
    _impl_.body_.drops_ = drops;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.drops)
}
inline ::greptime::v1::region::DropRequests* RegionRequest::_internal_mutable_drops() {
  if (!_internal_has_drops()) {
    clear_body();
    set_has_drops();
    _impl_.body_.drops_ = CreateMaybeMessage< ::greptime::v1::region::DropRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.drops_;
}
inline ::greptime::v1::region::DropRequests* RegionRequest::mutable_drops() {
  ::greptime::v1::region::DropRequests* _msg = _internal_mutable_drops();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.drops)
  return _msg;
}

// .greptime.v1.region.AlterRequests alters = 15;
inline bool RegionRequest::_internal_has_alters() const {
  return body_case() == kAlters;
}
inline bool RegionRequest::has_alters() const {
  return _internal_has_alters();
}
inline void RegionRequest::set_has_alters() {
  _impl_._oneof_case_[0] = kAlters;
}
inline void RegionRequest::clear_alters() {
  if (_internal_has_alters()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.alters_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::AlterRequests* RegionRequest::release_alters() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.alters)
  if (_internal_has_alters()) {
    clear_has_body();
    ::greptime::v1::region::AlterRequests* temp = _impl_.body_.alters_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.alters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::AlterRequests& RegionRequest::_internal_alters() const {
  return _internal_has_alters()
      ? *_impl_.body_.alters_
      : reinterpret_cast< ::greptime::v1::region::AlterRequests&>(::greptime::v1::region::_AlterRequests_default_instance_);
}
inline const ::greptime::v1::region::AlterRequests& RegionRequest::alters() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.alters)
  return _internal_alters();
}
inline ::greptime::v1::region::AlterRequests* RegionRequest::unsafe_arena_release_alters() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.alters)
  if (_internal_has_alters()) {
    clear_has_body();
    ::greptime::v1::region::AlterRequests* temp = _impl_.body_.alters_;
    _impl_.body_.alters_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_alters(::greptime::v1::region::AlterRequests* alters) {
  clear_body();
  if (alters) {
    set_has_alters();
    _impl_.body_.alters_ = alters;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.alters)
}
inline ::greptime::v1::region::AlterRequests* RegionRequest::_internal_mutable_alters() {
  if (!_internal_has_alters()) {
    clear_body();
    set_has_alters();
    _impl_.body_.alters_ = CreateMaybeMessage< ::greptime::v1::region::AlterRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.alters_;
}
inline ::greptime::v1::region::AlterRequests* RegionRequest::mutable_alters() {
  ::greptime::v1::region::AlterRequests* _msg = _internal_mutable_alters();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.alters)
  return _msg;
}

inline bool RegionRequest::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void RegionRequest::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline RegionRequest::BodyCase RegionRequest::body_case() const {
  return RegionRequest::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RegionResponse

// .greptime.v1.ResponseHeader header = 1;
inline bool RegionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::ResponseHeader& RegionResponse::_internal_header() const {
  const ::greptime::v1::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ResponseHeader&>(
      ::greptime::v1::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::ResponseHeader& RegionResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionResponse.header)
  return _internal_header();
}
inline void RegionResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionResponse.header)
}
inline ::greptime::v1::ResponseHeader* RegionResponse::release_header() {
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ResponseHeader* RegionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionResponse.header)
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::ResponseHeader* RegionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::ResponseHeader* RegionResponse::mutable_header() {
  ::greptime::v1::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionResponse.header)
  return _msg;
}
inline void RegionResponse::set_allocated_header(::greptime::v1::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionResponse.header)
}

// uint64 affected_rows = 2;
inline void RegionResponse::clear_affected_rows() {
  _impl_.affected_rows_ = uint64_t{0u};
}
inline uint64_t RegionResponse::_internal_affected_rows() const {
  return _impl_.affected_rows_;
}
inline uint64_t RegionResponse::affected_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionResponse.affected_rows)
  return _internal_affected_rows();
}
inline void RegionResponse::_internal_set_affected_rows(uint64_t value) {
  
  _impl_.affected_rows_ = value;
}
inline void RegionResponse::set_affected_rows(uint64_t value) {
  _internal_set_affected_rows(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.RegionResponse.affected_rows)
}

// map<string, bytes> extensions = 3;
inline int RegionResponse::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int RegionResponse::extensions_size() const {
  return _internal_extensions_size();
}
inline void RegionResponse::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionResponse::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegionResponse::extensions() const {
  // @@protoc_insertion_point(field_map:greptime.v1.region.RegionResponse.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionResponse::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegionResponse::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.region.RegionResponse.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// InsertRequests

// repeated .greptime.v1.region.InsertRequest requests = 1;
inline int InsertRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int InsertRequests::requests_size() const {
  return _internal_requests_size();
}
inline void InsertRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::InsertRequest* InsertRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.InsertRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >*
InsertRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.InsertRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::InsertRequest& InsertRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::InsertRequest& InsertRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.InsertRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::InsertRequest* InsertRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::InsertRequest* InsertRequests::add_requests() {
  ::greptime::v1::region::InsertRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.InsertRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >&
InsertRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.InsertRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// DeleteRequests

// repeated .greptime.v1.region.DeleteRequest requests = 1;
inline int DeleteRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int DeleteRequests::requests_size() const {
  return _internal_requests_size();
}
inline void DeleteRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::DeleteRequest* DeleteRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DeleteRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >*
DeleteRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.DeleteRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::DeleteRequest& DeleteRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::DeleteRequest& DeleteRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DeleteRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::DeleteRequest* DeleteRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::DeleteRequest* DeleteRequests::add_requests() {
  ::greptime::v1::region::DeleteRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.DeleteRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >&
DeleteRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.DeleteRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// InsertRequest

// uint64 region_id = 1;
inline void InsertRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t InsertRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t InsertRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.InsertRequest.region_id)
  return _internal_region_id();
}
inline void InsertRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void InsertRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.InsertRequest.region_id)
}

// .greptime.v1.Rows rows = 2;
inline bool InsertRequest::_internal_has_rows() const {
  return this != internal_default_instance() && _impl_.rows_ != nullptr;
}
inline bool InsertRequest::has_rows() const {
  return _internal_has_rows();
}
inline const ::greptime::v1::Rows& InsertRequest::_internal_rows() const {
  const ::greptime::v1::Rows* p = _impl_.rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Rows&>(
      ::greptime::v1::_Rows_default_instance_);
}
inline const ::greptime::v1::Rows& InsertRequest::rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.InsertRequest.rows)
  return _internal_rows();
}
inline void InsertRequest::unsafe_arena_set_allocated_rows(
    ::greptime::v1::Rows* rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  _impl_.rows_ = rows;
  if (rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.InsertRequest.rows)
}
inline ::greptime::v1::Rows* InsertRequest::release_rows() {
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::unsafe_arena_release_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.InsertRequest.rows)
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::_internal_mutable_rows() {
  
  if (_impl_.rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Rows>(GetArenaForAllocation());
    _impl_.rows_ = p;
  }
  return _impl_.rows_;
}
inline ::greptime::v1::Rows* InsertRequest::mutable_rows() {
  ::greptime::v1::Rows* _msg = _internal_mutable_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.InsertRequest.rows)
  return _msg;
}
inline void InsertRequest::set_allocated_rows(::greptime::v1::Rows* rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  if (rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rows));
    if (message_arena != submessage_arena) {
      rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rows_ = rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.InsertRequest.rows)
}

// -------------------------------------------------------------------

// DeleteRequest

// uint64 region_id = 1;
inline void DeleteRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t DeleteRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t DeleteRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DeleteRequest.region_id)
  return _internal_region_id();
}
inline void DeleteRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void DeleteRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.DeleteRequest.region_id)
}

// .greptime.v1.Rows rows = 2;
inline bool DeleteRequest::_internal_has_rows() const {
  return this != internal_default_instance() && _impl_.rows_ != nullptr;
}
inline bool DeleteRequest::has_rows() const {
  return _internal_has_rows();
}
inline const ::greptime::v1::Rows& DeleteRequest::_internal_rows() const {
  const ::greptime::v1::Rows* p = _impl_.rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Rows&>(
      ::greptime::v1::_Rows_default_instance_);
}
inline const ::greptime::v1::Rows& DeleteRequest::rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DeleteRequest.rows)
  return _internal_rows();
}
inline void DeleteRequest::unsafe_arena_set_allocated_rows(
    ::greptime::v1::Rows* rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  _impl_.rows_ = rows;
  if (rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.DeleteRequest.rows)
}
inline ::greptime::v1::Rows* DeleteRequest::release_rows() {
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Rows* DeleteRequest::unsafe_arena_release_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.DeleteRequest.rows)
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::Rows* DeleteRequest::_internal_mutable_rows() {
  
  if (_impl_.rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Rows>(GetArenaForAllocation());
    _impl_.rows_ = p;
  }
  return _impl_.rows_;
}
inline ::greptime::v1::Rows* DeleteRequest::mutable_rows() {
  ::greptime::v1::Rows* _msg = _internal_mutable_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DeleteRequest.rows)
  return _msg;
}
inline void DeleteRequest::set_allocated_rows(::greptime::v1::Rows* rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  if (rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rows));
    if (message_arena != submessage_arena) {
      rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rows_ = rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.DeleteRequest.rows)
}

// -------------------------------------------------------------------

// QueryRequest

// .greptime.v1.region.RegionRequestHeader header = 1;
inline bool QueryRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool QueryRequest::has_header() const {
  return _internal_has_header();
}
inline void QueryRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::greptime::v1::region::RegionRequestHeader& QueryRequest::_internal_header() const {
  const ::greptime::v1::region::RegionRequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::region::RegionRequestHeader&>(
      ::greptime::v1::region::_RegionRequestHeader_default_instance_);
}
inline const ::greptime::v1::region::RegionRequestHeader& QueryRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.QueryRequest.header)
  return _internal_header();
}
inline void QueryRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::region::RegionRequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.QueryRequest.header)
}
inline ::greptime::v1::region::RegionRequestHeader* QueryRequest::release_header() {
  
  ::greptime::v1::region::RegionRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::region::RegionRequestHeader* QueryRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.QueryRequest.header)
  
  ::greptime::v1::region::RegionRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::region::RegionRequestHeader* QueryRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::region::RegionRequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::region::RegionRequestHeader* QueryRequest::mutable_header() {
  ::greptime::v1::region::RegionRequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.QueryRequest.header)
  return _msg;
}
inline void QueryRequest::set_allocated_header(::greptime::v1::region::RegionRequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.QueryRequest.header)
}

// uint64 region_id = 2;
inline void QueryRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t QueryRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t QueryRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.QueryRequest.region_id)
  return _internal_region_id();
}
inline void QueryRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void QueryRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.QueryRequest.region_id)
}

// bytes plan = 3;
inline void QueryRequest::clear_plan() {
  _impl_.plan_.ClearToEmpty();
}
inline const std::string& QueryRequest::plan() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.QueryRequest.plan)
  return _internal_plan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_plan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plan_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.QueryRequest.plan)
}
inline std::string* QueryRequest::mutable_plan() {
  std::string* _s = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.QueryRequest.plan)
  return _s;
}
inline const std::string& QueryRequest::_internal_plan() const {
  return _impl_.plan_.Get();
}
inline void QueryRequest::_internal_set_plan(const std::string& value) {
  
  _impl_.plan_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_plan() {
  
  return _impl_.plan_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryRequest::release_plan() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.QueryRequest.plan)
  return _impl_.plan_.Release();
}
inline void QueryRequest::set_allocated_plan(std::string* plan) {
  if (plan != nullptr) {
    
  } else {
    
  }
  _impl_.plan_.SetAllocated(plan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plan_.IsDefault()) {
    _impl_.plan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.QueryRequest.plan)
}

// -------------------------------------------------------------------

// CreateRequests

// repeated .greptime.v1.region.CreateRequest requests = 1;
inline int CreateRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int CreateRequests::requests_size() const {
  return _internal_requests_size();
}
inline void CreateRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::CreateRequest* CreateRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::CreateRequest >*
CreateRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.CreateRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::CreateRequest& CreateRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::CreateRequest& CreateRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::CreateRequest* CreateRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::CreateRequest* CreateRequests::add_requests() {
  ::greptime::v1::region::CreateRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.CreateRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::CreateRequest >&
CreateRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.CreateRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateRequest

// uint64 region_id = 1;
inline void CreateRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t CreateRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t CreateRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.region_id)
  return _internal_region_id();
}
inline void CreateRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void CreateRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.region_id)
}

// string engine = 2;
inline void CreateRequest::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& CreateRequest::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.engine)
}
inline std::string* CreateRequest::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.engine)
  return _s;
}
inline const std::string& CreateRequest::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void CreateRequest::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CreateRequest.engine)
  return _impl_.engine_.Release();
}
inline void CreateRequest::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.CreateRequest.engine)
}

// repeated .greptime.v1.region.RegionColumnDef column_defs = 3;
inline int CreateRequest::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int CreateRequest::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void CreateRequest::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::greptime::v1::region::RegionColumnDef* CreateRequest::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::RegionColumnDef >*
CreateRequest::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.CreateRequest.column_defs)
  return &_impl_.column_defs_;
}
inline const ::greptime::v1::region::RegionColumnDef& CreateRequest::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::greptime::v1::region::RegionColumnDef& CreateRequest::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.column_defs)
  return _internal_column_defs(index);
}
inline ::greptime::v1::region::RegionColumnDef* CreateRequest::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::greptime::v1::region::RegionColumnDef* CreateRequest::add_column_defs() {
  ::greptime::v1::region::RegionColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:greptime.v1.region.CreateRequest.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::RegionColumnDef >&
CreateRequest::column_defs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.CreateRequest.column_defs)
  return _impl_.column_defs_;
}

// repeated uint32 primary_key = 4;
inline int CreateRequest::_internal_primary_key_size() const {
  return _impl_.primary_key_.size();
}
inline int CreateRequest::primary_key_size() const {
  return _internal_primary_key_size();
}
inline void CreateRequest::clear_primary_key() {
  _impl_.primary_key_.Clear();
}
inline uint32_t CreateRequest::_internal_primary_key(int index) const {
  return _impl_.primary_key_.Get(index);
}
inline uint32_t CreateRequest::primary_key(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.primary_key)
  return _internal_primary_key(index);
}
inline void CreateRequest::set_primary_key(int index, uint32_t value) {
  _impl_.primary_key_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.primary_key)
}
inline void CreateRequest::_internal_add_primary_key(uint32_t value) {
  _impl_.primary_key_.Add(value);
}
inline void CreateRequest::add_primary_key(uint32_t value) {
  _internal_add_primary_key(value);
  // @@protoc_insertion_point(field_add:greptime.v1.region.CreateRequest.primary_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CreateRequest::_internal_primary_key() const {
  return _impl_.primary_key_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CreateRequest::primary_key() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.CreateRequest.primary_key)
  return _internal_primary_key();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CreateRequest::_internal_mutable_primary_key() {
  return &_impl_.primary_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CreateRequest::mutable_primary_key() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.CreateRequest.primary_key)
  return _internal_mutable_primary_key();
}

// string path = 5;
inline void CreateRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& CreateRequest::path() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.path)
}
inline std::string* CreateRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.path)
  return _s;
}
inline const std::string& CreateRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void CreateRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_path() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CreateRequest.path)
  return _impl_.path_.Release();
}
inline void CreateRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.CreateRequest.path)
}

// map<string, string> options = 6;
inline int CreateRequest::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int CreateRequest::options_size() const {
  return _internal_options_size();
}
inline void CreateRequest::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.region.CreateRequest.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.region.CreateRequest.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// DropRequests

// repeated .greptime.v1.region.DropRequest requests = 1;
inline int DropRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int DropRequests::requests_size() const {
  return _internal_requests_size();
}
inline void DropRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::DropRequest* DropRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DropRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropRequest >*
DropRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.DropRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::DropRequest& DropRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::DropRequest& DropRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::DropRequest* DropRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::DropRequest* DropRequests::add_requests() {
  ::greptime::v1::region::DropRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.DropRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropRequest >&
DropRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.DropRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// DropRequest

// uint64 region_id = 1;
inline void DropRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t DropRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t DropRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropRequest.region_id)
  return _internal_region_id();
}
inline void DropRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void DropRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.DropRequest.region_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OpenRequest

// uint64 region_id = 1;
inline void OpenRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t OpenRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t OpenRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.region_id)
  return _internal_region_id();
}
inline void OpenRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void OpenRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.region_id)
}

// string engine = 2;
inline void OpenRequest::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& OpenRequest::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.engine)
}
inline std::string* OpenRequest::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.OpenRequest.engine)
  return _s;
}
inline const std::string& OpenRequest::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void OpenRequest::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.OpenRequest.engine)
  return _impl_.engine_.Release();
}
inline void OpenRequest::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.OpenRequest.engine)
}

// string path = 3;
inline void OpenRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& OpenRequest::path() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.path)
}
inline std::string* OpenRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.OpenRequest.path)
  return _s;
}
inline const std::string& OpenRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void OpenRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_path() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.OpenRequest.path)
  return _impl_.path_.Release();
}
inline void OpenRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.OpenRequest.path)
}

// map<string, string> options = 4;
inline int OpenRequest::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int OpenRequest::options_size() const {
  return _internal_options_size();
}
inline void OpenRequest::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OpenRequest::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OpenRequest::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.region.OpenRequest.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OpenRequest::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OpenRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.region.OpenRequest.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// CloseRequest

// uint64 region_id = 1;
inline void CloseRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t CloseRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t CloseRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CloseRequest.region_id)
  return _internal_region_id();
}
inline void CloseRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void CloseRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CloseRequest.region_id)
}

// -------------------------------------------------------------------

// AlterRequests

// repeated .greptime.v1.region.AlterRequest requests = 1;
inline int AlterRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int AlterRequests::requests_size() const {
  return _internal_requests_size();
}
inline void AlterRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::AlterRequest* AlterRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AlterRequest >*
AlterRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.AlterRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::AlterRequest& AlterRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::AlterRequest& AlterRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::AlterRequest* AlterRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::AlterRequest* AlterRequests::add_requests() {
  ::greptime::v1::region::AlterRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.AlterRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AlterRequest >&
AlterRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.AlterRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// AlterRequest

// uint64 region_id = 1;
inline void AlterRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t AlterRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t AlterRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.region_id)
  return _internal_region_id();
}
inline void AlterRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void AlterRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.AlterRequest.region_id)
}

// .greptime.v1.region.AddColumns add_columns = 2;
inline bool AlterRequest::_internal_has_add_columns() const {
  return kind_case() == kAddColumns;
}
inline bool AlterRequest::has_add_columns() const {
  return _internal_has_add_columns();
}
inline void AlterRequest::set_has_add_columns() {
  _impl_._oneof_case_[0] = kAddColumns;
}
inline void AlterRequest::clear_add_columns() {
  if (_internal_has_add_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.add_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::region::AddColumns* AlterRequest::release_add_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AlterRequest.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::region::AddColumns* temp = _impl_.kind_.add_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::AddColumns& AlterRequest::_internal_add_columns() const {
  return _internal_has_add_columns()
      ? *_impl_.kind_.add_columns_
      : reinterpret_cast< ::greptime::v1::region::AddColumns&>(::greptime::v1::region::_AddColumns_default_instance_);
}
inline const ::greptime::v1::region::AddColumns& AlterRequest::add_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.add_columns)
  return _internal_add_columns();
}
inline ::greptime::v1::region::AddColumns* AlterRequest::unsafe_arena_release_add_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.AlterRequest.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::region::AddColumns* temp = _impl_.kind_.add_columns_;
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterRequest::unsafe_arena_set_allocated_add_columns(::greptime::v1::region::AddColumns* add_columns) {
  clear_kind();
  if (add_columns) {
    set_has_add_columns();
    _impl_.kind_.add_columns_ = add_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AlterRequest.add_columns)
}
inline ::greptime::v1::region::AddColumns* AlterRequest::_internal_mutable_add_columns() {
  if (!_internal_has_add_columns()) {
    clear_kind();
    set_has_add_columns();
    _impl_.kind_.add_columns_ = CreateMaybeMessage< ::greptime::v1::region::AddColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.add_columns_;
}
inline ::greptime::v1::region::AddColumns* AlterRequest::mutable_add_columns() {
  ::greptime::v1::region::AddColumns* _msg = _internal_mutable_add_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequest.add_columns)
  return _msg;
}

// .greptime.v1.region.DropColumns drop_columns = 3;
inline bool AlterRequest::_internal_has_drop_columns() const {
  return kind_case() == kDropColumns;
}
inline bool AlterRequest::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void AlterRequest::set_has_drop_columns() {
  _impl_._oneof_case_[0] = kDropColumns;
}
inline void AlterRequest::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.drop_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::region::DropColumns* AlterRequest::release_drop_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AlterRequest.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::region::DropColumns* temp = _impl_.kind_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DropColumns& AlterRequest::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *_impl_.kind_.drop_columns_
      : reinterpret_cast< ::greptime::v1::region::DropColumns&>(::greptime::v1::region::_DropColumns_default_instance_);
}
inline const ::greptime::v1::region::DropColumns& AlterRequest::drop_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.drop_columns)
  return _internal_drop_columns();
}
inline ::greptime::v1::region::DropColumns* AlterRequest::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.AlterRequest.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::region::DropColumns* temp = _impl_.kind_.drop_columns_;
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterRequest::unsafe_arena_set_allocated_drop_columns(::greptime::v1::region::DropColumns* drop_columns) {
  clear_kind();
  if (drop_columns) {
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AlterRequest.drop_columns)
}
inline ::greptime::v1::region::DropColumns* AlterRequest::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_kind();
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = CreateMaybeMessage< ::greptime::v1::region::DropColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.drop_columns_;
}
inline ::greptime::v1::region::DropColumns* AlterRequest::mutable_drop_columns() {
  ::greptime::v1::region::DropColumns* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequest.drop_columns)
  return _msg;
}

// .greptime.v1.ChangeColumnTypes change_column_types = 5;
inline bool AlterRequest::_internal_has_change_column_types() const {
  return kind_case() == kChangeColumnTypes;
}
inline bool AlterRequest::has_change_column_types() const {
  return _internal_has_change_column_types();
}
inline void AlterRequest::set_has_change_column_types() {
  _impl_._oneof_case_[0] = kChangeColumnTypes;
}
inline ::greptime::v1::ChangeColumnTypes* AlterRequest::release_change_column_types() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AlterRequest.change_column_types)
  if (_internal_has_change_column_types()) {
    clear_has_kind();
    ::greptime::v1::ChangeColumnTypes* temp = _impl_.kind_.change_column_types_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.change_column_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::ChangeColumnTypes& AlterRequest::_internal_change_column_types() const {
  return _internal_has_change_column_types()
      ? *_impl_.kind_.change_column_types_
      : reinterpret_cast< ::greptime::v1::ChangeColumnTypes&>(::greptime::v1::_ChangeColumnTypes_default_instance_);
}
inline const ::greptime::v1::ChangeColumnTypes& AlterRequest::change_column_types() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.change_column_types)
  return _internal_change_column_types();
}
inline ::greptime::v1::ChangeColumnTypes* AlterRequest::unsafe_arena_release_change_column_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.AlterRequest.change_column_types)
  if (_internal_has_change_column_types()) {
    clear_has_kind();
    ::greptime::v1::ChangeColumnTypes* temp = _impl_.kind_.change_column_types_;
    _impl_.kind_.change_column_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterRequest::unsafe_arena_set_allocated_change_column_types(::greptime::v1::ChangeColumnTypes* change_column_types) {
  clear_kind();
  if (change_column_types) {
    set_has_change_column_types();
    _impl_.kind_.change_column_types_ = change_column_types;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AlterRequest.change_column_types)
}
inline ::greptime::v1::ChangeColumnTypes* AlterRequest::_internal_mutable_change_column_types() {
  if (!_internal_has_change_column_types()) {
    clear_kind();
    set_has_change_column_types();
    _impl_.kind_.change_column_types_ = CreateMaybeMessage< ::greptime::v1::ChangeColumnTypes >(GetArenaForAllocation());
  }
  return _impl_.kind_.change_column_types_;
}
inline ::greptime::v1::ChangeColumnTypes* AlterRequest::mutable_change_column_types() {
  ::greptime::v1::ChangeColumnTypes* _msg = _internal_mutable_change_column_types();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequest.change_column_types)
  return _msg;
}

// .greptime.v1.ChangeTableOptions change_table_options = 6;
inline bool AlterRequest::_internal_has_change_table_options() const {
  return kind_case() == kChangeTableOptions;
}
inline bool AlterRequest::has_change_table_options() const {
  return _internal_has_change_table_options();
}
inline void AlterRequest::set_has_change_table_options() {
  _impl_._oneof_case_[0] = kChangeTableOptions;
}
inline ::greptime::v1::ChangeTableOptions* AlterRequest::release_change_table_options() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AlterRequest.change_table_options)
  if (_internal_has_change_table_options()) {
    clear_has_kind();
    ::greptime::v1::ChangeTableOptions* temp = _impl_.kind_.change_table_options_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.change_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::ChangeTableOptions& AlterRequest::_internal_change_table_options() const {
  return _internal_has_change_table_options()
      ? *_impl_.kind_.change_table_options_
      : reinterpret_cast< ::greptime::v1::ChangeTableOptions&>(::greptime::v1::_ChangeTableOptions_default_instance_);
}
inline const ::greptime::v1::ChangeTableOptions& AlterRequest::change_table_options() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.change_table_options)
  return _internal_change_table_options();
}
inline ::greptime::v1::ChangeTableOptions* AlterRequest::unsafe_arena_release_change_table_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.AlterRequest.change_table_options)
  if (_internal_has_change_table_options()) {
    clear_has_kind();
    ::greptime::v1::ChangeTableOptions* temp = _impl_.kind_.change_table_options_;
    _impl_.kind_.change_table_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterRequest::unsafe_arena_set_allocated_change_table_options(::greptime::v1::ChangeTableOptions* change_table_options) {
  clear_kind();
  if (change_table_options) {
    set_has_change_table_options();
    _impl_.kind_.change_table_options_ = change_table_options;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AlterRequest.change_table_options)
}
inline ::greptime::v1::ChangeTableOptions* AlterRequest::_internal_mutable_change_table_options() {
  if (!_internal_has_change_table_options()) {
    clear_kind();
    set_has_change_table_options();
    _impl_.kind_.change_table_options_ = CreateMaybeMessage< ::greptime::v1::ChangeTableOptions >(GetArenaForAllocation());
  }
  return _impl_.kind_.change_table_options_;
}
inline ::greptime::v1::ChangeTableOptions* AlterRequest::mutable_change_table_options() {
  ::greptime::v1::ChangeTableOptions* _msg = _internal_mutable_change_table_options();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequest.change_table_options)
  return _msg;
}

// uint64 schema_version = 4;
inline void AlterRequest::clear_schema_version() {
  _impl_.schema_version_ = uint64_t{0u};
}
inline uint64_t AlterRequest::_internal_schema_version() const {
  return _impl_.schema_version_;
}
inline uint64_t AlterRequest::schema_version() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.schema_version)
  return _internal_schema_version();
}
inline void AlterRequest::_internal_set_schema_version(uint64_t value) {
  
  _impl_.schema_version_ = value;
}
inline void AlterRequest::set_schema_version(uint64_t value) {
  _internal_set_schema_version(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.AlterRequest.schema_version)
}

inline bool AlterRequest::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AlterRequest::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline AlterRequest::KindCase AlterRequest::kind_case() const {
  return AlterRequest::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddColumns

// repeated .greptime.v1.region.AddColumn add_columns = 1;
inline int AddColumns::_internal_add_columns_size() const {
  return _impl_.add_columns_.size();
}
inline int AddColumns::add_columns_size() const {
  return _internal_add_columns_size();
}
inline void AddColumns::clear_add_columns() {
  _impl_.add_columns_.Clear();
}
inline ::greptime::v1::region::AddColumn* AddColumns::mutable_add_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AddColumns.add_columns)
  return _impl_.add_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >*
AddColumns::mutable_add_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.AddColumns.add_columns)
  return &_impl_.add_columns_;
}
inline const ::greptime::v1::region::AddColumn& AddColumns::_internal_add_columns(int index) const {
  return _impl_.add_columns_.Get(index);
}
inline const ::greptime::v1::region::AddColumn& AddColumns::add_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumns.add_columns)
  return _internal_add_columns(index);
}
inline ::greptime::v1::region::AddColumn* AddColumns::_internal_add_add_columns() {
  return _impl_.add_columns_.Add();
}
inline ::greptime::v1::region::AddColumn* AddColumns::add_add_columns() {
  ::greptime::v1::region::AddColumn* _add = _internal_add_add_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.region.AddColumns.add_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >&
AddColumns::add_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.AddColumns.add_columns)
  return _impl_.add_columns_;
}

// -------------------------------------------------------------------

// DropColumns

// repeated .greptime.v1.region.DropColumn drop_columns = 1;
inline int DropColumns::_internal_drop_columns_size() const {
  return _impl_.drop_columns_.size();
}
inline int DropColumns::drop_columns_size() const {
  return _internal_drop_columns_size();
}
inline void DropColumns::clear_drop_columns() {
  _impl_.drop_columns_.Clear();
}
inline ::greptime::v1::region::DropColumn* DropColumns::mutable_drop_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DropColumns.drop_columns)
  return _impl_.drop_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >*
DropColumns::mutable_drop_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.DropColumns.drop_columns)
  return &_impl_.drop_columns_;
}
inline const ::greptime::v1::region::DropColumn& DropColumns::_internal_drop_columns(int index) const {
  return _impl_.drop_columns_.Get(index);
}
inline const ::greptime::v1::region::DropColumn& DropColumns::drop_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropColumns.drop_columns)
  return _internal_drop_columns(index);
}
inline ::greptime::v1::region::DropColumn* DropColumns::_internal_add_drop_columns() {
  return _impl_.drop_columns_.Add();
}
inline ::greptime::v1::region::DropColumn* DropColumns::add_drop_columns() {
  ::greptime::v1::region::DropColumn* _add = _internal_add_drop_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.region.DropColumns.drop_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >&
DropColumns::drop_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.DropColumns.drop_columns)
  return _impl_.drop_columns_;
}

// -------------------------------------------------------------------

// AddColumn

// .greptime.v1.region.RegionColumnDef column_def = 1;
inline bool AddColumn::_internal_has_column_def() const {
  return this != internal_default_instance() && _impl_.column_def_ != nullptr;
}
inline bool AddColumn::has_column_def() const {
  return _internal_has_column_def();
}
inline void AddColumn::clear_column_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_def_ != nullptr) {
    delete _impl_.column_def_;
  }
  _impl_.column_def_ = nullptr;
}
inline const ::greptime::v1::region::RegionColumnDef& AddColumn::_internal_column_def() const {
  const ::greptime::v1::region::RegionColumnDef* p = _impl_.column_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::region::RegionColumnDef&>(
      ::greptime::v1::region::_RegionColumnDef_default_instance_);
}
inline const ::greptime::v1::region::RegionColumnDef& AddColumn::column_def() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumn.column_def)
  return _internal_column_def();
}
inline void AddColumn::unsafe_arena_set_allocated_column_def(
    ::greptime::v1::region::RegionColumnDef* column_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  _impl_.column_def_ = column_def;
  if (column_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AddColumn.column_def)
}
inline ::greptime::v1::region::RegionColumnDef* AddColumn::release_column_def() {
  
  ::greptime::v1::region::RegionColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::region::RegionColumnDef* AddColumn::unsafe_arena_release_column_def() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AddColumn.column_def)
  
  ::greptime::v1::region::RegionColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
  return temp;
}
inline ::greptime::v1::region::RegionColumnDef* AddColumn::_internal_mutable_column_def() {
  
  if (_impl_.column_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::region::RegionColumnDef>(GetArenaForAllocation());
    _impl_.column_def_ = p;
  }
  return _impl_.column_def_;
}
inline ::greptime::v1::region::RegionColumnDef* AddColumn::mutable_column_def() {
  ::greptime::v1::region::RegionColumnDef* _msg = _internal_mutable_column_def();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AddColumn.column_def)
  return _msg;
}
inline void AddColumn::set_allocated_column_def(::greptime::v1::region::RegionColumnDef* column_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_def_;
  }
  if (column_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_def);
    if (message_arena != submessage_arena) {
      column_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_def_ = column_def;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.AddColumn.column_def)
}

// .greptime.v1.AddColumnLocation location = 3;
inline bool AddColumn::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AddColumn::has_location() const {
  return _internal_has_location();
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::_internal_location() const {
  const ::greptime::v1::AddColumnLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AddColumnLocation&>(
      ::greptime::v1::_AddColumnLocation_default_instance_);
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::location() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumn.location)
  return _internal_location();
}
inline void AddColumn::unsafe_arena_set_allocated_location(
    ::greptime::v1::AddColumnLocation* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AddColumn.location)
}
inline ::greptime::v1::AddColumnLocation* AddColumn::release_location() {
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AddColumn.location)
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AddColumnLocation>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::mutable_location() {
  ::greptime::v1::AddColumnLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AddColumn.location)
  return _msg;
}
inline void AddColumn::set_allocated_location(::greptime::v1::AddColumnLocation* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.AddColumn.location)
}

// -------------------------------------------------------------------

// DropColumn

// string name = 1;
inline void DropColumn::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DropColumn::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.DropColumn.name)
}
inline std::string* DropColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DropColumn.name)
  return _s;
}
inline const std::string& DropColumn::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DropColumn::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropColumn::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropColumn::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.DropColumn.name)
  return _impl_.name_.Release();
}
inline void DropColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.DropColumn.name)
}

// -------------------------------------------------------------------

// FlushRequest

// uint64 region_id = 1;
inline void FlushRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t FlushRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t FlushRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.FlushRequest.region_id)
  return _internal_region_id();
}
inline void FlushRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void FlushRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.FlushRequest.region_id)
}

// -------------------------------------------------------------------

// Regular

// -------------------------------------------------------------------

// StrictWindow

// int64 window_seconds = 1;
inline void StrictWindow::clear_window_seconds() {
  _impl_.window_seconds_ = int64_t{0};
}
inline int64_t StrictWindow::_internal_window_seconds() const {
  return _impl_.window_seconds_;
}
inline int64_t StrictWindow::window_seconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.StrictWindow.window_seconds)
  return _internal_window_seconds();
}
inline void StrictWindow::_internal_set_window_seconds(int64_t value) {
  
  _impl_.window_seconds_ = value;
}
inline void StrictWindow::set_window_seconds(int64_t value) {
  _internal_set_window_seconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.StrictWindow.window_seconds)
}

// -------------------------------------------------------------------

// CompactRequest

// uint64 region_id = 1;
inline void CompactRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t CompactRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t CompactRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CompactRequest.region_id)
  return _internal_region_id();
}
inline void CompactRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void CompactRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CompactRequest.region_id)
}

// .greptime.v1.region.Regular regular = 2;
inline bool CompactRequest::_internal_has_regular() const {
  return options_case() == kRegular;
}
inline bool CompactRequest::has_regular() const {
  return _internal_has_regular();
}
inline void CompactRequest::set_has_regular() {
  _impl_._oneof_case_[0] = kRegular;
}
inline void CompactRequest::clear_regular() {
  if (_internal_has_regular()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.regular_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::region::Regular* CompactRequest::release_regular() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CompactRequest.regular)
  if (_internal_has_regular()) {
    clear_has_options();
    ::greptime::v1::region::Regular* temp = _impl_.options_.regular_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.regular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::Regular& CompactRequest::_internal_regular() const {
  return _internal_has_regular()
      ? *_impl_.options_.regular_
      : reinterpret_cast< ::greptime::v1::region::Regular&>(::greptime::v1::region::_Regular_default_instance_);
}
inline const ::greptime::v1::region::Regular& CompactRequest::regular() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CompactRequest.regular)
  return _internal_regular();
}
inline ::greptime::v1::region::Regular* CompactRequest::unsafe_arena_release_regular() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.CompactRequest.regular)
  if (_internal_has_regular()) {
    clear_has_options();
    ::greptime::v1::region::Regular* temp = _impl_.options_.regular_;
    _impl_.options_.regular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompactRequest::unsafe_arena_set_allocated_regular(::greptime::v1::region::Regular* regular) {
  clear_options();
  if (regular) {
    set_has_regular();
    _impl_.options_.regular_ = regular;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.CompactRequest.regular)
}
inline ::greptime::v1::region::Regular* CompactRequest::_internal_mutable_regular() {
  if (!_internal_has_regular()) {
    clear_options();
    set_has_regular();
    _impl_.options_.regular_ = CreateMaybeMessage< ::greptime::v1::region::Regular >(GetArenaForAllocation());
  }
  return _impl_.options_.regular_;
}
inline ::greptime::v1::region::Regular* CompactRequest::mutable_regular() {
  ::greptime::v1::region::Regular* _msg = _internal_mutable_regular();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CompactRequest.regular)
  return _msg;
}

// .greptime.v1.region.StrictWindow strict_window = 3;
inline bool CompactRequest::_internal_has_strict_window() const {
  return options_case() == kStrictWindow;
}
inline bool CompactRequest::has_strict_window() const {
  return _internal_has_strict_window();
}
inline void CompactRequest::set_has_strict_window() {
  _impl_._oneof_case_[0] = kStrictWindow;
}
inline void CompactRequest::clear_strict_window() {
  if (_internal_has_strict_window()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.options_.strict_window_;
    }
    clear_has_options();
  }
}
inline ::greptime::v1::region::StrictWindow* CompactRequest::release_strict_window() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CompactRequest.strict_window)
  if (_internal_has_strict_window()) {
    clear_has_options();
    ::greptime::v1::region::StrictWindow* temp = _impl_.options_.strict_window_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.options_.strict_window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::StrictWindow& CompactRequest::_internal_strict_window() const {
  return _internal_has_strict_window()
      ? *_impl_.options_.strict_window_
      : reinterpret_cast< ::greptime::v1::region::StrictWindow&>(::greptime::v1::region::_StrictWindow_default_instance_);
}
inline const ::greptime::v1::region::StrictWindow& CompactRequest::strict_window() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CompactRequest.strict_window)
  return _internal_strict_window();
}
inline ::greptime::v1::region::StrictWindow* CompactRequest::unsafe_arena_release_strict_window() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.CompactRequest.strict_window)
  if (_internal_has_strict_window()) {
    clear_has_options();
    ::greptime::v1::region::StrictWindow* temp = _impl_.options_.strict_window_;
    _impl_.options_.strict_window_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CompactRequest::unsafe_arena_set_allocated_strict_window(::greptime::v1::region::StrictWindow* strict_window) {
  clear_options();
  if (strict_window) {
    set_has_strict_window();
    _impl_.options_.strict_window_ = strict_window;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.CompactRequest.strict_window)
}
inline ::greptime::v1::region::StrictWindow* CompactRequest::_internal_mutable_strict_window() {
  if (!_internal_has_strict_window()) {
    clear_options();
    set_has_strict_window();
    _impl_.options_.strict_window_ = CreateMaybeMessage< ::greptime::v1::region::StrictWindow >(GetArenaForAllocation());
  }
  return _impl_.options_.strict_window_;
}
inline ::greptime::v1::region::StrictWindow* CompactRequest::mutable_strict_window() {
  ::greptime::v1::region::StrictWindow* _msg = _internal_mutable_strict_window();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CompactRequest.strict_window)
  return _msg;
}

inline bool CompactRequest::has_options() const {
  return options_case() != OPTIONS_NOT_SET;
}
inline void CompactRequest::clear_has_options() {
  _impl_._oneof_case_[0] = OPTIONS_NOT_SET;
}
inline CompactRequest::OptionsCase CompactRequest::options_case() const {
  return CompactRequest::OptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TruncateRequest

// uint64 region_id = 1;
inline void TruncateRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t TruncateRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t TruncateRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.TruncateRequest.region_id)
  return _internal_region_id();
}
inline void TruncateRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void TruncateRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.TruncateRequest.region_id)
}

// -------------------------------------------------------------------

// RegionColumnDef

// .greptime.v1.ColumnDef column_def = 1;
inline bool RegionColumnDef::_internal_has_column_def() const {
  return this != internal_default_instance() && _impl_.column_def_ != nullptr;
}
inline bool RegionColumnDef::has_column_def() const {
  return _internal_has_column_def();
}
inline const ::greptime::v1::ColumnDef& RegionColumnDef::_internal_column_def() const {
  const ::greptime::v1::ColumnDef* p = _impl_.column_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDef&>(
      ::greptime::v1::_ColumnDef_default_instance_);
}
inline const ::greptime::v1::ColumnDef& RegionColumnDef::column_def() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionColumnDef.column_def)
  return _internal_column_def();
}
inline void RegionColumnDef::unsafe_arena_set_allocated_column_def(
    ::greptime::v1::ColumnDef* column_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  _impl_.column_def_ = column_def;
  if (column_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionColumnDef.column_def)
}
inline ::greptime::v1::ColumnDef* RegionColumnDef::release_column_def() {
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDef* RegionColumnDef::unsafe_arena_release_column_def() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionColumnDef.column_def)
  
  ::greptime::v1::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDef* RegionColumnDef::_internal_mutable_column_def() {
  
  if (_impl_.column_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDef>(GetArenaForAllocation());
    _impl_.column_def_ = p;
  }
  return _impl_.column_def_;
}
inline ::greptime::v1::ColumnDef* RegionColumnDef::mutable_column_def() {
  ::greptime::v1::ColumnDef* _msg = _internal_mutable_column_def();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionColumnDef.column_def)
  return _msg;
}
inline void RegionColumnDef::set_allocated_column_def(::greptime::v1::ColumnDef* column_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  if (column_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_def));
    if (message_arena != submessage_arena) {
      column_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_def_ = column_def;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionColumnDef.column_def)
}

// uint32 column_id = 2;
inline void RegionColumnDef::clear_column_id() {
  _impl_.column_id_ = 0u;
}
inline uint32_t RegionColumnDef::_internal_column_id() const {
  return _impl_.column_id_;
}
inline uint32_t RegionColumnDef::column_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionColumnDef.column_id)
  return _internal_column_id();
}
inline void RegionColumnDef::_internal_set_column_id(uint32_t value) {
  
  _impl_.column_id_ = value;
}
inline void RegionColumnDef::set_column_id(uint32_t value) {
  _internal_set_column_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.RegionColumnDef.column_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace region
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fregion_2fserver_2eproto
