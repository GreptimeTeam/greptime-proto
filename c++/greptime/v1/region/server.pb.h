// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/region/server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fregion_2fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fregion_2fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
#include "greptime/v1/row.pb.h"
#include "greptime/v1/ddl.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fregion_2fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fregion_2fserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fregion_2fserver_2eproto;
namespace greptime {
namespace v1 {
namespace region {
class AddColumn;
struct AddColumnDefaultTypeInternal;
extern AddColumnDefaultTypeInternal _AddColumn_default_instance_;
class AddColumns;
struct AddColumnsDefaultTypeInternal;
extern AddColumnsDefaultTypeInternal _AddColumns_default_instance_;
class AlterRequest;
struct AlterRequestDefaultTypeInternal;
extern AlterRequestDefaultTypeInternal _AlterRequest_default_instance_;
class CloseRequest;
struct CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class ColumnDef;
struct ColumnDefDefaultTypeInternal;
extern ColumnDefDefaultTypeInternal _ColumnDef_default_instance_;
class CompactRequest;
struct CompactRequestDefaultTypeInternal;
extern CompactRequestDefaultTypeInternal _CompactRequest_default_instance_;
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateRequest_OptionsEntry_DoNotUse;
struct CreateRequest_OptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateRequest_OptionsEntry_DoNotUseDefaultTypeInternal _CreateRequest_OptionsEntry_DoNotUse_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteRequests;
struct DeleteRequestsDefaultTypeInternal;
extern DeleteRequestsDefaultTypeInternal _DeleteRequests_default_instance_;
class DropColumn;
struct DropColumnDefaultTypeInternal;
extern DropColumnDefaultTypeInternal _DropColumn_default_instance_;
class DropColumns;
struct DropColumnsDefaultTypeInternal;
extern DropColumnsDefaultTypeInternal _DropColumns_default_instance_;
class DropRequest;
struct DropRequestDefaultTypeInternal;
extern DropRequestDefaultTypeInternal _DropRequest_default_instance_;
class FlushRequest;
struct FlushRequestDefaultTypeInternal;
extern FlushRequestDefaultTypeInternal _FlushRequest_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertRequests;
struct InsertRequestsDefaultTypeInternal;
extern InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
class OpenRequest;
struct OpenRequestDefaultTypeInternal;
extern OpenRequestDefaultTypeInternal _OpenRequest_default_instance_;
class OpenRequest_OptionsEntry_DoNotUse;
struct OpenRequest_OptionsEntry_DoNotUseDefaultTypeInternal;
extern OpenRequest_OptionsEntry_DoNotUseDefaultTypeInternal _OpenRequest_OptionsEntry_DoNotUse_default_instance_;
class QueryRequest;
struct QueryRequestDefaultTypeInternal;
extern QueryRequestDefaultTypeInternal _QueryRequest_default_instance_;
class RegionRequest;
struct RegionRequestDefaultTypeInternal;
extern RegionRequestDefaultTypeInternal _RegionRequest_default_instance_;
class RegionRequestHeader;
struct RegionRequestHeaderDefaultTypeInternal;
extern RegionRequestHeaderDefaultTypeInternal _RegionRequestHeader_default_instance_;
class RegionResponse;
struct RegionResponseDefaultTypeInternal;
extern RegionResponseDefaultTypeInternal _RegionResponse_default_instance_;
}  // namespace region
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::region::AddColumn* Arena::CreateMaybeMessage<::greptime::v1::region::AddColumn>(Arena*);
template<> ::greptime::v1::region::AddColumns* Arena::CreateMaybeMessage<::greptime::v1::region::AddColumns>(Arena*);
template<> ::greptime::v1::region::AlterRequest* Arena::CreateMaybeMessage<::greptime::v1::region::AlterRequest>(Arena*);
template<> ::greptime::v1::region::CloseRequest* Arena::CreateMaybeMessage<::greptime::v1::region::CloseRequest>(Arena*);
template<> ::greptime::v1::region::ColumnDef* Arena::CreateMaybeMessage<::greptime::v1::region::ColumnDef>(Arena*);
template<> ::greptime::v1::region::CompactRequest* Arena::CreateMaybeMessage<::greptime::v1::region::CompactRequest>(Arena*);
template<> ::greptime::v1::region::CreateRequest* Arena::CreateMaybeMessage<::greptime::v1::region::CreateRequest>(Arena*);
template<> ::greptime::v1::region::CreateRequest_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::region::CreateRequest_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::region::DeleteRequest* Arena::CreateMaybeMessage<::greptime::v1::region::DeleteRequest>(Arena*);
template<> ::greptime::v1::region::DeleteRequests* Arena::CreateMaybeMessage<::greptime::v1::region::DeleteRequests>(Arena*);
template<> ::greptime::v1::region::DropColumn* Arena::CreateMaybeMessage<::greptime::v1::region::DropColumn>(Arena*);
template<> ::greptime::v1::region::DropColumns* Arena::CreateMaybeMessage<::greptime::v1::region::DropColumns>(Arena*);
template<> ::greptime::v1::region::DropRequest* Arena::CreateMaybeMessage<::greptime::v1::region::DropRequest>(Arena*);
template<> ::greptime::v1::region::FlushRequest* Arena::CreateMaybeMessage<::greptime::v1::region::FlushRequest>(Arena*);
template<> ::greptime::v1::region::InsertRequest* Arena::CreateMaybeMessage<::greptime::v1::region::InsertRequest>(Arena*);
template<> ::greptime::v1::region::InsertRequests* Arena::CreateMaybeMessage<::greptime::v1::region::InsertRequests>(Arena*);
template<> ::greptime::v1::region::OpenRequest* Arena::CreateMaybeMessage<::greptime::v1::region::OpenRequest>(Arena*);
template<> ::greptime::v1::region::OpenRequest_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::region::OpenRequest_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::region::QueryRequest* Arena::CreateMaybeMessage<::greptime::v1::region::QueryRequest>(Arena*);
template<> ::greptime::v1::region::RegionRequest* Arena::CreateMaybeMessage<::greptime::v1::region::RegionRequest>(Arena*);
template<> ::greptime::v1::region::RegionRequestHeader* Arena::CreateMaybeMessage<::greptime::v1::region::RegionRequestHeader>(Arena*);
template<> ::greptime::v1::region::RegionResponse* Arena::CreateMaybeMessage<::greptime::v1::region::RegionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace region {

// ===================================================================

class RegionRequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionRequestHeader) */ {
 public:
  inline RegionRequestHeader() : RegionRequestHeader(nullptr) {}
  ~RegionRequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RegionRequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRequestHeader(const RegionRequestHeader& from);
  RegionRequestHeader(RegionRequestHeader&& from) noexcept
    : RegionRequestHeader() {
    *this = ::std::move(from);
  }

  inline RegionRequestHeader& operator=(const RegionRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRequestHeader& operator=(RegionRequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRequestHeader* internal_default_instance() {
    return reinterpret_cast<const RegionRequestHeader*>(
               &_RegionRequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegionRequestHeader& a, RegionRequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRequestHeader& from) {
    RegionRequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionRequestHeader";
  }
  protected:
  explicit RegionRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTraceIdFieldNumber = 1,
    kSpanIdFieldNumber = 2,
  };
  // uint64 trace_id = 1;
  void clear_trace_id();
  uint64_t trace_id() const;
  void set_trace_id(uint64_t value);
  private:
  uint64_t _internal_trace_id() const;
  void _internal_set_trace_id(uint64_t value);
  public:

  // uint64 span_id = 2;
  void clear_span_id();
  uint64_t span_id() const;
  void set_span_id(uint64_t value);
  private:
  uint64_t _internal_span_id() const;
  void _internal_set_span_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionRequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t trace_id_;
    uint64_t span_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RegionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionRequest) */ {
 public:
  inline RegionRequest() : RegionRequest(nullptr) {}
  ~RegionRequest() override;
  explicit PROTOBUF_CONSTEXPR RegionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRequest(const RegionRequest& from);
  RegionRequest(RegionRequest&& from) noexcept
    : RegionRequest() {
    *this = ::std::move(from);
  }

  inline RegionRequest& operator=(const RegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRequest& operator=(RegionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kInserts = 3,
    kDeletes = 4,
    kCreate = 5,
    kDrop = 6,
    kOpen = 7,
    kClose = 8,
    kAlter = 9,
    kFlush = 10,
    kCompact = 11,
    BODY_NOT_SET = 0,
  };

  static inline const RegionRequest* internal_default_instance() {
    return reinterpret_cast<const RegionRequest*>(
               &_RegionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegionRequest& a, RegionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionRequest& from) {
    RegionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionRequest";
  }
  protected:
  explicit RegionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kInsertsFieldNumber = 3,
    kDeletesFieldNumber = 4,
    kCreateFieldNumber = 5,
    kDropFieldNumber = 6,
    kOpenFieldNumber = 7,
    kCloseFieldNumber = 8,
    kAlterFieldNumber = 9,
    kFlushFieldNumber = 10,
    kCompactFieldNumber = 11,
  };
  // .greptime.v1.region.RegionRequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::region::RegionRequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::RegionRequestHeader* release_header();
  ::greptime::v1::region::RegionRequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::region::RegionRequestHeader* header);
  private:
  const ::greptime::v1::region::RegionRequestHeader& _internal_header() const;
  ::greptime::v1::region::RegionRequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::region::RegionRequestHeader* header);
  ::greptime::v1::region::RegionRequestHeader* unsafe_arena_release_header();

  // .greptime.v1.region.InsertRequests inserts = 3;
  bool has_inserts() const;
  private:
  bool _internal_has_inserts() const;
  public:
  void clear_inserts();
  const ::greptime::v1::region::InsertRequests& inserts() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::InsertRequests* release_inserts();
  ::greptime::v1::region::InsertRequests* mutable_inserts();
  void set_allocated_inserts(::greptime::v1::region::InsertRequests* inserts);
  private:
  const ::greptime::v1::region::InsertRequests& _internal_inserts() const;
  ::greptime::v1::region::InsertRequests* _internal_mutable_inserts();
  public:
  void unsafe_arena_set_allocated_inserts(
      ::greptime::v1::region::InsertRequests* inserts);
  ::greptime::v1::region::InsertRequests* unsafe_arena_release_inserts();

  // .greptime.v1.region.DeleteRequests deletes = 4;
  bool has_deletes() const;
  private:
  bool _internal_has_deletes() const;
  public:
  void clear_deletes();
  const ::greptime::v1::region::DeleteRequests& deletes() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DeleteRequests* release_deletes();
  ::greptime::v1::region::DeleteRequests* mutable_deletes();
  void set_allocated_deletes(::greptime::v1::region::DeleteRequests* deletes);
  private:
  const ::greptime::v1::region::DeleteRequests& _internal_deletes() const;
  ::greptime::v1::region::DeleteRequests* _internal_mutable_deletes();
  public:
  void unsafe_arena_set_allocated_deletes(
      ::greptime::v1::region::DeleteRequests* deletes);
  ::greptime::v1::region::DeleteRequests* unsafe_arena_release_deletes();

  // .greptime.v1.region.CreateRequest create = 5;
  bool has_create() const;
  private:
  bool _internal_has_create() const;
  public:
  void clear_create();
  const ::greptime::v1::region::CreateRequest& create() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CreateRequest* release_create();
  ::greptime::v1::region::CreateRequest* mutable_create();
  void set_allocated_create(::greptime::v1::region::CreateRequest* create);
  private:
  const ::greptime::v1::region::CreateRequest& _internal_create() const;
  ::greptime::v1::region::CreateRequest* _internal_mutable_create();
  public:
  void unsafe_arena_set_allocated_create(
      ::greptime::v1::region::CreateRequest* create);
  ::greptime::v1::region::CreateRequest* unsafe_arena_release_create();

  // .greptime.v1.region.DropRequest drop = 6;
  bool has_drop() const;
  private:
  bool _internal_has_drop() const;
  public:
  void clear_drop();
  const ::greptime::v1::region::DropRequest& drop() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DropRequest* release_drop();
  ::greptime::v1::region::DropRequest* mutable_drop();
  void set_allocated_drop(::greptime::v1::region::DropRequest* drop);
  private:
  const ::greptime::v1::region::DropRequest& _internal_drop() const;
  ::greptime::v1::region::DropRequest* _internal_mutable_drop();
  public:
  void unsafe_arena_set_allocated_drop(
      ::greptime::v1::region::DropRequest* drop);
  ::greptime::v1::region::DropRequest* unsafe_arena_release_drop();

  // .greptime.v1.region.OpenRequest open = 7;
  bool has_open() const;
  private:
  bool _internal_has_open() const;
  public:
  void clear_open();
  const ::greptime::v1::region::OpenRequest& open() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::OpenRequest* release_open();
  ::greptime::v1::region::OpenRequest* mutable_open();
  void set_allocated_open(::greptime::v1::region::OpenRequest* open);
  private:
  const ::greptime::v1::region::OpenRequest& _internal_open() const;
  ::greptime::v1::region::OpenRequest* _internal_mutable_open();
  public:
  void unsafe_arena_set_allocated_open(
      ::greptime::v1::region::OpenRequest* open);
  ::greptime::v1::region::OpenRequest* unsafe_arena_release_open();

  // .greptime.v1.region.CloseRequest close = 8;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::greptime::v1::region::CloseRequest& close() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CloseRequest* release_close();
  ::greptime::v1::region::CloseRequest* mutable_close();
  void set_allocated_close(::greptime::v1::region::CloseRequest* close);
  private:
  const ::greptime::v1::region::CloseRequest& _internal_close() const;
  ::greptime::v1::region::CloseRequest* _internal_mutable_close();
  public:
  void unsafe_arena_set_allocated_close(
      ::greptime::v1::region::CloseRequest* close);
  ::greptime::v1::region::CloseRequest* unsafe_arena_release_close();

  // .greptime.v1.region.AlterRequest alter = 9;
  bool has_alter() const;
  private:
  bool _internal_has_alter() const;
  public:
  void clear_alter();
  const ::greptime::v1::region::AlterRequest& alter() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::AlterRequest* release_alter();
  ::greptime::v1::region::AlterRequest* mutable_alter();
  void set_allocated_alter(::greptime::v1::region::AlterRequest* alter);
  private:
  const ::greptime::v1::region::AlterRequest& _internal_alter() const;
  ::greptime::v1::region::AlterRequest* _internal_mutable_alter();
  public:
  void unsafe_arena_set_allocated_alter(
      ::greptime::v1::region::AlterRequest* alter);
  ::greptime::v1::region::AlterRequest* unsafe_arena_release_alter();

  // .greptime.v1.region.FlushRequest flush = 10;
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;
  public:
  void clear_flush();
  const ::greptime::v1::region::FlushRequest& flush() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::FlushRequest* release_flush();
  ::greptime::v1::region::FlushRequest* mutable_flush();
  void set_allocated_flush(::greptime::v1::region::FlushRequest* flush);
  private:
  const ::greptime::v1::region::FlushRequest& _internal_flush() const;
  ::greptime::v1::region::FlushRequest* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::greptime::v1::region::FlushRequest* flush);
  ::greptime::v1::region::FlushRequest* unsafe_arena_release_flush();

  // .greptime.v1.region.CompactRequest compact = 11;
  bool has_compact() const;
  private:
  bool _internal_has_compact() const;
  public:
  void clear_compact();
  const ::greptime::v1::region::CompactRequest& compact() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::CompactRequest* release_compact();
  ::greptime::v1::region::CompactRequest* mutable_compact();
  void set_allocated_compact(::greptime::v1::region::CompactRequest* compact);
  private:
  const ::greptime::v1::region::CompactRequest& _internal_compact() const;
  ::greptime::v1::region::CompactRequest* _internal_mutable_compact();
  public:
  void unsafe_arena_set_allocated_compact(
      ::greptime::v1::region::CompactRequest* compact);
  ::greptime::v1::region::CompactRequest* unsafe_arena_release_compact();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionRequest)
 private:
  class _Internal;
  void set_has_inserts();
  void set_has_deletes();
  void set_has_create();
  void set_has_drop();
  void set_has_open();
  void set_has_close();
  void set_has_alter();
  void set_has_flush();
  void set_has_compact();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::region::RegionRequestHeader* header_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::region::InsertRequests* inserts_;
      ::greptime::v1::region::DeleteRequests* deletes_;
      ::greptime::v1::region::CreateRequest* create_;
      ::greptime::v1::region::DropRequest* drop_;
      ::greptime::v1::region::OpenRequest* open_;
      ::greptime::v1::region::CloseRequest* close_;
      ::greptime::v1::region::AlterRequest* alter_;
      ::greptime::v1::region::FlushRequest* flush_;
      ::greptime::v1::region::CompactRequest* compact_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class RegionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.RegionResponse) */ {
 public:
  inline RegionResponse() : RegionResponse(nullptr) {}
  ~RegionResponse() override;
  explicit PROTOBUF_CONSTEXPR RegionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionResponse(const RegionResponse& from);
  RegionResponse(RegionResponse&& from) noexcept
    : RegionResponse() {
    *this = ::std::move(from);
  }

  inline RegionResponse& operator=(const RegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionResponse& operator=(RegionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionResponse* internal_default_instance() {
    return reinterpret_cast<const RegionResponse*>(
               &_RegionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegionResponse& a, RegionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegionResponse& from) {
    RegionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.RegionResponse";
  }
  protected:
  explicit RegionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kAffectedRowsFieldNumber = 2,
  };
  // .greptime.v1.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::ResponseHeader* release_header();
  ::greptime::v1::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::ResponseHeader* header);
  private:
  const ::greptime::v1::ResponseHeader& _internal_header() const;
  ::greptime::v1::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::ResponseHeader* header);
  ::greptime::v1::ResponseHeader* unsafe_arena_release_header();

  // uint64 affected_rows = 2;
  void clear_affected_rows();
  uint64_t affected_rows() const;
  void set_affected_rows(uint64_t value);
  private:
  uint64_t _internal_affected_rows() const;
  void _internal_set_affected_rows(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.RegionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::ResponseHeader* header_;
    uint64_t affected_rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.InsertRequests) */ {
 public:
  inline InsertRequests() : InsertRequests(nullptr) {}
  ~InsertRequests() override;
  explicit PROTOBUF_CONSTEXPR InsertRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequests(const InsertRequests& from);
  InsertRequests(InsertRequests&& from) noexcept
    : InsertRequests() {
    *this = ::std::move(from);
  }

  inline InsertRequests& operator=(const InsertRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequests& operator=(InsertRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequests* internal_default_instance() {
    return reinterpret_cast<const InsertRequests*>(
               &_InsertRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InsertRequests& a, InsertRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequests& from) {
    InsertRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.InsertRequests";
  }
  protected:
  explicit InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.InsertRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::InsertRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::InsertRequest& _internal_requests(int index) const;
  ::greptime::v1::region::InsertRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::InsertRequest& requests(int index) const;
  ::greptime::v1::region::InsertRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.InsertRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DeleteRequests) */ {
 public:
  inline DeleteRequests() : DeleteRequests(nullptr) {}
  ~DeleteRequests() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequests(const DeleteRequests& from);
  DeleteRequests(DeleteRequests&& from) noexcept
    : DeleteRequests() {
    *this = ::std::move(from);
  }

  inline DeleteRequests& operator=(const DeleteRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequests& operator=(DeleteRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequests* internal_default_instance() {
    return reinterpret_cast<const DeleteRequests*>(
               &_DeleteRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteRequests& a, DeleteRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequests& from) {
    DeleteRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DeleteRequests";
  }
  protected:
  explicit DeleteRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.DeleteRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::region::DeleteRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::region::DeleteRequest& _internal_requests(int index) const;
  ::greptime::v1::region::DeleteRequest* _internal_add_requests();
  public:
  const ::greptime::v1::region::DeleteRequest& requests(int index) const;
  ::greptime::v1::region::DeleteRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DeleteRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .greptime.v1.Rows rows = 2;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  const ::greptime::v1::Rows& rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::Rows* release_rows();
  ::greptime::v1::Rows* mutable_rows();
  void set_allocated_rows(::greptime::v1::Rows* rows);
  private:
  const ::greptime::v1::Rows& _internal_rows() const;
  ::greptime::v1::Rows* _internal_mutable_rows();
  public:
  void unsafe_arena_set_allocated_rows(
      ::greptime::v1::Rows* rows);
  ::greptime::v1::Rows* unsafe_arena_release_rows();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Rows* rows_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .greptime.v1.Rows rows = 2;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  const ::greptime::v1::Rows& rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::Rows* release_rows();
  ::greptime::v1::Rows* mutable_rows();
  void set_allocated_rows(::greptime::v1::Rows* rows);
  private:
  const ::greptime::v1::Rows& _internal_rows() const;
  ::greptime::v1::Rows* _internal_mutable_rows();
  public:
  void unsafe_arena_set_allocated_rows(
      ::greptime::v1::Rows* rows);
  ::greptime::v1::Rows* unsafe_arena_release_rows();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Rows* rows_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class QueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.QueryRequest) */ {
 public:
  inline QueryRequest() : QueryRequest(nullptr) {}
  ~QueryRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRequest(const QueryRequest& from);
  QueryRequest(QueryRequest&& from) noexcept
    : QueryRequest() {
    *this = ::std::move(from);
  }

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRequest& operator=(QueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRequest*>(
               &_QueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryRequest& a, QueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRequest& from) {
    QueryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.QueryRequest";
  }
  protected:
  explicit QueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // bytes plan = 2;
  void clear_plan();
  const std::string& plan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plan();
  PROTOBUF_NODISCARD std::string* release_plan();
  void set_allocated_plan(std::string* plan);
  private:
  const std::string& _internal_plan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan(const std::string& value);
  std::string* _internal_mutable_plan();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.QueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateRequest_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateRequest_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateRequest_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateRequest_OptionsEntry_DoNotUse& other);
  static const CreateRequest_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateRequest_OptionsEntry_DoNotUse*>(&_CreateRequest_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.CreateRequest.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.CreateRequest.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};

// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRequest& from) {
    CreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 3,
    kPrimaryKeyFieldNumber = 4,
    kOptionsFieldNumber = 8,
    kEngineFieldNumber = 2,
    kCatalogFieldNumber = 6,
    kSchemaFieldNumber = 7,
    kRegionIdFieldNumber = 1,
    kCreateIfNotExistsFieldNumber = 5,
  };
  // repeated .greptime.v1.region.ColumnDef column_defs = 3;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::greptime::v1::region::ColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::ColumnDef >*
      mutable_column_defs();
  private:
  const ::greptime::v1::region::ColumnDef& _internal_column_defs(int index) const;
  ::greptime::v1::region::ColumnDef* _internal_add_column_defs();
  public:
  const ::greptime::v1::region::ColumnDef& column_defs(int index) const;
  ::greptime::v1::region::ColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::ColumnDef >&
      column_defs() const;

  // repeated uint32 primary_key = 4;
  int primary_key_size() const;
  private:
  int _internal_primary_key_size() const;
  public:
  void clear_primary_key();
  private:
  uint32_t _internal_primary_key(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_primary_key() const;
  void _internal_add_primary_key(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_primary_key();
  public:
  uint32_t primary_key(int index) const;
  void set_primary_key(int index, uint32_t value);
  void add_primary_key(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      primary_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_primary_key();

  // map<string, string> options = 8;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string engine = 2;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // string catalog = 6;
  void clear_catalog();
  const std::string& catalog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog();
  PROTOBUF_NODISCARD std::string* release_catalog();
  void set_allocated_catalog(std::string* catalog);
  private:
  const std::string& _internal_catalog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();
  public:

  // string schema = 7;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // bool create_if_not_exists = 5;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::ColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > primary_key_;
    mutable std::atomic<int> _primary_key_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateRequest_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    uint64_t region_id_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropRequest) */ {
 public:
  inline DropRequest() : DropRequest(nullptr) {}
  ~DropRequest() override;
  explicit PROTOBUF_CONSTEXPR DropRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropRequest(const DropRequest& from);
  DropRequest(DropRequest&& from) noexcept
    : DropRequest() {
    *this = ::std::move(from);
  }

  inline DropRequest& operator=(const DropRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropRequest& operator=(DropRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropRequest* internal_default_instance() {
    return reinterpret_cast<const DropRequest*>(
               &_DropRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DropRequest& a, DropRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropRequest& from) {
    DropRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropRequest";
  }
  protected:
  explicit DropRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class OpenRequest_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OpenRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OpenRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OpenRequest_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OpenRequest_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OpenRequest_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OpenRequest_OptionsEntry_DoNotUse& other);
  static const OpenRequest_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OpenRequest_OptionsEntry_DoNotUse*>(&_OpenRequest_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.OpenRequest.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.region.OpenRequest.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};

// -------------------------------------------------------------------

class OpenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.OpenRequest) */ {
 public:
  inline OpenRequest() : OpenRequest(nullptr) {}
  ~OpenRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenRequest(const OpenRequest& from);
  OpenRequest(OpenRequest&& from) noexcept
    : OpenRequest() {
    *this = ::std::move(from);
  }

  inline OpenRequest& operator=(const OpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenRequest& operator=(OpenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenRequest* internal_default_instance() {
    return reinterpret_cast<const OpenRequest*>(
               &_OpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OpenRequest& a, OpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenRequest& from) {
    OpenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.OpenRequest";
  }
  protected:
  explicit OpenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 5,
    kEngineFieldNumber = 2,
    kCatalogFieldNumber = 3,
    kSchemaFieldNumber = 4,
    kRegionIdFieldNumber = 1,
  };
  // map<string, string> options = 5;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string engine = 2;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // string catalog = 3;
  void clear_catalog();
  const std::string& catalog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog();
  PROTOBUF_NODISCARD std::string* release_catalog();
  void set_allocated_catalog(std::string* catalog);
  private:
  const std::string& _internal_catalog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();
  public:

  // string schema = 4;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.OpenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OpenRequest_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CloseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CloseRequest) */ {
 public:
  inline CloseRequest() : CloseRequest(nullptr) {}
  ~CloseRequest() override;
  explicit PROTOBUF_CONSTEXPR CloseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseRequest(const CloseRequest& from);
  CloseRequest(CloseRequest&& from) noexcept
    : CloseRequest() {
    *this = ::std::move(from);
  }

  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
               &_CloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CloseRequest& a, CloseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CloseRequest& from) {
    CloseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CloseRequest";
  }
  protected:
  explicit CloseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.CloseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AlterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AlterRequest) */ {
 public:
  inline AlterRequest() : AlterRequest(nullptr) {}
  ~AlterRequest() override;
  explicit PROTOBUF_CONSTEXPR AlterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterRequest(const AlterRequest& from);
  AlterRequest(AlterRequest&& from) noexcept
    : AlterRequest() {
    *this = ::std::move(from);
  }

  inline AlterRequest& operator=(const AlterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterRequest& operator=(AlterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterRequest& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kAddColumns = 2,
    kDropColumns = 3,
    KIND_NOT_SET = 0,
  };

  static inline const AlterRequest* internal_default_instance() {
    return reinterpret_cast<const AlterRequest*>(
               &_AlterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AlterRequest& a, AlterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlterRequest& from) {
    AlterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AlterRequest";
  }
  protected:
  explicit AlterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kSchemaVersionFieldNumber = 4,
    kAddColumnsFieldNumber = 2,
    kDropColumnsFieldNumber = 3,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // uint64 schema_version = 4;
  void clear_schema_version();
  uint64_t schema_version() const;
  void set_schema_version(uint64_t value);
  private:
  uint64_t _internal_schema_version() const;
  void _internal_set_schema_version(uint64_t value);
  public:

  // .greptime.v1.region.AddColumns add_columns = 2;
  bool has_add_columns() const;
  private:
  bool _internal_has_add_columns() const;
  public:
  void clear_add_columns();
  const ::greptime::v1::region::AddColumns& add_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::AddColumns* release_add_columns();
  ::greptime::v1::region::AddColumns* mutable_add_columns();
  void set_allocated_add_columns(::greptime::v1::region::AddColumns* add_columns);
  private:
  const ::greptime::v1::region::AddColumns& _internal_add_columns() const;
  ::greptime::v1::region::AddColumns* _internal_mutable_add_columns();
  public:
  void unsafe_arena_set_allocated_add_columns(
      ::greptime::v1::region::AddColumns* add_columns);
  ::greptime::v1::region::AddColumns* unsafe_arena_release_add_columns();

  // .greptime.v1.region.DropColumns drop_columns = 3;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::greptime::v1::region::DropColumns& drop_columns() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::DropColumns* release_drop_columns();
  ::greptime::v1::region::DropColumns* mutable_drop_columns();
  void set_allocated_drop_columns(::greptime::v1::region::DropColumns* drop_columns);
  private:
  const ::greptime::v1::region::DropColumns& _internal_drop_columns() const;
  ::greptime::v1::region::DropColumns* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::greptime::v1::region::DropColumns* drop_columns);
  ::greptime::v1::region::DropColumns* unsafe_arena_release_drop_columns();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.region.AlterRequest)
 private:
  class _Internal;
  void set_has_add_columns();
  void set_has_drop_columns();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    uint64_t schema_version_;
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::region::AddColumns* add_columns_;
      ::greptime::v1::region::DropColumns* drop_columns_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AddColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AddColumns) */ {
 public:
  inline AddColumns() : AddColumns(nullptr) {}
  ~AddColumns() override;
  explicit PROTOBUF_CONSTEXPR AddColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumns(const AddColumns& from);
  AddColumns(AddColumns&& from) noexcept
    : AddColumns() {
    *this = ::std::move(from);
  }

  inline AddColumns& operator=(const AddColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumns& operator=(AddColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumns* internal_default_instance() {
    return reinterpret_cast<const AddColumns*>(
               &_AddColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AddColumns& a, AddColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumns& from) {
    AddColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AddColumns";
  }
  protected:
  explicit AddColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.AddColumn add_columns = 1;
  int add_columns_size() const;
  private:
  int _internal_add_columns_size() const;
  public:
  void clear_add_columns();
  ::greptime::v1::region::AddColumn* mutable_add_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >*
      mutable_add_columns();
  private:
  const ::greptime::v1::region::AddColumn& _internal_add_columns(int index) const;
  ::greptime::v1::region::AddColumn* _internal_add_add_columns();
  public:
  const ::greptime::v1::region::AddColumn& add_columns(int index) const;
  ::greptime::v1::region::AddColumn* add_add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >&
      add_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.AddColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn > add_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropColumns) */ {
 public:
  inline DropColumns() : DropColumns(nullptr) {}
  ~DropColumns() override;
  explicit PROTOBUF_CONSTEXPR DropColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumns(const DropColumns& from);
  DropColumns(DropColumns&& from) noexcept
    : DropColumns() {
    *this = ::std::move(from);
  }

  inline DropColumns& operator=(const DropColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumns& operator=(DropColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumns* internal_default_instance() {
    return reinterpret_cast<const DropColumns*>(
               &_DropColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DropColumns& a, DropColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumns& from) {
    DropColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropColumns";
  }
  protected:
  explicit DropColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropColumnsFieldNumber = 1,
  };
  // repeated .greptime.v1.region.DropColumn drop_columns = 1;
  int drop_columns_size() const;
  private:
  int _internal_drop_columns_size() const;
  public:
  void clear_drop_columns();
  ::greptime::v1::region::DropColumn* mutable_drop_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >*
      mutable_drop_columns();
  private:
  const ::greptime::v1::region::DropColumn& _internal_drop_columns(int index) const;
  ::greptime::v1::region::DropColumn* _internal_add_drop_columns();
  public:
  const ::greptime::v1::region::DropColumn& drop_columns(int index) const;
  ::greptime::v1::region::DropColumn* add_drop_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >&
      drop_columns() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn > drop_columns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class AddColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.AddColumn) */ {
 public:
  inline AddColumn() : AddColumn(nullptr) {}
  ~AddColumn() override;
  explicit PROTOBUF_CONSTEXPR AddColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddColumn(const AddColumn& from);
  AddColumn(AddColumn&& from) noexcept
    : AddColumn() {
    *this = ::std::move(from);
  }

  inline AddColumn& operator=(const AddColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddColumn& operator=(AddColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddColumn* internal_default_instance() {
    return reinterpret_cast<const AddColumn*>(
               &_AddColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AddColumn& a, AddColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AddColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddColumn& from) {
    AddColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.AddColumn";
  }
  protected:
  explicit AddColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefFieldNumber = 1,
    kLocationFieldNumber = 3,
    kIsKeyFieldNumber = 2,
  };
  // .greptime.v1.region.ColumnDef column_def = 1;
  bool has_column_def() const;
  private:
  bool _internal_has_column_def() const;
  public:
  void clear_column_def();
  const ::greptime::v1::region::ColumnDef& column_def() const;
  PROTOBUF_NODISCARD ::greptime::v1::region::ColumnDef* release_column_def();
  ::greptime::v1::region::ColumnDef* mutable_column_def();
  void set_allocated_column_def(::greptime::v1::region::ColumnDef* column_def);
  private:
  const ::greptime::v1::region::ColumnDef& _internal_column_def() const;
  ::greptime::v1::region::ColumnDef* _internal_mutable_column_def();
  public:
  void unsafe_arena_set_allocated_column_def(
      ::greptime::v1::region::ColumnDef* column_def);
  ::greptime::v1::region::ColumnDef* unsafe_arena_release_column_def();

  // .greptime.v1.AddColumnLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::greptime::v1::AddColumnLocation& location() const;
  PROTOBUF_NODISCARD ::greptime::v1::AddColumnLocation* release_location();
  ::greptime::v1::AddColumnLocation* mutable_location();
  void set_allocated_location(::greptime::v1::AddColumnLocation* location);
  private:
  const ::greptime::v1::AddColumnLocation& _internal_location() const;
  ::greptime::v1::AddColumnLocation* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::greptime::v1::AddColumnLocation* location);
  ::greptime::v1::AddColumnLocation* unsafe_arena_release_location();

  // bool is_key = 2;
  void clear_is_key();
  bool is_key() const;
  void set_is_key(bool value);
  private:
  bool _internal_is_key() const;
  void _internal_set_is_key(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.AddColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::region::ColumnDef* column_def_;
    ::greptime::v1::AddColumnLocation* location_;
    bool is_key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.DropColumn) */ {
 public:
  inline DropColumn() : DropColumn(nullptr) {}
  ~DropColumn() override;
  explicit PROTOBUF_CONSTEXPR DropColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumn(const DropColumn& from);
  DropColumn(DropColumn&& from) noexcept
    : DropColumn() {
    *this = ::std::move(from);
  }

  inline DropColumn& operator=(const DropColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumn& operator=(DropColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumn* internal_default_instance() {
    return reinterpret_cast<const DropColumn*>(
               &_DropColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DropColumn& a, DropColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropColumn& from) {
    DropColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.DropColumn";
  }
  protected:
  explicit DropColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.DropColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.FlushRequest) */ {
 public:
  inline FlushRequest() : FlushRequest(nullptr) {}
  ~FlushRequest() override;
  explicit PROTOBUF_CONSTEXPR FlushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushRequest(const FlushRequest& from);
  FlushRequest(FlushRequest&& from) noexcept
    : FlushRequest() {
    *this = ::std::move(from);
  }

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushRequest& operator=(FlushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushRequest* internal_default_instance() {
    return reinterpret_cast<const FlushRequest*>(
               &_FlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FlushRequest& a, FlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushRequest& from) {
    FlushRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.FlushRequest";
  }
  protected:
  explicit FlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.FlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CompactRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.CompactRequest) */ {
 public:
  inline CompactRequest() : CompactRequest(nullptr) {}
  ~CompactRequest() override;
  explicit PROTOBUF_CONSTEXPR CompactRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactRequest(const CompactRequest& from);
  CompactRequest(CompactRequest&& from) noexcept
    : CompactRequest() {
    *this = ::std::move(from);
  }

  inline CompactRequest& operator=(const CompactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactRequest& operator=(CompactRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompactRequest* internal_default_instance() {
    return reinterpret_cast<const CompactRequest*>(
               &_CompactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CompactRequest& a, CompactRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompactRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompactRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompactRequest& from) {
    CompactRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.CompactRequest";
  }
  protected:
  explicit CompactRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.CompactRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// -------------------------------------------------------------------

class ColumnDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.region.ColumnDef) */ {
 public:
  inline ColumnDef() : ColumnDef(nullptr) {}
  ~ColumnDef() override;
  explicit PROTOBUF_CONSTEXPR ColumnDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDef(const ColumnDef& from);
  ColumnDef(ColumnDef&& from) noexcept
    : ColumnDef() {
    *this = ::std::move(from);
  }

  inline ColumnDef& operator=(const ColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDef& operator=(ColumnDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDef* internal_default_instance() {
    return reinterpret_cast<const ColumnDef*>(
               &_ColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ColumnDef& a, ColumnDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDef& from) {
    ColumnDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.region.ColumnDef";
  }
  protected:
  explicit ColumnDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultConstraintFieldNumber = 5,
    kColumnIdFieldNumber = 2,
    kDatatypeFieldNumber = 3,
    kIsNullableFieldNumber = 4,
    kSemanticTypeFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes default_constraint = 5;
  void clear_default_constraint();
  const std::string& default_constraint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_constraint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_constraint();
  PROTOBUF_NODISCARD std::string* release_default_constraint();
  void set_allocated_default_constraint(std::string* default_constraint);
  private:
  const std::string& _internal_default_constraint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_constraint(const std::string& value);
  std::string* _internal_mutable_default_constraint();
  public:

  // uint32 column_id = 2;
  void clear_column_id();
  uint32_t column_id() const;
  void set_column_id(uint32_t value);
  private:
  uint32_t _internal_column_id() const;
  void _internal_set_column_id(uint32_t value);
  public:

  // .greptime.v1.ColumnDataType datatype = 3;
  void clear_datatype();
  ::greptime::v1::ColumnDataType datatype() const;
  void set_datatype(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_datatype() const;
  void _internal_set_datatype(::greptime::v1::ColumnDataType value);
  public:

  // bool is_nullable = 4;
  void clear_is_nullable();
  bool is_nullable() const;
  void set_is_nullable(bool value);
  private:
  bool _internal_is_nullable() const;
  void _internal_set_is_nullable(bool value);
  public:

  // .greptime.v1.SemanticType semantic_type = 6;
  void clear_semantic_type();
  ::greptime::v1::SemanticType semantic_type() const;
  void set_semantic_type(::greptime::v1::SemanticType value);
  private:
  ::greptime::v1::SemanticType _internal_semantic_type() const;
  void _internal_set_semantic_type(::greptime::v1::SemanticType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.region.ColumnDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_constraint_;
    uint32_t column_id_;
    int datatype_;
    bool is_nullable_;
    int semantic_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fregion_2fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegionRequestHeader

// uint64 trace_id = 1;
inline void RegionRequestHeader::clear_trace_id() {
  _impl_.trace_id_ = uint64_t{0u};
}
inline uint64_t RegionRequestHeader::_internal_trace_id() const {
  return _impl_.trace_id_;
}
inline uint64_t RegionRequestHeader::trace_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequestHeader.trace_id)
  return _internal_trace_id();
}
inline void RegionRequestHeader::_internal_set_trace_id(uint64_t value) {
  
  _impl_.trace_id_ = value;
}
inline void RegionRequestHeader::set_trace_id(uint64_t value) {
  _internal_set_trace_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.RegionRequestHeader.trace_id)
}

// uint64 span_id = 2;
inline void RegionRequestHeader::clear_span_id() {
  _impl_.span_id_ = uint64_t{0u};
}
inline uint64_t RegionRequestHeader::_internal_span_id() const {
  return _impl_.span_id_;
}
inline uint64_t RegionRequestHeader::span_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequestHeader.span_id)
  return _internal_span_id();
}
inline void RegionRequestHeader::_internal_set_span_id(uint64_t value) {
  
  _impl_.span_id_ = value;
}
inline void RegionRequestHeader::set_span_id(uint64_t value) {
  _internal_set_span_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.RegionRequestHeader.span_id)
}

// -------------------------------------------------------------------

// RegionRequest

// .greptime.v1.region.RegionRequestHeader header = 1;
inline bool RegionRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegionRequest::has_header() const {
  return _internal_has_header();
}
inline void RegionRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::greptime::v1::region::RegionRequestHeader& RegionRequest::_internal_header() const {
  const ::greptime::v1::region::RegionRequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::region::RegionRequestHeader&>(
      ::greptime::v1::region::_RegionRequestHeader_default_instance_);
}
inline const ::greptime::v1::region::RegionRequestHeader& RegionRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.header)
  return _internal_header();
}
inline void RegionRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::region::RegionRequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.header)
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::release_header() {
  
  ::greptime::v1::region::RegionRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.header)
  
  ::greptime::v1::region::RegionRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::region::RegionRequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::region::RegionRequestHeader* RegionRequest::mutable_header() {
  ::greptime::v1::region::RegionRequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.header)
  return _msg;
}
inline void RegionRequest::set_allocated_header(::greptime::v1::region::RegionRequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionRequest.header)
}

// .greptime.v1.region.InsertRequests inserts = 3;
inline bool RegionRequest::_internal_has_inserts() const {
  return body_case() == kInserts;
}
inline bool RegionRequest::has_inserts() const {
  return _internal_has_inserts();
}
inline void RegionRequest::set_has_inserts() {
  _impl_._oneof_case_[0] = kInserts;
}
inline void RegionRequest::clear_inserts() {
  if (_internal_has_inserts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.inserts_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::release_inserts() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.inserts)
  if (_internal_has_inserts()) {
    clear_has_body();
    ::greptime::v1::region::InsertRequests* temp = _impl_.body_.inserts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.inserts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::InsertRequests& RegionRequest::_internal_inserts() const {
  return _internal_has_inserts()
      ? *_impl_.body_.inserts_
      : reinterpret_cast< ::greptime::v1::region::InsertRequests&>(::greptime::v1::region::_InsertRequests_default_instance_);
}
inline const ::greptime::v1::region::InsertRequests& RegionRequest::inserts() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.inserts)
  return _internal_inserts();
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::unsafe_arena_release_inserts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.inserts)
  if (_internal_has_inserts()) {
    clear_has_body();
    ::greptime::v1::region::InsertRequests* temp = _impl_.body_.inserts_;
    _impl_.body_.inserts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_inserts(::greptime::v1::region::InsertRequests* inserts) {
  clear_body();
  if (inserts) {
    set_has_inserts();
    _impl_.body_.inserts_ = inserts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.inserts)
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::_internal_mutable_inserts() {
  if (!_internal_has_inserts()) {
    clear_body();
    set_has_inserts();
    _impl_.body_.inserts_ = CreateMaybeMessage< ::greptime::v1::region::InsertRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.inserts_;
}
inline ::greptime::v1::region::InsertRequests* RegionRequest::mutable_inserts() {
  ::greptime::v1::region::InsertRequests* _msg = _internal_mutable_inserts();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.inserts)
  return _msg;
}

// .greptime.v1.region.DeleteRequests deletes = 4;
inline bool RegionRequest::_internal_has_deletes() const {
  return body_case() == kDeletes;
}
inline bool RegionRequest::has_deletes() const {
  return _internal_has_deletes();
}
inline void RegionRequest::set_has_deletes() {
  _impl_._oneof_case_[0] = kDeletes;
}
inline void RegionRequest::clear_deletes() {
  if (_internal_has_deletes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.deletes_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::release_deletes() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.deletes)
  if (_internal_has_deletes()) {
    clear_has_body();
    ::greptime::v1::region::DeleteRequests* temp = _impl_.body_.deletes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.deletes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DeleteRequests& RegionRequest::_internal_deletes() const {
  return _internal_has_deletes()
      ? *_impl_.body_.deletes_
      : reinterpret_cast< ::greptime::v1::region::DeleteRequests&>(::greptime::v1::region::_DeleteRequests_default_instance_);
}
inline const ::greptime::v1::region::DeleteRequests& RegionRequest::deletes() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.deletes)
  return _internal_deletes();
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::unsafe_arena_release_deletes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.deletes)
  if (_internal_has_deletes()) {
    clear_has_body();
    ::greptime::v1::region::DeleteRequests* temp = _impl_.body_.deletes_;
    _impl_.body_.deletes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_deletes(::greptime::v1::region::DeleteRequests* deletes) {
  clear_body();
  if (deletes) {
    set_has_deletes();
    _impl_.body_.deletes_ = deletes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.deletes)
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::_internal_mutable_deletes() {
  if (!_internal_has_deletes()) {
    clear_body();
    set_has_deletes();
    _impl_.body_.deletes_ = CreateMaybeMessage< ::greptime::v1::region::DeleteRequests >(GetArenaForAllocation());
  }
  return _impl_.body_.deletes_;
}
inline ::greptime::v1::region::DeleteRequests* RegionRequest::mutable_deletes() {
  ::greptime::v1::region::DeleteRequests* _msg = _internal_mutable_deletes();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.deletes)
  return _msg;
}

// .greptime.v1.region.CreateRequest create = 5;
inline bool RegionRequest::_internal_has_create() const {
  return body_case() == kCreate;
}
inline bool RegionRequest::has_create() const {
  return _internal_has_create();
}
inline void RegionRequest::set_has_create() {
  _impl_._oneof_case_[0] = kCreate;
}
inline void RegionRequest::clear_create() {
  if (_internal_has_create()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.create_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::release_create() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::region::CreateRequest* temp = _impl_.body_.create_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CreateRequest& RegionRequest::_internal_create() const {
  return _internal_has_create()
      ? *_impl_.body_.create_
      : reinterpret_cast< ::greptime::v1::region::CreateRequest&>(::greptime::v1::region::_CreateRequest_default_instance_);
}
inline const ::greptime::v1::region::CreateRequest& RegionRequest::create() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.create)
  return _internal_create();
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::unsafe_arena_release_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::region::CreateRequest* temp = _impl_.body_.create_;
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_create(::greptime::v1::region::CreateRequest* create) {
  clear_body();
  if (create) {
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.create)
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::_internal_mutable_create() {
  if (!_internal_has_create()) {
    clear_body();
    set_has_create();
    _impl_.body_.create_ = CreateMaybeMessage< ::greptime::v1::region::CreateRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.create_;
}
inline ::greptime::v1::region::CreateRequest* RegionRequest::mutable_create() {
  ::greptime::v1::region::CreateRequest* _msg = _internal_mutable_create();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.create)
  return _msg;
}

// .greptime.v1.region.DropRequest drop = 6;
inline bool RegionRequest::_internal_has_drop() const {
  return body_case() == kDrop;
}
inline bool RegionRequest::has_drop() const {
  return _internal_has_drop();
}
inline void RegionRequest::set_has_drop() {
  _impl_._oneof_case_[0] = kDrop;
}
inline void RegionRequest::clear_drop() {
  if (_internal_has_drop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.drop_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::DropRequest* RegionRequest::release_drop() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.drop)
  if (_internal_has_drop()) {
    clear_has_body();
    ::greptime::v1::region::DropRequest* temp = _impl_.body_.drop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DropRequest& RegionRequest::_internal_drop() const {
  return _internal_has_drop()
      ? *_impl_.body_.drop_
      : reinterpret_cast< ::greptime::v1::region::DropRequest&>(::greptime::v1::region::_DropRequest_default_instance_);
}
inline const ::greptime::v1::region::DropRequest& RegionRequest::drop() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.drop)
  return _internal_drop();
}
inline ::greptime::v1::region::DropRequest* RegionRequest::unsafe_arena_release_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.drop)
  if (_internal_has_drop()) {
    clear_has_body();
    ::greptime::v1::region::DropRequest* temp = _impl_.body_.drop_;
    _impl_.body_.drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_drop(::greptime::v1::region::DropRequest* drop) {
  clear_body();
  if (drop) {
    set_has_drop();
    _impl_.body_.drop_ = drop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.drop)
}
inline ::greptime::v1::region::DropRequest* RegionRequest::_internal_mutable_drop() {
  if (!_internal_has_drop()) {
    clear_body();
    set_has_drop();
    _impl_.body_.drop_ = CreateMaybeMessage< ::greptime::v1::region::DropRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.drop_;
}
inline ::greptime::v1::region::DropRequest* RegionRequest::mutable_drop() {
  ::greptime::v1::region::DropRequest* _msg = _internal_mutable_drop();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.drop)
  return _msg;
}

// .greptime.v1.region.OpenRequest open = 7;
inline bool RegionRequest::_internal_has_open() const {
  return body_case() == kOpen;
}
inline bool RegionRequest::has_open() const {
  return _internal_has_open();
}
inline void RegionRequest::set_has_open() {
  _impl_._oneof_case_[0] = kOpen;
}
inline void RegionRequest::clear_open() {
  if (_internal_has_open()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.open_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::release_open() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.open)
  if (_internal_has_open()) {
    clear_has_body();
    ::greptime::v1::region::OpenRequest* temp = _impl_.body_.open_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::OpenRequest& RegionRequest::_internal_open() const {
  return _internal_has_open()
      ? *_impl_.body_.open_
      : reinterpret_cast< ::greptime::v1::region::OpenRequest&>(::greptime::v1::region::_OpenRequest_default_instance_);
}
inline const ::greptime::v1::region::OpenRequest& RegionRequest::open() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.open)
  return _internal_open();
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::unsafe_arena_release_open() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.open)
  if (_internal_has_open()) {
    clear_has_body();
    ::greptime::v1::region::OpenRequest* temp = _impl_.body_.open_;
    _impl_.body_.open_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_open(::greptime::v1::region::OpenRequest* open) {
  clear_body();
  if (open) {
    set_has_open();
    _impl_.body_.open_ = open;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.open)
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::_internal_mutable_open() {
  if (!_internal_has_open()) {
    clear_body();
    set_has_open();
    _impl_.body_.open_ = CreateMaybeMessage< ::greptime::v1::region::OpenRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.open_;
}
inline ::greptime::v1::region::OpenRequest* RegionRequest::mutable_open() {
  ::greptime::v1::region::OpenRequest* _msg = _internal_mutable_open();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.open)
  return _msg;
}

// .greptime.v1.region.CloseRequest close = 8;
inline bool RegionRequest::_internal_has_close() const {
  return body_case() == kClose;
}
inline bool RegionRequest::has_close() const {
  return _internal_has_close();
}
inline void RegionRequest::set_has_close() {
  _impl_._oneof_case_[0] = kClose;
}
inline void RegionRequest::clear_close() {
  if (_internal_has_close()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.close_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::release_close() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.close)
  if (_internal_has_close()) {
    clear_has_body();
    ::greptime::v1::region::CloseRequest* temp = _impl_.body_.close_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CloseRequest& RegionRequest::_internal_close() const {
  return _internal_has_close()
      ? *_impl_.body_.close_
      : reinterpret_cast< ::greptime::v1::region::CloseRequest&>(::greptime::v1::region::_CloseRequest_default_instance_);
}
inline const ::greptime::v1::region::CloseRequest& RegionRequest::close() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.close)
  return _internal_close();
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.close)
  if (_internal_has_close()) {
    clear_has_body();
    ::greptime::v1::region::CloseRequest* temp = _impl_.body_.close_;
    _impl_.body_.close_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_close(::greptime::v1::region::CloseRequest* close) {
  clear_body();
  if (close) {
    set_has_close();
    _impl_.body_.close_ = close;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.close)
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::_internal_mutable_close() {
  if (!_internal_has_close()) {
    clear_body();
    set_has_close();
    _impl_.body_.close_ = CreateMaybeMessage< ::greptime::v1::region::CloseRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.close_;
}
inline ::greptime::v1::region::CloseRequest* RegionRequest::mutable_close() {
  ::greptime::v1::region::CloseRequest* _msg = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.close)
  return _msg;
}

// .greptime.v1.region.AlterRequest alter = 9;
inline bool RegionRequest::_internal_has_alter() const {
  return body_case() == kAlter;
}
inline bool RegionRequest::has_alter() const {
  return _internal_has_alter();
}
inline void RegionRequest::set_has_alter() {
  _impl_._oneof_case_[0] = kAlter;
}
inline void RegionRequest::clear_alter() {
  if (_internal_has_alter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.alter_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::release_alter() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.alter)
  if (_internal_has_alter()) {
    clear_has_body();
    ::greptime::v1::region::AlterRequest* temp = _impl_.body_.alter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::AlterRequest& RegionRequest::_internal_alter() const {
  return _internal_has_alter()
      ? *_impl_.body_.alter_
      : reinterpret_cast< ::greptime::v1::region::AlterRequest&>(::greptime::v1::region::_AlterRequest_default_instance_);
}
inline const ::greptime::v1::region::AlterRequest& RegionRequest::alter() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.alter)
  return _internal_alter();
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::unsafe_arena_release_alter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.alter)
  if (_internal_has_alter()) {
    clear_has_body();
    ::greptime::v1::region::AlterRequest* temp = _impl_.body_.alter_;
    _impl_.body_.alter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_alter(::greptime::v1::region::AlterRequest* alter) {
  clear_body();
  if (alter) {
    set_has_alter();
    _impl_.body_.alter_ = alter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.alter)
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::_internal_mutable_alter() {
  if (!_internal_has_alter()) {
    clear_body();
    set_has_alter();
    _impl_.body_.alter_ = CreateMaybeMessage< ::greptime::v1::region::AlterRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.alter_;
}
inline ::greptime::v1::region::AlterRequest* RegionRequest::mutable_alter() {
  ::greptime::v1::region::AlterRequest* _msg = _internal_mutable_alter();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.alter)
  return _msg;
}

// .greptime.v1.region.FlushRequest flush = 10;
inline bool RegionRequest::_internal_has_flush() const {
  return body_case() == kFlush;
}
inline bool RegionRequest::has_flush() const {
  return _internal_has_flush();
}
inline void RegionRequest::set_has_flush() {
  _impl_._oneof_case_[0] = kFlush;
}
inline void RegionRequest::clear_flush() {
  if (_internal_has_flush()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.flush_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::release_flush() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.flush)
  if (_internal_has_flush()) {
    clear_has_body();
    ::greptime::v1::region::FlushRequest* temp = _impl_.body_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::FlushRequest& RegionRequest::_internal_flush() const {
  return _internal_has_flush()
      ? *_impl_.body_.flush_
      : reinterpret_cast< ::greptime::v1::region::FlushRequest&>(::greptime::v1::region::_FlushRequest_default_instance_);
}
inline const ::greptime::v1::region::FlushRequest& RegionRequest::flush() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.flush)
  return _internal_flush();
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.flush)
  if (_internal_has_flush()) {
    clear_has_body();
    ::greptime::v1::region::FlushRequest* temp = _impl_.body_.flush_;
    _impl_.body_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_flush(::greptime::v1::region::FlushRequest* flush) {
  clear_body();
  if (flush) {
    set_has_flush();
    _impl_.body_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.flush)
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::_internal_mutable_flush() {
  if (!_internal_has_flush()) {
    clear_body();
    set_has_flush();
    _impl_.body_.flush_ = CreateMaybeMessage< ::greptime::v1::region::FlushRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.flush_;
}
inline ::greptime::v1::region::FlushRequest* RegionRequest::mutable_flush() {
  ::greptime::v1::region::FlushRequest* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.flush)
  return _msg;
}

// .greptime.v1.region.CompactRequest compact = 11;
inline bool RegionRequest::_internal_has_compact() const {
  return body_case() == kCompact;
}
inline bool RegionRequest::has_compact() const {
  return _internal_has_compact();
}
inline void RegionRequest::set_has_compact() {
  _impl_._oneof_case_[0] = kCompact;
}
inline void RegionRequest::clear_compact() {
  if (_internal_has_compact()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.compact_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::release_compact() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionRequest.compact)
  if (_internal_has_compact()) {
    clear_has_body();
    ::greptime::v1::region::CompactRequest* temp = _impl_.body_.compact_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.compact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::CompactRequest& RegionRequest::_internal_compact() const {
  return _internal_has_compact()
      ? *_impl_.body_.compact_
      : reinterpret_cast< ::greptime::v1::region::CompactRequest&>(::greptime::v1::region::_CompactRequest_default_instance_);
}
inline const ::greptime::v1::region::CompactRequest& RegionRequest::compact() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionRequest.compact)
  return _internal_compact();
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::unsafe_arena_release_compact() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.RegionRequest.compact)
  if (_internal_has_compact()) {
    clear_has_body();
    ::greptime::v1::region::CompactRequest* temp = _impl_.body_.compact_;
    _impl_.body_.compact_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegionRequest::unsafe_arena_set_allocated_compact(::greptime::v1::region::CompactRequest* compact) {
  clear_body();
  if (compact) {
    set_has_compact();
    _impl_.body_.compact_ = compact;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionRequest.compact)
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::_internal_mutable_compact() {
  if (!_internal_has_compact()) {
    clear_body();
    set_has_compact();
    _impl_.body_.compact_ = CreateMaybeMessage< ::greptime::v1::region::CompactRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.compact_;
}
inline ::greptime::v1::region::CompactRequest* RegionRequest::mutable_compact() {
  ::greptime::v1::region::CompactRequest* _msg = _internal_mutable_compact();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionRequest.compact)
  return _msg;
}

inline bool RegionRequest::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void RegionRequest::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline RegionRequest::BodyCase RegionRequest::body_case() const {
  return RegionRequest::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegionResponse

// .greptime.v1.ResponseHeader header = 1;
inline bool RegionResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RegionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::ResponseHeader& RegionResponse::_internal_header() const {
  const ::greptime::v1::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ResponseHeader&>(
      ::greptime::v1::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::ResponseHeader& RegionResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionResponse.header)
  return _internal_header();
}
inline void RegionResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.RegionResponse.header)
}
inline ::greptime::v1::ResponseHeader* RegionResponse::release_header() {
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ResponseHeader* RegionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.RegionResponse.header)
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::ResponseHeader* RegionResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::ResponseHeader* RegionResponse::mutable_header() {
  ::greptime::v1::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.RegionResponse.header)
  return _msg;
}
inline void RegionResponse::set_allocated_header(::greptime::v1::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.RegionResponse.header)
}

// uint64 affected_rows = 2;
inline void RegionResponse::clear_affected_rows() {
  _impl_.affected_rows_ = uint64_t{0u};
}
inline uint64_t RegionResponse::_internal_affected_rows() const {
  return _impl_.affected_rows_;
}
inline uint64_t RegionResponse::affected_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.RegionResponse.affected_rows)
  return _internal_affected_rows();
}
inline void RegionResponse::_internal_set_affected_rows(uint64_t value) {
  
  _impl_.affected_rows_ = value;
}
inline void RegionResponse::set_affected_rows(uint64_t value) {
  _internal_set_affected_rows(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.RegionResponse.affected_rows)
}

// -------------------------------------------------------------------

// InsertRequests

// repeated .greptime.v1.region.InsertRequest requests = 1;
inline int InsertRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int InsertRequests::requests_size() const {
  return _internal_requests_size();
}
inline void InsertRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::InsertRequest* InsertRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.InsertRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >*
InsertRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.InsertRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::InsertRequest& InsertRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::InsertRequest& InsertRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.InsertRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::InsertRequest* InsertRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::InsertRequest* InsertRequests::add_requests() {
  ::greptime::v1::region::InsertRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.InsertRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::InsertRequest >&
InsertRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.InsertRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// DeleteRequests

// repeated .greptime.v1.region.DeleteRequest requests = 1;
inline int DeleteRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int DeleteRequests::requests_size() const {
  return _internal_requests_size();
}
inline void DeleteRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::region::DeleteRequest* DeleteRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DeleteRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >*
DeleteRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.DeleteRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::region::DeleteRequest& DeleteRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::region::DeleteRequest& DeleteRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DeleteRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::region::DeleteRequest* DeleteRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::region::DeleteRequest* DeleteRequests::add_requests() {
  ::greptime::v1::region::DeleteRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.region.DeleteRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DeleteRequest >&
DeleteRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.DeleteRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// InsertRequest

// uint64 region_id = 1;
inline void InsertRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t InsertRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t InsertRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.InsertRequest.region_id)
  return _internal_region_id();
}
inline void InsertRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void InsertRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.InsertRequest.region_id)
}

// .greptime.v1.Rows rows = 2;
inline bool InsertRequest::_internal_has_rows() const {
  return this != internal_default_instance() && _impl_.rows_ != nullptr;
}
inline bool InsertRequest::has_rows() const {
  return _internal_has_rows();
}
inline const ::greptime::v1::Rows& InsertRequest::_internal_rows() const {
  const ::greptime::v1::Rows* p = _impl_.rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Rows&>(
      ::greptime::v1::_Rows_default_instance_);
}
inline const ::greptime::v1::Rows& InsertRequest::rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.InsertRequest.rows)
  return _internal_rows();
}
inline void InsertRequest::unsafe_arena_set_allocated_rows(
    ::greptime::v1::Rows* rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  _impl_.rows_ = rows;
  if (rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.InsertRequest.rows)
}
inline ::greptime::v1::Rows* InsertRequest::release_rows() {
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::unsafe_arena_release_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.InsertRequest.rows)
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::_internal_mutable_rows() {
  
  if (_impl_.rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Rows>(GetArenaForAllocation());
    _impl_.rows_ = p;
  }
  return _impl_.rows_;
}
inline ::greptime::v1::Rows* InsertRequest::mutable_rows() {
  ::greptime::v1::Rows* _msg = _internal_mutable_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.InsertRequest.rows)
  return _msg;
}
inline void InsertRequest::set_allocated_rows(::greptime::v1::Rows* rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  if (rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rows));
    if (message_arena != submessage_arena) {
      rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rows_ = rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.InsertRequest.rows)
}

// -------------------------------------------------------------------

// DeleteRequest

// uint64 region_id = 1;
inline void DeleteRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t DeleteRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t DeleteRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DeleteRequest.region_id)
  return _internal_region_id();
}
inline void DeleteRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void DeleteRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.DeleteRequest.region_id)
}

// .greptime.v1.Rows rows = 2;
inline bool DeleteRequest::_internal_has_rows() const {
  return this != internal_default_instance() && _impl_.rows_ != nullptr;
}
inline bool DeleteRequest::has_rows() const {
  return _internal_has_rows();
}
inline const ::greptime::v1::Rows& DeleteRequest::_internal_rows() const {
  const ::greptime::v1::Rows* p = _impl_.rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Rows&>(
      ::greptime::v1::_Rows_default_instance_);
}
inline const ::greptime::v1::Rows& DeleteRequest::rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DeleteRequest.rows)
  return _internal_rows();
}
inline void DeleteRequest::unsafe_arena_set_allocated_rows(
    ::greptime::v1::Rows* rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  _impl_.rows_ = rows;
  if (rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.DeleteRequest.rows)
}
inline ::greptime::v1::Rows* DeleteRequest::release_rows() {
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Rows* DeleteRequest::unsafe_arena_release_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.DeleteRequest.rows)
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::Rows* DeleteRequest::_internal_mutable_rows() {
  
  if (_impl_.rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Rows>(GetArenaForAllocation());
    _impl_.rows_ = p;
  }
  return _impl_.rows_;
}
inline ::greptime::v1::Rows* DeleteRequest::mutable_rows() {
  ::greptime::v1::Rows* _msg = _internal_mutable_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DeleteRequest.rows)
  return _msg;
}
inline void DeleteRequest::set_allocated_rows(::greptime::v1::Rows* rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  if (rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rows));
    if (message_arena != submessage_arena) {
      rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rows_ = rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.DeleteRequest.rows)
}

// -------------------------------------------------------------------

// QueryRequest

// uint64 region_id = 1;
inline void QueryRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t QueryRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t QueryRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.QueryRequest.region_id)
  return _internal_region_id();
}
inline void QueryRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void QueryRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.QueryRequest.region_id)
}

// bytes plan = 2;
inline void QueryRequest::clear_plan() {
  _impl_.plan_.ClearToEmpty();
}
inline const std::string& QueryRequest::plan() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.QueryRequest.plan)
  return _internal_plan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_plan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plan_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.QueryRequest.plan)
}
inline std::string* QueryRequest::mutable_plan() {
  std::string* _s = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.QueryRequest.plan)
  return _s;
}
inline const std::string& QueryRequest::_internal_plan() const {
  return _impl_.plan_.Get();
}
inline void QueryRequest::_internal_set_plan(const std::string& value) {
  
  _impl_.plan_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_plan() {
  
  return _impl_.plan_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryRequest::release_plan() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.QueryRequest.plan)
  return _impl_.plan_.Release();
}
inline void QueryRequest::set_allocated_plan(std::string* plan) {
  if (plan != nullptr) {
    
  } else {
    
  }
  _impl_.plan_.SetAllocated(plan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plan_.IsDefault()) {
    _impl_.plan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.QueryRequest.plan)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateRequest

// uint64 region_id = 1;
inline void CreateRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t CreateRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t CreateRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.region_id)
  return _internal_region_id();
}
inline void CreateRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void CreateRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.region_id)
}

// string engine = 2;
inline void CreateRequest::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& CreateRequest::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.engine)
}
inline std::string* CreateRequest::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.engine)
  return _s;
}
inline const std::string& CreateRequest::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void CreateRequest::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CreateRequest.engine)
  return _impl_.engine_.Release();
}
inline void CreateRequest::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.CreateRequest.engine)
}

// repeated .greptime.v1.region.ColumnDef column_defs = 3;
inline int CreateRequest::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int CreateRequest::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void CreateRequest::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::greptime::v1::region::ColumnDef* CreateRequest::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::ColumnDef >*
CreateRequest::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.CreateRequest.column_defs)
  return &_impl_.column_defs_;
}
inline const ::greptime::v1::region::ColumnDef& CreateRequest::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::greptime::v1::region::ColumnDef& CreateRequest::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.column_defs)
  return _internal_column_defs(index);
}
inline ::greptime::v1::region::ColumnDef* CreateRequest::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::greptime::v1::region::ColumnDef* CreateRequest::add_column_defs() {
  ::greptime::v1::region::ColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:greptime.v1.region.CreateRequest.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::ColumnDef >&
CreateRequest::column_defs() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.CreateRequest.column_defs)
  return _impl_.column_defs_;
}

// repeated uint32 primary_key = 4;
inline int CreateRequest::_internal_primary_key_size() const {
  return _impl_.primary_key_.size();
}
inline int CreateRequest::primary_key_size() const {
  return _internal_primary_key_size();
}
inline void CreateRequest::clear_primary_key() {
  _impl_.primary_key_.Clear();
}
inline uint32_t CreateRequest::_internal_primary_key(int index) const {
  return _impl_.primary_key_.Get(index);
}
inline uint32_t CreateRequest::primary_key(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.primary_key)
  return _internal_primary_key(index);
}
inline void CreateRequest::set_primary_key(int index, uint32_t value) {
  _impl_.primary_key_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.primary_key)
}
inline void CreateRequest::_internal_add_primary_key(uint32_t value) {
  _impl_.primary_key_.Add(value);
}
inline void CreateRequest::add_primary_key(uint32_t value) {
  _internal_add_primary_key(value);
  // @@protoc_insertion_point(field_add:greptime.v1.region.CreateRequest.primary_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CreateRequest::_internal_primary_key() const {
  return _impl_.primary_key_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CreateRequest::primary_key() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.CreateRequest.primary_key)
  return _internal_primary_key();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CreateRequest::_internal_mutable_primary_key() {
  return &_impl_.primary_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CreateRequest::mutable_primary_key() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.CreateRequest.primary_key)
  return _internal_mutable_primary_key();
}

// bool create_if_not_exists = 5;
inline void CreateRequest::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateRequest::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateRequest::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateRequest::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateRequest::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.create_if_not_exists)
}

// string catalog = 6;
inline void CreateRequest::clear_catalog() {
  _impl_.catalog_.ClearToEmpty();
}
inline const std::string& CreateRequest::catalog() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.catalog)
  return _internal_catalog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_catalog(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.catalog)
}
inline std::string* CreateRequest::mutable_catalog() {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.catalog)
  return _s;
}
inline const std::string& CreateRequest::_internal_catalog() const {
  return _impl_.catalog_.Get();
}
inline void CreateRequest::_internal_set_catalog(const std::string& value) {
  
  _impl_.catalog_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_catalog() {
  
  return _impl_.catalog_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_catalog() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CreateRequest.catalog)
  return _impl_.catalog_.Release();
}
inline void CreateRequest::set_allocated_catalog(std::string* catalog) {
  if (catalog != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_.SetAllocated(catalog, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.CreateRequest.catalog)
}

// string schema = 7;
inline void CreateRequest::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& CreateRequest::schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CreateRequest.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.CreateRequest.schema)
}
inline std::string* CreateRequest::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.CreateRequest.schema)
  return _s;
}
inline const std::string& CreateRequest::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void CreateRequest::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.CreateRequest.schema)
  return _impl_.schema_.Release();
}
inline void CreateRequest::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.CreateRequest.schema)
}

// map<string, string> options = 8;
inline int CreateRequest::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int CreateRequest::options_size() const {
  return _internal_options_size();
}
inline void CreateRequest::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.region.CreateRequest.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.region.CreateRequest.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// DropRequest

// uint64 region_id = 1;
inline void DropRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t DropRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t DropRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropRequest.region_id)
  return _internal_region_id();
}
inline void DropRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void DropRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.DropRequest.region_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OpenRequest

// uint64 region_id = 1;
inline void OpenRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t OpenRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t OpenRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.region_id)
  return _internal_region_id();
}
inline void OpenRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void OpenRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.region_id)
}

// string engine = 2;
inline void OpenRequest::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& OpenRequest::engine() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.engine)
}
inline std::string* OpenRequest::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.OpenRequest.engine)
  return _s;
}
inline const std::string& OpenRequest::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void OpenRequest::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_engine() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.OpenRequest.engine)
  return _impl_.engine_.Release();
}
inline void OpenRequest::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.OpenRequest.engine)
}

// string catalog = 3;
inline void OpenRequest::clear_catalog() {
  _impl_.catalog_.ClearToEmpty();
}
inline const std::string& OpenRequest::catalog() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.catalog)
  return _internal_catalog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_catalog(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.catalog)
}
inline std::string* OpenRequest::mutable_catalog() {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.OpenRequest.catalog)
  return _s;
}
inline const std::string& OpenRequest::_internal_catalog() const {
  return _impl_.catalog_.Get();
}
inline void OpenRequest::_internal_set_catalog(const std::string& value) {
  
  _impl_.catalog_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_catalog() {
  
  return _impl_.catalog_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_catalog() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.OpenRequest.catalog)
  return _impl_.catalog_.Release();
}
inline void OpenRequest::set_allocated_catalog(std::string* catalog) {
  if (catalog != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_.SetAllocated(catalog, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.OpenRequest.catalog)
}

// string schema = 4;
inline void OpenRequest::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& OpenRequest::schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.OpenRequest.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpenRequest::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.OpenRequest.schema)
}
inline std::string* OpenRequest::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.OpenRequest.schema)
  return _s;
}
inline const std::string& OpenRequest::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void OpenRequest::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* OpenRequest::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* OpenRequest::release_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.OpenRequest.schema)
  return _impl_.schema_.Release();
}
inline void OpenRequest::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.OpenRequest.schema)
}

// map<string, string> options = 5;
inline int OpenRequest::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int OpenRequest::options_size() const {
  return _internal_options_size();
}
inline void OpenRequest::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OpenRequest::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OpenRequest::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.region.OpenRequest.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OpenRequest::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OpenRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.region.OpenRequest.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// CloseRequest

// uint64 region_id = 1;
inline void CloseRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t CloseRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t CloseRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CloseRequest.region_id)
  return _internal_region_id();
}
inline void CloseRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void CloseRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CloseRequest.region_id)
}

// -------------------------------------------------------------------

// AlterRequest

// uint64 region_id = 1;
inline void AlterRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t AlterRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t AlterRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.region_id)
  return _internal_region_id();
}
inline void AlterRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void AlterRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.AlterRequest.region_id)
}

// .greptime.v1.region.AddColumns add_columns = 2;
inline bool AlterRequest::_internal_has_add_columns() const {
  return kind_case() == kAddColumns;
}
inline bool AlterRequest::has_add_columns() const {
  return _internal_has_add_columns();
}
inline void AlterRequest::set_has_add_columns() {
  _impl_._oneof_case_[0] = kAddColumns;
}
inline void AlterRequest::clear_add_columns() {
  if (_internal_has_add_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.add_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::region::AddColumns* AlterRequest::release_add_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AlterRequest.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::region::AddColumns* temp = _impl_.kind_.add_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::AddColumns& AlterRequest::_internal_add_columns() const {
  return _internal_has_add_columns()
      ? *_impl_.kind_.add_columns_
      : reinterpret_cast< ::greptime::v1::region::AddColumns&>(::greptime::v1::region::_AddColumns_default_instance_);
}
inline const ::greptime::v1::region::AddColumns& AlterRequest::add_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.add_columns)
  return _internal_add_columns();
}
inline ::greptime::v1::region::AddColumns* AlterRequest::unsafe_arena_release_add_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.AlterRequest.add_columns)
  if (_internal_has_add_columns()) {
    clear_has_kind();
    ::greptime::v1::region::AddColumns* temp = _impl_.kind_.add_columns_;
    _impl_.kind_.add_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterRequest::unsafe_arena_set_allocated_add_columns(::greptime::v1::region::AddColumns* add_columns) {
  clear_kind();
  if (add_columns) {
    set_has_add_columns();
    _impl_.kind_.add_columns_ = add_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AlterRequest.add_columns)
}
inline ::greptime::v1::region::AddColumns* AlterRequest::_internal_mutable_add_columns() {
  if (!_internal_has_add_columns()) {
    clear_kind();
    set_has_add_columns();
    _impl_.kind_.add_columns_ = CreateMaybeMessage< ::greptime::v1::region::AddColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.add_columns_;
}
inline ::greptime::v1::region::AddColumns* AlterRequest::mutable_add_columns() {
  ::greptime::v1::region::AddColumns* _msg = _internal_mutable_add_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequest.add_columns)
  return _msg;
}

// .greptime.v1.region.DropColumns drop_columns = 3;
inline bool AlterRequest::_internal_has_drop_columns() const {
  return kind_case() == kDropColumns;
}
inline bool AlterRequest::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void AlterRequest::set_has_drop_columns() {
  _impl_._oneof_case_[0] = kDropColumns;
}
inline void AlterRequest::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.drop_columns_;
    }
    clear_has_kind();
  }
}
inline ::greptime::v1::region::DropColumns* AlterRequest::release_drop_columns() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AlterRequest.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::region::DropColumns* temp = _impl_.kind_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::region::DropColumns& AlterRequest::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *_impl_.kind_.drop_columns_
      : reinterpret_cast< ::greptime::v1::region::DropColumns&>(::greptime::v1::region::_DropColumns_default_instance_);
}
inline const ::greptime::v1::region::DropColumns& AlterRequest::drop_columns() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.drop_columns)
  return _internal_drop_columns();
}
inline ::greptime::v1::region::DropColumns* AlterRequest::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.region.AlterRequest.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_kind();
    ::greptime::v1::region::DropColumns* temp = _impl_.kind_.drop_columns_;
    _impl_.kind_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AlterRequest::unsafe_arena_set_allocated_drop_columns(::greptime::v1::region::DropColumns* drop_columns) {
  clear_kind();
  if (drop_columns) {
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AlterRequest.drop_columns)
}
inline ::greptime::v1::region::DropColumns* AlterRequest::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_kind();
    set_has_drop_columns();
    _impl_.kind_.drop_columns_ = CreateMaybeMessage< ::greptime::v1::region::DropColumns >(GetArenaForAllocation());
  }
  return _impl_.kind_.drop_columns_;
}
inline ::greptime::v1::region::DropColumns* AlterRequest::mutable_drop_columns() {
  ::greptime::v1::region::DropColumns* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AlterRequest.drop_columns)
  return _msg;
}

// uint64 schema_version = 4;
inline void AlterRequest::clear_schema_version() {
  _impl_.schema_version_ = uint64_t{0u};
}
inline uint64_t AlterRequest::_internal_schema_version() const {
  return _impl_.schema_version_;
}
inline uint64_t AlterRequest::schema_version() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AlterRequest.schema_version)
  return _internal_schema_version();
}
inline void AlterRequest::_internal_set_schema_version(uint64_t value) {
  
  _impl_.schema_version_ = value;
}
inline void AlterRequest::set_schema_version(uint64_t value) {
  _internal_set_schema_version(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.AlterRequest.schema_version)
}

inline bool AlterRequest::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void AlterRequest::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline AlterRequest::KindCase AlterRequest::kind_case() const {
  return AlterRequest::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddColumns

// repeated .greptime.v1.region.AddColumn add_columns = 1;
inline int AddColumns::_internal_add_columns_size() const {
  return _impl_.add_columns_.size();
}
inline int AddColumns::add_columns_size() const {
  return _internal_add_columns_size();
}
inline void AddColumns::clear_add_columns() {
  _impl_.add_columns_.Clear();
}
inline ::greptime::v1::region::AddColumn* AddColumns::mutable_add_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AddColumns.add_columns)
  return _impl_.add_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >*
AddColumns::mutable_add_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.AddColumns.add_columns)
  return &_impl_.add_columns_;
}
inline const ::greptime::v1::region::AddColumn& AddColumns::_internal_add_columns(int index) const {
  return _impl_.add_columns_.Get(index);
}
inline const ::greptime::v1::region::AddColumn& AddColumns::add_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumns.add_columns)
  return _internal_add_columns(index);
}
inline ::greptime::v1::region::AddColumn* AddColumns::_internal_add_add_columns() {
  return _impl_.add_columns_.Add();
}
inline ::greptime::v1::region::AddColumn* AddColumns::add_add_columns() {
  ::greptime::v1::region::AddColumn* _add = _internal_add_add_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.region.AddColumns.add_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::AddColumn >&
AddColumns::add_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.AddColumns.add_columns)
  return _impl_.add_columns_;
}

// -------------------------------------------------------------------

// DropColumns

// repeated .greptime.v1.region.DropColumn drop_columns = 1;
inline int DropColumns::_internal_drop_columns_size() const {
  return _impl_.drop_columns_.size();
}
inline int DropColumns::drop_columns_size() const {
  return _internal_drop_columns_size();
}
inline void DropColumns::clear_drop_columns() {
  _impl_.drop_columns_.Clear();
}
inline ::greptime::v1::region::DropColumn* DropColumns::mutable_drop_columns(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DropColumns.drop_columns)
  return _impl_.drop_columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >*
DropColumns::mutable_drop_columns() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.region.DropColumns.drop_columns)
  return &_impl_.drop_columns_;
}
inline const ::greptime::v1::region::DropColumn& DropColumns::_internal_drop_columns(int index) const {
  return _impl_.drop_columns_.Get(index);
}
inline const ::greptime::v1::region::DropColumn& DropColumns::drop_columns(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropColumns.drop_columns)
  return _internal_drop_columns(index);
}
inline ::greptime::v1::region::DropColumn* DropColumns::_internal_add_drop_columns() {
  return _impl_.drop_columns_.Add();
}
inline ::greptime::v1::region::DropColumn* DropColumns::add_drop_columns() {
  ::greptime::v1::region::DropColumn* _add = _internal_add_drop_columns();
  // @@protoc_insertion_point(field_add:greptime.v1.region.DropColumns.drop_columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::region::DropColumn >&
DropColumns::drop_columns() const {
  // @@protoc_insertion_point(field_list:greptime.v1.region.DropColumns.drop_columns)
  return _impl_.drop_columns_;
}

// -------------------------------------------------------------------

// AddColumn

// .greptime.v1.region.ColumnDef column_def = 1;
inline bool AddColumn::_internal_has_column_def() const {
  return this != internal_default_instance() && _impl_.column_def_ != nullptr;
}
inline bool AddColumn::has_column_def() const {
  return _internal_has_column_def();
}
inline void AddColumn::clear_column_def() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_def_ != nullptr) {
    delete _impl_.column_def_;
  }
  _impl_.column_def_ = nullptr;
}
inline const ::greptime::v1::region::ColumnDef& AddColumn::_internal_column_def() const {
  const ::greptime::v1::region::ColumnDef* p = _impl_.column_def_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::region::ColumnDef&>(
      ::greptime::v1::region::_ColumnDef_default_instance_);
}
inline const ::greptime::v1::region::ColumnDef& AddColumn::column_def() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumn.column_def)
  return _internal_column_def();
}
inline void AddColumn::unsafe_arena_set_allocated_column_def(
    ::greptime::v1::region::ColumnDef* column_def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_def_);
  }
  _impl_.column_def_ = column_def;
  if (column_def) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AddColumn.column_def)
}
inline ::greptime::v1::region::ColumnDef* AddColumn::release_column_def() {
  
  ::greptime::v1::region::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::region::ColumnDef* AddColumn::unsafe_arena_release_column_def() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AddColumn.column_def)
  
  ::greptime::v1::region::ColumnDef* temp = _impl_.column_def_;
  _impl_.column_def_ = nullptr;
  return temp;
}
inline ::greptime::v1::region::ColumnDef* AddColumn::_internal_mutable_column_def() {
  
  if (_impl_.column_def_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::region::ColumnDef>(GetArenaForAllocation());
    _impl_.column_def_ = p;
  }
  return _impl_.column_def_;
}
inline ::greptime::v1::region::ColumnDef* AddColumn::mutable_column_def() {
  ::greptime::v1::region::ColumnDef* _msg = _internal_mutable_column_def();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AddColumn.column_def)
  return _msg;
}
inline void AddColumn::set_allocated_column_def(::greptime::v1::region::ColumnDef* column_def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_def_;
  }
  if (column_def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_def);
    if (message_arena != submessage_arena) {
      column_def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_def, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_def_ = column_def;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.AddColumn.column_def)
}

// bool is_key = 2;
inline void AddColumn::clear_is_key() {
  _impl_.is_key_ = false;
}
inline bool AddColumn::_internal_is_key() const {
  return _impl_.is_key_;
}
inline bool AddColumn::is_key() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumn.is_key)
  return _internal_is_key();
}
inline void AddColumn::_internal_set_is_key(bool value) {
  
  _impl_.is_key_ = value;
}
inline void AddColumn::set_is_key(bool value) {
  _internal_set_is_key(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.AddColumn.is_key)
}

// .greptime.v1.AddColumnLocation location = 3;
inline bool AddColumn::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool AddColumn::has_location() const {
  return _internal_has_location();
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::_internal_location() const {
  const ::greptime::v1::AddColumnLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AddColumnLocation&>(
      ::greptime::v1::_AddColumnLocation_default_instance_);
}
inline const ::greptime::v1::AddColumnLocation& AddColumn::location() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.AddColumn.location)
  return _internal_location();
}
inline void AddColumn::unsafe_arena_set_allocated_location(
    ::greptime::v1::AddColumnLocation* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.region.AddColumn.location)
}
inline ::greptime::v1::AddColumnLocation* AddColumn::release_location() {
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.AddColumn.location)
  
  ::greptime::v1::AddColumnLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AddColumnLocation>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::greptime::v1::AddColumnLocation* AddColumn::mutable_location() {
  ::greptime::v1::AddColumnLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.AddColumn.location)
  return _msg;
}
inline void AddColumn::set_allocated_location(::greptime::v1::AddColumnLocation* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.AddColumn.location)
}

// -------------------------------------------------------------------

// DropColumn

// string name = 1;
inline void DropColumn::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DropColumn::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.DropColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropColumn::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.DropColumn.name)
}
inline std::string* DropColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.DropColumn.name)
  return _s;
}
inline const std::string& DropColumn::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DropColumn::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropColumn::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropColumn::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.DropColumn.name)
  return _impl_.name_.Release();
}
inline void DropColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.DropColumn.name)
}

// -------------------------------------------------------------------

// FlushRequest

// uint64 region_id = 1;
inline void FlushRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t FlushRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t FlushRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.FlushRequest.region_id)
  return _internal_region_id();
}
inline void FlushRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void FlushRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.FlushRequest.region_id)
}

// -------------------------------------------------------------------

// CompactRequest

// uint64 region_id = 1;
inline void CompactRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t CompactRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t CompactRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.CompactRequest.region_id)
  return _internal_region_id();
}
inline void CompactRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void CompactRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.CompactRequest.region_id)
}

// -------------------------------------------------------------------

// ColumnDef

// string name = 1;
inline void ColumnDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDef::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.ColumnDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.ColumnDef.name)
}
inline std::string* ColumnDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.ColumnDef.name)
  return _s;
}
inline const std::string& ColumnDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.ColumnDef.name)
  return _impl_.name_.Release();
}
inline void ColumnDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.ColumnDef.name)
}

// uint32 column_id = 2;
inline void ColumnDef::clear_column_id() {
  _impl_.column_id_ = 0u;
}
inline uint32_t ColumnDef::_internal_column_id() const {
  return _impl_.column_id_;
}
inline uint32_t ColumnDef::column_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.ColumnDef.column_id)
  return _internal_column_id();
}
inline void ColumnDef::_internal_set_column_id(uint32_t value) {
  
  _impl_.column_id_ = value;
}
inline void ColumnDef::set_column_id(uint32_t value) {
  _internal_set_column_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.ColumnDef.column_id)
}

// .greptime.v1.ColumnDataType datatype = 3;
inline void ColumnDef::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::greptime::v1::ColumnDataType ColumnDef::_internal_datatype() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.datatype_);
}
inline ::greptime::v1::ColumnDataType ColumnDef::datatype() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.ColumnDef.datatype)
  return _internal_datatype();
}
inline void ColumnDef::_internal_set_datatype(::greptime::v1::ColumnDataType value) {
  
  _impl_.datatype_ = value;
}
inline void ColumnDef::set_datatype(::greptime::v1::ColumnDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.ColumnDef.datatype)
}

// bool is_nullable = 4;
inline void ColumnDef::clear_is_nullable() {
  _impl_.is_nullable_ = false;
}
inline bool ColumnDef::_internal_is_nullable() const {
  return _impl_.is_nullable_;
}
inline bool ColumnDef::is_nullable() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.ColumnDef.is_nullable)
  return _internal_is_nullable();
}
inline void ColumnDef::_internal_set_is_nullable(bool value) {
  
  _impl_.is_nullable_ = value;
}
inline void ColumnDef::set_is_nullable(bool value) {
  _internal_set_is_nullable(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.ColumnDef.is_nullable)
}

// bytes default_constraint = 5;
inline void ColumnDef::clear_default_constraint() {
  _impl_.default_constraint_.ClearToEmpty();
}
inline const std::string& ColumnDef::default_constraint() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.ColumnDef.default_constraint)
  return _internal_default_constraint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_default_constraint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_constraint_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.region.ColumnDef.default_constraint)
}
inline std::string* ColumnDef::mutable_default_constraint() {
  std::string* _s = _internal_mutable_default_constraint();
  // @@protoc_insertion_point(field_mutable:greptime.v1.region.ColumnDef.default_constraint)
  return _s;
}
inline const std::string& ColumnDef::_internal_default_constraint() const {
  return _impl_.default_constraint_.Get();
}
inline void ColumnDef::_internal_set_default_constraint(const std::string& value) {
  
  _impl_.default_constraint_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_default_constraint() {
  
  return _impl_.default_constraint_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_default_constraint() {
  // @@protoc_insertion_point(field_release:greptime.v1.region.ColumnDef.default_constraint)
  return _impl_.default_constraint_.Release();
}
inline void ColumnDef::set_allocated_default_constraint(std::string* default_constraint) {
  if (default_constraint != nullptr) {
    
  } else {
    
  }
  _impl_.default_constraint_.SetAllocated(default_constraint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_constraint_.IsDefault()) {
    _impl_.default_constraint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.region.ColumnDef.default_constraint)
}

// .greptime.v1.SemanticType semantic_type = 6;
inline void ColumnDef::clear_semantic_type() {
  _impl_.semantic_type_ = 0;
}
inline ::greptime::v1::SemanticType ColumnDef::_internal_semantic_type() const {
  return static_cast< ::greptime::v1::SemanticType >(_impl_.semantic_type_);
}
inline ::greptime::v1::SemanticType ColumnDef::semantic_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.region.ColumnDef.semantic_type)
  return _internal_semantic_type();
}
inline void ColumnDef::_internal_set_semantic_type(::greptime::v1::SemanticType value) {
  
  _impl_.semantic_type_ = value;
}
inline void ColumnDef::set_semantic_type(::greptime::v1::SemanticType value) {
  _internal_set_semantic_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.region.ColumnDef.semantic_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace region
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fregion_2fserver_2eproto
