// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/common.proto

#include "greptime/v1/common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace greptime {
namespace v1 {
PROTOBUF_CONSTEXPR QueryContext_ExtensionsEntry_DoNotUse::QueryContext_ExtensionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    QueryContext_ExtensionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal _QueryContext_ExtensionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR QueryContext::QueryContext(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extensions_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.current_catalog_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.current_schema_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timezone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.seq_snapshots_)*/nullptr
  , /*decltype(_impl_.channel_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct QueryContextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueryContextDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueryContextDefaultTypeInternal() {}
  union {
    QueryContext _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueryContextDefaultTypeInternal _QueryContext_default_instance_;
PROTOBUF_CONSTEXPR SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SequenceSnapshots_SeqSnapshotsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SequenceSnapshots_SeqSnapshotsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SequenceSnapshots_SeqSnapshotsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SequenceSnapshots_SeqSnapshotsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SequenceSnapshots_SeqSnapshotsEntry_DoNotUseDefaultTypeInternal _SequenceSnapshots_SeqSnapshotsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SequenceSnapshots::SequenceSnapshots(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seq_snapshots_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SequenceSnapshotsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SequenceSnapshotsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SequenceSnapshotsDefaultTypeInternal() {}
  union {
    SequenceSnapshots _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SequenceSnapshotsDefaultTypeInternal _SequenceSnapshots_default_instance_;
PROTOBUF_CONSTEXPR RequestHeader_TracingContextEntry_DoNotUse::RequestHeader_TracingContextEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal() {}
  union {
    RequestHeader_TracingContextEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _RequestHeader_TracingContextEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR RequestHeader::RequestHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tracing_context_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.catalog_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.schema_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dbname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timezone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.authorization_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RequestHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequestHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequestHeaderDefaultTypeInternal() {}
  union {
    RequestHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
PROTOBUF_CONSTEXPR ResponseHeader::ResponseHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResponseHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResponseHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResponseHeaderDefaultTypeInternal() {}
  union {
    ResponseHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
PROTOBUF_CONSTEXPR Status::Status(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.err_msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_code_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDefaultTypeInternal _Status_default_instance_;
PROTOBUF_CONSTEXPR AuthHeader::AuthHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.auth_scheme_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AuthHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthHeaderDefaultTypeInternal() {}
  union {
    AuthHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthHeaderDefaultTypeInternal _AuthHeader_default_instance_;
PROTOBUF_CONSTEXPR Basic::Basic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.username_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BasicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BasicDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BasicDefaultTypeInternal() {}
  union {
    Basic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BasicDefaultTypeInternal _Basic_default_instance_;
PROTOBUF_CONSTEXPR Token::Token(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenDefaultTypeInternal() {}
  union {
    Token _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenDefaultTypeInternal _Token_default_instance_;
PROTOBUF_CONSTEXPR TableName::TableName(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.catalog_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.schema_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.table_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableNameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableNameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableNameDefaultTypeInternal() {}
  union {
    TableName _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableNameDefaultTypeInternal _TableName_default_instance_;
PROTOBUF_CONSTEXPR AffectedRows::AffectedRows(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AffectedRowsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AffectedRowsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AffectedRowsDefaultTypeInternal() {}
  union {
    AffectedRows _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AffectedRowsDefaultTypeInternal _AffectedRows_default_instance_;
PROTOBUF_CONSTEXPR Metrics::Metrics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metrics_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MetricsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MetricsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MetricsDefaultTypeInternal() {}
  union {
    Metrics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MetricsDefaultTypeInternal _Metrics_default_instance_;
PROTOBUF_CONSTEXPR ExpireAfter::ExpireAfter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ExpireAfterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpireAfterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpireAfterDefaultTypeInternal() {}
  union {
    ExpireAfter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpireAfterDefaultTypeInternal _ExpireAfter_default_instance_;
PROTOBUF_CONSTEXPR FlightMetadata::FlightMetadata(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.affected_rows_)*/nullptr
  , /*decltype(_impl_.metrics_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlightMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlightMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlightMetadataDefaultTypeInternal() {}
  union {
    FlightMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlightMetadataDefaultTypeInternal _FlightMetadata_default_instance_;
PROTOBUF_CONSTEXPR IntervalMonthDayNano::IntervalMonthDayNano(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.months_)*/0
  , /*decltype(_impl_.days_)*/0
  , /*decltype(_impl_.nanoseconds_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IntervalMonthDayNanoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntervalMonthDayNanoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntervalMonthDayNanoDefaultTypeInternal() {}
  union {
    IntervalMonthDayNano _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntervalMonthDayNanoDefaultTypeInternal _IntervalMonthDayNano_default_instance_;
PROTOBUF_CONSTEXPR Decimal128::Decimal128(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hi_)*/int64_t{0}
  , /*decltype(_impl_.lo_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Decimal128DefaultTypeInternal {
  PROTOBUF_CONSTEXPR Decimal128DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Decimal128DefaultTypeInternal() {}
  union {
    Decimal128 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Decimal128DefaultTypeInternal _Decimal128_default_instance_;
PROTOBUF_CONSTEXPR ColumnDataTypeExtension::ColumnDataTypeExtension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.type_ext_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ColumnDataTypeExtensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColumnDataTypeExtensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColumnDataTypeExtensionDefaultTypeInternal() {}
  union {
    ColumnDataTypeExtension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColumnDataTypeExtensionDefaultTypeInternal _ColumnDataTypeExtension_default_instance_;
PROTOBUF_CONSTEXPR DecimalTypeExtension::DecimalTypeExtension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.precision_)*/0
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DecimalTypeExtensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecimalTypeExtensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecimalTypeExtensionDefaultTypeInternal() {}
  union {
    DecimalTypeExtension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecimalTypeExtensionDefaultTypeInternal _DecimalTypeExtension_default_instance_;
PROTOBUF_CONSTEXPR VectorTypeExtension::VectorTypeExtension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dim_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VectorTypeExtensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VectorTypeExtensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VectorTypeExtensionDefaultTypeInternal() {}
  union {
    VectorTypeExtension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VectorTypeExtensionDefaultTypeInternal _VectorTypeExtension_default_instance_;
PROTOBUF_CONSTEXPR ColumnOptions_OptionsEntry_DoNotUse::ColumnOptions_OptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ColumnOptions_OptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal _ColumnOptions_OptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ColumnOptions::ColumnOptions(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ColumnOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColumnOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColumnOptionsDefaultTypeInternal() {}
  union {
    ColumnOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColumnOptionsDefaultTypeInternal _ColumnOptions_default_instance_;
}  // namespace v1
}  // namespace greptime
static ::_pb::Metadata file_level_metadata_greptime_2fv1_2fcommon_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_greptime_2fv1_2fcommon_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_greptime_2fv1_2fcommon_2eproto = nullptr;

const uint32_t TableStruct_greptime_2fv1_2fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _impl_.current_catalog_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _impl_.current_schema_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _impl_.timezone_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _impl_.extensions_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::QueryContext, _impl_.seq_snapshots_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::SequenceSnapshots, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::SequenceSnapshots, _impl_.seq_snapshots_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _impl_.catalog_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _impl_.schema_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _impl_.authorization_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _impl_.dbname_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _impl_.tracing_context_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::RequestHeader, _impl_.timezone_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ResponseHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ResponseHeader, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Status, _impl_.status_code_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Status, _impl_.err_msg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::AuthHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::AuthHeader, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::greptime::v1::AuthHeader, _impl_.auth_scheme_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Basic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Basic, _impl_.username_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Basic, _impl_.password_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Token, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Token, _impl_.token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::TableName, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::TableName, _impl_.catalog_name_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::TableName, _impl_.schema_name_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::TableName, _impl_.table_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::AffectedRows, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::AffectedRows, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Metrics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Metrics, _impl_.metrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ExpireAfter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ExpireAfter, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::FlightMetadata, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::FlightMetadata, _impl_.affected_rows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::FlightMetadata, _impl_.metrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::IntervalMonthDayNano, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::IntervalMonthDayNano, _impl_.months_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::IntervalMonthDayNano, _impl_.days_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::IntervalMonthDayNano, _impl_.nanoseconds_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Decimal128, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Decimal128, _impl_.hi_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::Decimal128, _impl_.lo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnDataTypeExtension, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnDataTypeExtension, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnDataTypeExtension, _impl_.type_ext_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::DecimalTypeExtension, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::DecimalTypeExtension, _impl_.precision_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::DecimalTypeExtension, _impl_.scale_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::VectorTypeExtension, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::VectorTypeExtension, _impl_.dim_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::ColumnOptions, _impl_.options_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse)},
  { 10, -1, -1, sizeof(::greptime::v1::QueryContext)},
  { 22, 30, -1, sizeof(::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse)},
  { 32, -1, -1, sizeof(::greptime::v1::SequenceSnapshots)},
  { 39, 47, -1, sizeof(::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse)},
  { 49, -1, -1, sizeof(::greptime::v1::RequestHeader)},
  { 61, -1, -1, sizeof(::greptime::v1::ResponseHeader)},
  { 68, -1, -1, sizeof(::greptime::v1::Status)},
  { 76, -1, -1, sizeof(::greptime::v1::AuthHeader)},
  { 85, -1, -1, sizeof(::greptime::v1::Basic)},
  { 93, -1, -1, sizeof(::greptime::v1::Token)},
  { 100, -1, -1, sizeof(::greptime::v1::TableName)},
  { 109, -1, -1, sizeof(::greptime::v1::AffectedRows)},
  { 116, -1, -1, sizeof(::greptime::v1::Metrics)},
  { 123, -1, -1, sizeof(::greptime::v1::ExpireAfter)},
  { 130, -1, -1, sizeof(::greptime::v1::FlightMetadata)},
  { 138, -1, -1, sizeof(::greptime::v1::IntervalMonthDayNano)},
  { 147, -1, -1, sizeof(::greptime::v1::Decimal128)},
  { 155, -1, -1, sizeof(::greptime::v1::ColumnDataTypeExtension)},
  { 165, -1, -1, sizeof(::greptime::v1::DecimalTypeExtension)},
  { 173, -1, -1, sizeof(::greptime::v1::VectorTypeExtension)},
  { 180, 188, -1, sizeof(::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse)},
  { 190, -1, -1, sizeof(::greptime::v1::ColumnOptions)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::greptime::v1::_QueryContext_ExtensionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::_QueryContext_default_instance_._instance,
  &::greptime::v1::_SequenceSnapshots_SeqSnapshotsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::_SequenceSnapshots_default_instance_._instance,
  &::greptime::v1::_RequestHeader_TracingContextEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::_RequestHeader_default_instance_._instance,
  &::greptime::v1::_ResponseHeader_default_instance_._instance,
  &::greptime::v1::_Status_default_instance_._instance,
  &::greptime::v1::_AuthHeader_default_instance_._instance,
  &::greptime::v1::_Basic_default_instance_._instance,
  &::greptime::v1::_Token_default_instance_._instance,
  &::greptime::v1::_TableName_default_instance_._instance,
  &::greptime::v1::_AffectedRows_default_instance_._instance,
  &::greptime::v1::_Metrics_default_instance_._instance,
  &::greptime::v1::_ExpireAfter_default_instance_._instance,
  &::greptime::v1::_FlightMetadata_default_instance_._instance,
  &::greptime::v1::_IntervalMonthDayNano_default_instance_._instance,
  &::greptime::v1::_Decimal128_default_instance_._instance,
  &::greptime::v1::_ColumnDataTypeExtension_default_instance_._instance,
  &::greptime::v1::_DecimalTypeExtension_default_instance_._instance,
  &::greptime::v1::_VectorTypeExtension_default_instance_._instance,
  &::greptime::v1::_ColumnOptions_OptionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::_ColumnOptions_default_instance_._instance,
};

const char descriptor_table_protodef_greptime_2fv1_2fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030greptime/v1/common.proto\022\013greptime.v1\""
  "\213\002\n\014QueryContext\022\027\n\017current_catalog\030\001 \001("
  "\t\022\026\n\016current_schema\030\002 \001(\t\022\020\n\010timezone\030\004 "
  "\001(\t\022=\n\nextensions\030\005 \003(\0132).greptime.v1.Qu"
  "eryContext.ExtensionsEntry\022\017\n\007channel\030\006 "
  "\001(\r\0225\n\rseq_snapshots\030\007 \001(\0132\036.greptime.v1"
  ".SequenceSnapshots\0321\n\017ExtensionsEntry\022\013\n"
  "\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\221\001\n\021Sequen"
  "ceSnapshots\022G\n\rseq_snapshots\030\007 \003(\01320.gre"
  "ptime.v1.SequenceSnapshots.SeqSnapshotsE"
  "ntry\0323\n\021SeqSnapshotsEntry\022\013\n\003key\030\001 \001(\004\022\r"
  "\n\005value\030\002 \001(\004:\0028\001\"\202\002\n\rRequestHeader\022\017\n\007c"
  "atalog\030\001 \001(\t\022\016\n\006schema\030\002 \001(\t\022.\n\rauthoriz"
  "ation\030\003 \001(\0132\027.greptime.v1.AuthHeader\022\016\n\006"
  "dbname\030\004 \001(\t\022G\n\017tracing_context\030\005 \003(\0132.."
  "greptime.v1.RequestHeader.TracingContext"
  "Entry\022\020\n\010timezone\030\006 \001(\t\0325\n\023TracingContex"
  "tEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"5"
  "\n\016ResponseHeader\022#\n\006status\030\001 \001(\0132\023.grept"
  "ime.v1.Status\".\n\006Status\022\023\n\013status_code\030\001"
  " \001(\r\022\017\n\007err_msg\030\002 \001(\t\"e\n\nAuthHeader\022#\n\005b"
  "asic\030\001 \001(\0132\022.greptime.v1.BasicH\000\022#\n\005toke"
  "n\030\002 \001(\0132\022.greptime.v1.TokenH\000B\r\n\013auth_sc"
  "heme\"+\n\005Basic\022\020\n\010username\030\001 \001(\t\022\020\n\010passw"
  "ord\030\002 \001(\t\"\026\n\005Token\022\r\n\005token\030\001 \001(\t\"J\n\tTab"
  "leName\022\024\n\014catalog_name\030\001 \001(\t\022\023\n\013schema_n"
  "ame\030\002 \001(\t\022\022\n\ntable_name\030\003 \001(\t\"\035\n\014Affecte"
  "dRows\022\r\n\005value\030\001 \001(\r\"\032\n\007Metrics\022\017\n\007metri"
  "cs\030\001 \001(\014\"\034\n\013ExpireAfter\022\r\n\005value\030\001 \001(\003\"i"
  "\n\016FlightMetadata\0220\n\raffected_rows\030\001 \001(\0132"
  "\031.greptime.v1.AffectedRows\022%\n\007metrics\030\002 "
  "\001(\0132\024.greptime.v1.Metrics\"I\n\024IntervalMon"
  "thDayNano\022\016\n\006months\030\001 \001(\005\022\014\n\004days\030\002 \001(\005\022"
  "\023\n\013nanoseconds\030\003 \001(\003\"$\n\nDecimal128\022\n\n\002hi"
  "\030\001 \001(\003\022\n\n\002lo\030\002 \001(\003\"\316\001\n\027ColumnDataTypeExt"
  "ension\0229\n\014decimal_type\030\001 \001(\0132!.greptime."
  "v1.DecimalTypeExtensionH\000\0223\n\tjson_type\030\002"
  " \001(\0162\036.greptime.v1.JsonTypeExtensionH\000\0227"
  "\n\013vector_type\030\003 \001(\0132 .greptime.v1.Vector"
  "TypeExtensionH\000B\n\n\010type_ext\"8\n\024DecimalTy"
  "peExtension\022\021\n\tprecision\030\001 \001(\005\022\r\n\005scale\030"
  "\002 \001(\005\"\"\n\023VectorTypeExtension\022\013\n\003dim\030\001 \001("
  "\r\"y\n\rColumnOptions\0228\n\007options\030\001 \003(\0132\'.gr"
  "eptime.v1.ColumnOptions.OptionsEntry\032.\n\014"
  "OptionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t"
  ":\0028\001*1\n\014SemanticType\022\007\n\003TAG\020\000\022\t\n\005FIELD\020\001"
  "\022\r\n\tTIMESTAMP\020\002*\354\003\n\016ColumnDataType\022\013\n\007BO"
  "OLEAN\020\000\022\010\n\004INT8\020\001\022\t\n\005INT16\020\002\022\t\n\005INT32\020\003\022"
  "\t\n\005INT64\020\004\022\t\n\005UINT8\020\005\022\n\n\006UINT16\020\006\022\n\n\006UIN"
  "T32\020\007\022\n\n\006UINT64\020\010\022\013\n\007FLOAT32\020\t\022\013\n\007FLOAT6"
  "4\020\n\022\n\n\006BINARY\020\013\022\n\n\006STRING\020\014\022\010\n\004DATE\020\r\022\014\n"
  "\010DATETIME\020\016\022\024\n\020TIMESTAMP_SECOND\020\017\022\031\n\025TIM"
  "ESTAMP_MILLISECOND\020\020\022\031\n\025TIMESTAMP_MICROS"
  "ECOND\020\021\022\030\n\024TIMESTAMP_NANOSECOND\020\022\022\017\n\013TIM"
  "E_SECOND\020\023\022\024\n\020TIME_MILLISECOND\020\024\022\024\n\020TIME"
  "_MICROSECOND\020\025\022\023\n\017TIME_NANOSECOND\020\026\022\027\n\023I"
  "NTERVAL_YEAR_MONTH\020\027\022\025\n\021INTERVAL_DAY_TIM"
  "E\020\030\022\033\n\027INTERVAL_MONTH_DAY_NANO\020\031\022\016\n\nDECI"
  "MAL128\020\036\022\010\n\004JSON\020\037\022\n\n\006VECTOR\020 *$\n\021JsonTy"
  "peExtension\022\017\n\013JSON_BINARY\020\000BO\n\016io.grept"
  "ime.v1B\006CommonZ5github.com/GreptimeTeam/"
  "greptime-proto/go/greptime/v1b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_greptime_2fv1_2fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_greptime_2fv1_2fcommon_2eproto = {
    false, false, 2477, descriptor_table_protodef_greptime_2fv1_2fcommon_2eproto,
    "greptime/v1/common.proto",
    &descriptor_table_greptime_2fv1_2fcommon_2eproto_once, nullptr, 0, 23,
    schemas, file_default_instances, TableStruct_greptime_2fv1_2fcommon_2eproto::offsets,
    file_level_metadata_greptime_2fv1_2fcommon_2eproto, file_level_enum_descriptors_greptime_2fv1_2fcommon_2eproto,
    file_level_service_descriptors_greptime_2fv1_2fcommon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_greptime_2fv1_2fcommon_2eproto_getter() {
  return &descriptor_table_greptime_2fv1_2fcommon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_greptime_2fv1_2fcommon_2eproto(&descriptor_table_greptime_2fv1_2fcommon_2eproto);
namespace greptime {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SemanticType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_greptime_2fv1_2fcommon_2eproto);
  return file_level_enum_descriptors_greptime_2fv1_2fcommon_2eproto[0];
}
bool SemanticType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnDataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_greptime_2fv1_2fcommon_2eproto);
  return file_level_enum_descriptors_greptime_2fv1_2fcommon_2eproto[1];
}
bool ColumnDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JsonTypeExtension_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_greptime_2fv1_2fcommon_2eproto);
  return file_level_enum_descriptors_greptime_2fv1_2fcommon_2eproto[2];
}
bool JsonTypeExtension_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}


// ===================================================================

QueryContext_ExtensionsEntry_DoNotUse::QueryContext_ExtensionsEntry_DoNotUse() {}
QueryContext_ExtensionsEntry_DoNotUse::QueryContext_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void QueryContext_ExtensionsEntry_DoNotUse::MergeFrom(const QueryContext_ExtensionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata QueryContext_ExtensionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[0]);
}

// ===================================================================

class QueryContext::_Internal {
 public:
  static const ::greptime::v1::SequenceSnapshots& seq_snapshots(const QueryContext* msg);
};

const ::greptime::v1::SequenceSnapshots&
QueryContext::_Internal::seq_snapshots(const QueryContext* msg) {
  return *msg->_impl_.seq_snapshots_;
}
QueryContext::QueryContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &QueryContext::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.QueryContext)
}
QueryContext::QueryContext(const QueryContext& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  QueryContext* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.extensions_)*/{}
    , decltype(_impl_.current_catalog_){}
    , decltype(_impl_.current_schema_){}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.seq_snapshots_){nullptr}
    , decltype(_impl_.channel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.extensions_.MergeFrom(from._impl_.extensions_);
  _impl_.current_catalog_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_catalog_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_current_catalog().empty()) {
    _this->_impl_.current_catalog_.Set(from._internal_current_catalog(), 
      _this->GetArenaForAllocation());
  }
  _impl_.current_schema_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_schema_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_current_schema().empty()) {
    _this->_impl_.current_schema_.Set(from._internal_current_schema(), 
      _this->GetArenaForAllocation());
  }
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_timezone().empty()) {
    _this->_impl_.timezone_.Set(from._internal_timezone(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_seq_snapshots()) {
    _this->_impl_.seq_snapshots_ = new ::greptime::v1::SequenceSnapshots(*from._impl_.seq_snapshots_);
  }
  _this->_impl_.channel_ = from._impl_.channel_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.QueryContext)
}

inline void QueryContext::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.current_catalog_){}
    , decltype(_impl_.current_schema_){}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.seq_snapshots_){nullptr}
    , decltype(_impl_.channel_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.current_catalog_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_catalog_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.current_schema_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_schema_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

QueryContext::~QueryContext() {
  // @@protoc_insertion_point(destructor:greptime.v1.QueryContext)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void QueryContext::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extensions_.Destruct();
  _impl_.extensions_.~MapField();
  _impl_.current_catalog_.Destroy();
  _impl_.current_schema_.Destroy();
  _impl_.timezone_.Destroy();
  if (this != internal_default_instance()) delete _impl_.seq_snapshots_;
}

void QueryContext::ArenaDtor(void* object) {
  QueryContext* _this = reinterpret_cast< QueryContext* >(object);
  _this->_impl_.extensions_.Destruct();
}
void QueryContext::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void QueryContext::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.QueryContext)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extensions_.Clear();
  _impl_.current_catalog_.ClearToEmpty();
  _impl_.current_schema_.ClearToEmpty();
  _impl_.timezone_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.seq_snapshots_ != nullptr) {
    delete _impl_.seq_snapshots_;
  }
  _impl_.seq_snapshots_ = nullptr;
  _impl_.channel_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* QueryContext::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string current_catalog = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_current_catalog();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.QueryContext.current_catalog"));
        } else
          goto handle_unusual;
        continue;
      // string current_schema = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_current_schema();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.QueryContext.current_schema"));
        } else
          goto handle_unusual;
        continue;
      // string timezone = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_timezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.QueryContext.timezone"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> extensions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.extensions_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 channel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.SequenceSnapshots seq_snapshots = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_seq_snapshots(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* QueryContext::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.QueryContext)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string current_catalog = 1;
  if (!this->_internal_current_catalog().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_current_catalog().data(), static_cast<int>(this->_internal_current_catalog().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.QueryContext.current_catalog");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_current_catalog(), target);
  }

  // string current_schema = 2;
  if (!this->_internal_current_schema().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_current_schema().data(), static_cast<int>(this->_internal_current_schema().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.QueryContext.current_schema");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_current_schema(), target);
  }

  // string timezone = 4;
  if (!this->_internal_timezone().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_timezone().data(), static_cast<int>(this->_internal_timezone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.QueryContext.timezone");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_timezone(), target);
  }

  // map<string, string> extensions = 5;
  if (!this->_internal_extensions().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = QueryContext_ExtensionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_extensions();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.QueryContext.ExtensionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.QueryContext.ExtensionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // uint32 channel = 6;
  if (this->_internal_channel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_channel(), target);
  }

  // .greptime.v1.SequenceSnapshots seq_snapshots = 7;
  if (this->_internal_has_seq_snapshots()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::seq_snapshots(this),
        _Internal::seq_snapshots(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.QueryContext)
  return target;
}

size_t QueryContext::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.QueryContext)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> extensions = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_extensions_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_extensions().begin();
      it != this->_internal_extensions().end(); ++it) {
    total_size += QueryContext_ExtensionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string current_catalog = 1;
  if (!this->_internal_current_catalog().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_current_catalog());
  }

  // string current_schema = 2;
  if (!this->_internal_current_schema().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_current_schema());
  }

  // string timezone = 4;
  if (!this->_internal_timezone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_timezone());
  }

  // .greptime.v1.SequenceSnapshots seq_snapshots = 7;
  if (this->_internal_has_seq_snapshots()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.seq_snapshots_);
  }

  // uint32 channel = 6;
  if (this->_internal_channel() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData QueryContext::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    QueryContext::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*QueryContext::GetClassData() const { return &_class_data_; }


void QueryContext::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<QueryContext*>(&to_msg);
  auto& from = static_cast<const QueryContext&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.QueryContext)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extensions_.MergeFrom(from._impl_.extensions_);
  if (!from._internal_current_catalog().empty()) {
    _this->_internal_set_current_catalog(from._internal_current_catalog());
  }
  if (!from._internal_current_schema().empty()) {
    _this->_internal_set_current_schema(from._internal_current_schema());
  }
  if (!from._internal_timezone().empty()) {
    _this->_internal_set_timezone(from._internal_timezone());
  }
  if (from._internal_has_seq_snapshots()) {
    _this->_internal_mutable_seq_snapshots()->::greptime::v1::SequenceSnapshots::MergeFrom(
        from._internal_seq_snapshots());
  }
  if (from._internal_channel() != 0) {
    _this->_internal_set_channel(from._internal_channel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void QueryContext::CopyFrom(const QueryContext& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.QueryContext)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryContext::IsInitialized() const {
  return true;
}

void QueryContext::InternalSwap(QueryContext* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extensions_.InternalSwap(&other->_impl_.extensions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.current_catalog_, lhs_arena,
      &other->_impl_.current_catalog_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.current_schema_, lhs_arena,
      &other->_impl_.current_schema_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.timezone_, lhs_arena,
      &other->_impl_.timezone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueryContext, _impl_.channel_)
      + sizeof(QueryContext::_impl_.channel_)
      - PROTOBUF_FIELD_OFFSET(QueryContext, _impl_.seq_snapshots_)>(
          reinterpret_cast<char*>(&_impl_.seq_snapshots_),
          reinterpret_cast<char*>(&other->_impl_.seq_snapshots_));
}

::PROTOBUF_NAMESPACE_ID::Metadata QueryContext::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[1]);
}

// ===================================================================

SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse() {}
SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::MergeFrom(const SequenceSnapshots_SeqSnapshotsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[2]);
}

// ===================================================================

class SequenceSnapshots::_Internal {
 public:
};

SequenceSnapshots::SequenceSnapshots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &SequenceSnapshots::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.SequenceSnapshots)
}
SequenceSnapshots::SequenceSnapshots(const SequenceSnapshots& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SequenceSnapshots* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.seq_snapshots_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.seq_snapshots_.MergeFrom(from._impl_.seq_snapshots_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.SequenceSnapshots)
}

inline void SequenceSnapshots::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.seq_snapshots_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SequenceSnapshots::~SequenceSnapshots() {
  // @@protoc_insertion_point(destructor:greptime.v1.SequenceSnapshots)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void SequenceSnapshots::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.seq_snapshots_.Destruct();
  _impl_.seq_snapshots_.~MapField();
}

void SequenceSnapshots::ArenaDtor(void* object) {
  SequenceSnapshots* _this = reinterpret_cast< SequenceSnapshots* >(object);
  _this->_impl_.seq_snapshots_.Destruct();
}
void SequenceSnapshots::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SequenceSnapshots::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.SequenceSnapshots)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.seq_snapshots_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SequenceSnapshots::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<uint64, uint64> seq_snapshots = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.seq_snapshots_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SequenceSnapshots::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.SequenceSnapshots)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<uint64, uint64> seq_snapshots = 7;
  if (!this->_internal_seq_snapshots().empty()) {
    using MapType = ::_pb::Map<uint64_t, uint64_t>;
    using WireHelper = SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_seq_snapshots();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.SequenceSnapshots)
  return target;
}

size_t SequenceSnapshots::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.SequenceSnapshots)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<uint64, uint64> seq_snapshots = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_seq_snapshots_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >::const_iterator
      it = this->_internal_seq_snapshots().begin();
      it != this->_internal_seq_snapshots().end(); ++it) {
    total_size += SequenceSnapshots_SeqSnapshotsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SequenceSnapshots::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SequenceSnapshots::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SequenceSnapshots::GetClassData() const { return &_class_data_; }


void SequenceSnapshots::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SequenceSnapshots*>(&to_msg);
  auto& from = static_cast<const SequenceSnapshots&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.SequenceSnapshots)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.seq_snapshots_.MergeFrom(from._impl_.seq_snapshots_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SequenceSnapshots::CopyFrom(const SequenceSnapshots& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.SequenceSnapshots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SequenceSnapshots::IsInitialized() const {
  return true;
}

void SequenceSnapshots::InternalSwap(SequenceSnapshots* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.seq_snapshots_.InternalSwap(&other->_impl_.seq_snapshots_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SequenceSnapshots::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[3]);
}

// ===================================================================

RequestHeader_TracingContextEntry_DoNotUse::RequestHeader_TracingContextEntry_DoNotUse() {}
RequestHeader_TracingContextEntry_DoNotUse::RequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void RequestHeader_TracingContextEntry_DoNotUse::MergeFrom(const RequestHeader_TracingContextEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata RequestHeader_TracingContextEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[4]);
}

// ===================================================================

class RequestHeader::_Internal {
 public:
  static const ::greptime::v1::AuthHeader& authorization(const RequestHeader* msg);
};

const ::greptime::v1::AuthHeader&
RequestHeader::_Internal::authorization(const RequestHeader* msg) {
  return *msg->_impl_.authorization_;
}
RequestHeader::RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &RequestHeader::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.RequestHeader)
}
RequestHeader::RequestHeader(const RequestHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RequestHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.tracing_context_)*/{}
    , decltype(_impl_.catalog_){}
    , decltype(_impl_.schema_){}
    , decltype(_impl_.dbname_){}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.authorization_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.tracing_context_.MergeFrom(from._impl_.tracing_context_);
  _impl_.catalog_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.catalog_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_catalog().empty()) {
    _this->_impl_.catalog_.Set(from._internal_catalog(), 
      _this->GetArenaForAllocation());
  }
  _impl_.schema_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_schema().empty()) {
    _this->_impl_.schema_.Set(from._internal_schema(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dbname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dbname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dbname().empty()) {
    _this->_impl_.dbname_.Set(from._internal_dbname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_timezone().empty()) {
    _this->_impl_.timezone_.Set(from._internal_timezone(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_authorization()) {
    _this->_impl_.authorization_ = new ::greptime::v1::AuthHeader(*from._impl_.authorization_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.RequestHeader)
}

inline void RequestHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.tracing_context_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.catalog_){}
    , decltype(_impl_.schema_){}
    , decltype(_impl_.dbname_){}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.authorization_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.catalog_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.catalog_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dbname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dbname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RequestHeader::~RequestHeader() {
  // @@protoc_insertion_point(destructor:greptime.v1.RequestHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void RequestHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tracing_context_.Destruct();
  _impl_.tracing_context_.~MapField();
  _impl_.catalog_.Destroy();
  _impl_.schema_.Destroy();
  _impl_.dbname_.Destroy();
  _impl_.timezone_.Destroy();
  if (this != internal_default_instance()) delete _impl_.authorization_;
}

void RequestHeader::ArenaDtor(void* object) {
  RequestHeader* _this = reinterpret_cast< RequestHeader* >(object);
  _this->_impl_.tracing_context_.Destruct();
}
void RequestHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RequestHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.RequestHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tracing_context_.Clear();
  _impl_.catalog_.ClearToEmpty();
  _impl_.schema_.ClearToEmpty();
  _impl_.dbname_.ClearToEmpty();
  _impl_.timezone_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.authorization_ != nullptr) {
    delete _impl_.authorization_;
  }
  _impl_.authorization_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RequestHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string catalog = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_catalog();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.RequestHeader.catalog"));
        } else
          goto handle_unusual;
        continue;
      // string schema = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_schema();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.RequestHeader.schema"));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.AuthHeader authorization = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_authorization(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string dbname = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_dbname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.RequestHeader.dbname"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> tracing_context = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.tracing_context_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string timezone = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_timezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.RequestHeader.timezone"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequestHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.RequestHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string catalog = 1;
  if (!this->_internal_catalog().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_catalog().data(), static_cast<int>(this->_internal_catalog().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.RequestHeader.catalog");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_catalog(), target);
  }

  // string schema = 2;
  if (!this->_internal_schema().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_schema().data(), static_cast<int>(this->_internal_schema().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.RequestHeader.schema");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_schema(), target);
  }

  // .greptime.v1.AuthHeader authorization = 3;
  if (this->_internal_has_authorization()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::authorization(this),
        _Internal::authorization(this).GetCachedSize(), target, stream);
  }

  // string dbname = 4;
  if (!this->_internal_dbname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dbname().data(), static_cast<int>(this->_internal_dbname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.RequestHeader.dbname");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_dbname(), target);
  }

  // map<string, string> tracing_context = 5;
  if (!this->_internal_tracing_context().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = RequestHeader_TracingContextEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_tracing_context();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.RequestHeader.TracingContextEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.RequestHeader.TracingContextEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string timezone = 6;
  if (!this->_internal_timezone().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_timezone().data(), static_cast<int>(this->_internal_timezone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.RequestHeader.timezone");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_timezone(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.RequestHeader)
  return target;
}

size_t RequestHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.RequestHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> tracing_context = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_tracing_context_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_tracing_context().begin();
      it != this->_internal_tracing_context().end(); ++it) {
    total_size += RequestHeader_TracingContextEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string catalog = 1;
  if (!this->_internal_catalog().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_catalog());
  }

  // string schema = 2;
  if (!this->_internal_schema().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_schema());
  }

  // string dbname = 4;
  if (!this->_internal_dbname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dbname());
  }

  // string timezone = 6;
  if (!this->_internal_timezone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_timezone());
  }

  // .greptime.v1.AuthHeader authorization = 3;
  if (this->_internal_has_authorization()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.authorization_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RequestHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RequestHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RequestHeader::GetClassData() const { return &_class_data_; }


void RequestHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RequestHeader*>(&to_msg);
  auto& from = static_cast<const RequestHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.RequestHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tracing_context_.MergeFrom(from._impl_.tracing_context_);
  if (!from._internal_catalog().empty()) {
    _this->_internal_set_catalog(from._internal_catalog());
  }
  if (!from._internal_schema().empty()) {
    _this->_internal_set_schema(from._internal_schema());
  }
  if (!from._internal_dbname().empty()) {
    _this->_internal_set_dbname(from._internal_dbname());
  }
  if (!from._internal_timezone().empty()) {
    _this->_internal_set_timezone(from._internal_timezone());
  }
  if (from._internal_has_authorization()) {
    _this->_internal_mutable_authorization()->::greptime::v1::AuthHeader::MergeFrom(
        from._internal_authorization());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RequestHeader::CopyFrom(const RequestHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.RequestHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestHeader::IsInitialized() const {
  return true;
}

void RequestHeader::InternalSwap(RequestHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tracing_context_.InternalSwap(&other->_impl_.tracing_context_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.catalog_, lhs_arena,
      &other->_impl_.catalog_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.schema_, lhs_arena,
      &other->_impl_.schema_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dbname_, lhs_arena,
      &other->_impl_.dbname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.timezone_, lhs_arena,
      &other->_impl_.timezone_, rhs_arena
  );
  swap(_impl_.authorization_, other->_impl_.authorization_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RequestHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[5]);
}

// ===================================================================

class ResponseHeader::_Internal {
 public:
  static const ::greptime::v1::Status& status(const ResponseHeader* msg);
};

const ::greptime::v1::Status&
ResponseHeader::_Internal::status(const ResponseHeader* msg) {
  return *msg->_impl_.status_;
}
ResponseHeader::ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.ResponseHeader)
}
ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResponseHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::greptime::v1::Status(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.ResponseHeader)
}

inline void ResponseHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ResponseHeader::~ResponseHeader() {
  // @@protoc_insertion_point(destructor:greptime.v1.ResponseHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResponseHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.status_;
}

void ResponseHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResponseHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.ResponseHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResponseHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResponseHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.ResponseHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.Status status = 1;
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.ResponseHeader)
  return target;
}

size_t ResponseHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.ResponseHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.Status status = 1;
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResponseHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResponseHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResponseHeader::GetClassData() const { return &_class_data_; }


void ResponseHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResponseHeader*>(&to_msg);
  auto& from = static_cast<const ResponseHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.ResponseHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::greptime::v1::Status::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.ResponseHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {
  return true;
}

void ResponseHeader::InternalSwap(ResponseHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ResponseHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[6]);
}

// ===================================================================

class Status::_Internal {
 public:
};

Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Status* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.err_msg_){}
    , decltype(_impl_.status_code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.err_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_err_msg().empty()) {
    _this->_impl_.err_msg_.Set(from._internal_err_msg(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.status_code_ = from._impl_.status_code_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.Status)
}

inline void Status::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.err_msg_){}
    , decltype(_impl_.status_code_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.err_msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:greptime.v1.Status)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.err_msg_.Destroy();
}

void Status::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.err_msg_.ClearToEmpty();
  _impl_.status_code_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Status::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 status_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.status_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string err_msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_err_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.Status.err_msg"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 status_code = 1;
  if (this->_internal_status_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_status_code(), target);
  }

  // string err_msg = 2;
  if (!this->_internal_err_msg().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_err_msg().data(), static_cast<int>(this->_internal_err_msg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.Status.err_msg");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_err_msg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.Status)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string err_msg = 2;
  if (!this->_internal_err_msg().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_err_msg());
  }

  // uint32 status_code = 1;
  if (this->_internal_status_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Status::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Status::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Status::GetClassData() const { return &_class_data_; }


void Status::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Status*>(&to_msg);
  auto& from = static_cast<const Status&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.Status)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_err_msg().empty()) {
    _this->_internal_set_err_msg(from._internal_err_msg());
  }
  if (from._internal_status_code() != 0) {
    _this->_internal_set_status_code(from._internal_status_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.err_msg_, lhs_arena,
      &other->_impl_.err_msg_, rhs_arena
  );
  swap(_impl_.status_code_, other->_impl_.status_code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Status::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[7]);
}

// ===================================================================

class AuthHeader::_Internal {
 public:
  static const ::greptime::v1::Basic& basic(const AuthHeader* msg);
  static const ::greptime::v1::Token& token(const AuthHeader* msg);
};

const ::greptime::v1::Basic&
AuthHeader::_Internal::basic(const AuthHeader* msg) {
  return *msg->_impl_.auth_scheme_.basic_;
}
const ::greptime::v1::Token&
AuthHeader::_Internal::token(const AuthHeader* msg) {
  return *msg->_impl_.auth_scheme_.token_;
}
void AuthHeader::set_allocated_basic(::greptime::v1::Basic* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_auth_scheme();
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basic);
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    set_has_basic();
    _impl_.auth_scheme_.basic_ = basic;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AuthHeader.basic)
}
void AuthHeader::set_allocated_token(::greptime::v1::Token* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_auth_scheme();
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    set_has_token();
    _impl_.auth_scheme_.token_ = token;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.AuthHeader.token)
}
AuthHeader::AuthHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.AuthHeader)
}
AuthHeader::AuthHeader(const AuthHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.auth_scheme_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_auth_scheme();
  switch (from.auth_scheme_case()) {
    case kBasic: {
      _this->_internal_mutable_basic()->::greptime::v1::Basic::MergeFrom(
          from._internal_basic());
      break;
    }
    case kToken: {
      _this->_internal_mutable_token()->::greptime::v1::Token::MergeFrom(
          from._internal_token());
      break;
    }
    case AUTH_SCHEME_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.AuthHeader)
}

inline void AuthHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.auth_scheme_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_auth_scheme();
}

AuthHeader::~AuthHeader() {
  // @@protoc_insertion_point(destructor:greptime.v1.AuthHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_auth_scheme()) {
    clear_auth_scheme();
  }
}

void AuthHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthHeader::clear_auth_scheme() {
// @@protoc_insertion_point(one_of_clear_start:greptime.v1.AuthHeader)
  switch (auth_scheme_case()) {
    case kBasic: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.auth_scheme_.basic_;
      }
      break;
    }
    case kToken: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.auth_scheme_.token_;
      }
      break;
    }
    case AUTH_SCHEME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = AUTH_SCHEME_NOT_SET;
}


void AuthHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.AuthHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_auth_scheme();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.Basic basic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_basic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.Token token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_token(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.AuthHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.Basic basic = 1;
  if (_internal_has_basic()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::basic(this),
        _Internal::basic(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.Token token = 2;
  if (_internal_has_token()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::token(this),
        _Internal::token(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.AuthHeader)
  return target;
}

size_t AuthHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.AuthHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (auth_scheme_case()) {
    // .greptime.v1.Basic basic = 1;
    case kBasic: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auth_scheme_.basic_);
      break;
    }
    // .greptime.v1.Token token = 2;
    case kToken: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.auth_scheme_.token_);
      break;
    }
    case AUTH_SCHEME_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthHeader::GetClassData() const { return &_class_data_; }


void AuthHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthHeader*>(&to_msg);
  auto& from = static_cast<const AuthHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.AuthHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.auth_scheme_case()) {
    case kBasic: {
      _this->_internal_mutable_basic()->::greptime::v1::Basic::MergeFrom(
          from._internal_basic());
      break;
    }
    case kToken: {
      _this->_internal_mutable_token()->::greptime::v1::Token::MergeFrom(
          from._internal_token());
      break;
    }
    case AUTH_SCHEME_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthHeader::CopyFrom(const AuthHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.AuthHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthHeader::IsInitialized() const {
  return true;
}

void AuthHeader::InternalSwap(AuthHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.auth_scheme_, other->_impl_.auth_scheme_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[8]);
}

// ===================================================================

class Basic::_Internal {
 public:
};

Basic::Basic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.Basic)
}
Basic::Basic(const Basic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Basic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.username_){}
    , decltype(_impl_.password_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    _this->_impl_.username_.Set(from._internal_username(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.Basic)
}

inline void Basic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.username_){}
    , decltype(_impl_.password_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Basic::~Basic() {
  // @@protoc_insertion_point(destructor:greptime.v1.Basic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Basic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.username_.Destroy();
  _impl_.password_.Destroy();
}

void Basic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Basic::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.Basic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.username_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Basic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string username = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.Basic.username"));
        } else
          goto handle_unusual;
        continue;
      // string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.Basic.password"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Basic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.Basic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string username = 1;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.Basic.username");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_username(), target);
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.Basic.password");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.Basic)
  return target;
}

size_t Basic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.Basic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string username = 1;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  // string password = 2;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Basic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Basic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Basic::GetClassData() const { return &_class_data_; }


void Basic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Basic*>(&to_msg);
  auto& from = static_cast<const Basic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.Basic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_username().empty()) {
    _this->_internal_set_username(from._internal_username());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Basic::CopyFrom(const Basic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.Basic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Basic::IsInitialized() const {
  return true;
}

void Basic::InternalSwap(Basic* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.username_, lhs_arena,
      &other->_impl_.username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Basic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[9]);
}

// ===================================================================

class Token::_Internal {
 public:
};

Token::Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.Token)
}
Token::Token(const Token& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Token* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token().empty()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.Token)
}

inline void Token::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Token::~Token() {
  // @@protoc_insertion_point(destructor:greptime.v1.Token)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Token::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
}

void Token::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Token::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.Token)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Token::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.Token.token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Token::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.Token)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string token = 1;
  if (!this->_internal_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.Token.token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.Token)
  return target;
}

size_t Token::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.Token)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string token = 1;
  if (!this->_internal_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Token::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Token::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Token::GetClassData() const { return &_class_data_; }


void Token::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Token*>(&to_msg);
  auto& from = static_cast<const Token&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.Token)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_token().empty()) {
    _this->_internal_set_token(from._internal_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Token::CopyFrom(const Token& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.Token)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Token::IsInitialized() const {
  return true;
}

void Token::InternalSwap(Token* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Token::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[10]);
}

// ===================================================================

class TableName::_Internal {
 public:
};

TableName::TableName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.TableName)
}
TableName::TableName(const TableName& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableName* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.catalog_name_){}
    , decltype(_impl_.schema_name_){}
    , decltype(_impl_.table_name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.catalog_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_catalog_name().empty()) {
    _this->_impl_.catalog_name_.Set(from._internal_catalog_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.schema_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_schema_name().empty()) {
    _this->_impl_.schema_name_.Set(from._internal_schema_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_table_name().empty()) {
    _this->_impl_.table_name_.Set(from._internal_table_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.TableName)
}

inline void TableName::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.catalog_name_){}
    , decltype(_impl_.schema_name_){}
    , decltype(_impl_.table_name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.catalog_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TableName::~TableName() {
  // @@protoc_insertion_point(destructor:greptime.v1.TableName)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableName::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.catalog_name_.Destroy();
  _impl_.schema_name_.Destroy();
  _impl_.table_name_.Destroy();
}

void TableName::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableName::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.TableName)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.catalog_name_.ClearToEmpty();
  _impl_.schema_name_.ClearToEmpty();
  _impl_.table_name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableName::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string catalog_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_catalog_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.TableName.catalog_name"));
        } else
          goto handle_unusual;
        continue;
      // string schema_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_schema_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.TableName.schema_name"));
        } else
          goto handle_unusual;
        continue;
      // string table_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_table_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.TableName.table_name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableName::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.TableName)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string catalog_name = 1;
  if (!this->_internal_catalog_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_catalog_name().data(), static_cast<int>(this->_internal_catalog_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.TableName.catalog_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_catalog_name(), target);
  }

  // string schema_name = 2;
  if (!this->_internal_schema_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_schema_name().data(), static_cast<int>(this->_internal_schema_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.TableName.schema_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_schema_name(), target);
  }

  // string table_name = 3;
  if (!this->_internal_table_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_table_name().data(), static_cast<int>(this->_internal_table_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.TableName.table_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_table_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.TableName)
  return target;
}

size_t TableName::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.TableName)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string catalog_name = 1;
  if (!this->_internal_catalog_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_catalog_name());
  }

  // string schema_name = 2;
  if (!this->_internal_schema_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_schema_name());
  }

  // string table_name = 3;
  if (!this->_internal_table_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_table_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableName::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableName::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableName::GetClassData() const { return &_class_data_; }


void TableName::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableName*>(&to_msg);
  auto& from = static_cast<const TableName&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.TableName)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_catalog_name().empty()) {
    _this->_internal_set_catalog_name(from._internal_catalog_name());
  }
  if (!from._internal_schema_name().empty()) {
    _this->_internal_set_schema_name(from._internal_schema_name());
  }
  if (!from._internal_table_name().empty()) {
    _this->_internal_set_table_name(from._internal_table_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableName::CopyFrom(const TableName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.TableName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableName::IsInitialized() const {
  return true;
}

void TableName::InternalSwap(TableName* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.catalog_name_, lhs_arena,
      &other->_impl_.catalog_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.schema_name_, lhs_arena,
      &other->_impl_.schema_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.table_name_, lhs_arena,
      &other->_impl_.table_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TableName::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[11]);
}

// ===================================================================

class AffectedRows::_Internal {
 public:
};

AffectedRows::AffectedRows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.AffectedRows)
}
AffectedRows::AffectedRows(const AffectedRows& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AffectedRows* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.AffectedRows)
}

inline void AffectedRows::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AffectedRows::~AffectedRows() {
  // @@protoc_insertion_point(destructor:greptime.v1.AffectedRows)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AffectedRows::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AffectedRows::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AffectedRows::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.AffectedRows)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AffectedRows::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AffectedRows::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.AffectedRows)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.AffectedRows)
  return target;
}

size_t AffectedRows::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.AffectedRows)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 value = 1;
  if (this->_internal_value() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AffectedRows::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AffectedRows::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AffectedRows::GetClassData() const { return &_class_data_; }


void AffectedRows::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AffectedRows*>(&to_msg);
  auto& from = static_cast<const AffectedRows&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.AffectedRows)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AffectedRows::CopyFrom(const AffectedRows& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.AffectedRows)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AffectedRows::IsInitialized() const {
  return true;
}

void AffectedRows::InternalSwap(AffectedRows* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AffectedRows::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[12]);
}

// ===================================================================

class Metrics::_Internal {
 public:
};

Metrics::Metrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.Metrics)
}
Metrics::Metrics(const Metrics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Metrics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.metrics_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.metrics_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.metrics_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_metrics().empty()) {
    _this->_impl_.metrics_.Set(from._internal_metrics(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.Metrics)
}

inline void Metrics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.metrics_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.metrics_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.metrics_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Metrics::~Metrics() {
  // @@protoc_insertion_point(destructor:greptime.v1.Metrics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Metrics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metrics_.Destroy();
}

void Metrics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Metrics::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.Metrics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metrics_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Metrics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes metrics = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_metrics();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Metrics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.Metrics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes metrics = 1;
  if (!this->_internal_metrics().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_metrics(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.Metrics)
  return target;
}

size_t Metrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.Metrics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes metrics = 1;
  if (!this->_internal_metrics().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_metrics());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Metrics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Metrics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Metrics::GetClassData() const { return &_class_data_; }


void Metrics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Metrics*>(&to_msg);
  auto& from = static_cast<const Metrics&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.Metrics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_metrics().empty()) {
    _this->_internal_set_metrics(from._internal_metrics());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Metrics::CopyFrom(const Metrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.Metrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metrics::IsInitialized() const {
  return true;
}

void Metrics::InternalSwap(Metrics* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.metrics_, lhs_arena,
      &other->_impl_.metrics_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Metrics::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[13]);
}

// ===================================================================

class ExpireAfter::_Internal {
 public:
};

ExpireAfter::ExpireAfter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.ExpireAfter)
}
ExpireAfter::ExpireAfter(const ExpireAfter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpireAfter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.ExpireAfter)
}

inline void ExpireAfter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ExpireAfter::~ExpireAfter() {
  // @@protoc_insertion_point(destructor:greptime.v1.ExpireAfter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpireAfter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExpireAfter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpireAfter::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.ExpireAfter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpireAfter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpireAfter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.ExpireAfter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 value = 1;
  if (this->_internal_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.ExpireAfter)
  return target;
}

size_t ExpireAfter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.ExpireAfter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 value = 1;
  if (this->_internal_value() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpireAfter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpireAfter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpireAfter::GetClassData() const { return &_class_data_; }


void ExpireAfter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpireAfter*>(&to_msg);
  auto& from = static_cast<const ExpireAfter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.ExpireAfter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpireAfter::CopyFrom(const ExpireAfter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.ExpireAfter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpireAfter::IsInitialized() const {
  return true;
}

void ExpireAfter::InternalSwap(ExpireAfter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpireAfter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[14]);
}

// ===================================================================

class FlightMetadata::_Internal {
 public:
  static const ::greptime::v1::AffectedRows& affected_rows(const FlightMetadata* msg);
  static const ::greptime::v1::Metrics& metrics(const FlightMetadata* msg);
};

const ::greptime::v1::AffectedRows&
FlightMetadata::_Internal::affected_rows(const FlightMetadata* msg) {
  return *msg->_impl_.affected_rows_;
}
const ::greptime::v1::Metrics&
FlightMetadata::_Internal::metrics(const FlightMetadata* msg) {
  return *msg->_impl_.metrics_;
}
FlightMetadata::FlightMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.FlightMetadata)
}
FlightMetadata::FlightMetadata(const FlightMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlightMetadata* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.affected_rows_){nullptr}
    , decltype(_impl_.metrics_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_affected_rows()) {
    _this->_impl_.affected_rows_ = new ::greptime::v1::AffectedRows(*from._impl_.affected_rows_);
  }
  if (from._internal_has_metrics()) {
    _this->_impl_.metrics_ = new ::greptime::v1::Metrics(*from._impl_.metrics_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.FlightMetadata)
}

inline void FlightMetadata::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.affected_rows_){nullptr}
    , decltype(_impl_.metrics_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlightMetadata::~FlightMetadata() {
  // @@protoc_insertion_point(destructor:greptime.v1.FlightMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlightMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.affected_rows_;
  if (this != internal_default_instance()) delete _impl_.metrics_;
}

void FlightMetadata::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlightMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.FlightMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.affected_rows_ != nullptr) {
    delete _impl_.affected_rows_;
  }
  _impl_.affected_rows_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlightMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.AffectedRows affected_rows = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_affected_rows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.Metrics metrics = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlightMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.FlightMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.AffectedRows affected_rows = 1;
  if (this->_internal_has_affected_rows()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::affected_rows(this),
        _Internal::affected_rows(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.Metrics metrics = 2;
  if (this->_internal_has_metrics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::metrics(this),
        _Internal::metrics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.FlightMetadata)
  return target;
}

size_t FlightMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.FlightMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.AffectedRows affected_rows = 1;
  if (this->_internal_has_affected_rows()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.affected_rows_);
  }

  // .greptime.v1.Metrics metrics = 2;
  if (this->_internal_has_metrics()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.metrics_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlightMetadata::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlightMetadata::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlightMetadata::GetClassData() const { return &_class_data_; }


void FlightMetadata::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlightMetadata*>(&to_msg);
  auto& from = static_cast<const FlightMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.FlightMetadata)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_affected_rows()) {
    _this->_internal_mutable_affected_rows()->::greptime::v1::AffectedRows::MergeFrom(
        from._internal_affected_rows());
  }
  if (from._internal_has_metrics()) {
    _this->_internal_mutable_metrics()->::greptime::v1::Metrics::MergeFrom(
        from._internal_metrics());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlightMetadata::CopyFrom(const FlightMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.FlightMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlightMetadata::IsInitialized() const {
  return true;
}

void FlightMetadata::InternalSwap(FlightMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlightMetadata, _impl_.metrics_)
      + sizeof(FlightMetadata::_impl_.metrics_)
      - PROTOBUF_FIELD_OFFSET(FlightMetadata, _impl_.affected_rows_)>(
          reinterpret_cast<char*>(&_impl_.affected_rows_),
          reinterpret_cast<char*>(&other->_impl_.affected_rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlightMetadata::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[15]);
}

// ===================================================================

class IntervalMonthDayNano::_Internal {
 public:
};

IntervalMonthDayNano::IntervalMonthDayNano(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.IntervalMonthDayNano)
}
IntervalMonthDayNano::IntervalMonthDayNano(const IntervalMonthDayNano& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntervalMonthDayNano* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.months_){}
    , decltype(_impl_.days_){}
    , decltype(_impl_.nanoseconds_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.months_, &from._impl_.months_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanoseconds_) -
    reinterpret_cast<char*>(&_impl_.months_)) + sizeof(_impl_.nanoseconds_));
  // @@protoc_insertion_point(copy_constructor:greptime.v1.IntervalMonthDayNano)
}

inline void IntervalMonthDayNano::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.months_){0}
    , decltype(_impl_.days_){0}
    , decltype(_impl_.nanoseconds_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

IntervalMonthDayNano::~IntervalMonthDayNano() {
  // @@protoc_insertion_point(destructor:greptime.v1.IntervalMonthDayNano)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntervalMonthDayNano::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IntervalMonthDayNano::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntervalMonthDayNano::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.IntervalMonthDayNano)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.months_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nanoseconds_) -
      reinterpret_cast<char*>(&_impl_.months_)) + sizeof(_impl_.nanoseconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntervalMonthDayNano::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 months = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.months_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 days = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.days_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 nanoseconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.nanoseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntervalMonthDayNano::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.IntervalMonthDayNano)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 months = 1;
  if (this->_internal_months() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_months(), target);
  }

  // int32 days = 2;
  if (this->_internal_days() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_days(), target);
  }

  // int64 nanoseconds = 3;
  if (this->_internal_nanoseconds() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_nanoseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.IntervalMonthDayNano)
  return target;
}

size_t IntervalMonthDayNano::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.IntervalMonthDayNano)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 months = 1;
  if (this->_internal_months() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_months());
  }

  // int32 days = 2;
  if (this->_internal_days() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_days());
  }

  // int64 nanoseconds = 3;
  if (this->_internal_nanoseconds() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nanoseconds());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntervalMonthDayNano::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntervalMonthDayNano::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntervalMonthDayNano::GetClassData() const { return &_class_data_; }


void IntervalMonthDayNano::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntervalMonthDayNano*>(&to_msg);
  auto& from = static_cast<const IntervalMonthDayNano&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.IntervalMonthDayNano)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_months() != 0) {
    _this->_internal_set_months(from._internal_months());
  }
  if (from._internal_days() != 0) {
    _this->_internal_set_days(from._internal_days());
  }
  if (from._internal_nanoseconds() != 0) {
    _this->_internal_set_nanoseconds(from._internal_nanoseconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntervalMonthDayNano::CopyFrom(const IntervalMonthDayNano& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.IntervalMonthDayNano)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntervalMonthDayNano::IsInitialized() const {
  return true;
}

void IntervalMonthDayNano::InternalSwap(IntervalMonthDayNano* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntervalMonthDayNano, _impl_.nanoseconds_)
      + sizeof(IntervalMonthDayNano::_impl_.nanoseconds_)
      - PROTOBUF_FIELD_OFFSET(IntervalMonthDayNano, _impl_.months_)>(
          reinterpret_cast<char*>(&_impl_.months_),
          reinterpret_cast<char*>(&other->_impl_.months_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IntervalMonthDayNano::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[16]);
}

// ===================================================================

class Decimal128::_Internal {
 public:
};

Decimal128::Decimal128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.Decimal128)
}
Decimal128::Decimal128(const Decimal128& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Decimal128* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hi_){}
    , decltype(_impl_.lo_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hi_, &from._impl_.hi_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lo_) -
    reinterpret_cast<char*>(&_impl_.hi_)) + sizeof(_impl_.lo_));
  // @@protoc_insertion_point(copy_constructor:greptime.v1.Decimal128)
}

inline void Decimal128::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hi_){int64_t{0}}
    , decltype(_impl_.lo_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Decimal128::~Decimal128() {
  // @@protoc_insertion_point(destructor:greptime.v1.Decimal128)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Decimal128::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Decimal128::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Decimal128::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.Decimal128)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hi_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.lo_) -
      reinterpret_cast<char*>(&_impl_.hi_)) + sizeof(_impl_.lo_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Decimal128::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 hi = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 lo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.lo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Decimal128::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.Decimal128)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 hi = 1;
  if (this->_internal_hi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_hi(), target);
  }

  // int64 lo = 2;
  if (this->_internal_lo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_lo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.Decimal128)
  return target;
}

size_t Decimal128::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.Decimal128)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 hi = 1;
  if (this->_internal_hi() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_hi());
  }

  // int64 lo = 2;
  if (this->_internal_lo() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lo());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Decimal128::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Decimal128::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Decimal128::GetClassData() const { return &_class_data_; }


void Decimal128::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Decimal128*>(&to_msg);
  auto& from = static_cast<const Decimal128&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.Decimal128)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hi() != 0) {
    _this->_internal_set_hi(from._internal_hi());
  }
  if (from._internal_lo() != 0) {
    _this->_internal_set_lo(from._internal_lo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Decimal128::CopyFrom(const Decimal128& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.Decimal128)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Decimal128::IsInitialized() const {
  return true;
}

void Decimal128::InternalSwap(Decimal128* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Decimal128, _impl_.lo_)
      + sizeof(Decimal128::_impl_.lo_)
      - PROTOBUF_FIELD_OFFSET(Decimal128, _impl_.hi_)>(
          reinterpret_cast<char*>(&_impl_.hi_),
          reinterpret_cast<char*>(&other->_impl_.hi_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Decimal128::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[17]);
}

// ===================================================================

class ColumnDataTypeExtension::_Internal {
 public:
  static const ::greptime::v1::DecimalTypeExtension& decimal_type(const ColumnDataTypeExtension* msg);
  static const ::greptime::v1::VectorTypeExtension& vector_type(const ColumnDataTypeExtension* msg);
};

const ::greptime::v1::DecimalTypeExtension&
ColumnDataTypeExtension::_Internal::decimal_type(const ColumnDataTypeExtension* msg) {
  return *msg->_impl_.type_ext_.decimal_type_;
}
const ::greptime::v1::VectorTypeExtension&
ColumnDataTypeExtension::_Internal::vector_type(const ColumnDataTypeExtension* msg) {
  return *msg->_impl_.type_ext_.vector_type_;
}
void ColumnDataTypeExtension::set_allocated_decimal_type(::greptime::v1::DecimalTypeExtension* decimal_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type_ext();
  if (decimal_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decimal_type);
    if (message_arena != submessage_arena) {
      decimal_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decimal_type, submessage_arena);
    }
    set_has_decimal_type();
    _impl_.type_ext_.decimal_type_ = decimal_type;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDataTypeExtension.decimal_type)
}
void ColumnDataTypeExtension::set_allocated_vector_type(::greptime::v1::VectorTypeExtension* vector_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type_ext();
  if (vector_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector_type);
    if (message_arena != submessage_arena) {
      vector_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector_type, submessage_arena);
    }
    set_has_vector_type();
    _impl_.type_ext_.vector_type_ = vector_type;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ColumnDataTypeExtension.vector_type)
}
ColumnDataTypeExtension::ColumnDataTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.ColumnDataTypeExtension)
}
ColumnDataTypeExtension::ColumnDataTypeExtension(const ColumnDataTypeExtension& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColumnDataTypeExtension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.type_ext_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_type_ext();
  switch (from.type_ext_case()) {
    case kDecimalType: {
      _this->_internal_mutable_decimal_type()->::greptime::v1::DecimalTypeExtension::MergeFrom(
          from._internal_decimal_type());
      break;
    }
    case kJsonType: {
      _this->_internal_set_json_type(from._internal_json_type());
      break;
    }
    case kVectorType: {
      _this->_internal_mutable_vector_type()->::greptime::v1::VectorTypeExtension::MergeFrom(
          from._internal_vector_type());
      break;
    }
    case TYPE_EXT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.ColumnDataTypeExtension)
}

inline void ColumnDataTypeExtension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.type_ext_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_type_ext();
}

ColumnDataTypeExtension::~ColumnDataTypeExtension() {
  // @@protoc_insertion_point(destructor:greptime.v1.ColumnDataTypeExtension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColumnDataTypeExtension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_type_ext()) {
    clear_type_ext();
  }
}

void ColumnDataTypeExtension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColumnDataTypeExtension::clear_type_ext() {
// @@protoc_insertion_point(one_of_clear_start:greptime.v1.ColumnDataTypeExtension)
  switch (type_ext_case()) {
    case kDecimalType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_ext_.decimal_type_;
      }
      break;
    }
    case kJsonType: {
      // No need to clear
      break;
    }
    case kVectorType: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_ext_.vector_type_;
      }
      break;
    }
    case TYPE_EXT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_EXT_NOT_SET;
}


void ColumnDataTypeExtension::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.ColumnDataTypeExtension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type_ext();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnDataTypeExtension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.DecimalTypeExtension decimal_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_decimal_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.JsonTypeExtension json_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_json_type(static_cast<::greptime::v1::JsonTypeExtension>(val));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.VectorTypeExtension vector_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vector_type(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColumnDataTypeExtension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.ColumnDataTypeExtension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.DecimalTypeExtension decimal_type = 1;
  if (_internal_has_decimal_type()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::decimal_type(this),
        _Internal::decimal_type(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.JsonTypeExtension json_type = 2;
  if (_internal_has_json_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_json_type(), target);
  }

  // .greptime.v1.VectorTypeExtension vector_type = 3;
  if (_internal_has_vector_type()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vector_type(this),
        _Internal::vector_type(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.ColumnDataTypeExtension)
  return target;
}

size_t ColumnDataTypeExtension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.ColumnDataTypeExtension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_ext_case()) {
    // .greptime.v1.DecimalTypeExtension decimal_type = 1;
    case kDecimalType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_ext_.decimal_type_);
      break;
    }
    // .greptime.v1.JsonTypeExtension json_type = 2;
    case kJsonType: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_json_type());
      break;
    }
    // .greptime.v1.VectorTypeExtension vector_type = 3;
    case kVectorType: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.type_ext_.vector_type_);
      break;
    }
    case TYPE_EXT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnDataTypeExtension::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColumnDataTypeExtension::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnDataTypeExtension::GetClassData() const { return &_class_data_; }


void ColumnDataTypeExtension::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColumnDataTypeExtension*>(&to_msg);
  auto& from = static_cast<const ColumnDataTypeExtension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.ColumnDataTypeExtension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_ext_case()) {
    case kDecimalType: {
      _this->_internal_mutable_decimal_type()->::greptime::v1::DecimalTypeExtension::MergeFrom(
          from._internal_decimal_type());
      break;
    }
    case kJsonType: {
      _this->_internal_set_json_type(from._internal_json_type());
      break;
    }
    case kVectorType: {
      _this->_internal_mutable_vector_type()->::greptime::v1::VectorTypeExtension::MergeFrom(
          from._internal_vector_type());
      break;
    }
    case TYPE_EXT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnDataTypeExtension::CopyFrom(const ColumnDataTypeExtension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.ColumnDataTypeExtension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnDataTypeExtension::IsInitialized() const {
  return true;
}

void ColumnDataTypeExtension::InternalSwap(ColumnDataTypeExtension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.type_ext_, other->_impl_.type_ext_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnDataTypeExtension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[18]);
}

// ===================================================================

class DecimalTypeExtension::_Internal {
 public:
};

DecimalTypeExtension::DecimalTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.DecimalTypeExtension)
}
DecimalTypeExtension::DecimalTypeExtension(const DecimalTypeExtension& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DecimalTypeExtension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.precision_){}
    , decltype(_impl_.scale_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.precision_, &from._impl_.precision_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scale_) -
    reinterpret_cast<char*>(&_impl_.precision_)) + sizeof(_impl_.scale_));
  // @@protoc_insertion_point(copy_constructor:greptime.v1.DecimalTypeExtension)
}

inline void DecimalTypeExtension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.precision_){0}
    , decltype(_impl_.scale_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DecimalTypeExtension::~DecimalTypeExtension() {
  // @@protoc_insertion_point(destructor:greptime.v1.DecimalTypeExtension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DecimalTypeExtension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DecimalTypeExtension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DecimalTypeExtension::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.DecimalTypeExtension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.precision_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.scale_) -
      reinterpret_cast<char*>(&_impl_.precision_)) + sizeof(_impl_.scale_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecimalTypeExtension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 precision = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DecimalTypeExtension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.DecimalTypeExtension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 precision = 1;
  if (this->_internal_precision() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_precision(), target);
  }

  // int32 scale = 2;
  if (this->_internal_scale() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.DecimalTypeExtension)
  return target;
}

size_t DecimalTypeExtension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.DecimalTypeExtension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 precision = 1;
  if (this->_internal_precision() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_precision());
  }

  // int32 scale = 2;
  if (this->_internal_scale() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_scale());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecimalTypeExtension::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DecimalTypeExtension::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecimalTypeExtension::GetClassData() const { return &_class_data_; }


void DecimalTypeExtension::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DecimalTypeExtension*>(&to_msg);
  auto& from = static_cast<const DecimalTypeExtension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.DecimalTypeExtension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_precision() != 0) {
    _this->_internal_set_precision(from._internal_precision());
  }
  if (from._internal_scale() != 0) {
    _this->_internal_set_scale(from._internal_scale());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecimalTypeExtension::CopyFrom(const DecimalTypeExtension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.DecimalTypeExtension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecimalTypeExtension::IsInitialized() const {
  return true;
}

void DecimalTypeExtension::InternalSwap(DecimalTypeExtension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecimalTypeExtension, _impl_.scale_)
      + sizeof(DecimalTypeExtension::_impl_.scale_)
      - PROTOBUF_FIELD_OFFSET(DecimalTypeExtension, _impl_.precision_)>(
          reinterpret_cast<char*>(&_impl_.precision_),
          reinterpret_cast<char*>(&other->_impl_.precision_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecimalTypeExtension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[19]);
}

// ===================================================================

class VectorTypeExtension::_Internal {
 public:
};

VectorTypeExtension::VectorTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.VectorTypeExtension)
}
VectorTypeExtension::VectorTypeExtension(const VectorTypeExtension& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VectorTypeExtension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dim_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.dim_ = from._impl_.dim_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.VectorTypeExtension)
}

inline void VectorTypeExtension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dim_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VectorTypeExtension::~VectorTypeExtension() {
  // @@protoc_insertion_point(destructor:greptime.v1.VectorTypeExtension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VectorTypeExtension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VectorTypeExtension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VectorTypeExtension::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.VectorTypeExtension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dim_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VectorTypeExtension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 dim = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.dim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VectorTypeExtension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.VectorTypeExtension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 dim = 1;
  if (this->_internal_dim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_dim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.VectorTypeExtension)
  return target;
}

size_t VectorTypeExtension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.VectorTypeExtension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 dim = 1;
  if (this->_internal_dim() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dim());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VectorTypeExtension::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VectorTypeExtension::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VectorTypeExtension::GetClassData() const { return &_class_data_; }


void VectorTypeExtension::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VectorTypeExtension*>(&to_msg);
  auto& from = static_cast<const VectorTypeExtension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.VectorTypeExtension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_dim() != 0) {
    _this->_internal_set_dim(from._internal_dim());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VectorTypeExtension::CopyFrom(const VectorTypeExtension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.VectorTypeExtension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VectorTypeExtension::IsInitialized() const {
  return true;
}

void VectorTypeExtension::InternalSwap(VectorTypeExtension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.dim_, other->_impl_.dim_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VectorTypeExtension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[20]);
}

// ===================================================================

ColumnOptions_OptionsEntry_DoNotUse::ColumnOptions_OptionsEntry_DoNotUse() {}
ColumnOptions_OptionsEntry_DoNotUse::ColumnOptions_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ColumnOptions_OptionsEntry_DoNotUse::MergeFrom(const ColumnOptions_OptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ColumnOptions_OptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[21]);
}

// ===================================================================

class ColumnOptions::_Internal {
 public:
};

ColumnOptions::ColumnOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &ColumnOptions::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.ColumnOptions)
}
ColumnOptions::ColumnOptions(const ColumnOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColumnOptions* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.options_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.ColumnOptions)
}

inline void ColumnOptions::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.options_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ColumnOptions::~ColumnOptions() {
  // @@protoc_insertion_point(destructor:greptime.v1.ColumnOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void ColumnOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.options_.Destruct();
  _impl_.options_.~MapField();
}

void ColumnOptions::ArenaDtor(void* object) {
  ColumnOptions* _this = reinterpret_cast< ColumnOptions* >(object);
  _this->_impl_.options_.Destruct();
}
void ColumnOptions::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColumnOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.ColumnOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.options_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColumnOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.ColumnOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> options = 1;
  if (!this->_internal_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ColumnOptions_OptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.ColumnOptions.OptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.ColumnOptions.OptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.ColumnOptions)
  return target;
}

size_t ColumnOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.ColumnOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> options = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_options().begin();
      it != this->_internal_options().end(); ++it) {
    total_size += ColumnOptions_OptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnOptions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColumnOptions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnOptions::GetClassData() const { return &_class_data_; }


void ColumnOptions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColumnOptions*>(&to_msg);
  auto& from = static_cast<const ColumnOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.ColumnOptions)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.options_.MergeFrom(from._impl_.options_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnOptions::CopyFrom(const ColumnOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.ColumnOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnOptions::IsInitialized() const {
  return true;
}

void ColumnOptions::InternalSwap(ColumnOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.options_.InternalSwap(&other->_impl_.options_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnOptions::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fcommon_2eproto_getter, &descriptor_table_greptime_2fv1_2fcommon_2eproto_once,
      file_level_metadata_greptime_2fv1_2fcommon_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::QueryContext*
Arena::CreateMaybeMessage< ::greptime::v1::QueryContext >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::QueryContext >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::SequenceSnapshots_SeqSnapshotsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::SequenceSnapshots*
Arena::CreateMaybeMessage< ::greptime::v1::SequenceSnapshots >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::SequenceSnapshots >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::RequestHeader*
Arena::CreateMaybeMessage< ::greptime::v1::RequestHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::RequestHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::ResponseHeader*
Arena::CreateMaybeMessage< ::greptime::v1::ResponseHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::ResponseHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::Status*
Arena::CreateMaybeMessage< ::greptime::v1::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::AuthHeader*
Arena::CreateMaybeMessage< ::greptime::v1::AuthHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::AuthHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::Basic*
Arena::CreateMaybeMessage< ::greptime::v1::Basic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::Basic >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::Token*
Arena::CreateMaybeMessage< ::greptime::v1::Token >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::Token >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::TableName*
Arena::CreateMaybeMessage< ::greptime::v1::TableName >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::TableName >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::AffectedRows*
Arena::CreateMaybeMessage< ::greptime::v1::AffectedRows >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::AffectedRows >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::Metrics*
Arena::CreateMaybeMessage< ::greptime::v1::Metrics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::Metrics >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::ExpireAfter*
Arena::CreateMaybeMessage< ::greptime::v1::ExpireAfter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::ExpireAfter >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::FlightMetadata*
Arena::CreateMaybeMessage< ::greptime::v1::FlightMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::FlightMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::IntervalMonthDayNano*
Arena::CreateMaybeMessage< ::greptime::v1::IntervalMonthDayNano >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::IntervalMonthDayNano >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::Decimal128*
Arena::CreateMaybeMessage< ::greptime::v1::Decimal128 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::Decimal128 >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::ColumnDataTypeExtension*
Arena::CreateMaybeMessage< ::greptime::v1::ColumnDataTypeExtension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::ColumnDataTypeExtension >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::DecimalTypeExtension*
Arena::CreateMaybeMessage< ::greptime::v1::DecimalTypeExtension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::DecimalTypeExtension >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::VectorTypeExtension*
Arena::CreateMaybeMessage< ::greptime::v1::VectorTypeExtension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::VectorTypeExtension >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::ColumnOptions*
Arena::CreateMaybeMessage< ::greptime::v1::ColumnOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::ColumnOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
