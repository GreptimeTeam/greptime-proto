// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/flow/server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fflow_2fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fflow_2fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
#include "greptime/v1/ddl.pb.h"
#include "greptime/v1/row.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fflow_2fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fflow_2fserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto;
namespace greptime {
namespace v1 {
namespace flow {
class FlowCreateRequest;
struct FlowCreateRequestDefaultTypeInternal;
extern FlowCreateRequestDefaultTypeInternal _FlowCreateRequest_default_instance_;
class FlowCreateRequest_TaskOptionsEntry_DoNotUse;
struct FlowCreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal;
extern FlowCreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal _FlowCreateRequest_TaskOptionsEntry_DoNotUse_default_instance_;
class FlowRemoveRequest;
struct FlowRemoveRequestDefaultTypeInternal;
extern FlowRemoveRequestDefaultTypeInternal _FlowRemoveRequest_default_instance_;
class FlowRequest;
struct FlowRequestDefaultTypeInternal;
extern FlowRequestDefaultTypeInternal _FlowRequest_default_instance_;
class FlowResponse;
struct FlowResponseDefaultTypeInternal;
extern FlowResponseDefaultTypeInternal _FlowResponse_default_instance_;
class FlowResponse_ExtensionEntry_DoNotUse;
struct FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal;
extern FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal _FlowResponse_ExtensionEntry_DoNotUse_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertRequests;
struct InsertRequestsDefaultTypeInternal;
extern InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
class TaskId;
struct TaskIdDefaultTypeInternal;
extern TaskIdDefaultTypeInternal _TaskId_default_instance_;
}  // namespace flow
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::flow::FlowCreateRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowCreateRequest>(Arena*);
template<> ::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::flow::FlowRemoveRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowRemoveRequest>(Arena*);
template<> ::greptime::v1::flow::FlowRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowRequest>(Arena*);
template<> ::greptime::v1::flow::FlowResponse* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowResponse>(Arena*);
template<> ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::flow::InsertRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::InsertRequest>(Arena*);
template<> ::greptime::v1::flow::InsertRequests* Arena::CreateMaybeMessage<::greptime::v1::flow::InsertRequests>(Arena*);
template<> ::greptime::v1::flow::TaskId* Arena::CreateMaybeMessage<::greptime::v1::flow::TaskId>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace flow {

// ===================================================================

class InsertRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.InsertRequests) */ {
 public:
  inline InsertRequests() : InsertRequests(nullptr) {}
  ~InsertRequests() override;
  explicit PROTOBUF_CONSTEXPR InsertRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequests(const InsertRequests& from);
  InsertRequests(InsertRequests&& from) noexcept
    : InsertRequests() {
    *this = ::std::move(from);
  }

  inline InsertRequests& operator=(const InsertRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequests& operator=(InsertRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequests* internal_default_instance() {
    return reinterpret_cast<const InsertRequests*>(
               &_InsertRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InsertRequests& a, InsertRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequests& from) {
    InsertRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.InsertRequests";
  }
  protected:
  explicit InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::flow::InsertRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::flow::InsertRequest& _internal_requests(int index) const;
  ::greptime::v1::flow::InsertRequest* _internal_add_requests();
  public:
  const ::greptime::v1::flow::InsertRequest& requests(int index) const;
  ::greptime::v1::flow::InsertRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.InsertRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .greptime.v1.Rows rows = 2;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  const ::greptime::v1::Rows& rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::Rows* release_rows();
  ::greptime::v1::Rows* mutable_rows();
  void set_allocated_rows(::greptime::v1::Rows* rows);
  private:
  const ::greptime::v1::Rows& _internal_rows() const;
  ::greptime::v1::Rows* _internal_mutable_rows();
  public:
  void unsafe_arena_set_allocated_rows(
      ::greptime::v1::Rows* rows);
  ::greptime::v1::Rows* unsafe_arena_release_rows();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Rows* rows_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowRequest) */ {
 public:
  inline FlowRequest() : FlowRequest(nullptr) {}
  ~FlowRequest() override;
  explicit PROTOBUF_CONSTEXPR FlowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRequest(const FlowRequest& from);
  FlowRequest(FlowRequest&& from) noexcept
    : FlowRequest() {
    *this = ::std::move(from);
  }

  inline FlowRequest& operator=(const FlowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRequest& operator=(FlowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRequest& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kCreate = 1,
    kRemove = 2,
    BODY_NOT_SET = 0,
  };

  static inline const FlowRequest* internal_default_instance() {
    return reinterpret_cast<const FlowRequest*>(
               &_FlowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FlowRequest& a, FlowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRequest& from) {
    FlowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowRequest";
  }
  protected:
  explicit FlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateFieldNumber = 1,
    kRemoveFieldNumber = 2,
  };
  // .greptime.v1.flow.FlowCreateRequest create = 1;
  bool has_create() const;
  private:
  bool _internal_has_create() const;
  public:
  void clear_create();
  const ::greptime::v1::flow::FlowCreateRequest& create() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::FlowCreateRequest* release_create();
  ::greptime::v1::flow::FlowCreateRequest* mutable_create();
  void set_allocated_create(::greptime::v1::flow::FlowCreateRequest* create);
  private:
  const ::greptime::v1::flow::FlowCreateRequest& _internal_create() const;
  ::greptime::v1::flow::FlowCreateRequest* _internal_mutable_create();
  public:
  void unsafe_arena_set_allocated_create(
      ::greptime::v1::flow::FlowCreateRequest* create);
  ::greptime::v1::flow::FlowCreateRequest* unsafe_arena_release_create();

  // .greptime.v1.flow.FlowRemoveRequest remove = 2;
  bool has_remove() const;
  private:
  bool _internal_has_remove() const;
  public:
  void clear_remove();
  const ::greptime::v1::flow::FlowRemoveRequest& remove() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::FlowRemoveRequest* release_remove();
  ::greptime::v1::flow::FlowRemoveRequest* mutable_remove();
  void set_allocated_remove(::greptime::v1::flow::FlowRemoveRequest* remove);
  private:
  const ::greptime::v1::flow::FlowRemoveRequest& _internal_remove() const;
  ::greptime::v1::flow::FlowRemoveRequest* _internal_mutable_remove();
  public:
  void unsafe_arena_set_allocated_remove(
      ::greptime::v1::flow::FlowRemoveRequest* remove);
  ::greptime::v1::flow::FlowRemoveRequest* unsafe_arena_release_remove();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowRequest)
 private:
  class _Internal;
  void set_has_create();
  void set_has_remove();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::flow::FlowCreateRequest* create_;
      ::greptime::v1::flow::FlowRemoveRequest* remove_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowResponse_ExtensionEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowResponse_ExtensionEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowResponse_ExtensionEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  FlowResponse_ExtensionEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FlowResponse_ExtensionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FlowResponse_ExtensionEntry_DoNotUse& other);
  static const FlowResponse_ExtensionEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FlowResponse_ExtensionEntry_DoNotUse*>(&_FlowResponse_ExtensionEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.FlowResponse.ExtensionEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};

// -------------------------------------------------------------------

class FlowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowResponse) */ {
 public:
  inline FlowResponse() : FlowResponse(nullptr) {}
  ~FlowResponse() override;
  explicit PROTOBUF_CONSTEXPR FlowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowResponse(const FlowResponse& from);
  FlowResponse(FlowResponse&& from) noexcept
    : FlowResponse() {
    *this = ::std::move(from);
  }

  inline FlowResponse& operator=(const FlowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowResponse& operator=(FlowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowResponse* internal_default_instance() {
    return reinterpret_cast<const FlowResponse*>(
               &_FlowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FlowResponse& a, FlowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowResponse& from) {
    FlowResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowResponse";
  }
  protected:
  explicit FlowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 3,
    kAffectedTasksFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kAffectedRowsFieldNumber = 2,
  };
  // map<string, bytes> extension = 3;
  int extension_size() const;
  private:
  int _internal_extension_size() const;
  public:
  void clear_extension();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extension() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extension();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extension() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extension();

  // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
  int affected_tasks_size() const;
  private:
  int _internal_affected_tasks_size() const;
  public:
  void clear_affected_tasks();
  ::greptime::v1::flow::TaskId* mutable_affected_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::TaskId >*
      mutable_affected_tasks();
  private:
  const ::greptime::v1::flow::TaskId& _internal_affected_tasks(int index) const;
  ::greptime::v1::flow::TaskId* _internal_add_affected_tasks();
  public:
  const ::greptime::v1::flow::TaskId& affected_tasks(int index) const;
  ::greptime::v1::flow::TaskId* add_affected_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::TaskId >&
      affected_tasks() const;

  // .greptime.v1.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::ResponseHeader* release_header();
  ::greptime::v1::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::ResponseHeader* header);
  private:
  const ::greptime::v1::ResponseHeader& _internal_header() const;
  ::greptime::v1::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::ResponseHeader* header);
  ::greptime::v1::ResponseHeader* unsafe_arena_release_header();

  // uint64 affected_rows = 2;
  void clear_affected_rows();
  uint64_t affected_rows() const;
  void set_affected_rows(uint64_t value);
  private:
  uint64_t _internal_affected_rows() const;
  void _internal_set_affected_rows(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FlowResponse_ExtensionEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extension_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::TaskId > affected_tasks_;
    ::greptime::v1::ResponseHeader* header_;
    uint64_t affected_rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowCreateRequest_TaskOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowCreateRequest_TaskOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowCreateRequest_TaskOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  FlowCreateRequest_TaskOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FlowCreateRequest_TaskOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FlowCreateRequest_TaskOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FlowCreateRequest_TaskOptionsEntry_DoNotUse& other);
  static const FlowCreateRequest_TaskOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FlowCreateRequest_TaskOptionsEntry_DoNotUse*>(&_FlowCreateRequest_TaskOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.FlowCreateRequest.TaskOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.FlowCreateRequest.TaskOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};

// -------------------------------------------------------------------

class FlowCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowCreateRequest) */ {
 public:
  inline FlowCreateRequest() : FlowCreateRequest(nullptr) {}
  ~FlowCreateRequest() override;
  explicit PROTOBUF_CONSTEXPR FlowCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowCreateRequest(const FlowCreateRequest& from);
  FlowCreateRequest(FlowCreateRequest&& from) noexcept
    : FlowCreateRequest() {
    *this = ::std::move(from);
  }

  inline FlowCreateRequest& operator=(const FlowCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowCreateRequest& operator=(FlowCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowCreateRequest* internal_default_instance() {
    return reinterpret_cast<const FlowCreateRequest*>(
               &_FlowCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlowCreateRequest& a, FlowCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowCreateRequest& from) {
    FlowCreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowCreateRequest";
  }
  protected:
  explicit FlowCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSourceTableIdsFieldNumber = 2,
    kTaskOptionsFieldNumber = 8,
    kExpireWhenFieldNumber = 5,
    kCommentFieldNumber = 6,
    kSqlFieldNumber = 7,
    kTaskIdFieldNumber = 1,
    kOutputTableIdFieldNumber = 3,
    kCreateIfNotExistsFieldNumber = 4,
  };
  // repeated .greptime.v1.TableId source_table_ids = 2;
  int source_table_ids_size() const;
  private:
  int _internal_source_table_ids_size() const;
  public:
  void clear_source_table_ids();
  ::greptime::v1::TableId* mutable_source_table_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >*
      mutable_source_table_ids();
  private:
  const ::greptime::v1::TableId& _internal_source_table_ids(int index) const;
  ::greptime::v1::TableId* _internal_add_source_table_ids();
  public:
  const ::greptime::v1::TableId& source_table_ids(int index) const;
  ::greptime::v1::TableId* add_source_table_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >&
      source_table_ids() const;

  // map<string, string> task_options = 8;
  int task_options_size() const;
  private:
  int _internal_task_options_size() const;
  public:
  void clear_task_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_task_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_task_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      task_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_task_options();

  // string expire_when = 5;
  void clear_expire_when();
  const std::string& expire_when() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expire_when(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expire_when();
  PROTOBUF_NODISCARD std::string* release_expire_when();
  void set_allocated_expire_when(std::string* expire_when);
  private:
  const std::string& _internal_expire_when() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expire_when(const std::string& value);
  std::string* _internal_mutable_expire_when();
  public:

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string sql = 7;
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // .greptime.v1.flow.TaskId task_id = 1;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::greptime::v1::flow::TaskId& task_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::TaskId* release_task_id();
  ::greptime::v1::flow::TaskId* mutable_task_id();
  void set_allocated_task_id(::greptime::v1::flow::TaskId* task_id);
  private:
  const ::greptime::v1::flow::TaskId& _internal_task_id() const;
  ::greptime::v1::flow::TaskId* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::greptime::v1::flow::TaskId* task_id);
  ::greptime::v1::flow::TaskId* unsafe_arena_release_task_id();

  // .greptime.v1.TableId output_table_id = 3;
  bool has_output_table_id() const;
  private:
  bool _internal_has_output_table_id() const;
  public:
  void clear_output_table_id();
  const ::greptime::v1::TableId& output_table_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableId* release_output_table_id();
  ::greptime::v1::TableId* mutable_output_table_id();
  void set_allocated_output_table_id(::greptime::v1::TableId* output_table_id);
  private:
  const ::greptime::v1::TableId& _internal_output_table_id() const;
  ::greptime::v1::TableId* _internal_mutable_output_table_id();
  public:
  void unsafe_arena_set_allocated_output_table_id(
      ::greptime::v1::TableId* output_table_id);
  ::greptime::v1::TableId* unsafe_arena_release_output_table_id();

  // bool create_if_not_exists = 4;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId > source_table_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FlowCreateRequest_TaskOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> task_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expire_when_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::greptime::v1::flow::TaskId* task_id_;
    ::greptime::v1::TableId* output_table_id_;
    bool create_if_not_exists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowRemoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowRemoveRequest) */ {
 public:
  inline FlowRemoveRequest() : FlowRemoveRequest(nullptr) {}
  ~FlowRemoveRequest() override;
  explicit PROTOBUF_CONSTEXPR FlowRemoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRemoveRequest(const FlowRemoveRequest& from);
  FlowRemoveRequest(FlowRemoveRequest&& from) noexcept
    : FlowRemoveRequest() {
    *this = ::std::move(from);
  }

  inline FlowRemoveRequest& operator=(const FlowRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRemoveRequest& operator=(FlowRemoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRemoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRemoveRequest* internal_default_instance() {
    return reinterpret_cast<const FlowRemoveRequest*>(
               &_FlowRemoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FlowRemoveRequest& a, FlowRemoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRemoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRemoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRemoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRemoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRemoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRemoveRequest& from) {
    FlowRemoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRemoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowRemoveRequest";
  }
  protected:
  explicit FlowRemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
  };
  // .greptime.v1.flow.TaskId task_id = 1;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::greptime::v1::flow::TaskId& task_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::TaskId* release_task_id();
  ::greptime::v1::flow::TaskId* mutable_task_id();
  void set_allocated_task_id(::greptime::v1::flow::TaskId* task_id);
  private:
  const ::greptime::v1::flow::TaskId& _internal_task_id() const;
  ::greptime::v1::flow::TaskId* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::greptime::v1::flow::TaskId* task_id);
  ::greptime::v1::flow::TaskId* unsafe_arena_release_task_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowRemoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::flow::TaskId* task_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class TaskId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.TaskId) */ {
 public:
  inline TaskId() : TaskId(nullptr) {}
  ~TaskId() override;
  explicit PROTOBUF_CONSTEXPR TaskId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskId(const TaskId& from);
  TaskId(TaskId&& from) noexcept
    : TaskId() {
    *this = ::std::move(from);
  }

  inline TaskId& operator=(const TaskId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskId& operator=(TaskId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskId* internal_default_instance() {
    return reinterpret_cast<const TaskId*>(
               &_TaskId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TaskId& a, TaskId& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskId& from) {
    TaskId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.TaskId";
  }
  protected:
  explicit TaskId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.TaskId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InsertRequests

// repeated .greptime.v1.flow.InsertRequest requests = 1;
inline int InsertRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int InsertRequests::requests_size() const {
  return _internal_requests_size();
}
inline void InsertRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::flow::InsertRequest* InsertRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.InsertRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >*
InsertRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.InsertRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::flow::InsertRequest& InsertRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::flow::InsertRequest& InsertRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.InsertRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::flow::InsertRequest* InsertRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::flow::InsertRequest* InsertRequests::add_requests() {
  ::greptime::v1::flow::InsertRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.InsertRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >&
InsertRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.InsertRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// InsertRequest

// uint64 region_id = 1;
inline void InsertRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t InsertRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t InsertRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.InsertRequest.region_id)
  return _internal_region_id();
}
inline void InsertRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void InsertRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.InsertRequest.region_id)
}

// .greptime.v1.Rows rows = 2;
inline bool InsertRequest::_internal_has_rows() const {
  return this != internal_default_instance() && _impl_.rows_ != nullptr;
}
inline bool InsertRequest::has_rows() const {
  return _internal_has_rows();
}
inline const ::greptime::v1::Rows& InsertRequest::_internal_rows() const {
  const ::greptime::v1::Rows* p = _impl_.rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Rows&>(
      ::greptime::v1::_Rows_default_instance_);
}
inline const ::greptime::v1::Rows& InsertRequest::rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.InsertRequest.rows)
  return _internal_rows();
}
inline void InsertRequest::unsafe_arena_set_allocated_rows(
    ::greptime::v1::Rows* rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  _impl_.rows_ = rows;
  if (rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.InsertRequest.rows)
}
inline ::greptime::v1::Rows* InsertRequest::release_rows() {
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::unsafe_arena_release_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.InsertRequest.rows)
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::_internal_mutable_rows() {
  
  if (_impl_.rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Rows>(GetArenaForAllocation());
    _impl_.rows_ = p;
  }
  return _impl_.rows_;
}
inline ::greptime::v1::Rows* InsertRequest::mutable_rows() {
  ::greptime::v1::Rows* _msg = _internal_mutable_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.InsertRequest.rows)
  return _msg;
}
inline void InsertRequest::set_allocated_rows(::greptime::v1::Rows* rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  if (rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rows));
    if (message_arena != submessage_arena) {
      rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rows_ = rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.InsertRequest.rows)
}

// -------------------------------------------------------------------

// FlowRequest

// .greptime.v1.flow.FlowCreateRequest create = 1;
inline bool FlowRequest::_internal_has_create() const {
  return body_case() == kCreate;
}
inline bool FlowRequest::has_create() const {
  return _internal_has_create();
}
inline void FlowRequest::set_has_create() {
  _impl_._oneof_case_[0] = kCreate;
}
inline void FlowRequest::clear_create() {
  if (_internal_has_create()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.create_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::flow::FlowCreateRequest* FlowRequest::release_create() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::flow::FlowCreateRequest* temp = _impl_.body_.create_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::flow::FlowCreateRequest& FlowRequest::_internal_create() const {
  return _internal_has_create()
      ? *_impl_.body_.create_
      : reinterpret_cast< ::greptime::v1::flow::FlowCreateRequest&>(::greptime::v1::flow::_FlowCreateRequest_default_instance_);
}
inline const ::greptime::v1::flow::FlowCreateRequest& FlowRequest::create() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequest.create)
  return _internal_create();
}
inline ::greptime::v1::flow::FlowCreateRequest* FlowRequest::unsafe_arena_release_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.flow.FlowRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::flow::FlowCreateRequest* temp = _impl_.body_.create_;
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRequest::unsafe_arena_set_allocated_create(::greptime::v1::flow::FlowCreateRequest* create) {
  clear_body();
  if (create) {
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequest.create)
}
inline ::greptime::v1::flow::FlowCreateRequest* FlowRequest::_internal_mutable_create() {
  if (!_internal_has_create()) {
    clear_body();
    set_has_create();
    _impl_.body_.create_ = CreateMaybeMessage< ::greptime::v1::flow::FlowCreateRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.create_;
}
inline ::greptime::v1::flow::FlowCreateRequest* FlowRequest::mutable_create() {
  ::greptime::v1::flow::FlowCreateRequest* _msg = _internal_mutable_create();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequest.create)
  return _msg;
}

// .greptime.v1.flow.FlowRemoveRequest remove = 2;
inline bool FlowRequest::_internal_has_remove() const {
  return body_case() == kRemove;
}
inline bool FlowRequest::has_remove() const {
  return _internal_has_remove();
}
inline void FlowRequest::set_has_remove() {
  _impl_._oneof_case_[0] = kRemove;
}
inline void FlowRequest::clear_remove() {
  if (_internal_has_remove()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.remove_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::flow::FlowRemoveRequest* FlowRequest::release_remove() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequest.remove)
  if (_internal_has_remove()) {
    clear_has_body();
    ::greptime::v1::flow::FlowRemoveRequest* temp = _impl_.body_.remove_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::flow::FlowRemoveRequest& FlowRequest::_internal_remove() const {
  return _internal_has_remove()
      ? *_impl_.body_.remove_
      : reinterpret_cast< ::greptime::v1::flow::FlowRemoveRequest&>(::greptime::v1::flow::_FlowRemoveRequest_default_instance_);
}
inline const ::greptime::v1::flow::FlowRemoveRequest& FlowRequest::remove() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequest.remove)
  return _internal_remove();
}
inline ::greptime::v1::flow::FlowRemoveRequest* FlowRequest::unsafe_arena_release_remove() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.flow.FlowRequest.remove)
  if (_internal_has_remove()) {
    clear_has_body();
    ::greptime::v1::flow::FlowRemoveRequest* temp = _impl_.body_.remove_;
    _impl_.body_.remove_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRequest::unsafe_arena_set_allocated_remove(::greptime::v1::flow::FlowRemoveRequest* remove) {
  clear_body();
  if (remove) {
    set_has_remove();
    _impl_.body_.remove_ = remove;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequest.remove)
}
inline ::greptime::v1::flow::FlowRemoveRequest* FlowRequest::_internal_mutable_remove() {
  if (!_internal_has_remove()) {
    clear_body();
    set_has_remove();
    _impl_.body_.remove_ = CreateMaybeMessage< ::greptime::v1::flow::FlowRemoveRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.remove_;
}
inline ::greptime::v1::flow::FlowRemoveRequest* FlowRequest::mutable_remove() {
  ::greptime::v1::flow::FlowRemoveRequest* _msg = _internal_mutable_remove();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequest.remove)
  return _msg;
}

inline bool FlowRequest::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void FlowRequest::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline FlowRequest::BodyCase FlowRequest::body_case() const {
  return FlowRequest::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FlowResponse

// .greptime.v1.ResponseHeader header = 1;
inline bool FlowResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FlowResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::ResponseHeader& FlowResponse::_internal_header() const {
  const ::greptime::v1::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ResponseHeader&>(
      ::greptime::v1::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::ResponseHeader& FlowResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowResponse.header)
  return _internal_header();
}
inline void FlowResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowResponse.header)
}
inline ::greptime::v1::ResponseHeader* FlowResponse::release_header() {
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ResponseHeader* FlowResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowResponse.header)
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::ResponseHeader* FlowResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::ResponseHeader* FlowResponse::mutable_header() {
  ::greptime::v1::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowResponse.header)
  return _msg;
}
inline void FlowResponse::set_allocated_header(::greptime::v1::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowResponse.header)
}

// uint64 affected_rows = 2;
inline void FlowResponse::clear_affected_rows() {
  _impl_.affected_rows_ = uint64_t{0u};
}
inline uint64_t FlowResponse::_internal_affected_rows() const {
  return _impl_.affected_rows_;
}
inline uint64_t FlowResponse::affected_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowResponse.affected_rows)
  return _internal_affected_rows();
}
inline void FlowResponse::_internal_set_affected_rows(uint64_t value) {
  
  _impl_.affected_rows_ = value;
}
inline void FlowResponse::set_affected_rows(uint64_t value) {
  _internal_set_affected_rows(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.FlowResponse.affected_rows)
}

// map<string, bytes> extension = 3;
inline int FlowResponse::_internal_extension_size() const {
  return _impl_.extension_.size();
}
inline int FlowResponse::extension_size() const {
  return _internal_extension_size();
}
inline void FlowResponse::clear_extension() {
  _impl_.extension_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowResponse::_internal_extension() const {
  return _impl_.extension_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowResponse::extension() const {
  // @@protoc_insertion_point(field_map:greptime.v1.flow.FlowResponse.extension)
  return _internal_extension();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowResponse::_internal_mutable_extension() {
  return _impl_.extension_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowResponse::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.flow.FlowResponse.extension)
  return _internal_mutable_extension();
}

// repeated .greptime.v1.flow.TaskId affected_tasks = 4;
inline int FlowResponse::_internal_affected_tasks_size() const {
  return _impl_.affected_tasks_.size();
}
inline int FlowResponse::affected_tasks_size() const {
  return _internal_affected_tasks_size();
}
inline void FlowResponse::clear_affected_tasks() {
  _impl_.affected_tasks_.Clear();
}
inline ::greptime::v1::flow::TaskId* FlowResponse::mutable_affected_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowResponse.affected_tasks)
  return _impl_.affected_tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::TaskId >*
FlowResponse::mutable_affected_tasks() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.FlowResponse.affected_tasks)
  return &_impl_.affected_tasks_;
}
inline const ::greptime::v1::flow::TaskId& FlowResponse::_internal_affected_tasks(int index) const {
  return _impl_.affected_tasks_.Get(index);
}
inline const ::greptime::v1::flow::TaskId& FlowResponse::affected_tasks(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowResponse.affected_tasks)
  return _internal_affected_tasks(index);
}
inline ::greptime::v1::flow::TaskId* FlowResponse::_internal_add_affected_tasks() {
  return _impl_.affected_tasks_.Add();
}
inline ::greptime::v1::flow::TaskId* FlowResponse::add_affected_tasks() {
  ::greptime::v1::flow::TaskId* _add = _internal_add_affected_tasks();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.FlowResponse.affected_tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::TaskId >&
FlowResponse::affected_tasks() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.FlowResponse.affected_tasks)
  return _impl_.affected_tasks_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FlowCreateRequest

// .greptime.v1.flow.TaskId task_id = 1;
inline bool FlowCreateRequest::_internal_has_task_id() const {
  return this != internal_default_instance() && _impl_.task_id_ != nullptr;
}
inline bool FlowCreateRequest::has_task_id() const {
  return _internal_has_task_id();
}
inline void FlowCreateRequest::clear_task_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.task_id_ != nullptr) {
    delete _impl_.task_id_;
  }
  _impl_.task_id_ = nullptr;
}
inline const ::greptime::v1::flow::TaskId& FlowCreateRequest::_internal_task_id() const {
  const ::greptime::v1::flow::TaskId* p = _impl_.task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::flow::TaskId&>(
      ::greptime::v1::flow::_TaskId_default_instance_);
}
inline const ::greptime::v1::flow::TaskId& FlowCreateRequest::task_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.task_id)
  return _internal_task_id();
}
inline void FlowCreateRequest::unsafe_arena_set_allocated_task_id(
    ::greptime::v1::flow::TaskId* task_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_id_);
  }
  _impl_.task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowCreateRequest.task_id)
}
inline ::greptime::v1::flow::TaskId* FlowCreateRequest::release_task_id() {
  
  ::greptime::v1::flow::TaskId* temp = _impl_.task_id_;
  _impl_.task_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::flow::TaskId* FlowCreateRequest::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowCreateRequest.task_id)
  
  ::greptime::v1::flow::TaskId* temp = _impl_.task_id_;
  _impl_.task_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::flow::TaskId* FlowCreateRequest::_internal_mutable_task_id() {
  
  if (_impl_.task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::flow::TaskId>(GetArenaForAllocation());
    _impl_.task_id_ = p;
  }
  return _impl_.task_id_;
}
inline ::greptime::v1::flow::TaskId* FlowCreateRequest::mutable_task_id() {
  ::greptime::v1::flow::TaskId* _msg = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowCreateRequest.task_id)
  return _msg;
}
inline void FlowCreateRequest::set_allocated_task_id(::greptime::v1::flow::TaskId* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.task_id_;
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowCreateRequest.task_id)
}

// repeated .greptime.v1.TableId source_table_ids = 2;
inline int FlowCreateRequest::_internal_source_table_ids_size() const {
  return _impl_.source_table_ids_.size();
}
inline int FlowCreateRequest::source_table_ids_size() const {
  return _internal_source_table_ids_size();
}
inline ::greptime::v1::TableId* FlowCreateRequest::mutable_source_table_ids(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowCreateRequest.source_table_ids)
  return _impl_.source_table_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >*
FlowCreateRequest::mutable_source_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.FlowCreateRequest.source_table_ids)
  return &_impl_.source_table_ids_;
}
inline const ::greptime::v1::TableId& FlowCreateRequest::_internal_source_table_ids(int index) const {
  return _impl_.source_table_ids_.Get(index);
}
inline const ::greptime::v1::TableId& FlowCreateRequest::source_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.source_table_ids)
  return _internal_source_table_ids(index);
}
inline ::greptime::v1::TableId* FlowCreateRequest::_internal_add_source_table_ids() {
  return _impl_.source_table_ids_.Add();
}
inline ::greptime::v1::TableId* FlowCreateRequest::add_source_table_ids() {
  ::greptime::v1::TableId* _add = _internal_add_source_table_ids();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.FlowCreateRequest.source_table_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >&
FlowCreateRequest::source_table_ids() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.FlowCreateRequest.source_table_ids)
  return _impl_.source_table_ids_;
}

// .greptime.v1.TableId output_table_id = 3;
inline bool FlowCreateRequest::_internal_has_output_table_id() const {
  return this != internal_default_instance() && _impl_.output_table_id_ != nullptr;
}
inline bool FlowCreateRequest::has_output_table_id() const {
  return _internal_has_output_table_id();
}
inline const ::greptime::v1::TableId& FlowCreateRequest::_internal_output_table_id() const {
  const ::greptime::v1::TableId* p = _impl_.output_table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableId&>(
      ::greptime::v1::_TableId_default_instance_);
}
inline const ::greptime::v1::TableId& FlowCreateRequest::output_table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.output_table_id)
  return _internal_output_table_id();
}
inline void FlowCreateRequest::unsafe_arena_set_allocated_output_table_id(
    ::greptime::v1::TableId* output_table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_table_id_);
  }
  _impl_.output_table_id_ = output_table_id;
  if (output_table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowCreateRequest.output_table_id)
}
inline ::greptime::v1::TableId* FlowCreateRequest::release_output_table_id() {
  
  ::greptime::v1::TableId* temp = _impl_.output_table_id_;
  _impl_.output_table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableId* FlowCreateRequest::unsafe_arena_release_output_table_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowCreateRequest.output_table_id)
  
  ::greptime::v1::TableId* temp = _impl_.output_table_id_;
  _impl_.output_table_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableId* FlowCreateRequest::_internal_mutable_output_table_id() {
  
  if (_impl_.output_table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableId>(GetArenaForAllocation());
    _impl_.output_table_id_ = p;
  }
  return _impl_.output_table_id_;
}
inline ::greptime::v1::TableId* FlowCreateRequest::mutable_output_table_id() {
  ::greptime::v1::TableId* _msg = _internal_mutable_output_table_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowCreateRequest.output_table_id)
  return _msg;
}
inline void FlowCreateRequest::set_allocated_output_table_id(::greptime::v1::TableId* output_table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_table_id_);
  }
  if (output_table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_table_id));
    if (message_arena != submessage_arena) {
      output_table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_table_id_ = output_table_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowCreateRequest.output_table_id)
}

// bool create_if_not_exists = 4;
inline void FlowCreateRequest::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool FlowCreateRequest::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool FlowCreateRequest::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void FlowCreateRequest::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void FlowCreateRequest::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.FlowCreateRequest.create_if_not_exists)
}

// string expire_when = 5;
inline void FlowCreateRequest::clear_expire_when() {
  _impl_.expire_when_.ClearToEmpty();
}
inline const std::string& FlowCreateRequest::expire_when() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.expire_when)
  return _internal_expire_when();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlowCreateRequest::set_expire_when(ArgT0&& arg0, ArgT... args) {
 
 _impl_.expire_when_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.flow.FlowCreateRequest.expire_when)
}
inline std::string* FlowCreateRequest::mutable_expire_when() {
  std::string* _s = _internal_mutable_expire_when();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowCreateRequest.expire_when)
  return _s;
}
inline const std::string& FlowCreateRequest::_internal_expire_when() const {
  return _impl_.expire_when_.Get();
}
inline void FlowCreateRequest::_internal_set_expire_when(const std::string& value) {
  
  _impl_.expire_when_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowCreateRequest::_internal_mutable_expire_when() {
  
  return _impl_.expire_when_.Mutable(GetArenaForAllocation());
}
inline std::string* FlowCreateRequest::release_expire_when() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowCreateRequest.expire_when)
  return _impl_.expire_when_.Release();
}
inline void FlowCreateRequest::set_allocated_expire_when(std::string* expire_when) {
  if (expire_when != nullptr) {
    
  } else {
    
  }
  _impl_.expire_when_.SetAllocated(expire_when, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expire_when_.IsDefault()) {
    _impl_.expire_when_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowCreateRequest.expire_when)
}

// string comment = 6;
inline void FlowCreateRequest::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& FlowCreateRequest::comment() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlowCreateRequest::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.flow.FlowCreateRequest.comment)
}
inline std::string* FlowCreateRequest::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowCreateRequest.comment)
  return _s;
}
inline const std::string& FlowCreateRequest::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void FlowCreateRequest::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowCreateRequest::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* FlowCreateRequest::release_comment() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowCreateRequest.comment)
  return _impl_.comment_.Release();
}
inline void FlowCreateRequest::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowCreateRequest.comment)
}

// string sql = 7;
inline void FlowCreateRequest::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& FlowCreateRequest::sql() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowCreateRequest.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlowCreateRequest::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.flow.FlowCreateRequest.sql)
}
inline std::string* FlowCreateRequest::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowCreateRequest.sql)
  return _s;
}
inline const std::string& FlowCreateRequest::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void FlowCreateRequest::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* FlowCreateRequest::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* FlowCreateRequest::release_sql() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowCreateRequest.sql)
  return _impl_.sql_.Release();
}
inline void FlowCreateRequest::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowCreateRequest.sql)
}

// map<string, string> task_options = 8;
inline int FlowCreateRequest::_internal_task_options_size() const {
  return _impl_.task_options_.size();
}
inline int FlowCreateRequest::task_options_size() const {
  return _internal_task_options_size();
}
inline void FlowCreateRequest::clear_task_options() {
  _impl_.task_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowCreateRequest::_internal_task_options() const {
  return _impl_.task_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowCreateRequest::task_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.flow.FlowCreateRequest.task_options)
  return _internal_task_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowCreateRequest::_internal_mutable_task_options() {
  return _impl_.task_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowCreateRequest::mutable_task_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.flow.FlowCreateRequest.task_options)
  return _internal_mutable_task_options();
}

// -------------------------------------------------------------------

// FlowRemoveRequest

// .greptime.v1.flow.TaskId task_id = 1;
inline bool FlowRemoveRequest::_internal_has_task_id() const {
  return this != internal_default_instance() && _impl_.task_id_ != nullptr;
}
inline bool FlowRemoveRequest::has_task_id() const {
  return _internal_has_task_id();
}
inline void FlowRemoveRequest::clear_task_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.task_id_ != nullptr) {
    delete _impl_.task_id_;
  }
  _impl_.task_id_ = nullptr;
}
inline const ::greptime::v1::flow::TaskId& FlowRemoveRequest::_internal_task_id() const {
  const ::greptime::v1::flow::TaskId* p = _impl_.task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::flow::TaskId&>(
      ::greptime::v1::flow::_TaskId_default_instance_);
}
inline const ::greptime::v1::flow::TaskId& FlowRemoveRequest::task_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRemoveRequest.task_id)
  return _internal_task_id();
}
inline void FlowRemoveRequest::unsafe_arena_set_allocated_task_id(
    ::greptime::v1::flow::TaskId* task_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_id_);
  }
  _impl_.task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRemoveRequest.task_id)
}
inline ::greptime::v1::flow::TaskId* FlowRemoveRequest::release_task_id() {
  
  ::greptime::v1::flow::TaskId* temp = _impl_.task_id_;
  _impl_.task_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::flow::TaskId* FlowRemoveRequest::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRemoveRequest.task_id)
  
  ::greptime::v1::flow::TaskId* temp = _impl_.task_id_;
  _impl_.task_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::flow::TaskId* FlowRemoveRequest::_internal_mutable_task_id() {
  
  if (_impl_.task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::flow::TaskId>(GetArenaForAllocation());
    _impl_.task_id_ = p;
  }
  return _impl_.task_id_;
}
inline ::greptime::v1::flow::TaskId* FlowRemoveRequest::mutable_task_id() {
  ::greptime::v1::flow::TaskId* _msg = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRemoveRequest.task_id)
  return _msg;
}
inline void FlowRemoveRequest::set_allocated_task_id(::greptime::v1::flow::TaskId* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.task_id_;
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRemoveRequest.task_id)
}

// -------------------------------------------------------------------

// TaskId

// uint32 id = 1;
inline void TaskId::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t TaskId::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t TaskId::id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.TaskId.id)
  return _internal_id();
}
inline void TaskId::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void TaskId::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.TaskId.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flow
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fflow_2fserver_2eproto
