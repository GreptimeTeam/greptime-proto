// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/flow/server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fflow_2fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fflow_2fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "greptime/v1/common.pb.h"
#include "greptime/v1/ddl.pb.h"
#include "greptime/v1/row.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fflow_2fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fflow_2fserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto;
namespace greptime {
namespace v1 {
namespace flow {
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateRequest_FlowOptionsEntry_DoNotUse;
struct CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal;
extern CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal _CreateRequest_FlowOptionsEntry_DoNotUse_default_instance_;
class DirtyWindowRequest;
struct DirtyWindowRequestDefaultTypeInternal;
extern DirtyWindowRequestDefaultTypeInternal _DirtyWindowRequest_default_instance_;
class DirtyWindowRequests;
struct DirtyWindowRequestsDefaultTypeInternal;
extern DirtyWindowRequestsDefaultTypeInternal _DirtyWindowRequests_default_instance_;
class DropRequest;
struct DropRequestDefaultTypeInternal;
extern DropRequestDefaultTypeInternal _DropRequest_default_instance_;
class FlowRequest;
struct FlowRequestDefaultTypeInternal;
extern FlowRequestDefaultTypeInternal _FlowRequest_default_instance_;
class FlowRequestHeader;
struct FlowRequestHeaderDefaultTypeInternal;
extern FlowRequestHeaderDefaultTypeInternal _FlowRequestHeader_default_instance_;
class FlowRequestHeader_TracingContextEntry_DoNotUse;
struct FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal;
extern FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _FlowRequestHeader_TracingContextEntry_DoNotUse_default_instance_;
class FlowResponse;
struct FlowResponseDefaultTypeInternal;
extern FlowResponseDefaultTypeInternal _FlowResponse_default_instance_;
class FlowResponse_ExtensionsEntry_DoNotUse;
struct FlowResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern FlowResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal _FlowResponse_ExtensionsEntry_DoNotUse_default_instance_;
class FlushFlow;
struct FlushFlowDefaultTypeInternal;
extern FlushFlowDefaultTypeInternal _FlushFlow_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class InsertRequests;
struct InsertRequestsDefaultTypeInternal;
extern InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
}  // namespace flow
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::flow::CreateRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::CreateRequest>(Arena*);
template<> ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::flow::DirtyWindowRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::DirtyWindowRequest>(Arena*);
template<> ::greptime::v1::flow::DirtyWindowRequests* Arena::CreateMaybeMessage<::greptime::v1::flow::DirtyWindowRequests>(Arena*);
template<> ::greptime::v1::flow::DropRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::DropRequest>(Arena*);
template<> ::greptime::v1::flow::FlowRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowRequest>(Arena*);
template<> ::greptime::v1::flow::FlowRequestHeader* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowRequestHeader>(Arena*);
template<> ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::flow::FlowResponse* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowResponse>(Arena*);
template<> ::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::flow::FlushFlow* Arena::CreateMaybeMessage<::greptime::v1::flow::FlushFlow>(Arena*);
template<> ::greptime::v1::flow::InsertRequest* Arena::CreateMaybeMessage<::greptime::v1::flow::InsertRequest>(Arena*);
template<> ::greptime::v1::flow::InsertRequests* Arena::CreateMaybeMessage<::greptime::v1::flow::InsertRequests>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {
namespace flow {

// ===================================================================

class DirtyWindowRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.DirtyWindowRequests) */ {
 public:
  inline DirtyWindowRequests() : DirtyWindowRequests(nullptr) {}
  ~DirtyWindowRequests() override;
  explicit PROTOBUF_CONSTEXPR DirtyWindowRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirtyWindowRequests(const DirtyWindowRequests& from);
  DirtyWindowRequests(DirtyWindowRequests&& from) noexcept
    : DirtyWindowRequests() {
    *this = ::std::move(from);
  }

  inline DirtyWindowRequests& operator=(const DirtyWindowRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirtyWindowRequests& operator=(DirtyWindowRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirtyWindowRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirtyWindowRequests* internal_default_instance() {
    return reinterpret_cast<const DirtyWindowRequests*>(
               &_DirtyWindowRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DirtyWindowRequests& a, DirtyWindowRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(DirtyWindowRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirtyWindowRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirtyWindowRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirtyWindowRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirtyWindowRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirtyWindowRequests& from) {
    DirtyWindowRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirtyWindowRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.DirtyWindowRequests";
  }
  protected:
  explicit DirtyWindowRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.flow.DirtyWindowRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::flow::DirtyWindowRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::DirtyWindowRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::flow::DirtyWindowRequest& _internal_requests(int index) const;
  ::greptime::v1::flow::DirtyWindowRequest* _internal_add_requests();
  public:
  const ::greptime::v1::flow::DirtyWindowRequest& requests(int index) const;
  ::greptime::v1::flow::DirtyWindowRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::DirtyWindowRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.DirtyWindowRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::DirtyWindowRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DirtyWindowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.DirtyWindowRequest) */ {
 public:
  inline DirtyWindowRequest() : DirtyWindowRequest(nullptr) {}
  ~DirtyWindowRequest() override;
  explicit PROTOBUF_CONSTEXPR DirtyWindowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirtyWindowRequest(const DirtyWindowRequest& from);
  DirtyWindowRequest(DirtyWindowRequest&& from) noexcept
    : DirtyWindowRequest() {
    *this = ::std::move(from);
  }

  inline DirtyWindowRequest& operator=(const DirtyWindowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirtyWindowRequest& operator=(DirtyWindowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirtyWindowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirtyWindowRequest* internal_default_instance() {
    return reinterpret_cast<const DirtyWindowRequest*>(
               &_DirtyWindowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DirtyWindowRequest& a, DirtyWindowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DirtyWindowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirtyWindowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirtyWindowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirtyWindowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirtyWindowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirtyWindowRequest& from) {
    DirtyWindowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirtyWindowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.DirtyWindowRequest";
  }
  protected:
  explicit DirtyWindowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampsFieldNumber = 2,
    kTableIdFieldNumber = 1,
  };
  // repeated int64 timestamps = 2;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;
  public:
  void clear_timestamps();
  private:
  int64_t _internal_timestamps(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_timestamps() const;
  void _internal_add_timestamps(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_timestamps();
  public:
  int64_t timestamps(int index) const;
  void set_timestamps(int index, int64_t value);
  void add_timestamps(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      timestamps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_timestamps();

  // uint32 table_id = 1;
  void clear_table_id();
  uint32_t table_id() const;
  void set_table_id(uint32_t value);
  private:
  uint32_t _internal_table_id() const;
  void _internal_set_table_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.DirtyWindowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > timestamps_;
    mutable std::atomic<int> _timestamps_cached_byte_size_;
    uint32_t table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowRequestHeader_TracingContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowRequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowRequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  FlowRequestHeader_TracingContextEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FlowRequestHeader_TracingContextEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FlowRequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FlowRequestHeader_TracingContextEntry_DoNotUse& other);
  static const FlowRequestHeader_TracingContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FlowRequestHeader_TracingContextEntry_DoNotUse*>(&_FlowRequestHeader_TracingContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.FlowRequestHeader.TracingContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.FlowRequestHeader.TracingContextEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};

// -------------------------------------------------------------------

class FlowRequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowRequestHeader) */ {
 public:
  inline FlowRequestHeader() : FlowRequestHeader(nullptr) {}
  ~FlowRequestHeader() override;
  explicit PROTOBUF_CONSTEXPR FlowRequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRequestHeader(const FlowRequestHeader& from);
  FlowRequestHeader(FlowRequestHeader&& from) noexcept
    : FlowRequestHeader() {
    *this = ::std::move(from);
  }

  inline FlowRequestHeader& operator=(const FlowRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRequestHeader& operator=(FlowRequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowRequestHeader* internal_default_instance() {
    return reinterpret_cast<const FlowRequestHeader*>(
               &_FlowRequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FlowRequestHeader& a, FlowRequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRequestHeader& from) {
    FlowRequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowRequestHeader";
  }
  protected:
  explicit FlowRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTracingContextFieldNumber = 1,
    kQueryContextFieldNumber = 2,
  };
  // map<string, string> tracing_context = 1;
  int tracing_context_size() const;
  private:
  int _internal_tracing_context_size() const;
  public:
  void clear_tracing_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tracing_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tracing_context();

  // .greptime.v1.QueryContext query_context = 2;
  bool has_query_context() const;
  private:
  bool _internal_has_query_context() const;
  public:
  void clear_query_context();
  const ::greptime::v1::QueryContext& query_context() const;
  PROTOBUF_NODISCARD ::greptime::v1::QueryContext* release_query_context();
  ::greptime::v1::QueryContext* mutable_query_context();
  void set_allocated_query_context(::greptime::v1::QueryContext* query_context);
  private:
  const ::greptime::v1::QueryContext& _internal_query_context() const;
  ::greptime::v1::QueryContext* _internal_mutable_query_context();
  public:
  void unsafe_arena_set_allocated_query_context(
      ::greptime::v1::QueryContext* query_context);
  ::greptime::v1::QueryContext* unsafe_arena_release_query_context();

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowRequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FlowRequestHeader_TracingContextEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tracing_context_;
    ::greptime::v1::QueryContext* query_context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.InsertRequests) */ {
 public:
  inline InsertRequests() : InsertRequests(nullptr) {}
  ~InsertRequests() override;
  explicit PROTOBUF_CONSTEXPR InsertRequests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequests(const InsertRequests& from);
  InsertRequests(InsertRequests&& from) noexcept
    : InsertRequests() {
    *this = ::std::move(from);
  }

  inline InsertRequests& operator=(const InsertRequests& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequests& operator=(InsertRequests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequests& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequests* internal_default_instance() {
    return reinterpret_cast<const InsertRequests*>(
               &_InsertRequests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InsertRequests& a, InsertRequests& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequests& from) {
    InsertRequests::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.InsertRequests";
  }
  protected:
  explicit InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::greptime::v1::flow::InsertRequest* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >*
      mutable_requests();
  private:
  const ::greptime::v1::flow::InsertRequest& _internal_requests(int index) const;
  ::greptime::v1::flow::InsertRequest* _internal_add_requests();
  public:
  const ::greptime::v1::flow::InsertRequest& requests(int index) const;
  ::greptime::v1::flow::InsertRequest* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >&
      requests() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.InsertRequests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest > requests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // .greptime.v1.Rows rows = 2;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  const ::greptime::v1::Rows& rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::Rows* release_rows();
  ::greptime::v1::Rows* mutable_rows();
  void set_allocated_rows(::greptime::v1::Rows* rows);
  private:
  const ::greptime::v1::Rows& _internal_rows() const;
  ::greptime::v1::Rows* _internal_mutable_rows();
  public:
  void unsafe_arena_set_allocated_rows(
      ::greptime::v1::Rows* rows);
  ::greptime::v1::Rows* unsafe_arena_release_rows();

  // uint64 region_id = 1;
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Rows* rows_;
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowRequest) */ {
 public:
  inline FlowRequest() : FlowRequest(nullptr) {}
  ~FlowRequest() override;
  explicit PROTOBUF_CONSTEXPR FlowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowRequest(const FlowRequest& from);
  FlowRequest(FlowRequest&& from) noexcept
    : FlowRequest() {
    *this = ::std::move(from);
  }

  inline FlowRequest& operator=(const FlowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowRequest& operator=(FlowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowRequest& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kCreate = 1,
    kDrop = 2,
    kFlush = 3,
    BODY_NOT_SET = 0,
  };

  static inline const FlowRequest* internal_default_instance() {
    return reinterpret_cast<const FlowRequest*>(
               &_FlowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlowRequest& a, FlowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowRequest& from) {
    FlowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowRequest";
  }
  protected:
  explicit FlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 64,
    kCreateFieldNumber = 1,
    kDropFieldNumber = 2,
    kFlushFieldNumber = 3,
  };
  // .greptime.v1.flow.FlowRequestHeader header = 64;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::flow::FlowRequestHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::FlowRequestHeader* release_header();
  ::greptime::v1::flow::FlowRequestHeader* mutable_header();
  void set_allocated_header(::greptime::v1::flow::FlowRequestHeader* header);
  private:
  const ::greptime::v1::flow::FlowRequestHeader& _internal_header() const;
  ::greptime::v1::flow::FlowRequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::flow::FlowRequestHeader* header);
  ::greptime::v1::flow::FlowRequestHeader* unsafe_arena_release_header();

  // .greptime.v1.flow.CreateRequest create = 1;
  bool has_create() const;
  private:
  bool _internal_has_create() const;
  public:
  void clear_create();
  const ::greptime::v1::flow::CreateRequest& create() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::CreateRequest* release_create();
  ::greptime::v1::flow::CreateRequest* mutable_create();
  void set_allocated_create(::greptime::v1::flow::CreateRequest* create);
  private:
  const ::greptime::v1::flow::CreateRequest& _internal_create() const;
  ::greptime::v1::flow::CreateRequest* _internal_mutable_create();
  public:
  void unsafe_arena_set_allocated_create(
      ::greptime::v1::flow::CreateRequest* create);
  ::greptime::v1::flow::CreateRequest* unsafe_arena_release_create();

  // .greptime.v1.flow.DropRequest drop = 2;
  bool has_drop() const;
  private:
  bool _internal_has_drop() const;
  public:
  void clear_drop();
  const ::greptime::v1::flow::DropRequest& drop() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::DropRequest* release_drop();
  ::greptime::v1::flow::DropRequest* mutable_drop();
  void set_allocated_drop(::greptime::v1::flow::DropRequest* drop);
  private:
  const ::greptime::v1::flow::DropRequest& _internal_drop() const;
  ::greptime::v1::flow::DropRequest* _internal_mutable_drop();
  public:
  void unsafe_arena_set_allocated_drop(
      ::greptime::v1::flow::DropRequest* drop);
  ::greptime::v1::flow::DropRequest* unsafe_arena_release_drop();

  // .greptime.v1.flow.FlushFlow flush = 3;
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;
  public:
  void clear_flush();
  const ::greptime::v1::flow::FlushFlow& flush() const;
  PROTOBUF_NODISCARD ::greptime::v1::flow::FlushFlow* release_flush();
  ::greptime::v1::flow::FlushFlow* mutable_flush();
  void set_allocated_flush(::greptime::v1::flow::FlushFlow* flush);
  private:
  const ::greptime::v1::flow::FlushFlow& _internal_flush() const;
  ::greptime::v1::flow::FlushFlow* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::greptime::v1::flow::FlushFlow* flush);
  ::greptime::v1::flow::FlushFlow* unsafe_arena_release_flush();

  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowRequest)
 private:
  class _Internal;
  void set_has_create();
  void set_has_drop();
  void set_has_flush();

  inline bool has_body() const;
  inline void clear_has_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::flow::FlowRequestHeader* header_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::flow::CreateRequest* create_;
      ::greptime::v1::flow::DropRequest* drop_;
      ::greptime::v1::flow::FlushFlow* flush_;
    } body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlowResponse_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowResponse_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FlowResponse_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  FlowResponse_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FlowResponse_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FlowResponse_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FlowResponse_ExtensionsEntry_DoNotUse& other);
  static const FlowResponse_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FlowResponse_ExtensionsEntry_DoNotUse*>(&_FlowResponse_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.FlowResponse.ExtensionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};

// -------------------------------------------------------------------

class FlowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlowResponse) */ {
 public:
  inline FlowResponse() : FlowResponse(nullptr) {}
  ~FlowResponse() override;
  explicit PROTOBUF_CONSTEXPR FlowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowResponse(const FlowResponse& from);
  FlowResponse(FlowResponse&& from) noexcept
    : FlowResponse() {
    *this = ::std::move(from);
  }

  inline FlowResponse& operator=(const FlowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowResponse& operator=(FlowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowResponse* internal_default_instance() {
    return reinterpret_cast<const FlowResponse*>(
               &_FlowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FlowResponse& a, FlowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlowResponse& from) {
    FlowResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlowResponse";
  }
  protected:
  explicit FlowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAffectedFlowsFieldNumber = 3,
    kExtensionsFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kAffectedRowsFieldNumber = 2,
  };
  // repeated .greptime.v1.FlowId affected_flows = 3;
  int affected_flows_size() const;
  private:
  int _internal_affected_flows_size() const;
  public:
  void clear_affected_flows();
  ::greptime::v1::FlowId* mutable_affected_flows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::FlowId >*
      mutable_affected_flows();
  private:
  const ::greptime::v1::FlowId& _internal_affected_flows(int index) const;
  ::greptime::v1::FlowId* _internal_add_affected_flows();
  public:
  const ::greptime::v1::FlowId& affected_flows(int index) const;
  ::greptime::v1::FlowId* add_affected_flows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::FlowId >&
      affected_flows() const;

  // map<string, bytes> extensions = 4;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extensions();

  // .greptime.v1.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::greptime::v1::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::greptime::v1::ResponseHeader* release_header();
  ::greptime::v1::ResponseHeader* mutable_header();
  void set_allocated_header(::greptime::v1::ResponseHeader* header);
  private:
  const ::greptime::v1::ResponseHeader& _internal_header() const;
  ::greptime::v1::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::greptime::v1::ResponseHeader* header);
  ::greptime::v1::ResponseHeader* unsafe_arena_release_header();

  // uint64 affected_rows = 2;
  void clear_affected_rows();
  uint64_t affected_rows() const;
  void set_affected_rows(uint64_t value);
  private:
  uint64_t _internal_affected_rows() const;
  void _internal_set_affected_rows(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::FlowId > affected_flows_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FlowResponse_ExtensionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> extensions_;
    ::greptime::v1::ResponseHeader* header_;
    uint64_t affected_rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest_FlowOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_FlowOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRequest_FlowOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CreateRequest_FlowOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR CreateRequest_FlowOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateRequest_FlowOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateRequest_FlowOptionsEntry_DoNotUse& other);
  static const CreateRequest_FlowOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateRequest_FlowOptionsEntry_DoNotUse*>(&_CreateRequest_FlowOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.CreateRequest.FlowOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.flow.CreateRequest.FlowOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};

// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRequest& from) {
    CreateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSourceTableIdsFieldNumber = 2,
    kFlowOptionsFieldNumber = 8,
    kCommentFieldNumber = 6,
    kSqlFieldNumber = 7,
    kFlowIdFieldNumber = 1,
    kSinkTableNameFieldNumber = 3,
    kExpireAfterFieldNumber = 5,
    kEvalIntervalFieldNumber = 10,
    kCreateIfNotExistsFieldNumber = 4,
    kOrReplaceFieldNumber = 9,
  };
  // repeated .greptime.v1.TableId source_table_ids = 2;
  int source_table_ids_size() const;
  private:
  int _internal_source_table_ids_size() const;
  public:
  void clear_source_table_ids();
  ::greptime::v1::TableId* mutable_source_table_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >*
      mutable_source_table_ids();
  private:
  const ::greptime::v1::TableId& _internal_source_table_ids(int index) const;
  ::greptime::v1::TableId* _internal_add_source_table_ids();
  public:
  const ::greptime::v1::TableId& source_table_ids(int index) const;
  ::greptime::v1::TableId* add_source_table_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >&
      source_table_ids() const;

  // map<string, string> flow_options = 8;
  int flow_options_size() const;
  private:
  int _internal_flow_options_size() const;
  public:
  void clear_flow_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_flow_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_flow_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      flow_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_flow_options();

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // string sql = 7;
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // .greptime.v1.FlowId flow_id = 1;
  bool has_flow_id() const;
  private:
  bool _internal_has_flow_id() const;
  public:
  void clear_flow_id();
  const ::greptime::v1::FlowId& flow_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::FlowId* release_flow_id();
  ::greptime::v1::FlowId* mutable_flow_id();
  void set_allocated_flow_id(::greptime::v1::FlowId* flow_id);
  private:
  const ::greptime::v1::FlowId& _internal_flow_id() const;
  ::greptime::v1::FlowId* _internal_mutable_flow_id();
  public:
  void unsafe_arena_set_allocated_flow_id(
      ::greptime::v1::FlowId* flow_id);
  ::greptime::v1::FlowId* unsafe_arena_release_flow_id();

  // .greptime.v1.TableName sink_table_name = 3;
  bool has_sink_table_name() const;
  private:
  bool _internal_has_sink_table_name() const;
  public:
  void clear_sink_table_name();
  const ::greptime::v1::TableName& sink_table_name() const;
  PROTOBUF_NODISCARD ::greptime::v1::TableName* release_sink_table_name();
  ::greptime::v1::TableName* mutable_sink_table_name();
  void set_allocated_sink_table_name(::greptime::v1::TableName* sink_table_name);
  private:
  const ::greptime::v1::TableName& _internal_sink_table_name() const;
  ::greptime::v1::TableName* _internal_mutable_sink_table_name();
  public:
  void unsafe_arena_set_allocated_sink_table_name(
      ::greptime::v1::TableName* sink_table_name);
  ::greptime::v1::TableName* unsafe_arena_release_sink_table_name();

  // .greptime.v1.ExpireAfter expire_after = 5;
  bool has_expire_after() const;
  private:
  bool _internal_has_expire_after() const;
  public:
  void clear_expire_after();
  const ::greptime::v1::ExpireAfter& expire_after() const;
  PROTOBUF_NODISCARD ::greptime::v1::ExpireAfter* release_expire_after();
  ::greptime::v1::ExpireAfter* mutable_expire_after();
  void set_allocated_expire_after(::greptime::v1::ExpireAfter* expire_after);
  private:
  const ::greptime::v1::ExpireAfter& _internal_expire_after() const;
  ::greptime::v1::ExpireAfter* _internal_mutable_expire_after();
  public:
  void unsafe_arena_set_allocated_expire_after(
      ::greptime::v1::ExpireAfter* expire_after);
  ::greptime::v1::ExpireAfter* unsafe_arena_release_expire_after();

  // .greptime.v1.EvalInterval eval_interval = 10;
  bool has_eval_interval() const;
  private:
  bool _internal_has_eval_interval() const;
  public:
  void clear_eval_interval();
  const ::greptime::v1::EvalInterval& eval_interval() const;
  PROTOBUF_NODISCARD ::greptime::v1::EvalInterval* release_eval_interval();
  ::greptime::v1::EvalInterval* mutable_eval_interval();
  void set_allocated_eval_interval(::greptime::v1::EvalInterval* eval_interval);
  private:
  const ::greptime::v1::EvalInterval& _internal_eval_interval() const;
  ::greptime::v1::EvalInterval* _internal_mutable_eval_interval();
  public:
  void unsafe_arena_set_allocated_eval_interval(
      ::greptime::v1::EvalInterval* eval_interval);
  ::greptime::v1::EvalInterval* unsafe_arena_release_eval_interval();

  // bool create_if_not_exists = 4;
  void clear_create_if_not_exists();
  bool create_if_not_exists() const;
  void set_create_if_not_exists(bool value);
  private:
  bool _internal_create_if_not_exists() const;
  void _internal_set_create_if_not_exists(bool value);
  public:

  // bool or_replace = 9;
  void clear_or_replace();
  bool or_replace() const;
  void set_or_replace(bool value);
  private:
  bool _internal_or_replace() const;
  void _internal_set_or_replace(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId > source_table_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        CreateRequest_FlowOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> flow_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
    ::greptime::v1::FlowId* flow_id_;
    ::greptime::v1::TableName* sink_table_name_;
    ::greptime::v1::ExpireAfter* expire_after_;
    ::greptime::v1::EvalInterval* eval_interval_;
    bool create_if_not_exists_;
    bool or_replace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class DropRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.DropRequest) */ {
 public:
  inline DropRequest() : DropRequest(nullptr) {}
  ~DropRequest() override;
  explicit PROTOBUF_CONSTEXPR DropRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropRequest(const DropRequest& from);
  DropRequest(DropRequest&& from) noexcept
    : DropRequest() {
    *this = ::std::move(from);
  }

  inline DropRequest& operator=(const DropRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropRequest& operator=(DropRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropRequest* internal_default_instance() {
    return reinterpret_cast<const DropRequest*>(
               &_DropRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DropRequest& a, DropRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropRequest& from) {
    DropRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.DropRequest";
  }
  protected:
  explicit DropRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowIdFieldNumber = 1,
  };
  // .greptime.v1.FlowId flow_id = 1;
  bool has_flow_id() const;
  private:
  bool _internal_has_flow_id() const;
  public:
  void clear_flow_id();
  const ::greptime::v1::FlowId& flow_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::FlowId* release_flow_id();
  ::greptime::v1::FlowId* mutable_flow_id();
  void set_allocated_flow_id(::greptime::v1::FlowId* flow_id);
  private:
  const ::greptime::v1::FlowId& _internal_flow_id() const;
  ::greptime::v1::FlowId* _internal_mutable_flow_id();
  public:
  void unsafe_arena_set_allocated_flow_id(
      ::greptime::v1::FlowId* flow_id);
  ::greptime::v1::FlowId* unsafe_arena_release_flow_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.DropRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::FlowId* flow_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// -------------------------------------------------------------------

class FlushFlow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.flow.FlushFlow) */ {
 public:
  inline FlushFlow() : FlushFlow(nullptr) {}
  ~FlushFlow() override;
  explicit PROTOBUF_CONSTEXPR FlushFlow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushFlow(const FlushFlow& from);
  FlushFlow(FlushFlow&& from) noexcept
    : FlushFlow() {
    *this = ::std::move(from);
  }

  inline FlushFlow& operator=(const FlushFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushFlow& operator=(FlushFlow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushFlow& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushFlow* internal_default_instance() {
    return reinterpret_cast<const FlushFlow*>(
               &_FlushFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FlushFlow& a, FlushFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushFlow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushFlow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushFlow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushFlow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushFlow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushFlow& from) {
    FlushFlow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushFlow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.flow.FlushFlow";
  }
  protected:
  explicit FlushFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlowIdFieldNumber = 1,
  };
  // .greptime.v1.FlowId flow_id = 1;
  bool has_flow_id() const;
  private:
  bool _internal_has_flow_id() const;
  public:
  void clear_flow_id();
  const ::greptime::v1::FlowId& flow_id() const;
  PROTOBUF_NODISCARD ::greptime::v1::FlowId* release_flow_id();
  ::greptime::v1::FlowId* mutable_flow_id();
  void set_allocated_flow_id(::greptime::v1::FlowId* flow_id);
  private:
  const ::greptime::v1::FlowId& _internal_flow_id() const;
  ::greptime::v1::FlowId* _internal_mutable_flow_id();
  public:
  void unsafe_arena_set_allocated_flow_id(
      ::greptime::v1::FlowId* flow_id);
  ::greptime::v1::FlowId* unsafe_arena_release_flow_id();

  // @@protoc_insertion_point(class_scope:greptime.v1.flow.FlushFlow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::FlowId* flow_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fflow_2fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DirtyWindowRequests

// repeated .greptime.v1.flow.DirtyWindowRequest requests = 1;
inline int DirtyWindowRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int DirtyWindowRequests::requests_size() const {
  return _internal_requests_size();
}
inline void DirtyWindowRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::flow::DirtyWindowRequest* DirtyWindowRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.DirtyWindowRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::DirtyWindowRequest >*
DirtyWindowRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.DirtyWindowRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::flow::DirtyWindowRequest& DirtyWindowRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::flow::DirtyWindowRequest& DirtyWindowRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.DirtyWindowRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::flow::DirtyWindowRequest* DirtyWindowRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::flow::DirtyWindowRequest* DirtyWindowRequests::add_requests() {
  ::greptime::v1::flow::DirtyWindowRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.DirtyWindowRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::DirtyWindowRequest >&
DirtyWindowRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.DirtyWindowRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// DirtyWindowRequest

// uint32 table_id = 1;
inline void DirtyWindowRequest::clear_table_id() {
  _impl_.table_id_ = 0u;
}
inline uint32_t DirtyWindowRequest::_internal_table_id() const {
  return _impl_.table_id_;
}
inline uint32_t DirtyWindowRequest::table_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.DirtyWindowRequest.table_id)
  return _internal_table_id();
}
inline void DirtyWindowRequest::_internal_set_table_id(uint32_t value) {
  
  _impl_.table_id_ = value;
}
inline void DirtyWindowRequest::set_table_id(uint32_t value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.DirtyWindowRequest.table_id)
}

// repeated int64 timestamps = 2;
inline int DirtyWindowRequest::_internal_timestamps_size() const {
  return _impl_.timestamps_.size();
}
inline int DirtyWindowRequest::timestamps_size() const {
  return _internal_timestamps_size();
}
inline void DirtyWindowRequest::clear_timestamps() {
  _impl_.timestamps_.Clear();
}
inline int64_t DirtyWindowRequest::_internal_timestamps(int index) const {
  return _impl_.timestamps_.Get(index);
}
inline int64_t DirtyWindowRequest::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.DirtyWindowRequest.timestamps)
  return _internal_timestamps(index);
}
inline void DirtyWindowRequest::set_timestamps(int index, int64_t value) {
  _impl_.timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.DirtyWindowRequest.timestamps)
}
inline void DirtyWindowRequest::_internal_add_timestamps(int64_t value) {
  _impl_.timestamps_.Add(value);
}
inline void DirtyWindowRequest::add_timestamps(int64_t value) {
  _internal_add_timestamps(value);
  // @@protoc_insertion_point(field_add:greptime.v1.flow.DirtyWindowRequest.timestamps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DirtyWindowRequest::_internal_timestamps() const {
  return _impl_.timestamps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DirtyWindowRequest::timestamps() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.DirtyWindowRequest.timestamps)
  return _internal_timestamps();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DirtyWindowRequest::_internal_mutable_timestamps() {
  return &_impl_.timestamps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DirtyWindowRequest::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.DirtyWindowRequest.timestamps)
  return _internal_mutable_timestamps();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FlowRequestHeader

// map<string, string> tracing_context = 1;
inline int FlowRequestHeader::_internal_tracing_context_size() const {
  return _impl_.tracing_context_.size();
}
inline int FlowRequestHeader::tracing_context_size() const {
  return _internal_tracing_context_size();
}
inline void FlowRequestHeader::clear_tracing_context() {
  _impl_.tracing_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowRequestHeader::_internal_tracing_context() const {
  return _impl_.tracing_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowRequestHeader::tracing_context() const {
  // @@protoc_insertion_point(field_map:greptime.v1.flow.FlowRequestHeader.tracing_context)
  return _internal_tracing_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowRequestHeader::_internal_mutable_tracing_context() {
  return _impl_.tracing_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowRequestHeader::mutable_tracing_context() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.flow.FlowRequestHeader.tracing_context)
  return _internal_mutable_tracing_context();
}

// .greptime.v1.QueryContext query_context = 2;
inline bool FlowRequestHeader::_internal_has_query_context() const {
  return this != internal_default_instance() && _impl_.query_context_ != nullptr;
}
inline bool FlowRequestHeader::has_query_context() const {
  return _internal_has_query_context();
}
inline const ::greptime::v1::QueryContext& FlowRequestHeader::_internal_query_context() const {
  const ::greptime::v1::QueryContext* p = _impl_.query_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::QueryContext&>(
      ::greptime::v1::_QueryContext_default_instance_);
}
inline const ::greptime::v1::QueryContext& FlowRequestHeader::query_context() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequestHeader.query_context)
  return _internal_query_context();
}
inline void FlowRequestHeader::unsafe_arena_set_allocated_query_context(
    ::greptime::v1::QueryContext* query_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_context_);
  }
  _impl_.query_context_ = query_context;
  if (query_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequestHeader.query_context)
}
inline ::greptime::v1::QueryContext* FlowRequestHeader::release_query_context() {
  
  ::greptime::v1::QueryContext* temp = _impl_.query_context_;
  _impl_.query_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::QueryContext* FlowRequestHeader::unsafe_arena_release_query_context() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequestHeader.query_context)
  
  ::greptime::v1::QueryContext* temp = _impl_.query_context_;
  _impl_.query_context_ = nullptr;
  return temp;
}
inline ::greptime::v1::QueryContext* FlowRequestHeader::_internal_mutable_query_context() {
  
  if (_impl_.query_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::QueryContext>(GetArenaForAllocation());
    _impl_.query_context_ = p;
  }
  return _impl_.query_context_;
}
inline ::greptime::v1::QueryContext* FlowRequestHeader::mutable_query_context() {
  ::greptime::v1::QueryContext* _msg = _internal_mutable_query_context();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequestHeader.query_context)
  return _msg;
}
inline void FlowRequestHeader::set_allocated_query_context(::greptime::v1::QueryContext* query_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_context_);
  }
  if (query_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_context));
    if (message_arena != submessage_arena) {
      query_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_context, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_context_ = query_context;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequestHeader.query_context)
}

// -------------------------------------------------------------------

// InsertRequests

// repeated .greptime.v1.flow.InsertRequest requests = 1;
inline int InsertRequests::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int InsertRequests::requests_size() const {
  return _internal_requests_size();
}
inline void InsertRequests::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::greptime::v1::flow::InsertRequest* InsertRequests::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.InsertRequests.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >*
InsertRequests::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.InsertRequests.requests)
  return &_impl_.requests_;
}
inline const ::greptime::v1::flow::InsertRequest& InsertRequests::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::greptime::v1::flow::InsertRequest& InsertRequests::requests(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.InsertRequests.requests)
  return _internal_requests(index);
}
inline ::greptime::v1::flow::InsertRequest* InsertRequests::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::greptime::v1::flow::InsertRequest* InsertRequests::add_requests() {
  ::greptime::v1::flow::InsertRequest* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.InsertRequests.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::flow::InsertRequest >&
InsertRequests::requests() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.InsertRequests.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// InsertRequest

// uint64 region_id = 1;
inline void InsertRequest::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t InsertRequest::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t InsertRequest::region_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.InsertRequest.region_id)
  return _internal_region_id();
}
inline void InsertRequest::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void InsertRequest::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.InsertRequest.region_id)
}

// .greptime.v1.Rows rows = 2;
inline bool InsertRequest::_internal_has_rows() const {
  return this != internal_default_instance() && _impl_.rows_ != nullptr;
}
inline bool InsertRequest::has_rows() const {
  return _internal_has_rows();
}
inline const ::greptime::v1::Rows& InsertRequest::_internal_rows() const {
  const ::greptime::v1::Rows* p = _impl_.rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Rows&>(
      ::greptime::v1::_Rows_default_instance_);
}
inline const ::greptime::v1::Rows& InsertRequest::rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.InsertRequest.rows)
  return _internal_rows();
}
inline void InsertRequest::unsafe_arena_set_allocated_rows(
    ::greptime::v1::Rows* rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  _impl_.rows_ = rows;
  if (rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.InsertRequest.rows)
}
inline ::greptime::v1::Rows* InsertRequest::release_rows() {
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::unsafe_arena_release_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.InsertRequest.rows)
  
  ::greptime::v1::Rows* temp = _impl_.rows_;
  _impl_.rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::Rows* InsertRequest::_internal_mutable_rows() {
  
  if (_impl_.rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Rows>(GetArenaForAllocation());
    _impl_.rows_ = p;
  }
  return _impl_.rows_;
}
inline ::greptime::v1::Rows* InsertRequest::mutable_rows() {
  ::greptime::v1::Rows* _msg = _internal_mutable_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.InsertRequest.rows)
  return _msg;
}
inline void InsertRequest::set_allocated_rows(::greptime::v1::Rows* rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rows_);
  }
  if (rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rows));
    if (message_arena != submessage_arena) {
      rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rows_ = rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.InsertRequest.rows)
}

// -------------------------------------------------------------------

// FlowRequest

// .greptime.v1.flow.FlowRequestHeader header = 64;
inline bool FlowRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FlowRequest::has_header() const {
  return _internal_has_header();
}
inline void FlowRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::greptime::v1::flow::FlowRequestHeader& FlowRequest::_internal_header() const {
  const ::greptime::v1::flow::FlowRequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::flow::FlowRequestHeader&>(
      ::greptime::v1::flow::_FlowRequestHeader_default_instance_);
}
inline const ::greptime::v1::flow::FlowRequestHeader& FlowRequest::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequest.header)
  return _internal_header();
}
inline void FlowRequest::unsafe_arena_set_allocated_header(
    ::greptime::v1::flow::FlowRequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequest.header)
}
inline ::greptime::v1::flow::FlowRequestHeader* FlowRequest::release_header() {
  
  ::greptime::v1::flow::FlowRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::flow::FlowRequestHeader* FlowRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequest.header)
  
  ::greptime::v1::flow::FlowRequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::flow::FlowRequestHeader* FlowRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::flow::FlowRequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::flow::FlowRequestHeader* FlowRequest::mutable_header() {
  ::greptime::v1::flow::FlowRequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequest.header)
  return _msg;
}
inline void FlowRequest::set_allocated_header(::greptime::v1::flow::FlowRequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.header)
}

// .greptime.v1.flow.CreateRequest create = 1;
inline bool FlowRequest::_internal_has_create() const {
  return body_case() == kCreate;
}
inline bool FlowRequest::has_create() const {
  return _internal_has_create();
}
inline void FlowRequest::set_has_create() {
  _impl_._oneof_case_[0] = kCreate;
}
inline void FlowRequest::clear_create() {
  if (_internal_has_create()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.create_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::flow::CreateRequest* FlowRequest::release_create() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::flow::CreateRequest* temp = _impl_.body_.create_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::flow::CreateRequest& FlowRequest::_internal_create() const {
  return _internal_has_create()
      ? *_impl_.body_.create_
      : reinterpret_cast< ::greptime::v1::flow::CreateRequest&>(::greptime::v1::flow::_CreateRequest_default_instance_);
}
inline const ::greptime::v1::flow::CreateRequest& FlowRequest::create() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequest.create)
  return _internal_create();
}
inline ::greptime::v1::flow::CreateRequest* FlowRequest::unsafe_arena_release_create() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.flow.FlowRequest.create)
  if (_internal_has_create()) {
    clear_has_body();
    ::greptime::v1::flow::CreateRequest* temp = _impl_.body_.create_;
    _impl_.body_.create_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRequest::unsafe_arena_set_allocated_create(::greptime::v1::flow::CreateRequest* create) {
  clear_body();
  if (create) {
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequest.create)
}
inline ::greptime::v1::flow::CreateRequest* FlowRequest::_internal_mutable_create() {
  if (!_internal_has_create()) {
    clear_body();
    set_has_create();
    _impl_.body_.create_ = CreateMaybeMessage< ::greptime::v1::flow::CreateRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.create_;
}
inline ::greptime::v1::flow::CreateRequest* FlowRequest::mutable_create() {
  ::greptime::v1::flow::CreateRequest* _msg = _internal_mutable_create();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequest.create)
  return _msg;
}

// .greptime.v1.flow.DropRequest drop = 2;
inline bool FlowRequest::_internal_has_drop() const {
  return body_case() == kDrop;
}
inline bool FlowRequest::has_drop() const {
  return _internal_has_drop();
}
inline void FlowRequest::set_has_drop() {
  _impl_._oneof_case_[0] = kDrop;
}
inline void FlowRequest::clear_drop() {
  if (_internal_has_drop()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.drop_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::flow::DropRequest* FlowRequest::release_drop() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequest.drop)
  if (_internal_has_drop()) {
    clear_has_body();
    ::greptime::v1::flow::DropRequest* temp = _impl_.body_.drop_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::flow::DropRequest& FlowRequest::_internal_drop() const {
  return _internal_has_drop()
      ? *_impl_.body_.drop_
      : reinterpret_cast< ::greptime::v1::flow::DropRequest&>(::greptime::v1::flow::_DropRequest_default_instance_);
}
inline const ::greptime::v1::flow::DropRequest& FlowRequest::drop() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequest.drop)
  return _internal_drop();
}
inline ::greptime::v1::flow::DropRequest* FlowRequest::unsafe_arena_release_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.flow.FlowRequest.drop)
  if (_internal_has_drop()) {
    clear_has_body();
    ::greptime::v1::flow::DropRequest* temp = _impl_.body_.drop_;
    _impl_.body_.drop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRequest::unsafe_arena_set_allocated_drop(::greptime::v1::flow::DropRequest* drop) {
  clear_body();
  if (drop) {
    set_has_drop();
    _impl_.body_.drop_ = drop;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequest.drop)
}
inline ::greptime::v1::flow::DropRequest* FlowRequest::_internal_mutable_drop() {
  if (!_internal_has_drop()) {
    clear_body();
    set_has_drop();
    _impl_.body_.drop_ = CreateMaybeMessage< ::greptime::v1::flow::DropRequest >(GetArenaForAllocation());
  }
  return _impl_.body_.drop_;
}
inline ::greptime::v1::flow::DropRequest* FlowRequest::mutable_drop() {
  ::greptime::v1::flow::DropRequest* _msg = _internal_mutable_drop();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequest.drop)
  return _msg;
}

// .greptime.v1.flow.FlushFlow flush = 3;
inline bool FlowRequest::_internal_has_flush() const {
  return body_case() == kFlush;
}
inline bool FlowRequest::has_flush() const {
  return _internal_has_flush();
}
inline void FlowRequest::set_has_flush() {
  _impl_._oneof_case_[0] = kFlush;
}
inline void FlowRequest::clear_flush() {
  if (_internal_has_flush()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.body_.flush_;
    }
    clear_has_body();
  }
}
inline ::greptime::v1::flow::FlushFlow* FlowRequest::release_flush() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowRequest.flush)
  if (_internal_has_flush()) {
    clear_has_body();
    ::greptime::v1::flow::FlushFlow* temp = _impl_.body_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::flow::FlushFlow& FlowRequest::_internal_flush() const {
  return _internal_has_flush()
      ? *_impl_.body_.flush_
      : reinterpret_cast< ::greptime::v1::flow::FlushFlow&>(::greptime::v1::flow::_FlushFlow_default_instance_);
}
inline const ::greptime::v1::flow::FlushFlow& FlowRequest::flush() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowRequest.flush)
  return _internal_flush();
}
inline ::greptime::v1::flow::FlushFlow* FlowRequest::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.flow.FlowRequest.flush)
  if (_internal_has_flush()) {
    clear_has_body();
    ::greptime::v1::flow::FlushFlow* temp = _impl_.body_.flush_;
    _impl_.body_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FlowRequest::unsafe_arena_set_allocated_flush(::greptime::v1::flow::FlushFlow* flush) {
  clear_body();
  if (flush) {
    set_has_flush();
    _impl_.body_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowRequest.flush)
}
inline ::greptime::v1::flow::FlushFlow* FlowRequest::_internal_mutable_flush() {
  if (!_internal_has_flush()) {
    clear_body();
    set_has_flush();
    _impl_.body_.flush_ = CreateMaybeMessage< ::greptime::v1::flow::FlushFlow >(GetArenaForAllocation());
  }
  return _impl_.body_.flush_;
}
inline ::greptime::v1::flow::FlushFlow* FlowRequest::mutable_flush() {
  ::greptime::v1::flow::FlushFlow* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowRequest.flush)
  return _msg;
}

inline bool FlowRequest::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void FlowRequest::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline FlowRequest::BodyCase FlowRequest::body_case() const {
  return FlowRequest::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FlowResponse

// .greptime.v1.ResponseHeader header = 1;
inline bool FlowResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool FlowResponse::has_header() const {
  return _internal_has_header();
}
inline const ::greptime::v1::ResponseHeader& FlowResponse::_internal_header() const {
  const ::greptime::v1::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ResponseHeader&>(
      ::greptime::v1::_ResponseHeader_default_instance_);
}
inline const ::greptime::v1::ResponseHeader& FlowResponse::header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowResponse.header)
  return _internal_header();
}
inline void FlowResponse::unsafe_arena_set_allocated_header(
    ::greptime::v1::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlowResponse.header)
}
inline ::greptime::v1::ResponseHeader* FlowResponse::release_header() {
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ResponseHeader* FlowResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlowResponse.header)
  
  ::greptime::v1::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::greptime::v1::ResponseHeader* FlowResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::greptime::v1::ResponseHeader* FlowResponse::mutable_header() {
  ::greptime::v1::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowResponse.header)
  return _msg;
}
inline void FlowResponse::set_allocated_header(::greptime::v1::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowResponse.header)
}

// uint64 affected_rows = 2;
inline void FlowResponse::clear_affected_rows() {
  _impl_.affected_rows_ = uint64_t{0u};
}
inline uint64_t FlowResponse::_internal_affected_rows() const {
  return _impl_.affected_rows_;
}
inline uint64_t FlowResponse::affected_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowResponse.affected_rows)
  return _internal_affected_rows();
}
inline void FlowResponse::_internal_set_affected_rows(uint64_t value) {
  
  _impl_.affected_rows_ = value;
}
inline void FlowResponse::set_affected_rows(uint64_t value) {
  _internal_set_affected_rows(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.FlowResponse.affected_rows)
}

// repeated .greptime.v1.FlowId affected_flows = 3;
inline int FlowResponse::_internal_affected_flows_size() const {
  return _impl_.affected_flows_.size();
}
inline int FlowResponse::affected_flows_size() const {
  return _internal_affected_flows_size();
}
inline ::greptime::v1::FlowId* FlowResponse::mutable_affected_flows(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlowResponse.affected_flows)
  return _impl_.affected_flows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::FlowId >*
FlowResponse::mutable_affected_flows() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.FlowResponse.affected_flows)
  return &_impl_.affected_flows_;
}
inline const ::greptime::v1::FlowId& FlowResponse::_internal_affected_flows(int index) const {
  return _impl_.affected_flows_.Get(index);
}
inline const ::greptime::v1::FlowId& FlowResponse::affected_flows(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlowResponse.affected_flows)
  return _internal_affected_flows(index);
}
inline ::greptime::v1::FlowId* FlowResponse::_internal_add_affected_flows() {
  return _impl_.affected_flows_.Add();
}
inline ::greptime::v1::FlowId* FlowResponse::add_affected_flows() {
  ::greptime::v1::FlowId* _add = _internal_add_affected_flows();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.FlowResponse.affected_flows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::FlowId >&
FlowResponse::affected_flows() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.FlowResponse.affected_flows)
  return _impl_.affected_flows_;
}

// map<string, bytes> extensions = 4;
inline int FlowResponse::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int FlowResponse::extensions_size() const {
  return _internal_extensions_size();
}
inline void FlowResponse::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowResponse::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
FlowResponse::extensions() const {
  // @@protoc_insertion_point(field_map:greptime.v1.flow.FlowResponse.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowResponse::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
FlowResponse::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.flow.FlowResponse.extensions)
  return _internal_mutable_extensions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateRequest

// .greptime.v1.FlowId flow_id = 1;
inline bool CreateRequest::_internal_has_flow_id() const {
  return this != internal_default_instance() && _impl_.flow_id_ != nullptr;
}
inline bool CreateRequest::has_flow_id() const {
  return _internal_has_flow_id();
}
inline const ::greptime::v1::FlowId& CreateRequest::_internal_flow_id() const {
  const ::greptime::v1::FlowId* p = _impl_.flow_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::FlowId&>(
      ::greptime::v1::_FlowId_default_instance_);
}
inline const ::greptime::v1::FlowId& CreateRequest::flow_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.flow_id)
  return _internal_flow_id();
}
inline void CreateRequest::unsafe_arena_set_allocated_flow_id(
    ::greptime::v1::FlowId* flow_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  _impl_.flow_id_ = flow_id;
  if (flow_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.CreateRequest.flow_id)
}
inline ::greptime::v1::FlowId* CreateRequest::release_flow_id() {
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::FlowId* CreateRequest::unsafe_arena_release_flow_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.CreateRequest.flow_id)
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::FlowId* CreateRequest::_internal_mutable_flow_id() {
  
  if (_impl_.flow_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::FlowId>(GetArenaForAllocation());
    _impl_.flow_id_ = p;
  }
  return _impl_.flow_id_;
}
inline ::greptime::v1::FlowId* CreateRequest::mutable_flow_id() {
  ::greptime::v1::FlowId* _msg = _internal_mutable_flow_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.flow_id)
  return _msg;
}
inline void CreateRequest::set_allocated_flow_id(::greptime::v1::FlowId* flow_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  if (flow_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_id));
    if (message_arena != submessage_arena) {
      flow_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flow_id_ = flow_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.CreateRequest.flow_id)
}

// repeated .greptime.v1.TableId source_table_ids = 2;
inline int CreateRequest::_internal_source_table_ids_size() const {
  return _impl_.source_table_ids_.size();
}
inline int CreateRequest::source_table_ids_size() const {
  return _internal_source_table_ids_size();
}
inline ::greptime::v1::TableId* CreateRequest::mutable_source_table_ids(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.source_table_ids)
  return _impl_.source_table_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >*
CreateRequest::mutable_source_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.flow.CreateRequest.source_table_ids)
  return &_impl_.source_table_ids_;
}
inline const ::greptime::v1::TableId& CreateRequest::_internal_source_table_ids(int index) const {
  return _impl_.source_table_ids_.Get(index);
}
inline const ::greptime::v1::TableId& CreateRequest::source_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.source_table_ids)
  return _internal_source_table_ids(index);
}
inline ::greptime::v1::TableId* CreateRequest::_internal_add_source_table_ids() {
  return _impl_.source_table_ids_.Add();
}
inline ::greptime::v1::TableId* CreateRequest::add_source_table_ids() {
  ::greptime::v1::TableId* _add = _internal_add_source_table_ids();
  // @@protoc_insertion_point(field_add:greptime.v1.flow.CreateRequest.source_table_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TableId >&
CreateRequest::source_table_ids() const {
  // @@protoc_insertion_point(field_list:greptime.v1.flow.CreateRequest.source_table_ids)
  return _impl_.source_table_ids_;
}

// .greptime.v1.TableName sink_table_name = 3;
inline bool CreateRequest::_internal_has_sink_table_name() const {
  return this != internal_default_instance() && _impl_.sink_table_name_ != nullptr;
}
inline bool CreateRequest::has_sink_table_name() const {
  return _internal_has_sink_table_name();
}
inline const ::greptime::v1::TableName& CreateRequest::_internal_sink_table_name() const {
  const ::greptime::v1::TableName* p = _impl_.sink_table_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::TableName&>(
      ::greptime::v1::_TableName_default_instance_);
}
inline const ::greptime::v1::TableName& CreateRequest::sink_table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.sink_table_name)
  return _internal_sink_table_name();
}
inline void CreateRequest::unsafe_arena_set_allocated_sink_table_name(
    ::greptime::v1::TableName* sink_table_name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_table_name_);
  }
  _impl_.sink_table_name_ = sink_table_name;
  if (sink_table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.CreateRequest.sink_table_name)
}
inline ::greptime::v1::TableName* CreateRequest::release_sink_table_name() {
  
  ::greptime::v1::TableName* temp = _impl_.sink_table_name_;
  _impl_.sink_table_name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::TableName* CreateRequest::unsafe_arena_release_sink_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.CreateRequest.sink_table_name)
  
  ::greptime::v1::TableName* temp = _impl_.sink_table_name_;
  _impl_.sink_table_name_ = nullptr;
  return temp;
}
inline ::greptime::v1::TableName* CreateRequest::_internal_mutable_sink_table_name() {
  
  if (_impl_.sink_table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::TableName>(GetArenaForAllocation());
    _impl_.sink_table_name_ = p;
  }
  return _impl_.sink_table_name_;
}
inline ::greptime::v1::TableName* CreateRequest::mutable_sink_table_name() {
  ::greptime::v1::TableName* _msg = _internal_mutable_sink_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.sink_table_name)
  return _msg;
}
inline void CreateRequest::set_allocated_sink_table_name(::greptime::v1::TableName* sink_table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sink_table_name_);
  }
  if (sink_table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sink_table_name));
    if (message_arena != submessage_arena) {
      sink_table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sink_table_name, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sink_table_name_ = sink_table_name;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.CreateRequest.sink_table_name)
}

// bool create_if_not_exists = 4;
inline void CreateRequest::clear_create_if_not_exists() {
  _impl_.create_if_not_exists_ = false;
}
inline bool CreateRequest::_internal_create_if_not_exists() const {
  return _impl_.create_if_not_exists_;
}
inline bool CreateRequest::create_if_not_exists() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.create_if_not_exists)
  return _internal_create_if_not_exists();
}
inline void CreateRequest::_internal_set_create_if_not_exists(bool value) {
  
  _impl_.create_if_not_exists_ = value;
}
inline void CreateRequest::set_create_if_not_exists(bool value) {
  _internal_set_create_if_not_exists(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.CreateRequest.create_if_not_exists)
}

// .greptime.v1.ExpireAfter expire_after = 5;
inline bool CreateRequest::_internal_has_expire_after() const {
  return this != internal_default_instance() && _impl_.expire_after_ != nullptr;
}
inline bool CreateRequest::has_expire_after() const {
  return _internal_has_expire_after();
}
inline const ::greptime::v1::ExpireAfter& CreateRequest::_internal_expire_after() const {
  const ::greptime::v1::ExpireAfter* p = _impl_.expire_after_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ExpireAfter&>(
      ::greptime::v1::_ExpireAfter_default_instance_);
}
inline const ::greptime::v1::ExpireAfter& CreateRequest::expire_after() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.expire_after)
  return _internal_expire_after();
}
inline void CreateRequest::unsafe_arena_set_allocated_expire_after(
    ::greptime::v1::ExpireAfter* expire_after) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_after_);
  }
  _impl_.expire_after_ = expire_after;
  if (expire_after) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.CreateRequest.expire_after)
}
inline ::greptime::v1::ExpireAfter* CreateRequest::release_expire_after() {
  
  ::greptime::v1::ExpireAfter* temp = _impl_.expire_after_;
  _impl_.expire_after_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ExpireAfter* CreateRequest::unsafe_arena_release_expire_after() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.CreateRequest.expire_after)
  
  ::greptime::v1::ExpireAfter* temp = _impl_.expire_after_;
  _impl_.expire_after_ = nullptr;
  return temp;
}
inline ::greptime::v1::ExpireAfter* CreateRequest::_internal_mutable_expire_after() {
  
  if (_impl_.expire_after_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ExpireAfter>(GetArenaForAllocation());
    _impl_.expire_after_ = p;
  }
  return _impl_.expire_after_;
}
inline ::greptime::v1::ExpireAfter* CreateRequest::mutable_expire_after() {
  ::greptime::v1::ExpireAfter* _msg = _internal_mutable_expire_after();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.expire_after)
  return _msg;
}
inline void CreateRequest::set_allocated_expire_after(::greptime::v1::ExpireAfter* expire_after) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expire_after_);
  }
  if (expire_after) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_after));
    if (message_arena != submessage_arena) {
      expire_after = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire_after, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.expire_after_ = expire_after;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.CreateRequest.expire_after)
}

// .greptime.v1.EvalInterval eval_interval = 10;
inline bool CreateRequest::_internal_has_eval_interval() const {
  return this != internal_default_instance() && _impl_.eval_interval_ != nullptr;
}
inline bool CreateRequest::has_eval_interval() const {
  return _internal_has_eval_interval();
}
inline const ::greptime::v1::EvalInterval& CreateRequest::_internal_eval_interval() const {
  const ::greptime::v1::EvalInterval* p = _impl_.eval_interval_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::EvalInterval&>(
      ::greptime::v1::_EvalInterval_default_instance_);
}
inline const ::greptime::v1::EvalInterval& CreateRequest::eval_interval() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.eval_interval)
  return _internal_eval_interval();
}
inline void CreateRequest::unsafe_arena_set_allocated_eval_interval(
    ::greptime::v1::EvalInterval* eval_interval) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eval_interval_);
  }
  _impl_.eval_interval_ = eval_interval;
  if (eval_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.CreateRequest.eval_interval)
}
inline ::greptime::v1::EvalInterval* CreateRequest::release_eval_interval() {
  
  ::greptime::v1::EvalInterval* temp = _impl_.eval_interval_;
  _impl_.eval_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::EvalInterval* CreateRequest::unsafe_arena_release_eval_interval() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.CreateRequest.eval_interval)
  
  ::greptime::v1::EvalInterval* temp = _impl_.eval_interval_;
  _impl_.eval_interval_ = nullptr;
  return temp;
}
inline ::greptime::v1::EvalInterval* CreateRequest::_internal_mutable_eval_interval() {
  
  if (_impl_.eval_interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::EvalInterval>(GetArenaForAllocation());
    _impl_.eval_interval_ = p;
  }
  return _impl_.eval_interval_;
}
inline ::greptime::v1::EvalInterval* CreateRequest::mutable_eval_interval() {
  ::greptime::v1::EvalInterval* _msg = _internal_mutable_eval_interval();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.eval_interval)
  return _msg;
}
inline void CreateRequest::set_allocated_eval_interval(::greptime::v1::EvalInterval* eval_interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eval_interval_);
  }
  if (eval_interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(eval_interval));
    if (message_arena != submessage_arena) {
      eval_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eval_interval, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.eval_interval_ = eval_interval;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.CreateRequest.eval_interval)
}

// string comment = 6;
inline void CreateRequest::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& CreateRequest::comment() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.flow.CreateRequest.comment)
}
inline std::string* CreateRequest::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.comment)
  return _s;
}
inline const std::string& CreateRequest::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void CreateRequest::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_comment() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.CreateRequest.comment)
  return _impl_.comment_.Release();
}
inline void CreateRequest::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.CreateRequest.comment)
}

// string sql = 7;
inline void CreateRequest::clear_sql() {
  _impl_.sql_.ClearToEmpty();
}
inline const std::string& CreateRequest::sql() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_sql(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sql_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.flow.CreateRequest.sql)
}
inline std::string* CreateRequest::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.CreateRequest.sql)
  return _s;
}
inline const std::string& CreateRequest::_internal_sql() const {
  return _impl_.sql_.Get();
}
inline void CreateRequest::_internal_set_sql(const std::string& value) {
  
  _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_sql() {
  
  return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRequest::release_sql() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.CreateRequest.sql)
  return _impl_.sql_.Release();
}
inline void CreateRequest::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    
  } else {
    
  }
  _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sql_.IsDefault()) {
    _impl_.sql_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.CreateRequest.sql)
}

// map<string, string> flow_options = 8;
inline int CreateRequest::_internal_flow_options_size() const {
  return _impl_.flow_options_.size();
}
inline int CreateRequest::flow_options_size() const {
  return _internal_flow_options_size();
}
inline void CreateRequest::clear_flow_options() {
  _impl_.flow_options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::_internal_flow_options() const {
  return _impl_.flow_options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateRequest::flow_options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.flow.CreateRequest.flow_options)
  return _internal_flow_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::_internal_mutable_flow_options() {
  return _impl_.flow_options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateRequest::mutable_flow_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.flow.CreateRequest.flow_options)
  return _internal_mutable_flow_options();
}

// bool or_replace = 9;
inline void CreateRequest::clear_or_replace() {
  _impl_.or_replace_ = false;
}
inline bool CreateRequest::_internal_or_replace() const {
  return _impl_.or_replace_;
}
inline bool CreateRequest::or_replace() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.CreateRequest.or_replace)
  return _internal_or_replace();
}
inline void CreateRequest::_internal_set_or_replace(bool value) {
  
  _impl_.or_replace_ = value;
}
inline void CreateRequest::set_or_replace(bool value) {
  _internal_set_or_replace(value);
  // @@protoc_insertion_point(field_set:greptime.v1.flow.CreateRequest.or_replace)
}

// -------------------------------------------------------------------

// DropRequest

// .greptime.v1.FlowId flow_id = 1;
inline bool DropRequest::_internal_has_flow_id() const {
  return this != internal_default_instance() && _impl_.flow_id_ != nullptr;
}
inline bool DropRequest::has_flow_id() const {
  return _internal_has_flow_id();
}
inline const ::greptime::v1::FlowId& DropRequest::_internal_flow_id() const {
  const ::greptime::v1::FlowId* p = _impl_.flow_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::FlowId&>(
      ::greptime::v1::_FlowId_default_instance_);
}
inline const ::greptime::v1::FlowId& DropRequest::flow_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.DropRequest.flow_id)
  return _internal_flow_id();
}
inline void DropRequest::unsafe_arena_set_allocated_flow_id(
    ::greptime::v1::FlowId* flow_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  _impl_.flow_id_ = flow_id;
  if (flow_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.DropRequest.flow_id)
}
inline ::greptime::v1::FlowId* DropRequest::release_flow_id() {
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::FlowId* DropRequest::unsafe_arena_release_flow_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.DropRequest.flow_id)
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::FlowId* DropRequest::_internal_mutable_flow_id() {
  
  if (_impl_.flow_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::FlowId>(GetArenaForAllocation());
    _impl_.flow_id_ = p;
  }
  return _impl_.flow_id_;
}
inline ::greptime::v1::FlowId* DropRequest::mutable_flow_id() {
  ::greptime::v1::FlowId* _msg = _internal_mutable_flow_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.DropRequest.flow_id)
  return _msg;
}
inline void DropRequest::set_allocated_flow_id(::greptime::v1::FlowId* flow_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  if (flow_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_id));
    if (message_arena != submessage_arena) {
      flow_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flow_id_ = flow_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.DropRequest.flow_id)
}

// -------------------------------------------------------------------

// FlushFlow

// .greptime.v1.FlowId flow_id = 1;
inline bool FlushFlow::_internal_has_flow_id() const {
  return this != internal_default_instance() && _impl_.flow_id_ != nullptr;
}
inline bool FlushFlow::has_flow_id() const {
  return _internal_has_flow_id();
}
inline const ::greptime::v1::FlowId& FlushFlow::_internal_flow_id() const {
  const ::greptime::v1::FlowId* p = _impl_.flow_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::FlowId&>(
      ::greptime::v1::_FlowId_default_instance_);
}
inline const ::greptime::v1::FlowId& FlushFlow::flow_id() const {
  // @@protoc_insertion_point(field_get:greptime.v1.flow.FlushFlow.flow_id)
  return _internal_flow_id();
}
inline void FlushFlow::unsafe_arena_set_allocated_flow_id(
    ::greptime::v1::FlowId* flow_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  _impl_.flow_id_ = flow_id;
  if (flow_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.flow.FlushFlow.flow_id)
}
inline ::greptime::v1::FlowId* FlushFlow::release_flow_id() {
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::FlowId* FlushFlow::unsafe_arena_release_flow_id() {
  // @@protoc_insertion_point(field_release:greptime.v1.flow.FlushFlow.flow_id)
  
  ::greptime::v1::FlowId* temp = _impl_.flow_id_;
  _impl_.flow_id_ = nullptr;
  return temp;
}
inline ::greptime::v1::FlowId* FlushFlow::_internal_mutable_flow_id() {
  
  if (_impl_.flow_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::FlowId>(GetArenaForAllocation());
    _impl_.flow_id_ = p;
  }
  return _impl_.flow_id_;
}
inline ::greptime::v1::FlowId* FlushFlow::mutable_flow_id() {
  ::greptime::v1::FlowId* _msg = _internal_mutable_flow_id();
  // @@protoc_insertion_point(field_mutable:greptime.v1.flow.FlushFlow.flow_id)
  return _msg;
}
inline void FlushFlow::set_allocated_flow_id(::greptime::v1::FlowId* flow_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.flow_id_);
  }
  if (flow_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(flow_id));
    if (message_arena != submessage_arena) {
      flow_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flow_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.flow_id_ = flow_id;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlushFlow.flow_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flow
}  // namespace v1
}  // namespace greptime

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fflow_2fserver_2eproto
