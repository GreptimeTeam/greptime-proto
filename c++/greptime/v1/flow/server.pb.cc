// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/flow/server.proto

#include "greptime/v1/flow/server.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace greptime {
namespace v1 {
namespace flow {
PROTOBUF_CONSTEXPR InsertRequests::InsertRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestsDefaultTypeInternal() {}
  union {
    InsertRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
PROTOBUF_CONSTEXPR InsertRequest::InsertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rows_)*/nullptr
  , /*decltype(_impl_.region_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestDefaultTypeInternal() {}
  union {
    InsertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowRequest::FlowRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.body_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FlowRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestDefaultTypeInternal() {}
  union {
    FlowRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestDefaultTypeInternal _FlowRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowResponse_ExtensionEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal _FlowResponse_ExtensionEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse::FlowResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extension_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.affected_tasks_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.affected_rows_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponseDefaultTypeInternal() {}
  union {
    FlowResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponseDefaultTypeInternal _FlowResponse_default_instance_;
PROTOBUF_CONSTEXPR FlowCreateRequest_TaskOptionsEntry_DoNotUse::FlowCreateRequest_TaskOptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowCreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowCreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowCreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowCreateRequest_TaskOptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowCreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal _FlowCreateRequest_TaskOptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowCreateRequest::FlowCreateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_table_ids_)*/{}
  , /*decltype(_impl_.task_options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.expire_when_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sql_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.task_id_)*/nullptr
  , /*decltype(_impl_.output_table_id_)*/nullptr
  , /*decltype(_impl_.create_if_not_exists_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowCreateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowCreateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowCreateRequestDefaultTypeInternal() {}
  union {
    FlowCreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowCreateRequestDefaultTypeInternal _FlowCreateRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowRemoveRequest::FlowRemoveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.task_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowRemoveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRemoveRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRemoveRequestDefaultTypeInternal() {}
  union {
    FlowRemoveRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRemoveRequestDefaultTypeInternal _FlowRemoveRequest_default_instance_;
PROTOBUF_CONSTEXPR TaskId::TaskId(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TaskIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TaskIdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TaskIdDefaultTypeInternal() {}
  union {
    TaskId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TaskIdDefaultTypeInternal _TaskId_default_instance_;
}  // namespace flow
}  // namespace v1
}  // namespace greptime
static ::_pb::Metadata file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[9];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;

const uint32_t TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.region_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.rows_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_rows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.extension_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_tasks_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.task_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.source_table_ids_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.output_table_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.create_if_not_exists_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.expire_when_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.sql_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowCreateRequest, _impl_.task_options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRemoveRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRemoveRequest, _impl_.task_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::TaskId, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::TaskId, _impl_.id_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::greptime::v1::flow::InsertRequests)},
  { 7, -1, -1, sizeof(::greptime::v1::flow::InsertRequest)},
  { 15, -1, -1, sizeof(::greptime::v1::flow::FlowRequest)},
  { 24, 32, -1, sizeof(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse)},
  { 34, -1, -1, sizeof(::greptime::v1::flow::FlowResponse)},
  { 44, 52, -1, sizeof(::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse)},
  { 54, -1, -1, sizeof(::greptime::v1::flow::FlowCreateRequest)},
  { 68, -1, -1, sizeof(::greptime::v1::flow::FlowRemoveRequest)},
  { 75, -1, -1, sizeof(::greptime::v1::flow::TaskId)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::greptime::v1::flow::_InsertRequests_default_instance_._instance,
  &::greptime::v1::flow::_InsertRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_ExtensionEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_default_instance_._instance,
  &::greptime::v1::flow::_FlowCreateRequest_TaskOptionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowCreateRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowRemoveRequest_default_instance_._instance,
  &::greptime::v1::flow::_TaskId_default_instance_._instance,
};

const char descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035greptime/v1/flow/server.proto\022\020greptim"
  "e.v1.flow\032\030greptime/v1/common.proto\032\025gre"
  "ptime/v1/ddl.proto\032\025greptime/v1/row.prot"
  "o\"C\n\016InsertRequests\0221\n\010requests\030\001 \003(\0132\037."
  "greptime.v1.flow.InsertRequest\"C\n\rInsert"
  "Request\022\021\n\tregion_id\030\001 \001(\004\022\037\n\004rows\030\002 \001(\013"
  "2\021.greptime.v1.Rows\"\203\001\n\013FlowRequest\0225\n\006c"
  "reate\030\001 \001(\0132#.greptime.v1.flow.FlowCreat"
  "eRequestH\000\0225\n\006remove\030\002 \001(\0132#.greptime.v1"
  ".flow.FlowRemoveRequestH\000B\006\n\004body\"\370\001\n\014Fl"
  "owResponse\022+\n\006header\030\001 \001(\0132\033.greptime.v1"
  ".ResponseHeader\022\025\n\raffected_rows\030\002 \001(\004\022@"
  "\n\textension\030\003 \003(\0132-.greptime.v1.flow.Flo"
  "wResponse.ExtensionEntry\0220\n\016affected_tas"
  "ks\030\004 \003(\0132\030.greptime.v1.flow.TaskId\0320\n\016Ex"
  "tensionEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014"
  ":\0028\001\"\356\002\n\021FlowCreateRequest\022)\n\007task_id\030\001 "
  "\001(\0132\030.greptime.v1.flow.TaskId\022.\n\020source_"
  "table_ids\030\002 \003(\0132\024.greptime.v1.TableId\022-\n"
  "\017output_table_id\030\003 \001(\0132\024.greptime.v1.Tab"
  "leId\022\034\n\024create_if_not_exists\030\004 \001(\010\022\023\n\013ex"
  "pire_when\030\005 \001(\t\022\017\n\007comment\030\006 \001(\t\022\013\n\003sql\030"
  "\007 \001(\t\022J\n\014task_options\030\010 \003(\01324.greptime.v"
  "1.flow.FlowCreateRequest.TaskOptionsEntr"
  "y\0322\n\020TaskOptionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005va"
  "lue\030\002 \001(\t:\0028\001\">\n\021FlowRemoveRequest\022)\n\007ta"
  "sk_id\030\001 \001(\0132\030.greptime.v1.flow.TaskId\"\024\n"
  "\006TaskId\022\n\n\002id\030\001 \001(\r2\264\001\n\004Flow\022S\n\022HandleCr"
  "eateRemove\022\035.greptime.v1.flow.FlowReques"
  "t\032\036.greptime.v1.flow.FlowResponse\022W\n\023Han"
  "dleMirrorRequest\022 .greptime.v1.flow.Inse"
  "rtRequests\032\036.greptime.v1.flow.FlowRespon"
  "seBY\n\023io.greptime.v1.flowB\006ServerZ:githu"
  "b.com/GreptimeTeam/greptime-proto/go/gre"
  "ptime/v1/flowb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps[3] = {
  &::descriptor_table_greptime_2fv1_2fcommon_2eproto,
  &::descriptor_table_greptime_2fv1_2fddl_2eproto,
  &::descriptor_table_greptime_2fv1_2frow_2eproto,
};
static ::_pbi::once_flag descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto = {
    false, false, 1381, descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto,
    "greptime/v1/flow/server.proto",
    &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once, descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps, 3, 9,
    schemas, file_default_instances, TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets,
    file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto, file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
    file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter() {
  return &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_greptime_2fv1_2fflow_2fserver_2eproto(&descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto);
namespace greptime {
namespace v1 {
namespace flow {

// ===================================================================

class InsertRequests::_Internal {
 public:
};

InsertRequests::InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequests)
}
InsertRequests::InsertRequests(const InsertRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){from._impl_.requests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequests)
}

inline void InsertRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequests::~InsertRequests() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void InsertRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .greptime.v1.flow.InsertRequest requests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequests)
  return target;
}

size_t InsertRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequests::GetClassData() const { return &_class_data_; }


void InsertRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequests*>(&to_msg);
  auto& from = static_cast<const InsertRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequests::CopyFrom(const InsertRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequests::IsInitialized() const {
  return true;
}

void InsertRequests::InternalSwap(InsertRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[0]);
}

// ===================================================================

class InsertRequest::_Internal {
 public:
  static const ::greptime::v1::Rows& rows(const InsertRequest* msg);
};

const ::greptime::v1::Rows&
InsertRequest::_Internal::rows(const InsertRequest* msg) {
  return *msg->_impl_.rows_;
}
void InsertRequest::clear_rows() {
  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
}
InsertRequest::InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequest)
}
InsertRequest::InsertRequest(const InsertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rows()) {
    _this->_impl_.rows_ = new ::greptime::v1::Rows(*from._impl_.rows_);
  }
  _this->_impl_.region_id_ = from._impl_.region_id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequest)
}

inline void InsertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequest::~InsertRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rows_;
}

void InsertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
  _impl_.region_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.Rows rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_region_id(), target);
  }

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rows(this),
        _Internal::rows(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequest)
  return target;
}

size_t InsertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rows_);
  }

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_region_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequest::GetClassData() const { return &_class_data_; }


void InsertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequest*>(&to_msg);
  auto& from = static_cast<const InsertRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rows()) {
    _this->_internal_mutable_rows()->::greptime::v1::Rows::MergeFrom(
        from._internal_rows());
  }
  if (from._internal_region_id() != 0) {
    _this->_internal_set_region_id(from._internal_region_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequest::CopyFrom(const InsertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequest::IsInitialized() const {
  return true;
}

void InsertRequest::InternalSwap(InsertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.region_id_)
      + sizeof(InsertRequest::_impl_.region_id_)
      - PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.rows_)>(
          reinterpret_cast<char*>(&_impl_.rows_),
          reinterpret_cast<char*>(&other->_impl_.rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[1]);
}

// ===================================================================

class FlowRequest::_Internal {
 public:
  static const ::greptime::v1::flow::FlowCreateRequest& create(const FlowRequest* msg);
  static const ::greptime::v1::flow::FlowRemoveRequest& remove(const FlowRequest* msg);
};

const ::greptime::v1::flow::FlowCreateRequest&
FlowRequest::_Internal::create(const FlowRequest* msg) {
  return *msg->_impl_.body_.create_;
}
const ::greptime::v1::flow::FlowRemoveRequest&
FlowRequest::_Internal::remove(const FlowRequest* msg) {
  return *msg->_impl_.body_.remove_;
}
void FlowRequest::set_allocated_create(::greptime::v1::flow::FlowCreateRequest* create) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (create) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create);
    if (message_arena != submessage_arena) {
      create = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.create)
}
void FlowRequest::set_allocated_remove(::greptime::v1::flow::FlowRemoveRequest* remove) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (remove) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remove);
    if (message_arena != submessage_arena) {
      remove = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remove, submessage_arena);
    }
    set_has_remove();
    _impl_.body_.remove_ = remove;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.remove)
}
FlowRequest::FlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRequest)
}
FlowRequest::FlowRequest(const FlowRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_body();
  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::FlowCreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kRemove: {
      _this->_internal_mutable_remove()->::greptime::v1::flow::FlowRemoveRequest::MergeFrom(
          from._internal_remove());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRequest)
}

inline void FlowRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_body();
}

FlowRequest::~FlowRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_body()) {
    clear_body();
  }
}

void FlowRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRequest::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:greptime.v1.flow.FlowRequest)
  switch (body_case()) {
    case kCreate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.create_;
      }
      break;
    }
    case kRemove: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.remove_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}


void FlowRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.FlowCreateRequest create = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.FlowRemoveRequest remove = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_remove(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.FlowCreateRequest create = 1;
  if (_internal_has_create()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::create(this),
        _Internal::create(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.FlowRemoveRequest remove = 2;
  if (_internal_has_remove()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::remove(this),
        _Internal::remove(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRequest)
  return target;
}

size_t FlowRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (body_case()) {
    // .greptime.v1.flow.FlowCreateRequest create = 1;
    case kCreate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.create_);
      break;
    }
    // .greptime.v1.flow.FlowRemoveRequest remove = 2;
    case kRemove: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.remove_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRequest::GetClassData() const { return &_class_data_; }


void FlowRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRequest*>(&to_msg);
  auto& from = static_cast<const FlowRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::FlowCreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kRemove: {
      _this->_internal_mutable_remove()->::greptime::v1::flow::FlowRemoveRequest::MergeFrom(
          from._internal_remove());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRequest::CopyFrom(const FlowRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRequest::IsInitialized() const {
  return true;
}

void FlowRequest::InternalSwap(FlowRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.body_, other->_impl_.body_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[2]);
}

// ===================================================================

FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse() {}
FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowResponse_ExtensionEntry_DoNotUse::MergeFrom(const FlowResponse_ExtensionEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse_ExtensionEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[3]);
}

// ===================================================================

class FlowResponse::_Internal {
 public:
  static const ::greptime::v1::ResponseHeader& header(const FlowResponse* msg);
};

const ::greptime::v1::ResponseHeader&
FlowResponse::_Internal::header(const FlowResponse* msg) {
  return *msg->_impl_.header_;
}
void FlowResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
FlowResponse::FlowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowResponse)
}
FlowResponse::FlowResponse(const FlowResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.extension_)*/{}
    , decltype(_impl_.affected_tasks_){from._impl_.affected_tasks_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.extension_.MergeFrom(from._impl_.extension_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.affected_rows_ = from._impl_.affected_rows_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowResponse)
}

inline void FlowResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.extension_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.affected_tasks_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowResponse::~FlowResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extension_.Destruct();
  _impl_.extension_.~MapField();
  _impl_.affected_tasks_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void FlowResponse::ArenaDtor(void* object) {
  FlowResponse* _this = reinterpret_cast< FlowResponse* >(object);
  _this->_impl_.extension_.Destruct();
}
void FlowResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  _impl_.affected_tasks_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.affected_rows_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 affected_rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.affected_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> extension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.extension_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_affected_tasks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_affected_rows(), target);
  }

  // map<string, bytes> extension = 3;
  if (!this->_internal_extension().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowResponse_ExtensionEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_extension();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowResponse.ExtensionEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_affected_tasks_size()); i < n; i++) {
    const auto& repfield = this->_internal_affected_tasks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowResponse)
  return target;
}

size_t FlowResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> extension = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_extension_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_extension().begin();
      it != this->_internal_extension().end(); ++it) {
    total_size += FlowResponse_ExtensionEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
  total_size += 1UL * this->_internal_affected_tasks_size();
  for (const auto& msg : this->_impl_.affected_tasks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_affected_rows());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowResponse::GetClassData() const { return &_class_data_; }


void FlowResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowResponse*>(&to_msg);
  auto& from = static_cast<const FlowResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extension_.MergeFrom(from._impl_.extension_);
  _this->_impl_.affected_tasks_.MergeFrom(from._impl_.affected_tasks_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_affected_rows() != 0) {
    _this->_internal_set_affected_rows(from._internal_affected_rows());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowResponse::CopyFrom(const FlowResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowResponse::IsInitialized() const {
  return true;
}

void FlowResponse::InternalSwap(FlowResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  _impl_.affected_tasks_.InternalSwap(&other->_impl_.affected_tasks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.affected_rows_)
      + sizeof(FlowResponse::_impl_.affected_rows_)
      - PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[4]);
}

// ===================================================================

FlowCreateRequest_TaskOptionsEntry_DoNotUse::FlowCreateRequest_TaskOptionsEntry_DoNotUse() {}
FlowCreateRequest_TaskOptionsEntry_DoNotUse::FlowCreateRequest_TaskOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowCreateRequest_TaskOptionsEntry_DoNotUse::MergeFrom(const FlowCreateRequest_TaskOptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowCreateRequest_TaskOptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[5]);
}

// ===================================================================

class FlowCreateRequest::_Internal {
 public:
  static const ::greptime::v1::flow::TaskId& task_id(const FlowCreateRequest* msg);
  static const ::greptime::v1::TableId& output_table_id(const FlowCreateRequest* msg);
};

const ::greptime::v1::flow::TaskId&
FlowCreateRequest::_Internal::task_id(const FlowCreateRequest* msg) {
  return *msg->_impl_.task_id_;
}
const ::greptime::v1::TableId&
FlowCreateRequest::_Internal::output_table_id(const FlowCreateRequest* msg) {
  return *msg->_impl_.output_table_id_;
}
void FlowCreateRequest::clear_source_table_ids() {
  _impl_.source_table_ids_.Clear();
}
void FlowCreateRequest::clear_output_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_table_id_ != nullptr) {
    delete _impl_.output_table_id_;
  }
  _impl_.output_table_id_ = nullptr;
}
FlowCreateRequest::FlowCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowCreateRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowCreateRequest)
}
FlowCreateRequest::FlowCreateRequest(const FlowCreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowCreateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){from._impl_.source_table_ids_}
    , /*decltype(_impl_.task_options_)*/{}
    , decltype(_impl_.expire_when_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.task_id_){nullptr}
    , decltype(_impl_.output_table_id_){nullptr}
    , decltype(_impl_.create_if_not_exists_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.task_options_.MergeFrom(from._impl_.task_options_);
  _impl_.expire_when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expire_when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expire_when().empty()) {
    _this->_impl_.expire_when_.Set(from._internal_expire_when(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sql().empty()) {
    _this->_impl_.sql_.Set(from._internal_sql(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_task_id()) {
    _this->_impl_.task_id_ = new ::greptime::v1::flow::TaskId(*from._impl_.task_id_);
  }
  if (from._internal_has_output_table_id()) {
    _this->_impl_.output_table_id_ = new ::greptime::v1::TableId(*from._impl_.output_table_id_);
  }
  _this->_impl_.create_if_not_exists_ = from._impl_.create_if_not_exists_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowCreateRequest)
}

inline void FlowCreateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){arena}
    , /*decltype(_impl_.task_options_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.expire_when_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.task_id_){nullptr}
    , decltype(_impl_.output_table_id_){nullptr}
    , decltype(_impl_.create_if_not_exists_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.expire_when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expire_when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FlowCreateRequest::~FlowCreateRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowCreateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowCreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_table_ids_.~RepeatedPtrField();
  _impl_.task_options_.Destruct();
  _impl_.task_options_.~MapField();
  _impl_.expire_when_.Destroy();
  _impl_.comment_.Destroy();
  _impl_.sql_.Destroy();
  if (this != internal_default_instance()) delete _impl_.task_id_;
  if (this != internal_default_instance()) delete _impl_.output_table_id_;
}

void FlowCreateRequest::ArenaDtor(void* object) {
  FlowCreateRequest* _this = reinterpret_cast< FlowCreateRequest* >(object);
  _this->_impl_.task_options_.Destruct();
}
void FlowCreateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowCreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowCreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_table_ids_.Clear();
  _impl_.task_options_.Clear();
  _impl_.expire_when_.ClearToEmpty();
  _impl_.comment_.ClearToEmpty();
  _impl_.sql_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.task_id_ != nullptr) {
    delete _impl_.task_id_;
  }
  _impl_.task_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.output_table_id_ != nullptr) {
    delete _impl_.output_table_id_;
  }
  _impl_.output_table_id_ = nullptr;
  _impl_.create_if_not_exists_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowCreateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.TaskId task_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_task_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.TableId source_table_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source_table_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.TableId output_table_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_output_table_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool create_if_not_exists = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.create_if_not_exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string expire_when = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_expire_when();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.FlowCreateRequest.expire_when"));
        } else
          goto handle_unusual;
        continue;
      // string comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.FlowCreateRequest.comment"));
        } else
          goto handle_unusual;
        continue;
      // string sql = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sql();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.FlowCreateRequest.sql"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> task_options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.task_options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowCreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowCreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.TaskId task_id = 1;
  if (this->_internal_has_task_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::task_id(this),
        _Internal::task_id(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.TableId source_table_ids = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_source_table_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_source_table_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .greptime.v1.TableId output_table_id = 3;
  if (this->_internal_has_output_table_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::output_table_id(this),
        _Internal::output_table_id(this).GetCachedSize(), target, stream);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_create_if_not_exists(), target);
  }

  // string expire_when = 5;
  if (!this->_internal_expire_when().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_expire_when().data(), static_cast<int>(this->_internal_expire_when().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.FlowCreateRequest.expire_when");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_expire_when(), target);
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.FlowCreateRequest.comment");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_comment(), target);
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sql().data(), static_cast<int>(this->_internal_sql().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.FlowCreateRequest.sql");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sql(), target);
  }

  // map<string, string> task_options = 8;
  if (!this->_internal_task_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowCreateRequest_TaskOptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_task_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowCreateRequest.TaskOptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowCreateRequest.TaskOptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowCreateRequest)
  return target;
}

size_t FlowCreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowCreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.TableId source_table_ids = 2;
  total_size += 1UL * this->_internal_source_table_ids_size();
  for (const auto& msg : this->_impl_.source_table_ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> task_options = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_task_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_task_options().begin();
      it != this->_internal_task_options().end(); ++it) {
    total_size += FlowCreateRequest_TaskOptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string expire_when = 5;
  if (!this->_internal_expire_when().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_expire_when());
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sql());
  }

  // .greptime.v1.flow.TaskId task_id = 1;
  if (this->_internal_has_task_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.task_id_);
  }

  // .greptime.v1.TableId output_table_id = 3;
  if (this->_internal_has_output_table_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.output_table_id_);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowCreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowCreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowCreateRequest::GetClassData() const { return &_class_data_; }


void FlowCreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowCreateRequest*>(&to_msg);
  auto& from = static_cast<const FlowCreateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowCreateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.source_table_ids_.MergeFrom(from._impl_.source_table_ids_);
  _this->_impl_.task_options_.MergeFrom(from._impl_.task_options_);
  if (!from._internal_expire_when().empty()) {
    _this->_internal_set_expire_when(from._internal_expire_when());
  }
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  if (!from._internal_sql().empty()) {
    _this->_internal_set_sql(from._internal_sql());
  }
  if (from._internal_has_task_id()) {
    _this->_internal_mutable_task_id()->::greptime::v1::flow::TaskId::MergeFrom(
        from._internal_task_id());
  }
  if (from._internal_has_output_table_id()) {
    _this->_internal_mutable_output_table_id()->::greptime::v1::TableId::MergeFrom(
        from._internal_output_table_id());
  }
  if (from._internal_create_if_not_exists() != 0) {
    _this->_internal_set_create_if_not_exists(from._internal_create_if_not_exists());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowCreateRequest::CopyFrom(const FlowCreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowCreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowCreateRequest::IsInitialized() const {
  return true;
}

void FlowCreateRequest::InternalSwap(FlowCreateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.source_table_ids_.InternalSwap(&other->_impl_.source_table_ids_);
  _impl_.task_options_.InternalSwap(&other->_impl_.task_options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.expire_when_, lhs_arena,
      &other->_impl_.expire_when_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sql_, lhs_arena,
      &other->_impl_.sql_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowCreateRequest, _impl_.create_if_not_exists_)
      + sizeof(FlowCreateRequest::_impl_.create_if_not_exists_)
      - PROTOBUF_FIELD_OFFSET(FlowCreateRequest, _impl_.task_id_)>(
          reinterpret_cast<char*>(&_impl_.task_id_),
          reinterpret_cast<char*>(&other->_impl_.task_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowCreateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[6]);
}

// ===================================================================

class FlowRemoveRequest::_Internal {
 public:
  static const ::greptime::v1::flow::TaskId& task_id(const FlowRemoveRequest* msg);
};

const ::greptime::v1::flow::TaskId&
FlowRemoveRequest::_Internal::task_id(const FlowRemoveRequest* msg) {
  return *msg->_impl_.task_id_;
}
FlowRemoveRequest::FlowRemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRemoveRequest)
}
FlowRemoveRequest::FlowRemoveRequest(const FlowRemoveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRemoveRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.task_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_task_id()) {
    _this->_impl_.task_id_ = new ::greptime::v1::flow::TaskId(*from._impl_.task_id_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRemoveRequest)
}

inline void FlowRemoveRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.task_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowRemoveRequest::~FlowRemoveRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRemoveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowRemoveRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.task_id_;
}

void FlowRemoveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRemoveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRemoveRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.task_id_ != nullptr) {
    delete _impl_.task_id_;
  }
  _impl_.task_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRemoveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.TaskId task_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_task_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRemoveRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRemoveRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.TaskId task_id = 1;
  if (this->_internal_has_task_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::task_id(this),
        _Internal::task_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRemoveRequest)
  return target;
}

size_t FlowRemoveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRemoveRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.flow.TaskId task_id = 1;
  if (this->_internal_has_task_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.task_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRemoveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRemoveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRemoveRequest::GetClassData() const { return &_class_data_; }


void FlowRemoveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRemoveRequest*>(&to_msg);
  auto& from = static_cast<const FlowRemoveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRemoveRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_task_id()) {
    _this->_internal_mutable_task_id()->::greptime::v1::flow::TaskId::MergeFrom(
        from._internal_task_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRemoveRequest::CopyFrom(const FlowRemoveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRemoveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRemoveRequest::IsInitialized() const {
  return true;
}

void FlowRemoveRequest::InternalSwap(FlowRemoveRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.task_id_, other->_impl_.task_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRemoveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[7]);
}

// ===================================================================

class TaskId::_Internal {
 public:
};

TaskId::TaskId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.TaskId)
}
TaskId::TaskId(const TaskId& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TaskId* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.TaskId)
}

inline void TaskId::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TaskId::~TaskId() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.TaskId)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TaskId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TaskId::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TaskId::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.TaskId)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TaskId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TaskId::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.TaskId)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.TaskId)
  return target;
}

size_t TaskId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.TaskId)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TaskId::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TaskId::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TaskId::GetClassData() const { return &_class_data_; }


void TaskId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TaskId*>(&to_msg);
  auto& from = static_cast<const TaskId&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.TaskId)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TaskId::CopyFrom(const TaskId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.TaskId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskId::IsInitialized() const {
  return true;
}

void TaskId::InternalSwap(TaskId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TaskId::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace flow
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequests*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowCreateRequest_TaskOptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowCreateRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowCreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowCreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRemoveRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRemoveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRemoveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::TaskId*
Arena::CreateMaybeMessage< ::greptime::v1::flow::TaskId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::TaskId >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
