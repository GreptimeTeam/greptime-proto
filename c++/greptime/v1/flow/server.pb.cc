// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/flow/server.proto

#include "greptime/v1/flow/server.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace greptime {
namespace v1 {
namespace flow {
PROTOBUF_CONSTEXPR DirtyWindowRequests::DirtyWindowRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DirtyWindowRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DirtyWindowRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DirtyWindowRequestsDefaultTypeInternal() {}
  union {
    DirtyWindowRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirtyWindowRequestsDefaultTypeInternal _DirtyWindowRequests_default_instance_;
PROTOBUF_CONSTEXPR DirtyWindowRequest::DirtyWindowRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dirty_time_ranges_)*/{}
  , /*decltype(_impl_.table_id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DirtyWindowRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DirtyWindowRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DirtyWindowRequestDefaultTypeInternal() {}
  union {
    DirtyWindowRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirtyWindowRequestDefaultTypeInternal _DirtyWindowRequest_default_instance_;
PROTOBUF_CONSTEXPR WindowRange::WindowRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_value_)*/int64_t{0}
  , /*decltype(_impl_.end_value_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WindowRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WindowRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WindowRangeDefaultTypeInternal() {}
  union {
    WindowRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WindowRangeDefaultTypeInternal _WindowRange_default_instance_;
PROTOBUF_CONSTEXPR FlowRequestHeader_TracingContextEntry_DoNotUse::FlowRequestHeader_TracingContextEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowRequestHeader_TracingContextEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _FlowRequestHeader_TracingContextEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowRequestHeader::FlowRequestHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tracing_context_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.query_context_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowRequestHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestHeaderDefaultTypeInternal() {}
  union {
    FlowRequestHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestHeaderDefaultTypeInternal _FlowRequestHeader_default_instance_;
PROTOBUF_CONSTEXPR InsertRequests::InsertRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestsDefaultTypeInternal() {}
  union {
    InsertRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
PROTOBUF_CONSTEXPR InsertRequest::InsertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rows_)*/nullptr
  , /*decltype(_impl_.region_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestDefaultTypeInternal() {}
  union {
    InsertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowRequest::FlowRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.body_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FlowRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestDefaultTypeInternal() {}
  union {
    FlowRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestDefaultTypeInternal _FlowRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse_ExtensionsEntry_DoNotUse::FlowResponse_ExtensionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowResponse_ExtensionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponse_ExtensionsEntry_DoNotUseDefaultTypeInternal _FlowResponse_ExtensionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse::FlowResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.affected_flows_)*/{}
  , /*decltype(_impl_.extensions_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.affected_rows_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponseDefaultTypeInternal() {}
  union {
    FlowResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponseDefaultTypeInternal _FlowResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest_FlowOptionsEntry_DoNotUse::CreateRequest_FlowOptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CreateRequest_FlowOptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal _CreateRequest_FlowOptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest::CreateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_table_ids_)*/{}
  , /*decltype(_impl_.flow_options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sql_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_.sink_table_name_)*/nullptr
  , /*decltype(_impl_.expire_after_)*/nullptr
  , /*decltype(_impl_.create_if_not_exists_)*/false
  , /*decltype(_impl_.or_replace_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequestDefaultTypeInternal() {}
  union {
    CreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
PROTOBUF_CONSTEXPR DropRequest::DropRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DropRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DropRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DropRequestDefaultTypeInternal() {}
  union {
    DropRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DropRequestDefaultTypeInternal _DropRequest_default_instance_;
PROTOBUF_CONSTEXPR FlushFlow::FlushFlow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlushFlowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushFlowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushFlowDefaultTypeInternal() {}
  union {
    FlushFlow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushFlowDefaultTypeInternal _FlushFlow_default_instance_;
}  // namespace flow
}  // namespace v1
}  // namespace greptime
static ::_pb::Metadata file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[14];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;

const uint32_t TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DirtyWindowRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DirtyWindowRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DirtyWindowRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DirtyWindowRequest, _impl_.table_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DirtyWindowRequest, _impl_.dirty_time_ranges_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::WindowRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::WindowRange, _impl_.start_value_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::WindowRange, _impl_.end_value_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader, _impl_.tracing_context_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader, _impl_.query_context_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.region_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.rows_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_.header_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_rows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_flows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.extensions_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.flow_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.source_table_ids_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.sink_table_name_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.create_if_not_exists_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.expire_after_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.sql_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.flow_options_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.or_replace_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DropRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DropRequest, _impl_.flow_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlushFlow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlushFlow, _impl_.flow_id_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::greptime::v1::flow::DirtyWindowRequests)},
  { 7, -1, -1, sizeof(::greptime::v1::flow::DirtyWindowRequest)},
  { 15, -1, -1, sizeof(::greptime::v1::flow::WindowRange)},
  { 23, 31, -1, sizeof(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse)},
  { 33, -1, -1, sizeof(::greptime::v1::flow::FlowRequestHeader)},
  { 41, -1, -1, sizeof(::greptime::v1::flow::InsertRequests)},
  { 48, -1, -1, sizeof(::greptime::v1::flow::InsertRequest)},
  { 56, -1, -1, sizeof(::greptime::v1::flow::FlowRequest)},
  { 67, 75, -1, sizeof(::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse)},
  { 77, -1, -1, sizeof(::greptime::v1::flow::FlowResponse)},
  { 87, 95, -1, sizeof(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse)},
  { 97, -1, -1, sizeof(::greptime::v1::flow::CreateRequest)},
  { 112, -1, -1, sizeof(::greptime::v1::flow::DropRequest)},
  { 119, -1, -1, sizeof(::greptime::v1::flow::FlushFlow)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::greptime::v1::flow::_DirtyWindowRequests_default_instance_._instance,
  &::greptime::v1::flow::_DirtyWindowRequest_default_instance_._instance,
  &::greptime::v1::flow::_WindowRange_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequestHeader_TracingContextEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequestHeader_default_instance_._instance,
  &::greptime::v1::flow::_InsertRequests_default_instance_._instance,
  &::greptime::v1::flow::_InsertRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_ExtensionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_default_instance_._instance,
  &::greptime::v1::flow::_CreateRequest_FlowOptionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_CreateRequest_default_instance_._instance,
  &::greptime::v1::flow::_DropRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlushFlow_default_instance_._instance,
};

const char descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035greptime/v1/flow/server.proto\022\020greptim"
  "e.v1.flow\032\030greptime/v1/common.proto\032\025gre"
  "ptime/v1/ddl.proto\032\025greptime/v1/row.prot"
  "o\"M\n\023DirtyWindowRequests\0226\n\010requests\030\001 \003"
  "(\0132$.greptime.v1.flow.DirtyWindowRequest"
  "\"`\n\022DirtyWindowRequest\022\020\n\010table_id\030\001 \001(\r"
  "\0228\n\021dirty_time_ranges\030\002 \003(\0132\035.greptime.v"
  "1.flow.WindowRange\"5\n\013WindowRange\022\023\n\013sta"
  "rt_value\030\001 \001(\003\022\021\n\tend_value\030\002 \001(\003\"\316\001\n\021Fl"
  "owRequestHeader\022P\n\017tracing_context\030\001 \003(\013"
  "27.greptime.v1.flow.FlowRequestHeader.Tr"
  "acingContextEntry\0220\n\rquery_context\030\002 \001(\013"
  "2\031.greptime.v1.QueryContext\0325\n\023TracingCo"
  "ntextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\002"
  "8\001\"C\n\016InsertRequests\0221\n\010requests\030\001 \003(\0132\037"
  ".greptime.v1.flow.InsertRequest\"C\n\rInser"
  "tRequest\022\021\n\tregion_id\030\001 \001(\004\022\037\n\004rows\030\002 \001("
  "\0132\021.greptime.v1.Rows\"\332\001\n\013FlowRequest\0223\n\006"
  "header\030@ \001(\0132#.greptime.v1.flow.FlowRequ"
  "estHeader\0221\n\006create\030\001 \001(\0132\037.greptime.v1."
  "flow.CreateRequestH\000\022-\n\004drop\030\002 \001(\0132\035.gre"
  "ptime.v1.flow.DropRequestH\000\022,\n\005flush\030\003 \001"
  "(\0132\033.greptime.v1.flow.FlushFlowH\000B\006\n\004bod"
  "y\"\366\001\n\014FlowResponse\022+\n\006header\030\001 \001(\0132\033.gre"
  "ptime.v1.ResponseHeader\022\025\n\raffected_rows"
  "\030\002 \001(\004\022+\n\016affected_flows\030\003 \003(\0132\023.greptim"
  "e.v1.FlowId\022B\n\nextensions\030\004 \003(\0132..grepti"
  "me.v1.flow.FlowResponse.ExtensionsEntry\032"
  "1\n\017ExtensionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value"
  "\030\002 \001(\014:\0028\001\"\222\003\n\rCreateRequest\022$\n\007flow_id\030"
  "\001 \001(\0132\023.greptime.v1.FlowId\022.\n\020source_tab"
  "le_ids\030\002 \003(\0132\024.greptime.v1.TableId\022/\n\017si"
  "nk_table_name\030\003 \001(\0132\026.greptime.v1.TableN"
  "ame\022\034\n\024create_if_not_exists\030\004 \001(\010\022.\n\014exp"
  "ire_after\030\005 \001(\0132\030.greptime.v1.ExpireAfte"
  "r\022\017\n\007comment\030\006 \001(\t\022\013\n\003sql\030\007 \001(\t\022F\n\014flow_"
  "options\030\010 \003(\01320.greptime.v1.flow.CreateR"
  "equest.FlowOptionsEntry\022\022\n\nor_replace\030\t "
  "\001(\010\0322\n\020FlowOptionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005"
  "value\030\002 \001(\t:\0028\001\"3\n\013DropRequest\022$\n\007flow_i"
  "d\030\001 \001(\0132\023.greptime.v1.FlowId\"1\n\tFlushFlo"
  "w\022$\n\007flow_id\030\001 \001(\0132\023.greptime.v1.FlowId2"
  "\230\002\n\004Flow\022S\n\022HandleCreateRemove\022\035.greptim"
  "e.v1.flow.FlowRequest\032\036.greptime.v1.flow"
  ".FlowResponse\022W\n\023HandleMirrorRequest\022 .g"
  "reptime.v1.flow.InsertRequests\032\036.greptim"
  "e.v1.flow.FlowResponse\022b\n\031HandleMarkDirt"
  "yTimeWindow\022%.greptime.v1.flow.DirtyWind"
  "owRequests\032\036.greptime.v1.flow.FlowRespon"
  "seBY\n\023io.greptime.v1.flowB\006ServerZ:githu"
  "b.com/GreptimeTeam/greptime-proto/go/gre"
  "ptime/v1/flowb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps[3] = {
  &::descriptor_table_greptime_2fv1_2fcommon_2eproto,
  &::descriptor_table_greptime_2fv1_2fddl_2eproto,
  &::descriptor_table_greptime_2fv1_2frow_2eproto,
};
static ::_pbi::once_flag descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto = {
    false, false, 2061, descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto,
    "greptime/v1/flow/server.proto",
    &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once, descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps, 3, 14,
    schemas, file_default_instances, TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets,
    file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto, file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
    file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter() {
  return &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_greptime_2fv1_2fflow_2fserver_2eproto(&descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto);
namespace greptime {
namespace v1 {
namespace flow {

// ===================================================================

class DirtyWindowRequests::_Internal {
 public:
};

DirtyWindowRequests::DirtyWindowRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.DirtyWindowRequests)
}
DirtyWindowRequests::DirtyWindowRequests(const DirtyWindowRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DirtyWindowRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){from._impl_.requests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.DirtyWindowRequests)
}

inline void DirtyWindowRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DirtyWindowRequests::~DirtyWindowRequests() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.DirtyWindowRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DirtyWindowRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void DirtyWindowRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DirtyWindowRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.DirtyWindowRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DirtyWindowRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .greptime.v1.flow.DirtyWindowRequest requests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DirtyWindowRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.DirtyWindowRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.DirtyWindowRequest requests = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.DirtyWindowRequests)
  return target;
}

size_t DirtyWindowRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.DirtyWindowRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.DirtyWindowRequest requests = 1;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DirtyWindowRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DirtyWindowRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DirtyWindowRequests::GetClassData() const { return &_class_data_; }


void DirtyWindowRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DirtyWindowRequests*>(&to_msg);
  auto& from = static_cast<const DirtyWindowRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.DirtyWindowRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DirtyWindowRequests::CopyFrom(const DirtyWindowRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.DirtyWindowRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirtyWindowRequests::IsInitialized() const {
  return true;
}

void DirtyWindowRequests::InternalSwap(DirtyWindowRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DirtyWindowRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[0]);
}

// ===================================================================

class DirtyWindowRequest::_Internal {
 public:
};

DirtyWindowRequest::DirtyWindowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.DirtyWindowRequest)
}
DirtyWindowRequest::DirtyWindowRequest(const DirtyWindowRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DirtyWindowRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dirty_time_ranges_){from._impl_.dirty_time_ranges_}
    , decltype(_impl_.table_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.table_id_ = from._impl_.table_id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.DirtyWindowRequest)
}

inline void DirtyWindowRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dirty_time_ranges_){arena}
    , decltype(_impl_.table_id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DirtyWindowRequest::~DirtyWindowRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.DirtyWindowRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DirtyWindowRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dirty_time_ranges_.~RepeatedPtrField();
}

void DirtyWindowRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DirtyWindowRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.DirtyWindowRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dirty_time_ranges_.Clear();
  _impl_.table_id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DirtyWindowRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.flow.WindowRange dirty_time_ranges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_dirty_time_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DirtyWindowRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.DirtyWindowRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 table_id = 1;
  if (this->_internal_table_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_table_id(), target);
  }

  // repeated .greptime.v1.flow.WindowRange dirty_time_ranges = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dirty_time_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_dirty_time_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.DirtyWindowRequest)
  return target;
}

size_t DirtyWindowRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.DirtyWindowRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.WindowRange dirty_time_ranges = 2;
  total_size += 1UL * this->_internal_dirty_time_ranges_size();
  for (const auto& msg : this->_impl_.dirty_time_ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 table_id = 1;
  if (this->_internal_table_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_table_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DirtyWindowRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DirtyWindowRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DirtyWindowRequest::GetClassData() const { return &_class_data_; }


void DirtyWindowRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DirtyWindowRequest*>(&to_msg);
  auto& from = static_cast<const DirtyWindowRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.DirtyWindowRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dirty_time_ranges_.MergeFrom(from._impl_.dirty_time_ranges_);
  if (from._internal_table_id() != 0) {
    _this->_internal_set_table_id(from._internal_table_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DirtyWindowRequest::CopyFrom(const DirtyWindowRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.DirtyWindowRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirtyWindowRequest::IsInitialized() const {
  return true;
}

void DirtyWindowRequest::InternalSwap(DirtyWindowRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.dirty_time_ranges_.InternalSwap(&other->_impl_.dirty_time_ranges_);
  swap(_impl_.table_id_, other->_impl_.table_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DirtyWindowRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[1]);
}

// ===================================================================

class WindowRange::_Internal {
 public:
};

WindowRange::WindowRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.WindowRange)
}
WindowRange::WindowRange(const WindowRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WindowRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_value_){}
    , decltype(_impl_.end_value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_value_, &from._impl_.start_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_value_) -
    reinterpret_cast<char*>(&_impl_.start_value_)) + sizeof(_impl_.end_value_));
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.WindowRange)
}

inline void WindowRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_value_){int64_t{0}}
    , decltype(_impl_.end_value_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WindowRange::~WindowRange() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.WindowRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WindowRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WindowRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WindowRange::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.WindowRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.start_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.end_value_) -
      reinterpret_cast<char*>(&_impl_.start_value_)) + sizeof(_impl_.end_value_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WindowRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 start_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.start_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 end_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.end_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WindowRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.WindowRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 start_value = 1;
  if (this->_internal_start_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_value(), target);
  }

  // int64 end_value = 2;
  if (this->_internal_end_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_end_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.WindowRange)
  return target;
}

size_t WindowRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.WindowRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 start_value = 1;
  if (this->_internal_start_value() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_value());
  }

  // int64 end_value = 2;
  if (this->_internal_end_value() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WindowRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WindowRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WindowRange::GetClassData() const { return &_class_data_; }


void WindowRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WindowRange*>(&to_msg);
  auto& from = static_cast<const WindowRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.WindowRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_start_value() != 0) {
    _this->_internal_set_start_value(from._internal_start_value());
  }
  if (from._internal_end_value() != 0) {
    _this->_internal_set_end_value(from._internal_end_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WindowRange::CopyFrom(const WindowRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.WindowRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowRange::IsInitialized() const {
  return true;
}

void WindowRange::InternalSwap(WindowRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WindowRange, _impl_.end_value_)
      + sizeof(WindowRange::_impl_.end_value_)
      - PROTOBUF_FIELD_OFFSET(WindowRange, _impl_.start_value_)>(
          reinterpret_cast<char*>(&_impl_.start_value_),
          reinterpret_cast<char*>(&other->_impl_.start_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WindowRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[2]);
}

// ===================================================================

FlowRequestHeader_TracingContextEntry_DoNotUse::FlowRequestHeader_TracingContextEntry_DoNotUse() {}
FlowRequestHeader_TracingContextEntry_DoNotUse::FlowRequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowRequestHeader_TracingContextEntry_DoNotUse::MergeFrom(const FlowRequestHeader_TracingContextEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowRequestHeader_TracingContextEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[3]);
}

// ===================================================================

class FlowRequestHeader::_Internal {
 public:
  static const ::greptime::v1::QueryContext& query_context(const FlowRequestHeader* msg);
};

const ::greptime::v1::QueryContext&
FlowRequestHeader::_Internal::query_context(const FlowRequestHeader* msg) {
  return *msg->_impl_.query_context_;
}
void FlowRequestHeader::clear_query_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_context_ != nullptr) {
    delete _impl_.query_context_;
  }
  _impl_.query_context_ = nullptr;
}
FlowRequestHeader::FlowRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowRequestHeader::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRequestHeader)
}
FlowRequestHeader::FlowRequestHeader(const FlowRequestHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRequestHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.tracing_context_)*/{}
    , decltype(_impl_.query_context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.tracing_context_.MergeFrom(from._impl_.tracing_context_);
  if (from._internal_has_query_context()) {
    _this->_impl_.query_context_ = new ::greptime::v1::QueryContext(*from._impl_.query_context_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRequestHeader)
}

inline void FlowRequestHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.tracing_context_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.query_context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowRequestHeader::~FlowRequestHeader() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRequestHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowRequestHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tracing_context_.Destruct();
  _impl_.tracing_context_.~MapField();
  if (this != internal_default_instance()) delete _impl_.query_context_;
}

void FlowRequestHeader::ArenaDtor(void* object) {
  FlowRequestHeader* _this = reinterpret_cast< FlowRequestHeader* >(object);
  _this->_impl_.tracing_context_.Destruct();
}
void FlowRequestHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRequestHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRequestHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tracing_context_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.query_context_ != nullptr) {
    delete _impl_.query_context_;
  }
  _impl_.query_context_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRequestHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> tracing_context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.tracing_context_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.QueryContext query_context = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_query_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRequestHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRequestHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> tracing_context = 1;
  if (!this->_internal_tracing_context().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowRequestHeader_TracingContextEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_tracing_context();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowRequestHeader.TracingContextEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowRequestHeader.TracingContextEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .greptime.v1.QueryContext query_context = 2;
  if (this->_internal_has_query_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::query_context(this),
        _Internal::query_context(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRequestHeader)
  return target;
}

size_t FlowRequestHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRequestHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> tracing_context = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_tracing_context_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_tracing_context().begin();
      it != this->_internal_tracing_context().end(); ++it) {
    total_size += FlowRequestHeader_TracingContextEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .greptime.v1.QueryContext query_context = 2;
  if (this->_internal_has_query_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.query_context_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRequestHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRequestHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRequestHeader::GetClassData() const { return &_class_data_; }


void FlowRequestHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRequestHeader*>(&to_msg);
  auto& from = static_cast<const FlowRequestHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRequestHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tracing_context_.MergeFrom(from._impl_.tracing_context_);
  if (from._internal_has_query_context()) {
    _this->_internal_mutable_query_context()->::greptime::v1::QueryContext::MergeFrom(
        from._internal_query_context());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRequestHeader::CopyFrom(const FlowRequestHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRequestHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRequestHeader::IsInitialized() const {
  return true;
}

void FlowRequestHeader::InternalSwap(FlowRequestHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tracing_context_.InternalSwap(&other->_impl_.tracing_context_);
  swap(_impl_.query_context_, other->_impl_.query_context_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRequestHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[4]);
}

// ===================================================================

class InsertRequests::_Internal {
 public:
};

InsertRequests::InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequests)
}
InsertRequests::InsertRequests(const InsertRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){from._impl_.requests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequests)
}

inline void InsertRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequests::~InsertRequests() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void InsertRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .greptime.v1.flow.InsertRequest requests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequests)
  return target;
}

size_t InsertRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequests::GetClassData() const { return &_class_data_; }


void InsertRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequests*>(&to_msg);
  auto& from = static_cast<const InsertRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequests::CopyFrom(const InsertRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequests::IsInitialized() const {
  return true;
}

void InsertRequests::InternalSwap(InsertRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[5]);
}

// ===================================================================

class InsertRequest::_Internal {
 public:
  static const ::greptime::v1::Rows& rows(const InsertRequest* msg);
};

const ::greptime::v1::Rows&
InsertRequest::_Internal::rows(const InsertRequest* msg) {
  return *msg->_impl_.rows_;
}
void InsertRequest::clear_rows() {
  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
}
InsertRequest::InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequest)
}
InsertRequest::InsertRequest(const InsertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rows()) {
    _this->_impl_.rows_ = new ::greptime::v1::Rows(*from._impl_.rows_);
  }
  _this->_impl_.region_id_ = from._impl_.region_id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequest)
}

inline void InsertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequest::~InsertRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rows_;
}

void InsertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
  _impl_.region_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.Rows rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_region_id(), target);
  }

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rows(this),
        _Internal::rows(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequest)
  return target;
}

size_t InsertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rows_);
  }

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_region_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequest::GetClassData() const { return &_class_data_; }


void InsertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequest*>(&to_msg);
  auto& from = static_cast<const InsertRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rows()) {
    _this->_internal_mutable_rows()->::greptime::v1::Rows::MergeFrom(
        from._internal_rows());
  }
  if (from._internal_region_id() != 0) {
    _this->_internal_set_region_id(from._internal_region_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequest::CopyFrom(const InsertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequest::IsInitialized() const {
  return true;
}

void InsertRequest::InternalSwap(InsertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.region_id_)
      + sizeof(InsertRequest::_impl_.region_id_)
      - PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.rows_)>(
          reinterpret_cast<char*>(&_impl_.rows_),
          reinterpret_cast<char*>(&other->_impl_.rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[6]);
}

// ===================================================================

class FlowRequest::_Internal {
 public:
  static const ::greptime::v1::flow::FlowRequestHeader& header(const FlowRequest* msg);
  static const ::greptime::v1::flow::CreateRequest& create(const FlowRequest* msg);
  static const ::greptime::v1::flow::DropRequest& drop(const FlowRequest* msg);
  static const ::greptime::v1::flow::FlushFlow& flush(const FlowRequest* msg);
};

const ::greptime::v1::flow::FlowRequestHeader&
FlowRequest::_Internal::header(const FlowRequest* msg) {
  return *msg->_impl_.header_;
}
const ::greptime::v1::flow::CreateRequest&
FlowRequest::_Internal::create(const FlowRequest* msg) {
  return *msg->_impl_.body_.create_;
}
const ::greptime::v1::flow::DropRequest&
FlowRequest::_Internal::drop(const FlowRequest* msg) {
  return *msg->_impl_.body_.drop_;
}
const ::greptime::v1::flow::FlushFlow&
FlowRequest::_Internal::flush(const FlowRequest* msg) {
  return *msg->_impl_.body_.flush_;
}
void FlowRequest::set_allocated_create(::greptime::v1::flow::CreateRequest* create) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (create) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create);
    if (message_arena != submessage_arena) {
      create = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.create)
}
void FlowRequest::set_allocated_drop(::greptime::v1::flow::DropRequest* drop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (drop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drop);
    if (message_arena != submessage_arena) {
      drop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drop, submessage_arena);
    }
    set_has_drop();
    _impl_.body_.drop_ = drop;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.drop)
}
void FlowRequest::set_allocated_flush(::greptime::v1::flow::FlushFlow* flush) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (flush) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flush);
    if (message_arena != submessage_arena) {
      flush = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, flush, submessage_arena);
    }
    set_has_flush();
    _impl_.body_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.flush)
}
FlowRequest::FlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRequest)
}
FlowRequest::FlowRequest(const FlowRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::flow::FlowRequestHeader(*from._impl_.header_);
  }
  clear_has_body();
  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::CreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kDrop: {
      _this->_internal_mutable_drop()->::greptime::v1::flow::DropRequest::MergeFrom(
          from._internal_drop());
      break;
    }
    case kFlush: {
      _this->_internal_mutable_flush()->::greptime::v1::flow::FlushFlow::MergeFrom(
          from._internal_flush());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRequest)
}

inline void FlowRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_body();
}

FlowRequest::~FlowRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (has_body()) {
    clear_body();
  }
}

void FlowRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRequest::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:greptime.v1.flow.FlowRequest)
  switch (body_case()) {
    case kCreate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.create_;
      }
      break;
    }
    case kDrop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.drop_;
      }
      break;
    }
    case kFlush: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.flush_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}


void FlowRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.CreateRequest create = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.DropRequest drop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_drop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.FlushFlow flush = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_flush(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.FlowRequestHeader header = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.CreateRequest create = 1;
  if (_internal_has_create()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::create(this),
        _Internal::create(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.DropRequest drop = 2;
  if (_internal_has_drop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::drop(this),
        _Internal::drop(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.FlushFlow flush = 3;
  if (_internal_has_flush()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::flush(this),
        _Internal::flush(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.FlowRequestHeader header = 64;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(64, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRequest)
  return target;
}

size_t FlowRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.flow.FlowRequestHeader header = 64;
  if (this->_internal_has_header()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  switch (body_case()) {
    // .greptime.v1.flow.CreateRequest create = 1;
    case kCreate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.create_);
      break;
    }
    // .greptime.v1.flow.DropRequest drop = 2;
    case kDrop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.drop_);
      break;
    }
    // .greptime.v1.flow.FlushFlow flush = 3;
    case kFlush: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.flush_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRequest::GetClassData() const { return &_class_data_; }


void FlowRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRequest*>(&to_msg);
  auto& from = static_cast<const FlowRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::flow::FlowRequestHeader::MergeFrom(
        from._internal_header());
  }
  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::CreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kDrop: {
      _this->_internal_mutable_drop()->::greptime::v1::flow::DropRequest::MergeFrom(
          from._internal_drop());
      break;
    }
    case kFlush: {
      _this->_internal_mutable_flush()->::greptime::v1::flow::FlushFlow::MergeFrom(
          from._internal_flush());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRequest::CopyFrom(const FlowRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRequest::IsInitialized() const {
  return true;
}

void FlowRequest::InternalSwap(FlowRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.header_, other->_impl_.header_);
  swap(_impl_.body_, other->_impl_.body_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[7]);
}

// ===================================================================

FlowResponse_ExtensionsEntry_DoNotUse::FlowResponse_ExtensionsEntry_DoNotUse() {}
FlowResponse_ExtensionsEntry_DoNotUse::FlowResponse_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowResponse_ExtensionsEntry_DoNotUse::MergeFrom(const FlowResponse_ExtensionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse_ExtensionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[8]);
}

// ===================================================================

class FlowResponse::_Internal {
 public:
  static const ::greptime::v1::ResponseHeader& header(const FlowResponse* msg);
};

const ::greptime::v1::ResponseHeader&
FlowResponse::_Internal::header(const FlowResponse* msg) {
  return *msg->_impl_.header_;
}
void FlowResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void FlowResponse::clear_affected_flows() {
  _impl_.affected_flows_.Clear();
}
FlowResponse::FlowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowResponse)
}
FlowResponse::FlowResponse(const FlowResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.affected_flows_){from._impl_.affected_flows_}
    , /*decltype(_impl_.extensions_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.extensions_.MergeFrom(from._impl_.extensions_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.affected_rows_ = from._impl_.affected_rows_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowResponse)
}

inline void FlowResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.affected_flows_){arena}
    , /*decltype(_impl_.extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowResponse::~FlowResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.affected_flows_.~RepeatedPtrField();
  _impl_.extensions_.Destruct();
  _impl_.extensions_.~MapField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void FlowResponse::ArenaDtor(void* object) {
  FlowResponse* _this = reinterpret_cast< FlowResponse* >(object);
  _this->_impl_.extensions_.Destruct();
}
void FlowResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.affected_flows_.Clear();
  _impl_.extensions_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.affected_rows_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 affected_rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.affected_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.FlowId affected_flows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_affected_flows(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> extensions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.extensions_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_affected_rows(), target);
  }

  // repeated .greptime.v1.FlowId affected_flows = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_affected_flows_size()); i < n; i++) {
    const auto& repfield = this->_internal_affected_flows(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, bytes> extensions = 4;
  if (!this->_internal_extensions().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowResponse_ExtensionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_extensions();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowResponse.ExtensionsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowResponse)
  return target;
}

size_t FlowResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.FlowId affected_flows = 3;
  total_size += 1UL * this->_internal_affected_flows_size();
  for (const auto& msg : this->_impl_.affected_flows_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, bytes> extensions = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_extensions_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_extensions().begin();
      it != this->_internal_extensions().end(); ++it) {
    total_size += FlowResponse_ExtensionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_affected_rows());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowResponse::GetClassData() const { return &_class_data_; }


void FlowResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowResponse*>(&to_msg);
  auto& from = static_cast<const FlowResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.affected_flows_.MergeFrom(from._impl_.affected_flows_);
  _this->_impl_.extensions_.MergeFrom(from._impl_.extensions_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_affected_rows() != 0) {
    _this->_internal_set_affected_rows(from._internal_affected_rows());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowResponse::CopyFrom(const FlowResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowResponse::IsInitialized() const {
  return true;
}

void FlowResponse::InternalSwap(FlowResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.affected_flows_.InternalSwap(&other->_impl_.affected_flows_);
  _impl_.extensions_.InternalSwap(&other->_impl_.extensions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.affected_rows_)
      + sizeof(FlowResponse::_impl_.affected_rows_)
      - PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[9]);
}

// ===================================================================

CreateRequest_FlowOptionsEntry_DoNotUse::CreateRequest_FlowOptionsEntry_DoNotUse() {}
CreateRequest_FlowOptionsEntry_DoNotUse::CreateRequest_FlowOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CreateRequest_FlowOptionsEntry_DoNotUse::MergeFrom(const CreateRequest_FlowOptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest_FlowOptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[10]);
}

// ===================================================================

class CreateRequest::_Internal {
 public:
  static const ::greptime::v1::FlowId& flow_id(const CreateRequest* msg);
  static const ::greptime::v1::TableName& sink_table_name(const CreateRequest* msg);
  static const ::greptime::v1::ExpireAfter& expire_after(const CreateRequest* msg);
};

const ::greptime::v1::FlowId&
CreateRequest::_Internal::flow_id(const CreateRequest* msg) {
  return *msg->_impl_.flow_id_;
}
const ::greptime::v1::TableName&
CreateRequest::_Internal::sink_table_name(const CreateRequest* msg) {
  return *msg->_impl_.sink_table_name_;
}
const ::greptime::v1::ExpireAfter&
CreateRequest::_Internal::expire_after(const CreateRequest* msg) {
  return *msg->_impl_.expire_after_;
}
void CreateRequest::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
void CreateRequest::clear_source_table_ids() {
  _impl_.source_table_ids_.Clear();
}
void CreateRequest::clear_sink_table_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.sink_table_name_ != nullptr) {
    delete _impl_.sink_table_name_;
  }
  _impl_.sink_table_name_ = nullptr;
}
void CreateRequest::clear_expire_after() {
  if (GetArenaForAllocation() == nullptr && _impl_.expire_after_ != nullptr) {
    delete _impl_.expire_after_;
  }
  _impl_.expire_after_ = nullptr;
}
CreateRequest::CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &CreateRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.CreateRequest)
}
CreateRequest::CreateRequest(const CreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){from._impl_.source_table_ids_}
    , /*decltype(_impl_.flow_options_)*/{}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.flow_id_){nullptr}
    , decltype(_impl_.sink_table_name_){nullptr}
    , decltype(_impl_.expire_after_){nullptr}
    , decltype(_impl_.create_if_not_exists_){}
    , decltype(_impl_.or_replace_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flow_options_.MergeFrom(from._impl_.flow_options_);
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sql().empty()) {
    _this->_impl_.sql_.Set(from._internal_sql(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::FlowId(*from._impl_.flow_id_);
  }
  if (from._internal_has_sink_table_name()) {
    _this->_impl_.sink_table_name_ = new ::greptime::v1::TableName(*from._impl_.sink_table_name_);
  }
  if (from._internal_has_expire_after()) {
    _this->_impl_.expire_after_ = new ::greptime::v1::ExpireAfter(*from._impl_.expire_after_);
  }
  ::memcpy(&_impl_.create_if_not_exists_, &from._impl_.create_if_not_exists_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.or_replace_) -
    reinterpret_cast<char*>(&_impl_.create_if_not_exists_)) + sizeof(_impl_.or_replace_));
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.CreateRequest)
}

inline void CreateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){arena}
    , /*decltype(_impl_.flow_options_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.flow_id_){nullptr}
    , decltype(_impl_.sink_table_name_){nullptr}
    , decltype(_impl_.expire_after_){nullptr}
    , decltype(_impl_.create_if_not_exists_){false}
    , decltype(_impl_.or_replace_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateRequest::~CreateRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.CreateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void CreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_table_ids_.~RepeatedPtrField();
  _impl_.flow_options_.Destruct();
  _impl_.flow_options_.~MapField();
  _impl_.comment_.Destroy();
  _impl_.sql_.Destroy();
  if (this != internal_default_instance()) delete _impl_.flow_id_;
  if (this != internal_default_instance()) delete _impl_.sink_table_name_;
  if (this != internal_default_instance()) delete _impl_.expire_after_;
}

void CreateRequest::ArenaDtor(void* object) {
  CreateRequest* _this = reinterpret_cast< CreateRequest* >(object);
  _this->_impl_.flow_options_.Destruct();
}
void CreateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.CreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_table_ids_.Clear();
  _impl_.flow_options_.Clear();
  _impl_.comment_.ClearToEmpty();
  _impl_.sql_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sink_table_name_ != nullptr) {
    delete _impl_.sink_table_name_;
  }
  _impl_.sink_table_name_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.expire_after_ != nullptr) {
    delete _impl_.expire_after_;
  }
  _impl_.expire_after_ = nullptr;
  ::memset(&_impl_.create_if_not_exists_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.or_replace_) -
      reinterpret_cast<char*>(&_impl_.create_if_not_exists_)) + sizeof(_impl_.or_replace_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.FlowId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.TableId source_table_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source_table_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.TableName sink_table_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sink_table_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool create_if_not_exists = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.create_if_not_exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.ExpireAfter expire_after = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_expire_after(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.comment"));
        } else
          goto handle_unusual;
        continue;
      // string sql = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sql();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.sql"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> flow_options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.flow_options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool or_replace = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.or_replace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.CreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.TableId source_table_ids = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_source_table_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_source_table_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .greptime.v1.TableName sink_table_name = 3;
  if (this->_internal_has_sink_table_name()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sink_table_name(this),
        _Internal::sink_table_name(this).GetCachedSize(), target, stream);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_create_if_not_exists(), target);
  }

  // .greptime.v1.ExpireAfter expire_after = 5;
  if (this->_internal_has_expire_after()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::expire_after(this),
        _Internal::expire_after(this).GetCachedSize(), target, stream);
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.comment");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_comment(), target);
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sql().data(), static_cast<int>(this->_internal_sql().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.sql");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sql(), target);
  }

  // map<string, string> flow_options = 8;
  if (!this->_internal_flow_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CreateRequest_FlowOptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_flow_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.CreateRequest.FlowOptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.CreateRequest.FlowOptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // bool or_replace = 9;
  if (this->_internal_or_replace() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_or_replace(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.CreateRequest)
  return target;
}

size_t CreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.CreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.TableId source_table_ids = 2;
  total_size += 1UL * this->_internal_source_table_ids_size();
  for (const auto& msg : this->_impl_.source_table_ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> flow_options = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_flow_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_flow_options().begin();
      it != this->_internal_flow_options().end(); ++it) {
    total_size += CreateRequest_FlowOptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sql());
  }

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  // .greptime.v1.TableName sink_table_name = 3;
  if (this->_internal_has_sink_table_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sink_table_name_);
  }

  // .greptime.v1.ExpireAfter expire_after = 5;
  if (this->_internal_has_expire_after()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expire_after_);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    total_size += 1 + 1;
  }

  // bool or_replace = 9;
  if (this->_internal_or_replace() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateRequest::GetClassData() const { return &_class_data_; }


void CreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateRequest*>(&to_msg);
  auto& from = static_cast<const CreateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.CreateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.source_table_ids_.MergeFrom(from._impl_.source_table_ids_);
  _this->_impl_.flow_options_.MergeFrom(from._impl_.flow_options_);
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  if (!from._internal_sql().empty()) {
    _this->_internal_set_sql(from._internal_sql());
  }
  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::FlowId::MergeFrom(
        from._internal_flow_id());
  }
  if (from._internal_has_sink_table_name()) {
    _this->_internal_mutable_sink_table_name()->::greptime::v1::TableName::MergeFrom(
        from._internal_sink_table_name());
  }
  if (from._internal_has_expire_after()) {
    _this->_internal_mutable_expire_after()->::greptime::v1::ExpireAfter::MergeFrom(
        from._internal_expire_after());
  }
  if (from._internal_create_if_not_exists() != 0) {
    _this->_internal_set_create_if_not_exists(from._internal_create_if_not_exists());
  }
  if (from._internal_or_replace() != 0) {
    _this->_internal_set_or_replace(from._internal_or_replace());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateRequest::CopyFrom(const CreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.CreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRequest::IsInitialized() const {
  return true;
}

void CreateRequest::InternalSwap(CreateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.source_table_ids_.InternalSwap(&other->_impl_.source_table_ids_);
  _impl_.flow_options_.InternalSwap(&other->_impl_.flow_options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sql_, lhs_arena,
      &other->_impl_.sql_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateRequest, _impl_.or_replace_)
      + sizeof(CreateRequest::_impl_.or_replace_)
      - PROTOBUF_FIELD_OFFSET(CreateRequest, _impl_.flow_id_)>(
          reinterpret_cast<char*>(&_impl_.flow_id_),
          reinterpret_cast<char*>(&other->_impl_.flow_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[11]);
}

// ===================================================================

class DropRequest::_Internal {
 public:
  static const ::greptime::v1::FlowId& flow_id(const DropRequest* msg);
};

const ::greptime::v1::FlowId&
DropRequest::_Internal::flow_id(const DropRequest* msg) {
  return *msg->_impl_.flow_id_;
}
void DropRequest::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
DropRequest::DropRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.DropRequest)
}
DropRequest::DropRequest(const DropRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DropRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::FlowId(*from._impl_.flow_id_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.DropRequest)
}

inline void DropRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DropRequest::~DropRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.DropRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DropRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.flow_id_;
}

void DropRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DropRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.DropRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DropRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.FlowId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DropRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.DropRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.DropRequest)
  return target;
}

size_t DropRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.DropRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DropRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DropRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DropRequest::GetClassData() const { return &_class_data_; }


void DropRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DropRequest*>(&to_msg);
  auto& from = static_cast<const DropRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.DropRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::FlowId::MergeFrom(
        from._internal_flow_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DropRequest::CopyFrom(const DropRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.DropRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropRequest::IsInitialized() const {
  return true;
}

void DropRequest::InternalSwap(DropRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flow_id_, other->_impl_.flow_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DropRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[12]);
}

// ===================================================================

class FlushFlow::_Internal {
 public:
  static const ::greptime::v1::FlowId& flow_id(const FlushFlow* msg);
};

const ::greptime::v1::FlowId&
FlushFlow::_Internal::flow_id(const FlushFlow* msg) {
  return *msg->_impl_.flow_id_;
}
void FlushFlow::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
FlushFlow::FlushFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlushFlow)
}
FlushFlow::FlushFlow(const FlushFlow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlushFlow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::FlowId(*from._impl_.flow_id_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlushFlow)
}

inline void FlushFlow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlushFlow::~FlushFlow() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlushFlow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushFlow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.flow_id_;
}

void FlushFlow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlushFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlushFlow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlushFlow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.FlowId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushFlow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlushFlow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlushFlow)
  return target;
}

size_t FlushFlow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlushFlow)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlushFlow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlushFlow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlushFlow::GetClassData() const { return &_class_data_; }


void FlushFlow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlushFlow*>(&to_msg);
  auto& from = static_cast<const FlushFlow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlushFlow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::FlowId::MergeFrom(
        from._internal_flow_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlushFlow::CopyFrom(const FlushFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlushFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushFlow::IsInitialized() const {
  return true;
}

void FlushFlow::InternalSwap(FlushFlow* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flow_id_, other->_impl_.flow_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlushFlow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[13]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace flow
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::DirtyWindowRequests*
Arena::CreateMaybeMessage< ::greptime::v1::flow::DirtyWindowRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::DirtyWindowRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::DirtyWindowRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::DirtyWindowRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::DirtyWindowRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::WindowRange*
Arena::CreateMaybeMessage< ::greptime::v1::flow::WindowRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::WindowRange >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequestHeader*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequestHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequestHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequests*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse_ExtensionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::CreateRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::CreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::CreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::DropRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::DropRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::DropRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlushFlow*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlushFlow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlushFlow >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
