// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/flow/server.proto

#include "greptime/v1/flow/server.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace greptime {
namespace v1 {
namespace flow {
PROTOBUF_CONSTEXPR FlowRequestHeader_TracingContextEntry_DoNotUse::FlowRequestHeader_TracingContextEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowRequestHeader_TracingContextEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _FlowRequestHeader_TracingContextEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowRequestHeader::FlowRequestHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tracing_context_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.query_context_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowRequestHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestHeaderDefaultTypeInternal() {}
  union {
    FlowRequestHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestHeaderDefaultTypeInternal _FlowRequestHeader_default_instance_;
PROTOBUF_CONSTEXPR InsertRequests::InsertRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestsDefaultTypeInternal() {}
  union {
    InsertRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
PROTOBUF_CONSTEXPR InsertRequest::InsertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rows_)*/nullptr
  , /*decltype(_impl_.region_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestDefaultTypeInternal() {}
  union {
    InsertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowRequest::FlowRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.body_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FlowRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestDefaultTypeInternal() {}
  union {
    FlowRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestDefaultTypeInternal _FlowRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowResponse_ExtensionEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal _FlowResponse_ExtensionEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse::FlowResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.affected_flows_)*/{}
  , /*decltype(_impl_.extension_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.affected_rows_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponseDefaultTypeInternal() {}
  union {
    FlowResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponseDefaultTypeInternal _FlowResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest_FlowOptionsEntry_DoNotUse::CreateRequest_FlowOptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CreateRequest_FlowOptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequest_FlowOptionsEntry_DoNotUseDefaultTypeInternal _CreateRequest_FlowOptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest::CreateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_table_ids_)*/{}
  , /*decltype(_impl_.flow_options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sql_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_.sink_table_name_)*/nullptr
  , /*decltype(_impl_.expire_after_)*/nullptr
  , /*decltype(_impl_.create_if_not_exists_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequestDefaultTypeInternal() {}
  union {
    CreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
PROTOBUF_CONSTEXPR DropRequest::DropRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DropRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DropRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DropRequestDefaultTypeInternal() {}
  union {
    DropRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DropRequestDefaultTypeInternal _DropRequest_default_instance_;
}  // namespace flow
}  // namespace v1
}  // namespace greptime
static ::_pb::Metadata file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[10];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;

const uint32_t TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader, _impl_.tracing_context_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequestHeader, _impl_.query_context_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.region_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.rows_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_.header_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_rows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_flows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.extension_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.flow_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.source_table_ids_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.sink_table_name_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.create_if_not_exists_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.expire_after_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.sql_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.flow_options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DropRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DropRequest, _impl_.flow_id_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse)},
  { 10, -1, -1, sizeof(::greptime::v1::flow::FlowRequestHeader)},
  { 18, -1, -1, sizeof(::greptime::v1::flow::InsertRequests)},
  { 25, -1, -1, sizeof(::greptime::v1::flow::InsertRequest)},
  { 33, -1, -1, sizeof(::greptime::v1::flow::FlowRequest)},
  { 43, 51, -1, sizeof(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse)},
  { 53, -1, -1, sizeof(::greptime::v1::flow::FlowResponse)},
  { 63, 71, -1, sizeof(::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse)},
  { 73, -1, -1, sizeof(::greptime::v1::flow::CreateRequest)},
  { 87, -1, -1, sizeof(::greptime::v1::flow::DropRequest)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::greptime::v1::flow::_FlowRequestHeader_TracingContextEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequestHeader_default_instance_._instance,
  &::greptime::v1::flow::_InsertRequests_default_instance_._instance,
  &::greptime::v1::flow::_InsertRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_ExtensionEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_default_instance_._instance,
  &::greptime::v1::flow::_CreateRequest_FlowOptionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_CreateRequest_default_instance_._instance,
  &::greptime::v1::flow::_DropRequest_default_instance_._instance,
};

const char descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035greptime/v1/flow/server.proto\022\020greptim"
  "e.v1.flow\032\030greptime/v1/common.proto\032\025gre"
  "ptime/v1/ddl.proto\032\025greptime/v1/row.prot"
  "o\"\316\001\n\021FlowRequestHeader\022P\n\017tracing_conte"
  "xt\030\001 \003(\01327.greptime.v1.flow.FlowRequestH"
  "eader.TracingContextEntry\0220\n\rquery_conte"
  "xt\030\002 \001(\0132\031.greptime.v1.QueryContext\0325\n\023T"
  "racingContextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value"
  "\030\002 \001(\t:\0028\001\"C\n\016InsertRequests\0221\n\010requests"
  "\030\001 \003(\0132\037.greptime.v1.flow.InsertRequest\""
  "C\n\rInsertRequest\022\021\n\tregion_id\030\001 \001(\004\022\037\n\004r"
  "ows\030\002 \001(\0132\021.greptime.v1.Rows\"\254\001\n\013FlowReq"
  "uest\0223\n\006header\030@ \001(\0132#.greptime.v1.flow."
  "FlowRequestHeader\0221\n\006create\030\001 \001(\0132\037.grep"
  "time.v1.flow.CreateRequestH\000\022-\n\004drop\030\002 \001"
  "(\0132\035.greptime.v1.flow.DropRequestH\000B\006\n\004b"
  "ody\"\363\001\n\014FlowResponse\022+\n\006header\030\001 \001(\0132\033.g"
  "reptime.v1.ResponseHeader\022\025\n\raffected_ro"
  "ws\030\002 \001(\004\022+\n\016affected_flows\030\003 \003(\0132\023.grept"
  "ime.v1.FlowId\022@\n\textension\030\004 \003(\0132-.grept"
  "ime.v1.flow.FlowResponse.ExtensionEntry\032"
  "0\n\016ExtensionEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030"
  "\002 \001(\014:\0028\001\"\376\002\n\rCreateRequest\022$\n\007flow_id\030\001"
  " \001(\0132\023.greptime.v1.FlowId\022.\n\020source_tabl"
  "e_ids\030\002 \003(\0132\024.greptime.v1.TableId\022/\n\017sin"
  "k_table_name\030\003 \001(\0132\026.greptime.v1.TableNa"
  "me\022\034\n\024create_if_not_exists\030\004 \001(\010\022.\n\014expi"
  "re_after\030\005 \001(\0132\030.greptime.v1.ExpireAfter"
  "\022\017\n\007comment\030\006 \001(\t\022\013\n\003sql\030\007 \001(\t\022F\n\014flow_o"
  "ptions\030\010 \003(\01320.greptime.v1.flow.CreateRe"
  "quest.FlowOptionsEntry\0322\n\020FlowOptionsEnt"
  "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"3\n\013Dr"
  "opRequest\022$\n\007flow_id\030\001 \001(\0132\023.greptime.v1"
  ".FlowId2\264\001\n\004Flow\022S\n\022HandleCreateRemove\022\035"
  ".greptime.v1.flow.FlowRequest\032\036.greptime"
  ".v1.flow.FlowResponse\022W\n\023HandleMirrorReq"
  "uest\022 .greptime.v1.flow.InsertRequests\032\036"
  ".greptime.v1.flow.FlowResponseBY\n\023io.gre"
  "ptime.v1.flowB\006ServerZ:github.com/Grepti"
  "meTeam/greptime-proto/go/greptime/v1/flo"
  "wb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps[3] = {
  &::descriptor_table_greptime_2fv1_2fcommon_2eproto,
  &::descriptor_table_greptime_2fv1_2fddl_2eproto,
  &::descriptor_table_greptime_2fv1_2frow_2eproto,
};
static ::_pbi::once_flag descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto = {
    false, false, 1609, descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto,
    "greptime/v1/flow/server.proto",
    &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once, descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps, 3, 10,
    schemas, file_default_instances, TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets,
    file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto, file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
    file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter() {
  return &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_greptime_2fv1_2fflow_2fserver_2eproto(&descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto);
namespace greptime {
namespace v1 {
namespace flow {

// ===================================================================

FlowRequestHeader_TracingContextEntry_DoNotUse::FlowRequestHeader_TracingContextEntry_DoNotUse() {}
FlowRequestHeader_TracingContextEntry_DoNotUse::FlowRequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowRequestHeader_TracingContextEntry_DoNotUse::MergeFrom(const FlowRequestHeader_TracingContextEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowRequestHeader_TracingContextEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[0]);
}

// ===================================================================

class FlowRequestHeader::_Internal {
 public:
  static const ::greptime::v1::QueryContext& query_context(const FlowRequestHeader* msg);
};

const ::greptime::v1::QueryContext&
FlowRequestHeader::_Internal::query_context(const FlowRequestHeader* msg) {
  return *msg->_impl_.query_context_;
}
void FlowRequestHeader::clear_query_context() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_context_ != nullptr) {
    delete _impl_.query_context_;
  }
  _impl_.query_context_ = nullptr;
}
FlowRequestHeader::FlowRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowRequestHeader::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRequestHeader)
}
FlowRequestHeader::FlowRequestHeader(const FlowRequestHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRequestHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.tracing_context_)*/{}
    , decltype(_impl_.query_context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.tracing_context_.MergeFrom(from._impl_.tracing_context_);
  if (from._internal_has_query_context()) {
    _this->_impl_.query_context_ = new ::greptime::v1::QueryContext(*from._impl_.query_context_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRequestHeader)
}

inline void FlowRequestHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.tracing_context_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.query_context_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowRequestHeader::~FlowRequestHeader() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRequestHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowRequestHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tracing_context_.Destruct();
  _impl_.tracing_context_.~MapField();
  if (this != internal_default_instance()) delete _impl_.query_context_;
}

void FlowRequestHeader::ArenaDtor(void* object) {
  FlowRequestHeader* _this = reinterpret_cast< FlowRequestHeader* >(object);
  _this->_impl_.tracing_context_.Destruct();
}
void FlowRequestHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRequestHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRequestHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tracing_context_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.query_context_ != nullptr) {
    delete _impl_.query_context_;
  }
  _impl_.query_context_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRequestHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> tracing_context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.tracing_context_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.QueryContext query_context = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_query_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRequestHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRequestHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> tracing_context = 1;
  if (!this->_internal_tracing_context().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowRequestHeader_TracingContextEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_tracing_context();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowRequestHeader.TracingContextEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowRequestHeader.TracingContextEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // .greptime.v1.QueryContext query_context = 2;
  if (this->_internal_has_query_context()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::query_context(this),
        _Internal::query_context(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRequestHeader)
  return target;
}

size_t FlowRequestHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRequestHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> tracing_context = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_tracing_context_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_tracing_context().begin();
      it != this->_internal_tracing_context().end(); ++it) {
    total_size += FlowRequestHeader_TracingContextEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .greptime.v1.QueryContext query_context = 2;
  if (this->_internal_has_query_context()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.query_context_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRequestHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRequestHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRequestHeader::GetClassData() const { return &_class_data_; }


void FlowRequestHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRequestHeader*>(&to_msg);
  auto& from = static_cast<const FlowRequestHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRequestHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tracing_context_.MergeFrom(from._impl_.tracing_context_);
  if (from._internal_has_query_context()) {
    _this->_internal_mutable_query_context()->::greptime::v1::QueryContext::MergeFrom(
        from._internal_query_context());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRequestHeader::CopyFrom(const FlowRequestHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRequestHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRequestHeader::IsInitialized() const {
  return true;
}

void FlowRequestHeader::InternalSwap(FlowRequestHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tracing_context_.InternalSwap(&other->_impl_.tracing_context_);
  swap(_impl_.query_context_, other->_impl_.query_context_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRequestHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[1]);
}

// ===================================================================

class InsertRequests::_Internal {
 public:
};

InsertRequests::InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequests)
}
InsertRequests::InsertRequests(const InsertRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){from._impl_.requests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequests)
}

inline void InsertRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequests::~InsertRequests() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void InsertRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .greptime.v1.flow.InsertRequest requests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequests)
  return target;
}

size_t InsertRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequests::GetClassData() const { return &_class_data_; }


void InsertRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequests*>(&to_msg);
  auto& from = static_cast<const InsertRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequests::CopyFrom(const InsertRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequests::IsInitialized() const {
  return true;
}

void InsertRequests::InternalSwap(InsertRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[2]);
}

// ===================================================================

class InsertRequest::_Internal {
 public:
  static const ::greptime::v1::Rows& rows(const InsertRequest* msg);
};

const ::greptime::v1::Rows&
InsertRequest::_Internal::rows(const InsertRequest* msg) {
  return *msg->_impl_.rows_;
}
void InsertRequest::clear_rows() {
  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
}
InsertRequest::InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequest)
}
InsertRequest::InsertRequest(const InsertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rows()) {
    _this->_impl_.rows_ = new ::greptime::v1::Rows(*from._impl_.rows_);
  }
  _this->_impl_.region_id_ = from._impl_.region_id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequest)
}

inline void InsertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequest::~InsertRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rows_;
}

void InsertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
  _impl_.region_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.Rows rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_region_id(), target);
  }

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rows(this),
        _Internal::rows(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequest)
  return target;
}

size_t InsertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rows_);
  }

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_region_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequest::GetClassData() const { return &_class_data_; }


void InsertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequest*>(&to_msg);
  auto& from = static_cast<const InsertRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rows()) {
    _this->_internal_mutable_rows()->::greptime::v1::Rows::MergeFrom(
        from._internal_rows());
  }
  if (from._internal_region_id() != 0) {
    _this->_internal_set_region_id(from._internal_region_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequest::CopyFrom(const InsertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequest::IsInitialized() const {
  return true;
}

void InsertRequest::InternalSwap(InsertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.region_id_)
      + sizeof(InsertRequest::_impl_.region_id_)
      - PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.rows_)>(
          reinterpret_cast<char*>(&_impl_.rows_),
          reinterpret_cast<char*>(&other->_impl_.rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[3]);
}

// ===================================================================

class FlowRequest::_Internal {
 public:
  static const ::greptime::v1::flow::FlowRequestHeader& header(const FlowRequest* msg);
  static const ::greptime::v1::flow::CreateRequest& create(const FlowRequest* msg);
  static const ::greptime::v1::flow::DropRequest& drop(const FlowRequest* msg);
};

const ::greptime::v1::flow::FlowRequestHeader&
FlowRequest::_Internal::header(const FlowRequest* msg) {
  return *msg->_impl_.header_;
}
const ::greptime::v1::flow::CreateRequest&
FlowRequest::_Internal::create(const FlowRequest* msg) {
  return *msg->_impl_.body_.create_;
}
const ::greptime::v1::flow::DropRequest&
FlowRequest::_Internal::drop(const FlowRequest* msg) {
  return *msg->_impl_.body_.drop_;
}
void FlowRequest::set_allocated_create(::greptime::v1::flow::CreateRequest* create) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (create) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create);
    if (message_arena != submessage_arena) {
      create = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.create)
}
void FlowRequest::set_allocated_drop(::greptime::v1::flow::DropRequest* drop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (drop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drop);
    if (message_arena != submessage_arena) {
      drop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drop, submessage_arena);
    }
    set_has_drop();
    _impl_.body_.drop_ = drop;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.drop)
}
FlowRequest::FlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRequest)
}
FlowRequest::FlowRequest(const FlowRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::flow::FlowRequestHeader(*from._impl_.header_);
  }
  clear_has_body();
  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::CreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kDrop: {
      _this->_internal_mutable_drop()->::greptime::v1::flow::DropRequest::MergeFrom(
          from._internal_drop());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRequest)
}

inline void FlowRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.header_){nullptr}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_body();
}

FlowRequest::~FlowRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.header_;
  if (has_body()) {
    clear_body();
  }
}

void FlowRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRequest::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:greptime.v1.flow.FlowRequest)
  switch (body_case()) {
    case kCreate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.create_;
      }
      break;
    }
    case kDrop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.drop_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}


void FlowRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.CreateRequest create = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.DropRequest drop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_drop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.FlowRequestHeader header = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.CreateRequest create = 1;
  if (_internal_has_create()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::create(this),
        _Internal::create(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.DropRequest drop = 2;
  if (_internal_has_drop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::drop(this),
        _Internal::drop(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.FlowRequestHeader header = 64;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(64, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRequest)
  return target;
}

size_t FlowRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.flow.FlowRequestHeader header = 64;
  if (this->_internal_has_header()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  switch (body_case()) {
    // .greptime.v1.flow.CreateRequest create = 1;
    case kCreate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.create_);
      break;
    }
    // .greptime.v1.flow.DropRequest drop = 2;
    case kDrop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.drop_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRequest::GetClassData() const { return &_class_data_; }


void FlowRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRequest*>(&to_msg);
  auto& from = static_cast<const FlowRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::flow::FlowRequestHeader::MergeFrom(
        from._internal_header());
  }
  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::CreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kDrop: {
      _this->_internal_mutable_drop()->::greptime::v1::flow::DropRequest::MergeFrom(
          from._internal_drop());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRequest::CopyFrom(const FlowRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRequest::IsInitialized() const {
  return true;
}

void FlowRequest::InternalSwap(FlowRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.header_, other->_impl_.header_);
  swap(_impl_.body_, other->_impl_.body_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[4]);
}

// ===================================================================

FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse() {}
FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowResponse_ExtensionEntry_DoNotUse::MergeFrom(const FlowResponse_ExtensionEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse_ExtensionEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[5]);
}

// ===================================================================

class FlowResponse::_Internal {
 public:
  static const ::greptime::v1::ResponseHeader& header(const FlowResponse* msg);
};

const ::greptime::v1::ResponseHeader&
FlowResponse::_Internal::header(const FlowResponse* msg) {
  return *msg->_impl_.header_;
}
void FlowResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
void FlowResponse::clear_affected_flows() {
  _impl_.affected_flows_.Clear();
}
FlowResponse::FlowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowResponse)
}
FlowResponse::FlowResponse(const FlowResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.affected_flows_){from._impl_.affected_flows_}
    , /*decltype(_impl_.extension_)*/{}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.extension_.MergeFrom(from._impl_.extension_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.affected_rows_ = from._impl_.affected_rows_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowResponse)
}

inline void FlowResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.affected_flows_){arena}
    , /*decltype(_impl_.extension_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowResponse::~FlowResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.affected_flows_.~RepeatedPtrField();
  _impl_.extension_.Destruct();
  _impl_.extension_.~MapField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void FlowResponse::ArenaDtor(void* object) {
  FlowResponse* _this = reinterpret_cast< FlowResponse* >(object);
  _this->_impl_.extension_.Destruct();
}
void FlowResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.affected_flows_.Clear();
  _impl_.extension_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.affected_rows_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 affected_rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.affected_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.FlowId affected_flows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_affected_flows(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> extension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.extension_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_affected_rows(), target);
  }

  // repeated .greptime.v1.FlowId affected_flows = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_affected_flows_size()); i < n; i++) {
    const auto& repfield = this->_internal_affected_flows(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, bytes> extension = 4;
  if (!this->_internal_extension().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowResponse_ExtensionEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_extension();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowResponse.ExtensionEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowResponse)
  return target;
}

size_t FlowResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.FlowId affected_flows = 3;
  total_size += 1UL * this->_internal_affected_flows_size();
  for (const auto& msg : this->_impl_.affected_flows_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, bytes> extension = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_extension_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_extension().begin();
      it != this->_internal_extension().end(); ++it) {
    total_size += FlowResponse_ExtensionEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_affected_rows());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowResponse::GetClassData() const { return &_class_data_; }


void FlowResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowResponse*>(&to_msg);
  auto& from = static_cast<const FlowResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.affected_flows_.MergeFrom(from._impl_.affected_flows_);
  _this->_impl_.extension_.MergeFrom(from._impl_.extension_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_affected_rows() != 0) {
    _this->_internal_set_affected_rows(from._internal_affected_rows());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowResponse::CopyFrom(const FlowResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowResponse::IsInitialized() const {
  return true;
}

void FlowResponse::InternalSwap(FlowResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.affected_flows_.InternalSwap(&other->_impl_.affected_flows_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.affected_rows_)
      + sizeof(FlowResponse::_impl_.affected_rows_)
      - PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[6]);
}

// ===================================================================

CreateRequest_FlowOptionsEntry_DoNotUse::CreateRequest_FlowOptionsEntry_DoNotUse() {}
CreateRequest_FlowOptionsEntry_DoNotUse::CreateRequest_FlowOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CreateRequest_FlowOptionsEntry_DoNotUse::MergeFrom(const CreateRequest_FlowOptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest_FlowOptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[7]);
}

// ===================================================================

class CreateRequest::_Internal {
 public:
  static const ::greptime::v1::FlowId& flow_id(const CreateRequest* msg);
  static const ::greptime::v1::TableName& sink_table_name(const CreateRequest* msg);
  static const ::greptime::v1::ExpireAfter& expire_after(const CreateRequest* msg);
};

const ::greptime::v1::FlowId&
CreateRequest::_Internal::flow_id(const CreateRequest* msg) {
  return *msg->_impl_.flow_id_;
}
const ::greptime::v1::TableName&
CreateRequest::_Internal::sink_table_name(const CreateRequest* msg) {
  return *msg->_impl_.sink_table_name_;
}
const ::greptime::v1::ExpireAfter&
CreateRequest::_Internal::expire_after(const CreateRequest* msg) {
  return *msg->_impl_.expire_after_;
}
void CreateRequest::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
void CreateRequest::clear_source_table_ids() {
  _impl_.source_table_ids_.Clear();
}
void CreateRequest::clear_sink_table_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.sink_table_name_ != nullptr) {
    delete _impl_.sink_table_name_;
  }
  _impl_.sink_table_name_ = nullptr;
}
void CreateRequest::clear_expire_after() {
  if (GetArenaForAllocation() == nullptr && _impl_.expire_after_ != nullptr) {
    delete _impl_.expire_after_;
  }
  _impl_.expire_after_ = nullptr;
}
CreateRequest::CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &CreateRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.CreateRequest)
}
CreateRequest::CreateRequest(const CreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){from._impl_.source_table_ids_}
    , /*decltype(_impl_.flow_options_)*/{}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.flow_id_){nullptr}
    , decltype(_impl_.sink_table_name_){nullptr}
    , decltype(_impl_.expire_after_){nullptr}
    , decltype(_impl_.create_if_not_exists_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flow_options_.MergeFrom(from._impl_.flow_options_);
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sql().empty()) {
    _this->_impl_.sql_.Set(from._internal_sql(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::FlowId(*from._impl_.flow_id_);
  }
  if (from._internal_has_sink_table_name()) {
    _this->_impl_.sink_table_name_ = new ::greptime::v1::TableName(*from._impl_.sink_table_name_);
  }
  if (from._internal_has_expire_after()) {
    _this->_impl_.expire_after_ = new ::greptime::v1::ExpireAfter(*from._impl_.expire_after_);
  }
  _this->_impl_.create_if_not_exists_ = from._impl_.create_if_not_exists_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.CreateRequest)
}

inline void CreateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){arena}
    , /*decltype(_impl_.flow_options_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.flow_id_){nullptr}
    , decltype(_impl_.sink_table_name_){nullptr}
    , decltype(_impl_.expire_after_){nullptr}
    , decltype(_impl_.create_if_not_exists_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateRequest::~CreateRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.CreateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void CreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_table_ids_.~RepeatedPtrField();
  _impl_.flow_options_.Destruct();
  _impl_.flow_options_.~MapField();
  _impl_.comment_.Destroy();
  _impl_.sql_.Destroy();
  if (this != internal_default_instance()) delete _impl_.flow_id_;
  if (this != internal_default_instance()) delete _impl_.sink_table_name_;
  if (this != internal_default_instance()) delete _impl_.expire_after_;
}

void CreateRequest::ArenaDtor(void* object) {
  CreateRequest* _this = reinterpret_cast< CreateRequest* >(object);
  _this->_impl_.flow_options_.Destruct();
}
void CreateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.CreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_table_ids_.Clear();
  _impl_.flow_options_.Clear();
  _impl_.comment_.ClearToEmpty();
  _impl_.sql_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sink_table_name_ != nullptr) {
    delete _impl_.sink_table_name_;
  }
  _impl_.sink_table_name_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.expire_after_ != nullptr) {
    delete _impl_.expire_after_;
  }
  _impl_.expire_after_ = nullptr;
  _impl_.create_if_not_exists_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.FlowId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.TableId source_table_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source_table_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.TableName sink_table_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sink_table_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool create_if_not_exists = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.create_if_not_exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.ExpireAfter expire_after = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_expire_after(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.comment"));
        } else
          goto handle_unusual;
        continue;
      // string sql = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sql();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.sql"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> flow_options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.flow_options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.CreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.TableId source_table_ids = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_source_table_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_source_table_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .greptime.v1.TableName sink_table_name = 3;
  if (this->_internal_has_sink_table_name()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sink_table_name(this),
        _Internal::sink_table_name(this).GetCachedSize(), target, stream);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_create_if_not_exists(), target);
  }

  // .greptime.v1.ExpireAfter expire_after = 5;
  if (this->_internal_has_expire_after()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::expire_after(this),
        _Internal::expire_after(this).GetCachedSize(), target, stream);
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.comment");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_comment(), target);
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sql().data(), static_cast<int>(this->_internal_sql().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.sql");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sql(), target);
  }

  // map<string, string> flow_options = 8;
  if (!this->_internal_flow_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CreateRequest_FlowOptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_flow_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.CreateRequest.FlowOptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.CreateRequest.FlowOptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.CreateRequest)
  return target;
}

size_t CreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.CreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.TableId source_table_ids = 2;
  total_size += 1UL * this->_internal_source_table_ids_size();
  for (const auto& msg : this->_impl_.source_table_ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> flow_options = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_flow_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_flow_options().begin();
      it != this->_internal_flow_options().end(); ++it) {
    total_size += CreateRequest_FlowOptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sql());
  }

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  // .greptime.v1.TableName sink_table_name = 3;
  if (this->_internal_has_sink_table_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sink_table_name_);
  }

  // .greptime.v1.ExpireAfter expire_after = 5;
  if (this->_internal_has_expire_after()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expire_after_);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateRequest::GetClassData() const { return &_class_data_; }


void CreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateRequest*>(&to_msg);
  auto& from = static_cast<const CreateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.CreateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.source_table_ids_.MergeFrom(from._impl_.source_table_ids_);
  _this->_impl_.flow_options_.MergeFrom(from._impl_.flow_options_);
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  if (!from._internal_sql().empty()) {
    _this->_internal_set_sql(from._internal_sql());
  }
  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::FlowId::MergeFrom(
        from._internal_flow_id());
  }
  if (from._internal_has_sink_table_name()) {
    _this->_internal_mutable_sink_table_name()->::greptime::v1::TableName::MergeFrom(
        from._internal_sink_table_name());
  }
  if (from._internal_has_expire_after()) {
    _this->_internal_mutable_expire_after()->::greptime::v1::ExpireAfter::MergeFrom(
        from._internal_expire_after());
  }
  if (from._internal_create_if_not_exists() != 0) {
    _this->_internal_set_create_if_not_exists(from._internal_create_if_not_exists());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateRequest::CopyFrom(const CreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.CreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRequest::IsInitialized() const {
  return true;
}

void CreateRequest::InternalSwap(CreateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.source_table_ids_.InternalSwap(&other->_impl_.source_table_ids_);
  _impl_.flow_options_.InternalSwap(&other->_impl_.flow_options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sql_, lhs_arena,
      &other->_impl_.sql_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateRequest, _impl_.create_if_not_exists_)
      + sizeof(CreateRequest::_impl_.create_if_not_exists_)
      - PROTOBUF_FIELD_OFFSET(CreateRequest, _impl_.flow_id_)>(
          reinterpret_cast<char*>(&_impl_.flow_id_),
          reinterpret_cast<char*>(&other->_impl_.flow_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[8]);
}

// ===================================================================

class DropRequest::_Internal {
 public:
  static const ::greptime::v1::FlowId& flow_id(const DropRequest* msg);
};

const ::greptime::v1::FlowId&
DropRequest::_Internal::flow_id(const DropRequest* msg) {
  return *msg->_impl_.flow_id_;
}
void DropRequest::clear_flow_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
}
DropRequest::DropRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.DropRequest)
}
DropRequest::DropRequest(const DropRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DropRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::FlowId(*from._impl_.flow_id_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.DropRequest)
}

inline void DropRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DropRequest::~DropRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.DropRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DropRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.flow_id_;
}

void DropRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DropRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.DropRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DropRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.FlowId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DropRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.DropRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.DropRequest)
  return target;
}

size_t DropRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.DropRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.FlowId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DropRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DropRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DropRequest::GetClassData() const { return &_class_data_; }


void DropRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DropRequest*>(&to_msg);
  auto& from = static_cast<const DropRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.DropRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::FlowId::MergeFrom(
        from._internal_flow_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DropRequest::CopyFrom(const DropRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.DropRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropRequest::IsInitialized() const {
  return true;
}

void DropRequest::InternalSwap(DropRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flow_id_, other->_impl_.flow_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DropRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace flow
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequestHeader_TracingContextEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequestHeader*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequestHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequestHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequests*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::CreateRequest_FlowOptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::CreateRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::CreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::CreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::DropRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::DropRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::DropRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
