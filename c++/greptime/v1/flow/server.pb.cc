// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/flow/server.proto

#include "greptime/v1/flow/server.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace greptime {
namespace v1 {
namespace flow {
PROTOBUF_CONSTEXPR InsertRequests::InsertRequests(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.requests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestsDefaultTypeInternal() {}
  union {
    InsertRequests _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestsDefaultTypeInternal _InsertRequests_default_instance_;
PROTOBUF_CONSTEXPR InsertRequest::InsertRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.rows_)*/nullptr
  , /*decltype(_impl_.region_id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InsertRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRequestDefaultTypeInternal() {}
  union {
    InsertRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowRequest::FlowRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.body_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FlowRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowRequestDefaultTypeInternal() {}
  union {
    FlowRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowRequestDefaultTypeInternal _FlowRequest_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FlowResponse_ExtensionEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponse_ExtensionEntry_DoNotUseDefaultTypeInternal _FlowResponse_ExtensionEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FlowResponse::FlowResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extension_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.affected_tasks_)*/{}
  , /*decltype(_impl_.header_)*/nullptr
  , /*decltype(_impl_.affected_rows_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FlowResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlowResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlowResponseDefaultTypeInternal() {}
  union {
    FlowResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlowResponseDefaultTypeInternal _FlowResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest_TaskOptionsEntry_DoNotUse::CreateRequest_TaskOptionsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct CreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CreateRequest_TaskOptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequest_TaskOptionsEntry_DoNotUseDefaultTypeInternal _CreateRequest_TaskOptionsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest::CreateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_table_ids_)*/{}
  , /*decltype(_impl_.task_options_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.expire_when_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sql_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_.sink_table_name_)*/nullptr
  , /*decltype(_impl_.create_if_not_exists_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequestDefaultTypeInternal() {}
  union {
    CreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
PROTOBUF_CONSTEXPR DropRequest::DropRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flow_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DropRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DropRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DropRequestDefaultTypeInternal() {}
  union {
    DropRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DropRequestDefaultTypeInternal _DropRequest_default_instance_;
PROTOBUF_CONSTEXPR TaskId::TaskId(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TaskIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TaskIdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TaskIdDefaultTypeInternal() {}
  union {
    TaskId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TaskIdDefaultTypeInternal _TaskId_default_instance_;
}  // namespace flow
}  // namespace v1
}  // namespace greptime
static ::_pb::Metadata file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[9];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto = nullptr;

const uint32_t TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequests, _impl_.requests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.region_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::InsertRequest, _impl_.rows_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowRequest, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.header_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_rows_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.extension_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::FlowResponse, _impl_.affected_tasks_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.flow_id_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.source_table_ids_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.sink_table_name_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.create_if_not_exists_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.expire_when_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.sql_),
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::CreateRequest, _impl_.task_options_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DropRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::DropRequest, _impl_.flow_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::TaskId, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::greptime::v1::flow::TaskId, _impl_.id_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::greptime::v1::flow::InsertRequests)},
  { 7, -1, -1, sizeof(::greptime::v1::flow::InsertRequest)},
  { 15, -1, -1, sizeof(::greptime::v1::flow::FlowRequest)},
  { 24, 32, -1, sizeof(::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse)},
  { 34, -1, -1, sizeof(::greptime::v1::flow::FlowResponse)},
  { 44, 52, -1, sizeof(::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse)},
  { 54, -1, -1, sizeof(::greptime::v1::flow::CreateRequest)},
  { 68, -1, -1, sizeof(::greptime::v1::flow::DropRequest)},
  { 75, -1, -1, sizeof(::greptime::v1::flow::TaskId)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::greptime::v1::flow::_InsertRequests_default_instance_._instance,
  &::greptime::v1::flow::_InsertRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowRequest_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_ExtensionEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_FlowResponse_default_instance_._instance,
  &::greptime::v1::flow::_CreateRequest_TaskOptionsEntry_DoNotUse_default_instance_._instance,
  &::greptime::v1::flow::_CreateRequest_default_instance_._instance,
  &::greptime::v1::flow::_DropRequest_default_instance_._instance,
  &::greptime::v1::flow::_TaskId_default_instance_._instance,
};

const char descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\035greptime/v1/flow/server.proto\022\020greptim"
  "e.v1.flow\032\030greptime/v1/common.proto\032\025gre"
  "ptime/v1/ddl.proto\032\025greptime/v1/row.prot"
  "o\"C\n\016InsertRequests\0221\n\010requests\030\001 \003(\0132\037."
  "greptime.v1.flow.InsertRequest\"C\n\rInsert"
  "Request\022\021\n\tregion_id\030\001 \001(\004\022\037\n\004rows\030\002 \001(\013"
  "2\021.greptime.v1.Rows\"w\n\013FlowRequest\0221\n\006cr"
  "eate\030\001 \001(\0132\037.greptime.v1.flow.CreateRequ"
  "estH\000\022-\n\004drop\030\002 \001(\0132\035.greptime.v1.flow.D"
  "ropRequestH\000B\006\n\004body\"\370\001\n\014FlowResponse\022+\n"
  "\006header\030\001 \001(\0132\033.greptime.v1.ResponseHead"
  "er\022\025\n\raffected_rows\030\002 \001(\004\022@\n\textension\030\003"
  " \003(\0132-.greptime.v1.flow.FlowResponse.Ext"
  "ensionEntry\0220\n\016affected_tasks\030\004 \003(\0132\030.gr"
  "eptime.v1.flow.TaskId\0320\n\016ExtensionEntry\022"
  "\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014:\0028\001\"\350\002\n\rCrea"
  "teRequest\022)\n\007flow_id\030\001 \001(\0132\030.greptime.v1"
  ".flow.TaskId\022.\n\020source_table_ids\030\002 \003(\0132\024"
  ".greptime.v1.TableId\022/\n\017sink_table_name\030"
  "\003 \001(\0132\026.greptime.v1.TableName\022\034\n\024create_"
  "if_not_exists\030\004 \001(\010\022\023\n\013expire_when\030\005 \001(\t"
  "\022\017\n\007comment\030\006 \001(\t\022\013\n\003sql\030\007 \001(\t\022F\n\014task_o"
  "ptions\030\010 \003(\01320.greptime.v1.flow.CreateRe"
  "quest.TaskOptionsEntry\0322\n\020TaskOptionsEnt"
  "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"8\n\013Dr"
  "opRequest\022)\n\007flow_id\030\001 \001(\0132\030.greptime.v1"
  ".flow.TaskId\"\024\n\006TaskId\022\n\n\002id\030\001 \001(\r2\264\001\n\004F"
  "low\022S\n\022HandleCreateRemove\022\035.greptime.v1."
  "flow.FlowRequest\032\036.greptime.v1.flow.Flow"
  "Response\022W\n\023HandleMirrorRequest\022 .grepti"
  "me.v1.flow.InsertRequests\032\036.greptime.v1."
  "flow.FlowResponseBY\n\023io.greptime.v1.flow"
  "B\006ServerZ:github.com/GreptimeTeam/grepti"
  "me-proto/go/greptime/v1/flowb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps[3] = {
  &::descriptor_table_greptime_2fv1_2fcommon_2eproto,
  &::descriptor_table_greptime_2fv1_2fddl_2eproto,
  &::descriptor_table_greptime_2fv1_2frow_2eproto,
};
static ::_pbi::once_flag descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto = {
    false, false, 1356, descriptor_table_protodef_greptime_2fv1_2fflow_2fserver_2eproto,
    "greptime/v1/flow/server.proto",
    &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once, descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_deps, 3, 9,
    schemas, file_default_instances, TableStruct_greptime_2fv1_2fflow_2fserver_2eproto::offsets,
    file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto, file_level_enum_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
    file_level_service_descriptors_greptime_2fv1_2fflow_2fserver_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter() {
  return &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_greptime_2fv1_2fflow_2fserver_2eproto(&descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto);
namespace greptime {
namespace v1 {
namespace flow {

// ===================================================================

class InsertRequests::_Internal {
 public:
};

InsertRequests::InsertRequests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequests)
}
InsertRequests::InsertRequests(const InsertRequests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequests* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){from._impl_.requests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequests)
}

inline void InsertRequests::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.requests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequests::~InsertRequests() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequests)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequests::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.requests_.~RepeatedPtrField();
}

void InsertRequests::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequests::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.requests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .greptime.v1.flow.InsertRequest requests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequests)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequests)
  return target;
}

size_t InsertRequests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequests)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.flow.InsertRequest requests = 1;
  total_size += 1UL * this->_internal_requests_size();
  for (const auto& msg : this->_impl_.requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequests::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequests::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequests::GetClassData() const { return &_class_data_; }


void InsertRequests::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequests*>(&to_msg);
  auto& from = static_cast<const InsertRequests&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequests)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.requests_.MergeFrom(from._impl_.requests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequests::CopyFrom(const InsertRequests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequests::IsInitialized() const {
  return true;
}

void InsertRequests::InternalSwap(InsertRequests* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.requests_.InternalSwap(&other->_impl_.requests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequests::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[0]);
}

// ===================================================================

class InsertRequest::_Internal {
 public:
  static const ::greptime::v1::Rows& rows(const InsertRequest* msg);
};

const ::greptime::v1::Rows&
InsertRequest::_Internal::rows(const InsertRequest* msg) {
  return *msg->_impl_.rows_;
}
void InsertRequest::clear_rows() {
  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
}
InsertRequest::InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.InsertRequest)
}
InsertRequest::InsertRequest(const InsertRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rows()) {
    _this->_impl_.rows_ = new ::greptime::v1::Rows(*from._impl_.rows_);
  }
  _this->_impl_.region_id_ = from._impl_.region_id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.InsertRequest)
}

inline void InsertRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.rows_){nullptr}
    , decltype(_impl_.region_id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

InsertRequest::~InsertRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.InsertRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rows_;
}

void InsertRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.rows_ != nullptr) {
    delete _impl_.rows_;
  }
  _impl_.rows_ = nullptr;
  _impl_.region_id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.Rows rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.InsertRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_region_id(), target);
  }

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rows(this),
        _Internal::rows(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.InsertRequest)
  return target;
}

size_t InsertRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.InsertRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.Rows rows = 2;
  if (this->_internal_has_rows()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rows_);
  }

  // uint64 region_id = 1;
  if (this->_internal_region_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_region_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRequest::GetClassData() const { return &_class_data_; }


void InsertRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRequest*>(&to_msg);
  auto& from = static_cast<const InsertRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.InsertRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_rows()) {
    _this->_internal_mutable_rows()->::greptime::v1::Rows::MergeFrom(
        from._internal_rows());
  }
  if (from._internal_region_id() != 0) {
    _this->_internal_set_region_id(from._internal_region_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRequest::CopyFrom(const InsertRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.InsertRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRequest::IsInitialized() const {
  return true;
}

void InsertRequest::InternalSwap(InsertRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.region_id_)
      + sizeof(InsertRequest::_impl_.region_id_)
      - PROTOBUF_FIELD_OFFSET(InsertRequest, _impl_.rows_)>(
          reinterpret_cast<char*>(&_impl_.rows_),
          reinterpret_cast<char*>(&other->_impl_.rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[1]);
}

// ===================================================================

class FlowRequest::_Internal {
 public:
  static const ::greptime::v1::flow::CreateRequest& create(const FlowRequest* msg);
  static const ::greptime::v1::flow::DropRequest& drop(const FlowRequest* msg);
};

const ::greptime::v1::flow::CreateRequest&
FlowRequest::_Internal::create(const FlowRequest* msg) {
  return *msg->_impl_.body_.create_;
}
const ::greptime::v1::flow::DropRequest&
FlowRequest::_Internal::drop(const FlowRequest* msg) {
  return *msg->_impl_.body_.drop_;
}
void FlowRequest::set_allocated_create(::greptime::v1::flow::CreateRequest* create) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (create) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create);
    if (message_arena != submessage_arena) {
      create = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create, submessage_arena);
    }
    set_has_create();
    _impl_.body_.create_ = create;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.create)
}
void FlowRequest::set_allocated_drop(::greptime::v1::flow::DropRequest* drop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_body();
  if (drop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drop);
    if (message_arena != submessage_arena) {
      drop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drop, submessage_arena);
    }
    set_has_drop();
    _impl_.body_.drop_ = drop;
  }
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.flow.FlowRequest.drop)
}
FlowRequest::FlowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowRequest)
}
FlowRequest::FlowRequest(const FlowRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_body();
  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::CreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kDrop: {
      _this->_internal_mutable_drop()->::greptime::v1::flow::DropRequest::MergeFrom(
          from._internal_drop());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowRequest)
}

inline void FlowRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_body();
}

FlowRequest::~FlowRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlowRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_body()) {
    clear_body();
  }
}

void FlowRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowRequest::clear_body() {
// @@protoc_insertion_point(one_of_clear_start:greptime.v1.flow.FlowRequest)
  switch (body_case()) {
    case kCreate: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.create_;
      }
      break;
    }
    case kDrop: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.body_.drop_;
      }
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}


void FlowRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_body();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.CreateRequest create = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_create(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.flow.DropRequest drop = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_drop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.CreateRequest create = 1;
  if (_internal_has_create()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::create(this),
        _Internal::create(this).GetCachedSize(), target, stream);
  }

  // .greptime.v1.flow.DropRequest drop = 2;
  if (_internal_has_drop()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::drop(this),
        _Internal::drop(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowRequest)
  return target;
}

size_t FlowRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (body_case()) {
    // .greptime.v1.flow.CreateRequest create = 1;
    case kCreate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.create_);
      break;
    }
    // .greptime.v1.flow.DropRequest drop = 2;
    case kDrop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.body_.drop_);
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowRequest::GetClassData() const { return &_class_data_; }


void FlowRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowRequest*>(&to_msg);
  auto& from = static_cast<const FlowRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.body_case()) {
    case kCreate: {
      _this->_internal_mutable_create()->::greptime::v1::flow::CreateRequest::MergeFrom(
          from._internal_create());
      break;
    }
    case kDrop: {
      _this->_internal_mutable_drop()->::greptime::v1::flow::DropRequest::MergeFrom(
          from._internal_drop());
      break;
    }
    case BODY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowRequest::CopyFrom(const FlowRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowRequest::IsInitialized() const {
  return true;
}

void FlowRequest::InternalSwap(FlowRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.body_, other->_impl_.body_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[2]);
}

// ===================================================================

FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse() {}
FlowResponse_ExtensionEntry_DoNotUse::FlowResponse_ExtensionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FlowResponse_ExtensionEntry_DoNotUse::MergeFrom(const FlowResponse_ExtensionEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse_ExtensionEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[3]);
}

// ===================================================================

class FlowResponse::_Internal {
 public:
  static const ::greptime::v1::ResponseHeader& header(const FlowResponse* msg);
};

const ::greptime::v1::ResponseHeader&
FlowResponse::_Internal::header(const FlowResponse* msg) {
  return *msg->_impl_.header_;
}
void FlowResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
FlowResponse::FlowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FlowResponse::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.FlowResponse)
}
FlowResponse::FlowResponse(const FlowResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FlowResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.extension_)*/{}
    , decltype(_impl_.affected_tasks_){from._impl_.affected_tasks_}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.extension_.MergeFrom(from._impl_.extension_);
  if (from._internal_has_header()) {
    _this->_impl_.header_ = new ::greptime::v1::ResponseHeader(*from._impl_.header_);
  }
  _this->_impl_.affected_rows_ = from._impl_.affected_rows_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.FlowResponse)
}

inline void FlowResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.extension_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.affected_tasks_){arena}
    , decltype(_impl_.header_){nullptr}
    , decltype(_impl_.affected_rows_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FlowResponse::~FlowResponse() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.FlowResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FlowResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extension_.Destruct();
  _impl_.extension_.~MapField();
  _impl_.affected_tasks_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void FlowResponse::ArenaDtor(void* object) {
  FlowResponse* _this = reinterpret_cast< FlowResponse* >(object);
  _this->_impl_.extension_.Destruct();
}
void FlowResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FlowResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  _impl_.affected_tasks_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
  _impl_.affected_rows_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FlowResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 affected_rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.affected_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, bytes> extension = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.extension_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_affected_tasks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlowResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.FlowResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_affected_rows(), target);
  }

  // map<string, bytes> extension = 3;
  if (!this->_internal_extension().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = FlowResponse_ExtensionEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_extension();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.FlowResponse.ExtensionEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_affected_tasks_size()); i < n; i++) {
    const auto& repfield = this->_internal_affected_tasks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.FlowResponse)
  return target;
}

size_t FlowResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.FlowResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, bytes> extension = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_extension_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_extension().begin();
      it != this->_internal_extension().end(); ++it) {
    total_size += FlowResponse_ExtensionEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // repeated .greptime.v1.flow.TaskId affected_tasks = 4;
  total_size += 1UL * this->_internal_affected_tasks_size();
  for (const auto& msg : this->_impl_.affected_tasks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .greptime.v1.ResponseHeader header = 1;
  if (this->_internal_has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }

  // uint64 affected_rows = 2;
  if (this->_internal_affected_rows() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_affected_rows());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FlowResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FlowResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FlowResponse::GetClassData() const { return &_class_data_; }


void FlowResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FlowResponse*>(&to_msg);
  auto& from = static_cast<const FlowResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.FlowResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extension_.MergeFrom(from._impl_.extension_);
  _this->_impl_.affected_tasks_.MergeFrom(from._impl_.affected_tasks_);
  if (from._internal_has_header()) {
    _this->_internal_mutable_header()->::greptime::v1::ResponseHeader::MergeFrom(
        from._internal_header());
  }
  if (from._internal_affected_rows() != 0) {
    _this->_internal_set_affected_rows(from._internal_affected_rows());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FlowResponse::CopyFrom(const FlowResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.FlowResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowResponse::IsInitialized() const {
  return true;
}

void FlowResponse::InternalSwap(FlowResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  _impl_.affected_tasks_.InternalSwap(&other->_impl_.affected_tasks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.affected_rows_)
      + sizeof(FlowResponse::_impl_.affected_rows_)
      - PROTOBUF_FIELD_OFFSET(FlowResponse, _impl_.header_)>(
          reinterpret_cast<char*>(&_impl_.header_),
          reinterpret_cast<char*>(&other->_impl_.header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FlowResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[4]);
}

// ===================================================================

CreateRequest_TaskOptionsEntry_DoNotUse::CreateRequest_TaskOptionsEntry_DoNotUse() {}
CreateRequest_TaskOptionsEntry_DoNotUse::CreateRequest_TaskOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CreateRequest_TaskOptionsEntry_DoNotUse::MergeFrom(const CreateRequest_TaskOptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest_TaskOptionsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[5]);
}

// ===================================================================

class CreateRequest::_Internal {
 public:
  static const ::greptime::v1::flow::TaskId& flow_id(const CreateRequest* msg);
  static const ::greptime::v1::TableName& sink_table_name(const CreateRequest* msg);
};

const ::greptime::v1::flow::TaskId&
CreateRequest::_Internal::flow_id(const CreateRequest* msg) {
  return *msg->_impl_.flow_id_;
}
const ::greptime::v1::TableName&
CreateRequest::_Internal::sink_table_name(const CreateRequest* msg) {
  return *msg->_impl_.sink_table_name_;
}
void CreateRequest::clear_source_table_ids() {
  _impl_.source_table_ids_.Clear();
}
void CreateRequest::clear_sink_table_name() {
  if (GetArenaForAllocation() == nullptr && _impl_.sink_table_name_ != nullptr) {
    delete _impl_.sink_table_name_;
  }
  _impl_.sink_table_name_ = nullptr;
}
CreateRequest::CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &CreateRequest::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.CreateRequest)
}
CreateRequest::CreateRequest(const CreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){from._impl_.source_table_ids_}
    , /*decltype(_impl_.task_options_)*/{}
    , decltype(_impl_.expire_when_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.flow_id_){nullptr}
    , decltype(_impl_.sink_table_name_){nullptr}
    , decltype(_impl_.create_if_not_exists_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.task_options_.MergeFrom(from._impl_.task_options_);
  _impl_.expire_when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expire_when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_expire_when().empty()) {
    _this->_impl_.expire_when_.Set(from._internal_expire_when(), 
      _this->GetArenaForAllocation());
  }
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_comment().empty()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sql().empty()) {
    _this->_impl_.sql_.Set(from._internal_sql(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::flow::TaskId(*from._impl_.flow_id_);
  }
  if (from._internal_has_sink_table_name()) {
    _this->_impl_.sink_table_name_ = new ::greptime::v1::TableName(*from._impl_.sink_table_name_);
  }
  _this->_impl_.create_if_not_exists_ = from._impl_.create_if_not_exists_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.CreateRequest)
}

inline void CreateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_table_ids_){arena}
    , /*decltype(_impl_.task_options_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.expire_when_){}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.sql_){}
    , decltype(_impl_.flow_id_){nullptr}
    , decltype(_impl_.sink_table_name_){nullptr}
    , decltype(_impl_.create_if_not_exists_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.expire_when_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.expire_when_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateRequest::~CreateRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.CreateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void CreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_table_ids_.~RepeatedPtrField();
  _impl_.task_options_.Destruct();
  _impl_.task_options_.~MapField();
  _impl_.expire_when_.Destroy();
  _impl_.comment_.Destroy();
  _impl_.sql_.Destroy();
  if (this != internal_default_instance()) delete _impl_.flow_id_;
  if (this != internal_default_instance()) delete _impl_.sink_table_name_;
}

void CreateRequest::ArenaDtor(void* object) {
  CreateRequest* _this = reinterpret_cast< CreateRequest* >(object);
  _this->_impl_.task_options_.Destruct();
}
void CreateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.CreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_table_ids_.Clear();
  _impl_.task_options_.Clear();
  _impl_.expire_when_.ClearToEmpty();
  _impl_.comment_.ClearToEmpty();
  _impl_.sql_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.sink_table_name_ != nullptr) {
    delete _impl_.sink_table_name_;
  }
  _impl_.sink_table_name_ = nullptr;
  _impl_.create_if_not_exists_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.TaskId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .greptime.v1.TableId source_table_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source_table_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .greptime.v1.TableName sink_table_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sink_table_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool create_if_not_exists = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.create_if_not_exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string expire_when = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_expire_when();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.expire_when"));
        } else
          goto handle_unusual;
        continue;
      // string comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.comment"));
        } else
          goto handle_unusual;
        continue;
      // string sql = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sql();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "greptime.v1.flow.CreateRequest.sql"));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> task_options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.task_options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.CreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.TaskId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  // repeated .greptime.v1.TableId source_table_ids = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_source_table_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_source_table_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .greptime.v1.TableName sink_table_name = 3;
  if (this->_internal_has_sink_table_name()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sink_table_name(this),
        _Internal::sink_table_name(this).GetCachedSize(), target, stream);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_create_if_not_exists(), target);
  }

  // string expire_when = 5;
  if (!this->_internal_expire_when().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_expire_when().data(), static_cast<int>(this->_internal_expire_when().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.expire_when");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_expire_when(), target);
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.comment");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_comment(), target);
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sql().data(), static_cast<int>(this->_internal_sql().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "greptime.v1.flow.CreateRequest.sql");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sql(), target);
  }

  // map<string, string> task_options = 8;
  if (!this->_internal_task_options().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CreateRequest_TaskOptionsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_task_options();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.CreateRequest.TaskOptionsEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "greptime.v1.flow.CreateRequest.TaskOptionsEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.CreateRequest)
  return target;
}

size_t CreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.CreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .greptime.v1.TableId source_table_ids = 2;
  total_size += 1UL * this->_internal_source_table_ids_size();
  for (const auto& msg : this->_impl_.source_table_ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> task_options = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_task_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_task_options().begin();
      it != this->_internal_task_options().end(); ++it) {
    total_size += CreateRequest_TaskOptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string expire_when = 5;
  if (!this->_internal_expire_when().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_expire_when());
  }

  // string comment = 6;
  if (!this->_internal_comment().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment());
  }

  // string sql = 7;
  if (!this->_internal_sql().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sql());
  }

  // .greptime.v1.flow.TaskId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  // .greptime.v1.TableName sink_table_name = 3;
  if (this->_internal_has_sink_table_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sink_table_name_);
  }

  // bool create_if_not_exists = 4;
  if (this->_internal_create_if_not_exists() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateRequest::GetClassData() const { return &_class_data_; }


void CreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateRequest*>(&to_msg);
  auto& from = static_cast<const CreateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.CreateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.source_table_ids_.MergeFrom(from._impl_.source_table_ids_);
  _this->_impl_.task_options_.MergeFrom(from._impl_.task_options_);
  if (!from._internal_expire_when().empty()) {
    _this->_internal_set_expire_when(from._internal_expire_when());
  }
  if (!from._internal_comment().empty()) {
    _this->_internal_set_comment(from._internal_comment());
  }
  if (!from._internal_sql().empty()) {
    _this->_internal_set_sql(from._internal_sql());
  }
  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::flow::TaskId::MergeFrom(
        from._internal_flow_id());
  }
  if (from._internal_has_sink_table_name()) {
    _this->_internal_mutable_sink_table_name()->::greptime::v1::TableName::MergeFrom(
        from._internal_sink_table_name());
  }
  if (from._internal_create_if_not_exists() != 0) {
    _this->_internal_set_create_if_not_exists(from._internal_create_if_not_exists());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateRequest::CopyFrom(const CreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.CreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRequest::IsInitialized() const {
  return true;
}

void CreateRequest::InternalSwap(CreateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.source_table_ids_.InternalSwap(&other->_impl_.source_table_ids_);
  _impl_.task_options_.InternalSwap(&other->_impl_.task_options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.expire_when_, lhs_arena,
      &other->_impl_.expire_when_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sql_, lhs_arena,
      &other->_impl_.sql_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateRequest, _impl_.create_if_not_exists_)
      + sizeof(CreateRequest::_impl_.create_if_not_exists_)
      - PROTOBUF_FIELD_OFFSET(CreateRequest, _impl_.flow_id_)>(
          reinterpret_cast<char*>(&_impl_.flow_id_),
          reinterpret_cast<char*>(&other->_impl_.flow_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[6]);
}

// ===================================================================

class DropRequest::_Internal {
 public:
  static const ::greptime::v1::flow::TaskId& flow_id(const DropRequest* msg);
};

const ::greptime::v1::flow::TaskId&
DropRequest::_Internal::flow_id(const DropRequest* msg) {
  return *msg->_impl_.flow_id_;
}
DropRequest::DropRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.DropRequest)
}
DropRequest::DropRequest(const DropRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DropRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_flow_id()) {
    _this->_impl_.flow_id_ = new ::greptime::v1::flow::TaskId(*from._impl_.flow_id_);
  }
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.DropRequest)
}

inline void DropRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flow_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DropRequest::~DropRequest() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.DropRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DropRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.flow_id_;
}

void DropRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DropRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.DropRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.flow_id_ != nullptr) {
    delete _impl_.flow_id_;
  }
  _impl_.flow_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DropRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .greptime.v1.flow.TaskId flow_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DropRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.DropRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .greptime.v1.flow.TaskId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::flow_id(this),
        _Internal::flow_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.DropRequest)
  return target;
}

size_t DropRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.DropRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .greptime.v1.flow.TaskId flow_id = 1;
  if (this->_internal_has_flow_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.flow_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DropRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DropRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DropRequest::GetClassData() const { return &_class_data_; }


void DropRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DropRequest*>(&to_msg);
  auto& from = static_cast<const DropRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.DropRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_flow_id()) {
    _this->_internal_mutable_flow_id()->::greptime::v1::flow::TaskId::MergeFrom(
        from._internal_flow_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DropRequest::CopyFrom(const DropRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.DropRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropRequest::IsInitialized() const {
  return true;
}

void DropRequest::InternalSwap(DropRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flow_id_, other->_impl_.flow_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DropRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[7]);
}

// ===================================================================

class TaskId::_Internal {
 public:
};

TaskId::TaskId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:greptime.v1.flow.TaskId)
}
TaskId::TaskId(const TaskId& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TaskId* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:greptime.v1.flow.TaskId)
}

inline void TaskId::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TaskId::~TaskId() {
  // @@protoc_insertion_point(destructor:greptime.v1.flow.TaskId)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TaskId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TaskId::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TaskId::Clear() {
// @@protoc_insertion_point(message_clear_start:greptime.v1.flow.TaskId)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TaskId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TaskId::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:greptime.v1.flow.TaskId)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:greptime.v1.flow.TaskId)
  return target;
}

size_t TaskId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:greptime.v1.flow.TaskId)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TaskId::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TaskId::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TaskId::GetClassData() const { return &_class_data_; }


void TaskId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TaskId*>(&to_msg);
  auto& from = static_cast<const TaskId&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:greptime.v1.flow.TaskId)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TaskId::CopyFrom(const TaskId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:greptime.v1.flow.TaskId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskId::IsInitialized() const {
  return true;
}

void TaskId::InternalSwap(TaskId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TaskId::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_getter, &descriptor_table_greptime_2fv1_2fflow_2fserver_2eproto_once,
      file_level_metadata_greptime_2fv1_2fflow_2fserver_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace flow
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequests*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequests >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::InsertRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::InsertRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::InsertRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse_ExtensionEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::FlowResponse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::FlowResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::FlowResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::CreateRequest_TaskOptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::CreateRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::CreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::CreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::DropRequest*
Arena::CreateMaybeMessage< ::greptime::v1::flow::DropRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::DropRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::greptime::v1::flow::TaskId*
Arena::CreateMaybeMessage< ::greptime::v1::flow::TaskId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::greptime::v1::flow::TaskId >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
