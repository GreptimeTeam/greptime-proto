// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fcommon_2eproto;
namespace greptime {
namespace v1 {
class AffectedRows;
struct AffectedRowsDefaultTypeInternal;
extern AffectedRowsDefaultTypeInternal _AffectedRows_default_instance_;
class AuthHeader;
struct AuthHeaderDefaultTypeInternal;
extern AuthHeaderDefaultTypeInternal _AuthHeader_default_instance_;
class Basic;
struct BasicDefaultTypeInternal;
extern BasicDefaultTypeInternal _Basic_default_instance_;
class ColumnDataTypeExtension;
struct ColumnDataTypeExtensionDefaultTypeInternal;
extern ColumnDataTypeExtensionDefaultTypeInternal _ColumnDataTypeExtension_default_instance_;
class ColumnOptions;
struct ColumnOptionsDefaultTypeInternal;
extern ColumnOptionsDefaultTypeInternal _ColumnOptions_default_instance_;
class ColumnOptions_OptionsEntry_DoNotUse;
struct ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal;
extern ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal _ColumnOptions_OptionsEntry_DoNotUse_default_instance_;
class Decimal128;
struct Decimal128DefaultTypeInternal;
extern Decimal128DefaultTypeInternal _Decimal128_default_instance_;
class DecimalTypeExtension;
struct DecimalTypeExtensionDefaultTypeInternal;
extern DecimalTypeExtensionDefaultTypeInternal _DecimalTypeExtension_default_instance_;
class ExpireAfter;
struct ExpireAfterDefaultTypeInternal;
extern ExpireAfterDefaultTypeInternal _ExpireAfter_default_instance_;
class FlightMetadata;
struct FlightMetadataDefaultTypeInternal;
extern FlightMetadataDefaultTypeInternal _FlightMetadata_default_instance_;
class IntervalMonthDayNano;
struct IntervalMonthDayNanoDefaultTypeInternal;
extern IntervalMonthDayNanoDefaultTypeInternal _IntervalMonthDayNano_default_instance_;
class Metrics;
struct MetricsDefaultTypeInternal;
extern MetricsDefaultTypeInternal _Metrics_default_instance_;
class QueryContext;
struct QueryContextDefaultTypeInternal;
extern QueryContextDefaultTypeInternal _QueryContext_default_instance_;
class QueryContext_ExtensionsEntry_DoNotUse;
struct QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal _QueryContext_ExtensionsEntry_DoNotUse_default_instance_;
class RequestHeader;
struct RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class RequestHeader_TracingContextEntry_DoNotUse;
struct RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal;
extern RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _RequestHeader_TracingContextEntry_DoNotUse_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class TableName;
struct TableNameDefaultTypeInternal;
extern TableNameDefaultTypeInternal _TableName_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::AffectedRows* Arena::CreateMaybeMessage<::greptime::v1::AffectedRows>(Arena*);
template<> ::greptime::v1::AuthHeader* Arena::CreateMaybeMessage<::greptime::v1::AuthHeader>(Arena*);
template<> ::greptime::v1::Basic* Arena::CreateMaybeMessage<::greptime::v1::Basic>(Arena*);
template<> ::greptime::v1::ColumnDataTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(Arena*);
template<> ::greptime::v1::ColumnOptions* Arena::CreateMaybeMessage<::greptime::v1::ColumnOptions>(Arena*);
template<> ::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::Decimal128* Arena::CreateMaybeMessage<::greptime::v1::Decimal128>(Arena*);
template<> ::greptime::v1::DecimalTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::DecimalTypeExtension>(Arena*);
template<> ::greptime::v1::ExpireAfter* Arena::CreateMaybeMessage<::greptime::v1::ExpireAfter>(Arena*);
template<> ::greptime::v1::FlightMetadata* Arena::CreateMaybeMessage<::greptime::v1::FlightMetadata>(Arena*);
template<> ::greptime::v1::IntervalMonthDayNano* Arena::CreateMaybeMessage<::greptime::v1::IntervalMonthDayNano>(Arena*);
template<> ::greptime::v1::Metrics* Arena::CreateMaybeMessage<::greptime::v1::Metrics>(Arena*);
template<> ::greptime::v1::QueryContext* Arena::CreateMaybeMessage<::greptime::v1::QueryContext>(Arena*);
template<> ::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::RequestHeader* Arena::CreateMaybeMessage<::greptime::v1::RequestHeader>(Arena*);
template<> ::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::ResponseHeader* Arena::CreateMaybeMessage<::greptime::v1::ResponseHeader>(Arena*);
template<> ::greptime::v1::Status* Arena::CreateMaybeMessage<::greptime::v1::Status>(Arena*);
template<> ::greptime::v1::TableName* Arena::CreateMaybeMessage<::greptime::v1::TableName>(Arena*);
template<> ::greptime::v1::Token* Arena::CreateMaybeMessage<::greptime::v1::Token>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {

enum SemanticType : int {
  TAG = 0,
  FIELD = 1,
  TIMESTAMP = 2,
  SemanticType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SemanticType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SemanticType_IsValid(int value);
constexpr SemanticType SemanticType_MIN = TAG;
constexpr SemanticType SemanticType_MAX = TIMESTAMP;
constexpr int SemanticType_ARRAYSIZE = SemanticType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SemanticType_descriptor();
template<typename T>
inline const std::string& SemanticType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SemanticType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SemanticType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SemanticType_descriptor(), enum_t_value);
}
inline bool SemanticType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SemanticType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SemanticType>(
    SemanticType_descriptor(), name, value);
}
enum ColumnDataType : int {
  BOOLEAN = 0,
  INT8 = 1,
  INT16 = 2,
  INT32 = 3,
  INT64 = 4,
  UINT8 = 5,
  UINT16 = 6,
  UINT32 = 7,
  UINT64 = 8,
  FLOAT32 = 9,
  FLOAT64 = 10,
  BINARY = 11,
  STRING = 12,
  DATE = 13,
  DATETIME = 14,
  TIMESTAMP_SECOND = 15,
  TIMESTAMP_MILLISECOND = 16,
  TIMESTAMP_MICROSECOND = 17,
  TIMESTAMP_NANOSECOND = 18,
  TIME_SECOND = 19,
  TIME_MILLISECOND = 20,
  TIME_MICROSECOND = 21,
  TIME_NANOSECOND = 22,
  INTERVAL_YEAR_MONTH = 23,
  INTERVAL_DAY_TIME = 24,
  INTERVAL_MONTH_DAY_NANO = 25,
  DECIMAL128 = 30,
  JSON = 31,
  ColumnDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ColumnDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ColumnDataType_IsValid(int value);
constexpr ColumnDataType ColumnDataType_MIN = BOOLEAN;
constexpr ColumnDataType ColumnDataType_MAX = JSON;
constexpr int ColumnDataType_ARRAYSIZE = ColumnDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnDataType_descriptor();
template<typename T>
inline const std::string& ColumnDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColumnDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColumnDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColumnDataType_descriptor(), enum_t_value);
}
inline bool ColumnDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnDataType>(
    ColumnDataType_descriptor(), name, value);
}
enum JsonTypeExtension : int {
  JSON_BINARY = 0,
  JsonTypeExtension_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JsonTypeExtension_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JsonTypeExtension_IsValid(int value);
constexpr JsonTypeExtension JsonTypeExtension_MIN = JSON_BINARY;
constexpr JsonTypeExtension JsonTypeExtension_MAX = JSON_BINARY;
constexpr int JsonTypeExtension_ARRAYSIZE = JsonTypeExtension_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JsonTypeExtension_descriptor();
template<typename T>
inline const std::string& JsonTypeExtension_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JsonTypeExtension>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JsonTypeExtension_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JsonTypeExtension_descriptor(), enum_t_value);
}
inline bool JsonTypeExtension_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JsonTypeExtension* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JsonTypeExtension>(
    JsonTypeExtension_descriptor(), name, value);
}
// ===================================================================

class QueryContext_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryContext_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryContext_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  QueryContext_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR QueryContext_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueryContext_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueryContext_ExtensionsEntry_DoNotUse& other);
  static const QueryContext_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryContext_ExtensionsEntry_DoNotUse*>(&_QueryContext_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.QueryContext.ExtensionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.QueryContext.ExtensionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class QueryContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.QueryContext) */ {
 public:
  inline QueryContext() : QueryContext(nullptr) {}
  ~QueryContext() override;
  explicit PROTOBUF_CONSTEXPR QueryContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryContext(const QueryContext& from);
  QueryContext(QueryContext&& from) noexcept
    : QueryContext() {
    *this = ::std::move(from);
  }

  inline QueryContext& operator=(const QueryContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryContext& operator=(QueryContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryContext* internal_default_instance() {
    return reinterpret_cast<const QueryContext*>(
               &_QueryContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryContext& a, QueryContext& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryContext& from) {
    QueryContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.QueryContext";
  }
  protected:
  explicit QueryContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 5,
    kCurrentCatalogFieldNumber = 1,
    kCurrentSchemaFieldNumber = 2,
    kTimezoneFieldNumber = 4,
    kChannelFieldNumber = 6,
  };
  // map<string, string> extensions = 5;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extensions();

  // string current_catalog = 1;
  void clear_current_catalog();
  const std::string& current_catalog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_catalog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_catalog();
  PROTOBUF_NODISCARD std::string* release_current_catalog();
  void set_allocated_current_catalog(std::string* current_catalog);
  private:
  const std::string& _internal_current_catalog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_catalog(const std::string& value);
  std::string* _internal_mutable_current_catalog();
  public:

  // string current_schema = 2;
  void clear_current_schema();
  const std::string& current_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_schema();
  PROTOBUF_NODISCARD std::string* release_current_schema();
  void set_allocated_current_schema(std::string* current_schema);
  private:
  const std::string& _internal_current_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_schema(const std::string& value);
  std::string* _internal_mutable_current_schema();
  public:

  // string timezone = 4;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // uint32 channel = 6;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.QueryContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        QueryContext_ExtensionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_catalog_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    uint32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class RequestHeader_TracingContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RequestHeader_TracingContextEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RequestHeader_TracingContextEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RequestHeader_TracingContextEntry_DoNotUse& other);
  static const RequestHeader_TracingContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RequestHeader_TracingContextEntry_DoNotUse*>(&_RequestHeader_TracingContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.RequestHeader.TracingContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.RequestHeader.TracingContextEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class RequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  ~RequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestHeader& from) {
    RequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTracingContextFieldNumber = 5,
    kCatalogFieldNumber = 1,
    kSchemaFieldNumber = 2,
    kDbnameFieldNumber = 4,
    kTimezoneFieldNumber = 6,
    kAuthorizationFieldNumber = 3,
  };
  // map<string, string> tracing_context = 5;
  int tracing_context_size() const;
  private:
  int _internal_tracing_context_size() const;
  public:
  void clear_tracing_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tracing_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tracing_context();

  // string catalog = 1;
  void clear_catalog();
  const std::string& catalog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog();
  PROTOBUF_NODISCARD std::string* release_catalog();
  void set_allocated_catalog(std::string* catalog);
  private:
  const std::string& _internal_catalog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();
  public:

  // string schema = 2;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // string dbname = 4;
  void clear_dbname();
  const std::string& dbname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* dbname);
  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(const std::string& value);
  std::string* _internal_mutable_dbname();
  public:

  // string timezone = 6;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // .greptime.v1.AuthHeader authorization = 3;
  bool has_authorization() const;
  private:
  bool _internal_has_authorization() const;
  public:
  void clear_authorization();
  const ::greptime::v1::AuthHeader& authorization() const;
  PROTOBUF_NODISCARD ::greptime::v1::AuthHeader* release_authorization();
  ::greptime::v1::AuthHeader* mutable_authorization();
  void set_allocated_authorization(::greptime::v1::AuthHeader* authorization);
  private:
  const ::greptime::v1::AuthHeader& _internal_authorization() const;
  ::greptime::v1::AuthHeader* _internal_mutable_authorization();
  public:
  void unsafe_arena_set_allocated_authorization(
      ::greptime::v1::AuthHeader* authorization);
  ::greptime::v1::AuthHeader* unsafe_arena_release_authorization();

  // @@protoc_insertion_point(class_scope:greptime.v1.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RequestHeader_TracingContextEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tracing_context_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    ::greptime::v1::AuthHeader* authorization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  ~ResponseHeader() override;
  explicit PROTOBUF_CONSTEXPR ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseHeader& from) {
    ResponseHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .greptime.v1.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::greptime::v1::Status& status() const;
  PROTOBUF_NODISCARD ::greptime::v1::Status* release_status();
  ::greptime::v1::Status* mutable_status();
  void set_allocated_status(::greptime::v1::Status* status);
  private:
  const ::greptime::v1::Status& _internal_status() const;
  ::greptime::v1::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::greptime::v1::Status* status);
  ::greptime::v1::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:greptime.v1.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string err_msg = 2;
  void clear_err_msg();
  const std::string& err_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_msg();
  PROTOBUF_NODISCARD std::string* release_err_msg();
  void set_allocated_err_msg(std::string* err_msg);
  private:
  const std::string& _internal_err_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_msg(const std::string& value);
  std::string* _internal_mutable_err_msg();
  public:

  // uint32 status_code = 1;
  void clear_status_code();
  uint32_t status_code() const;
  void set_status_code(uint32_t value);
  private:
  uint32_t _internal_status_code() const;
  void _internal_set_status_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_msg_;
    uint32_t status_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class AuthHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AuthHeader) */ {
 public:
  inline AuthHeader() : AuthHeader(nullptr) {}
  ~AuthHeader() override;
  explicit PROTOBUF_CONSTEXPR AuthHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthHeader(const AuthHeader& from);
  AuthHeader(AuthHeader&& from) noexcept
    : AuthHeader() {
    *this = ::std::move(from);
  }

  inline AuthHeader& operator=(const AuthHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthHeader& operator=(AuthHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthHeader& default_instance() {
    return *internal_default_instance();
  }
  enum AuthSchemeCase {
    kBasic = 1,
    kToken = 2,
    AUTH_SCHEME_NOT_SET = 0,
  };

  static inline const AuthHeader* internal_default_instance() {
    return reinterpret_cast<const AuthHeader*>(
               &_AuthHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AuthHeader& a, AuthHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthHeader& from) {
    AuthHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AuthHeader";
  }
  protected:
  explicit AuthHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // .greptime.v1.Basic basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::greptime::v1::Basic& basic() const;
  PROTOBUF_NODISCARD ::greptime::v1::Basic* release_basic();
  ::greptime::v1::Basic* mutable_basic();
  void set_allocated_basic(::greptime::v1::Basic* basic);
  private:
  const ::greptime::v1::Basic& _internal_basic() const;
  ::greptime::v1::Basic* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::greptime::v1::Basic* basic);
  ::greptime::v1::Basic* unsafe_arena_release_basic();

  // .greptime.v1.Token token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::greptime::v1::Token& token() const;
  PROTOBUF_NODISCARD ::greptime::v1::Token* release_token();
  ::greptime::v1::Token* mutable_token();
  void set_allocated_token(::greptime::v1::Token* token);
  private:
  const ::greptime::v1::Token& _internal_token() const;
  ::greptime::v1::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::greptime::v1::Token* token);
  ::greptime::v1::Token* unsafe_arena_release_token();

  void clear_auth_scheme();
  AuthSchemeCase auth_scheme_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.AuthHeader)
 private:
  class _Internal;
  void set_has_basic();
  void set_has_token();

  inline bool has_auth_scheme() const;
  inline void clear_has_auth_scheme();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union AuthSchemeUnion {
      constexpr AuthSchemeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::Basic* basic_;
      ::greptime::v1::Token* token_;
    } auth_scheme_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Basic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Basic) */ {
 public:
  inline Basic() : Basic(nullptr) {}
  ~Basic() override;
  explicit PROTOBUF_CONSTEXPR Basic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Basic(const Basic& from);
  Basic(Basic&& from) noexcept
    : Basic() {
    *this = ::std::move(from);
  }

  inline Basic& operator=(const Basic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Basic& operator=(Basic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Basic& default_instance() {
    return *internal_default_instance();
  }
  static inline const Basic* internal_default_instance() {
    return reinterpret_cast<const Basic*>(
               &_Basic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Basic& a, Basic& b) {
    a.Swap(&b);
  }
  inline void Swap(Basic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Basic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Basic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Basic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Basic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Basic& from) {
    Basic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Basic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Basic";
  }
  protected:
  explicit Basic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Basic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TableName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TableName) */ {
 public:
  inline TableName() : TableName(nullptr) {}
  ~TableName() override;
  explicit PROTOBUF_CONSTEXPR TableName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableName(const TableName& from);
  TableName(TableName&& from) noexcept
    : TableName() {
    *this = ::std::move(from);
  }

  inline TableName& operator=(const TableName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableName& operator=(TableName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableName& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableName* internal_default_instance() {
    return reinterpret_cast<const TableName*>(
               &_TableName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TableName& a, TableName& b) {
    a.Swap(&b);
  }
  inline void Swap(TableName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableName& from) {
    TableName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TableName";
  }
  protected:
  explicit TableName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TableName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class AffectedRows final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AffectedRows) */ {
 public:
  inline AffectedRows() : AffectedRows(nullptr) {}
  ~AffectedRows() override;
  explicit PROTOBUF_CONSTEXPR AffectedRows(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AffectedRows(const AffectedRows& from);
  AffectedRows(AffectedRows&& from) noexcept
    : AffectedRows() {
    *this = ::std::move(from);
  }

  inline AffectedRows& operator=(const AffectedRows& from) {
    CopyFrom(from);
    return *this;
  }
  inline AffectedRows& operator=(AffectedRows&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AffectedRows& default_instance() {
    return *internal_default_instance();
  }
  static inline const AffectedRows* internal_default_instance() {
    return reinterpret_cast<const AffectedRows*>(
               &_AffectedRows_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AffectedRows& a, AffectedRows& b) {
    a.Swap(&b);
  }
  inline void Swap(AffectedRows* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AffectedRows* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AffectedRows* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AffectedRows>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AffectedRows& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AffectedRows& from) {
    AffectedRows::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AffectedRows* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AffectedRows";
  }
  protected:
  explicit AffectedRows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.AffectedRows)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Metrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Metrics) */ {
 public:
  inline Metrics() : Metrics(nullptr) {}
  ~Metrics() override;
  explicit PROTOBUF_CONSTEXPR Metrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metrics(const Metrics& from);
  Metrics(Metrics&& from) noexcept
    : Metrics() {
    *this = ::std::move(from);
  }

  inline Metrics& operator=(const Metrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metrics& operator=(Metrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metrics* internal_default_instance() {
    return reinterpret_cast<const Metrics*>(
               &_Metrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Metrics& a, Metrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Metrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metrics& from) {
    Metrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Metrics";
  }
  protected:
  explicit Metrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 1,
  };
  // bytes metrics = 1;
  void clear_metrics();
  const std::string& metrics() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metrics(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metrics();
  PROTOBUF_NODISCARD std::string* release_metrics();
  void set_allocated_metrics(std::string* metrics);
  private:
  const std::string& _internal_metrics() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metrics(const std::string& value);
  std::string* _internal_mutable_metrics();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Metrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ExpireAfter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ExpireAfter) */ {
 public:
  inline ExpireAfter() : ExpireAfter(nullptr) {}
  ~ExpireAfter() override;
  explicit PROTOBUF_CONSTEXPR ExpireAfter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpireAfter(const ExpireAfter& from);
  ExpireAfter(ExpireAfter&& from) noexcept
    : ExpireAfter() {
    *this = ::std::move(from);
  }

  inline ExpireAfter& operator=(const ExpireAfter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpireAfter& operator=(ExpireAfter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpireAfter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpireAfter* internal_default_instance() {
    return reinterpret_cast<const ExpireAfter*>(
               &_ExpireAfter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ExpireAfter& a, ExpireAfter& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpireAfter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpireAfter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpireAfter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpireAfter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpireAfter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpireAfter& from) {
    ExpireAfter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpireAfter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ExpireAfter";
  }
  protected:
  explicit ExpireAfter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ExpireAfter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class FlightMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.FlightMetadata) */ {
 public:
  inline FlightMetadata() : FlightMetadata(nullptr) {}
  ~FlightMetadata() override;
  explicit PROTOBUF_CONSTEXPR FlightMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightMetadata(const FlightMetadata& from);
  FlightMetadata(FlightMetadata&& from) noexcept
    : FlightMetadata() {
    *this = ::std::move(from);
  }

  inline FlightMetadata& operator=(const FlightMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightMetadata& operator=(FlightMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightMetadata* internal_default_instance() {
    return reinterpret_cast<const FlightMetadata*>(
               &_FlightMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FlightMetadata& a, FlightMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightMetadata& from) {
    FlightMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.FlightMetadata";
  }
  protected:
  explicit FlightMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedRowsFieldNumber = 1,
    kMetricsFieldNumber = 2,
  };
  // .greptime.v1.AffectedRows affected_rows = 1;
  bool has_affected_rows() const;
  private:
  bool _internal_has_affected_rows() const;
  public:
  void clear_affected_rows();
  const ::greptime::v1::AffectedRows& affected_rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::AffectedRows* release_affected_rows();
  ::greptime::v1::AffectedRows* mutable_affected_rows();
  void set_allocated_affected_rows(::greptime::v1::AffectedRows* affected_rows);
  private:
  const ::greptime::v1::AffectedRows& _internal_affected_rows() const;
  ::greptime::v1::AffectedRows* _internal_mutable_affected_rows();
  public:
  void unsafe_arena_set_allocated_affected_rows(
      ::greptime::v1::AffectedRows* affected_rows);
  ::greptime::v1::AffectedRows* unsafe_arena_release_affected_rows();

  // .greptime.v1.Metrics metrics = 2;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::greptime::v1::Metrics& metrics() const;
  PROTOBUF_NODISCARD ::greptime::v1::Metrics* release_metrics();
  ::greptime::v1::Metrics* mutable_metrics();
  void set_allocated_metrics(::greptime::v1::Metrics* metrics);
  private:
  const ::greptime::v1::Metrics& _internal_metrics() const;
  ::greptime::v1::Metrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::greptime::v1::Metrics* metrics);
  ::greptime::v1::Metrics* unsafe_arena_release_metrics();

  // @@protoc_insertion_point(class_scope:greptime.v1.FlightMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::AffectedRows* affected_rows_;
    ::greptime::v1::Metrics* metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class IntervalMonthDayNano final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.IntervalMonthDayNano) */ {
 public:
  inline IntervalMonthDayNano() : IntervalMonthDayNano(nullptr) {}
  ~IntervalMonthDayNano() override;
  explicit PROTOBUF_CONSTEXPR IntervalMonthDayNano(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntervalMonthDayNano(const IntervalMonthDayNano& from);
  IntervalMonthDayNano(IntervalMonthDayNano&& from) noexcept
    : IntervalMonthDayNano() {
    *this = ::std::move(from);
  }

  inline IntervalMonthDayNano& operator=(const IntervalMonthDayNano& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntervalMonthDayNano& operator=(IntervalMonthDayNano&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntervalMonthDayNano& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntervalMonthDayNano* internal_default_instance() {
    return reinterpret_cast<const IntervalMonthDayNano*>(
               &_IntervalMonthDayNano_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IntervalMonthDayNano& a, IntervalMonthDayNano& b) {
    a.Swap(&b);
  }
  inline void Swap(IntervalMonthDayNano* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntervalMonthDayNano* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntervalMonthDayNano* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntervalMonthDayNano>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntervalMonthDayNano& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntervalMonthDayNano& from) {
    IntervalMonthDayNano::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntervalMonthDayNano* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.IntervalMonthDayNano";
  }
  protected:
  explicit IntervalMonthDayNano(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonthsFieldNumber = 1,
    kDaysFieldNumber = 2,
    kNanosecondsFieldNumber = 3,
  };
  // int32 months = 1;
  void clear_months();
  int32_t months() const;
  void set_months(int32_t value);
  private:
  int32_t _internal_months() const;
  void _internal_set_months(int32_t value);
  public:

  // int32 days = 2;
  void clear_days();
  int32_t days() const;
  void set_days(int32_t value);
  private:
  int32_t _internal_days() const;
  void _internal_set_days(int32_t value);
  public:

  // int64 nanoseconds = 3;
  void clear_nanoseconds();
  int64_t nanoseconds() const;
  void set_nanoseconds(int64_t value);
  private:
  int64_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.IntervalMonthDayNano)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t months_;
    int32_t days_;
    int64_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Decimal128 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Decimal128) */ {
 public:
  inline Decimal128() : Decimal128(nullptr) {}
  ~Decimal128() override;
  explicit PROTOBUF_CONSTEXPR Decimal128(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Decimal128(const Decimal128& from);
  Decimal128(Decimal128&& from) noexcept
    : Decimal128() {
    *this = ::std::move(from);
  }

  inline Decimal128& operator=(const Decimal128& from) {
    CopyFrom(from);
    return *this;
  }
  inline Decimal128& operator=(Decimal128&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Decimal128& default_instance() {
    return *internal_default_instance();
  }
  static inline const Decimal128* internal_default_instance() {
    return reinterpret_cast<const Decimal128*>(
               &_Decimal128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Decimal128& a, Decimal128& b) {
    a.Swap(&b);
  }
  inline void Swap(Decimal128* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Decimal128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Decimal128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Decimal128>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Decimal128& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Decimal128& from) {
    Decimal128::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Decimal128* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Decimal128";
  }
  protected:
  explicit Decimal128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // int64 hi = 1;
  void clear_hi();
  int64_t hi() const;
  void set_hi(int64_t value);
  private:
  int64_t _internal_hi() const;
  void _internal_set_hi(int64_t value);
  public:

  // int64 lo = 2;
  void clear_lo();
  int64_t lo() const;
  void set_lo(int64_t value);
  private:
  int64_t _internal_lo() const;
  void _internal_set_lo(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Decimal128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t hi_;
    int64_t lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColumnDataTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnDataTypeExtension) */ {
 public:
  inline ColumnDataTypeExtension() : ColumnDataTypeExtension(nullptr) {}
  ~ColumnDataTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR ColumnDataTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDataTypeExtension(const ColumnDataTypeExtension& from);
  ColumnDataTypeExtension(ColumnDataTypeExtension&& from) noexcept
    : ColumnDataTypeExtension() {
    *this = ::std::move(from);
  }

  inline ColumnDataTypeExtension& operator=(const ColumnDataTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDataTypeExtension& operator=(ColumnDataTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDataTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  enum TypeExtCase {
    kDecimalType = 1,
    kJsonType = 2,
    TYPE_EXT_NOT_SET = 0,
  };

  static inline const ColumnDataTypeExtension* internal_default_instance() {
    return reinterpret_cast<const ColumnDataTypeExtension*>(
               &_ColumnDataTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ColumnDataTypeExtension& a, ColumnDataTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDataTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDataTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDataTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDataTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDataTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDataTypeExtension& from) {
    ColumnDataTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDataTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnDataTypeExtension";
  }
  protected:
  explicit ColumnDataTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecimalTypeFieldNumber = 1,
    kJsonTypeFieldNumber = 2,
  };
  // .greptime.v1.DecimalTypeExtension decimal_type = 1;
  bool has_decimal_type() const;
  private:
  bool _internal_has_decimal_type() const;
  public:
  void clear_decimal_type();
  const ::greptime::v1::DecimalTypeExtension& decimal_type() const;
  PROTOBUF_NODISCARD ::greptime::v1::DecimalTypeExtension* release_decimal_type();
  ::greptime::v1::DecimalTypeExtension* mutable_decimal_type();
  void set_allocated_decimal_type(::greptime::v1::DecimalTypeExtension* decimal_type);
  private:
  const ::greptime::v1::DecimalTypeExtension& _internal_decimal_type() const;
  ::greptime::v1::DecimalTypeExtension* _internal_mutable_decimal_type();
  public:
  void unsafe_arena_set_allocated_decimal_type(
      ::greptime::v1::DecimalTypeExtension* decimal_type);
  ::greptime::v1::DecimalTypeExtension* unsafe_arena_release_decimal_type();

  // .greptime.v1.JsonTypeExtension json_type = 2;
  bool has_json_type() const;
  private:
  bool _internal_has_json_type() const;
  public:
  void clear_json_type();
  ::greptime::v1::JsonTypeExtension json_type() const;
  void set_json_type(::greptime::v1::JsonTypeExtension value);
  private:
  ::greptime::v1::JsonTypeExtension _internal_json_type() const;
  void _internal_set_json_type(::greptime::v1::JsonTypeExtension value);
  public:

  void clear_type_ext();
  TypeExtCase type_ext_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnDataTypeExtension)
 private:
  class _Internal;
  void set_has_decimal_type();
  void set_has_json_type();

  inline bool has_type_ext() const;
  inline void clear_has_type_ext();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeExtUnion {
      constexpr TypeExtUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::DecimalTypeExtension* decimal_type_;
      int json_type_;
    } type_ext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DecimalTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DecimalTypeExtension) */ {
 public:
  inline DecimalTypeExtension() : DecimalTypeExtension(nullptr) {}
  ~DecimalTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR DecimalTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecimalTypeExtension(const DecimalTypeExtension& from);
  DecimalTypeExtension(DecimalTypeExtension&& from) noexcept
    : DecimalTypeExtension() {
    *this = ::std::move(from);
  }

  inline DecimalTypeExtension& operator=(const DecimalTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecimalTypeExtension& operator=(DecimalTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecimalTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecimalTypeExtension* internal_default_instance() {
    return reinterpret_cast<const DecimalTypeExtension*>(
               &_DecimalTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DecimalTypeExtension& a, DecimalTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(DecimalTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecimalTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecimalTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecimalTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecimalTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DecimalTypeExtension& from) {
    DecimalTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecimalTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DecimalTypeExtension";
  }
  protected:
  explicit DecimalTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrecisionFieldNumber = 1,
    kScaleFieldNumber = 2,
  };
  // int32 precision = 1;
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // int32 scale = 2;
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DecimalTypeExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t precision_;
    int32_t scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColumnOptions_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ColumnOptions_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ColumnOptions_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ColumnOptions_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ColumnOptions_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ColumnOptions_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ColumnOptions_OptionsEntry_DoNotUse& other);
  static const ColumnOptions_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ColumnOptions_OptionsEntry_DoNotUse*>(&_ColumnOptions_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.ColumnOptions.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.ColumnOptions.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class ColumnOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnOptions) */ {
 public:
  inline ColumnOptions() : ColumnOptions(nullptr) {}
  ~ColumnOptions() override;
  explicit PROTOBUF_CONSTEXPR ColumnOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnOptions(const ColumnOptions& from);
  ColumnOptions(ColumnOptions&& from) noexcept
    : ColumnOptions() {
    *this = ::std::move(from);
  }

  inline ColumnOptions& operator=(const ColumnOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnOptions& operator=(ColumnOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnOptions* internal_default_instance() {
    return reinterpret_cast<const ColumnOptions*>(
               &_ColumnOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ColumnOptions& a, ColumnOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnOptions& from) {
    ColumnOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnOptions";
  }
  protected:
  explicit ColumnOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
  };
  // map<string, string> options = 1;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ColumnOptions_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// QueryContext

// string current_catalog = 1;
inline void QueryContext::clear_current_catalog() {
  _impl_.current_catalog_.ClearToEmpty();
}
inline const std::string& QueryContext::current_catalog() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.current_catalog)
  return _internal_current_catalog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryContext::set_current_catalog(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_catalog_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.current_catalog)
}
inline std::string* QueryContext::mutable_current_catalog() {
  std::string* _s = _internal_mutable_current_catalog();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.current_catalog)
  return _s;
}
inline const std::string& QueryContext::_internal_current_catalog() const {
  return _impl_.current_catalog_.Get();
}
inline void QueryContext::_internal_set_current_catalog(const std::string& value) {
  
  _impl_.current_catalog_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContext::_internal_mutable_current_catalog() {
  
  return _impl_.current_catalog_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryContext::release_current_catalog() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.current_catalog)
  return _impl_.current_catalog_.Release();
}
inline void QueryContext::set_allocated_current_catalog(std::string* current_catalog) {
  if (current_catalog != nullptr) {
    
  } else {
    
  }
  _impl_.current_catalog_.SetAllocated(current_catalog, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_catalog_.IsDefault()) {
    _impl_.current_catalog_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.current_catalog)
}

// string current_schema = 2;
inline void QueryContext::clear_current_schema() {
  _impl_.current_schema_.ClearToEmpty();
}
inline const std::string& QueryContext::current_schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.current_schema)
  return _internal_current_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryContext::set_current_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.current_schema)
}
inline std::string* QueryContext::mutable_current_schema() {
  std::string* _s = _internal_mutable_current_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.current_schema)
  return _s;
}
inline const std::string& QueryContext::_internal_current_schema() const {
  return _impl_.current_schema_.Get();
}
inline void QueryContext::_internal_set_current_schema(const std::string& value) {
  
  _impl_.current_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContext::_internal_mutable_current_schema() {
  
  return _impl_.current_schema_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryContext::release_current_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.current_schema)
  return _impl_.current_schema_.Release();
}
inline void QueryContext::set_allocated_current_schema(std::string* current_schema) {
  if (current_schema != nullptr) {
    
  } else {
    
  }
  _impl_.current_schema_.SetAllocated(current_schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_schema_.IsDefault()) {
    _impl_.current_schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.current_schema)
}

// string timezone = 4;
inline void QueryContext::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& QueryContext::timezone() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryContext::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.timezone)
}
inline std::string* QueryContext::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.timezone)
  return _s;
}
inline const std::string& QueryContext::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void QueryContext::_internal_set_timezone(const std::string& value) {
  
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContext::_internal_mutable_timezone() {
  
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryContext::release_timezone() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.timezone)
  return _impl_.timezone_.Release();
}
inline void QueryContext::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.timezone)
}

// map<string, string> extensions = 5;
inline int QueryContext::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int QueryContext::extensions_size() const {
  return _internal_extensions_size();
}
inline void QueryContext::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueryContext::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueryContext::extensions() const {
  // @@protoc_insertion_point(field_map:greptime.v1.QueryContext.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueryContext::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueryContext::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.QueryContext.extensions)
  return _internal_mutable_extensions();
}

// uint32 channel = 6;
inline void QueryContext::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t QueryContext::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t QueryContext::channel() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.channel)
  return _internal_channel();
}
inline void QueryContext::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void QueryContext::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.channel)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RequestHeader

// string catalog = 1;
inline void RequestHeader::clear_catalog() {
  _impl_.catalog_.ClearToEmpty();
}
inline const std::string& RequestHeader::catalog() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.catalog)
  return _internal_catalog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_catalog(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.catalog)
}
inline std::string* RequestHeader::mutable_catalog() {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.catalog)
  return _s;
}
inline const std::string& RequestHeader::_internal_catalog() const {
  return _impl_.catalog_.Get();
}
inline void RequestHeader::_internal_set_catalog(const std::string& value) {
  
  _impl_.catalog_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_catalog() {
  
  return _impl_.catalog_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_catalog() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.catalog)
  return _impl_.catalog_.Release();
}
inline void RequestHeader::set_allocated_catalog(std::string* catalog) {
  if (catalog != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_.SetAllocated(catalog, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.catalog)
}

// string schema = 2;
inline void RequestHeader::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& RequestHeader::schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.schema)
}
inline std::string* RequestHeader::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.schema)
  return _s;
}
inline const std::string& RequestHeader::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void RequestHeader::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.schema)
  return _impl_.schema_.Release();
}
inline void RequestHeader::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.schema)
}

// .greptime.v1.AuthHeader authorization = 3;
inline bool RequestHeader::_internal_has_authorization() const {
  return this != internal_default_instance() && _impl_.authorization_ != nullptr;
}
inline bool RequestHeader::has_authorization() const {
  return _internal_has_authorization();
}
inline void RequestHeader::clear_authorization() {
  if (GetArenaForAllocation() == nullptr && _impl_.authorization_ != nullptr) {
    delete _impl_.authorization_;
  }
  _impl_.authorization_ = nullptr;
}
inline const ::greptime::v1::AuthHeader& RequestHeader::_internal_authorization() const {
  const ::greptime::v1::AuthHeader* p = _impl_.authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AuthHeader&>(
      ::greptime::v1::_AuthHeader_default_instance_);
}
inline const ::greptime::v1::AuthHeader& RequestHeader::authorization() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.authorization)
  return _internal_authorization();
}
inline void RequestHeader::unsafe_arena_set_allocated_authorization(
    ::greptime::v1::AuthHeader* authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authorization_);
  }
  _impl_.authorization_ = authorization;
  if (authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.RequestHeader.authorization)
}
inline ::greptime::v1::AuthHeader* RequestHeader::release_authorization() {
  
  ::greptime::v1::AuthHeader* temp = _impl_.authorization_;
  _impl_.authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AuthHeader* RequestHeader::unsafe_arena_release_authorization() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.authorization)
  
  ::greptime::v1::AuthHeader* temp = _impl_.authorization_;
  _impl_.authorization_ = nullptr;
  return temp;
}
inline ::greptime::v1::AuthHeader* RequestHeader::_internal_mutable_authorization() {
  
  if (_impl_.authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AuthHeader>(GetArenaForAllocation());
    _impl_.authorization_ = p;
  }
  return _impl_.authorization_;
}
inline ::greptime::v1::AuthHeader* RequestHeader::mutable_authorization() {
  ::greptime::v1::AuthHeader* _msg = _internal_mutable_authorization();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.authorization)
  return _msg;
}
inline void RequestHeader::set_allocated_authorization(::greptime::v1::AuthHeader* authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authorization_;
  }
  if (authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization);
    if (message_arena != submessage_arena) {
      authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.authorization_ = authorization;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.authorization)
}

// string dbname = 4;
inline void RequestHeader::clear_dbname() {
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& RequestHeader::dbname() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.dbname)
  return _internal_dbname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_dbname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dbname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.dbname)
}
inline std::string* RequestHeader::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.dbname)
  return _s;
}
inline const std::string& RequestHeader::_internal_dbname() const {
  return _impl_.dbname_.Get();
}
inline void RequestHeader::_internal_set_dbname(const std::string& value) {
  
  _impl_.dbname_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_dbname() {
  
  return _impl_.dbname_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_dbname() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.dbname)
  return _impl_.dbname_.Release();
}
inline void RequestHeader::set_allocated_dbname(std::string* dbname) {
  if (dbname != nullptr) {
    
  } else {
    
  }
  _impl_.dbname_.SetAllocated(dbname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dbname_.IsDefault()) {
    _impl_.dbname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.dbname)
}

// map<string, string> tracing_context = 5;
inline int RequestHeader::_internal_tracing_context_size() const {
  return _impl_.tracing_context_.size();
}
inline int RequestHeader::tracing_context_size() const {
  return _internal_tracing_context_size();
}
inline void RequestHeader::clear_tracing_context() {
  _impl_.tracing_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestHeader::_internal_tracing_context() const {
  return _impl_.tracing_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestHeader::tracing_context() const {
  // @@protoc_insertion_point(field_map:greptime.v1.RequestHeader.tracing_context)
  return _internal_tracing_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestHeader::_internal_mutable_tracing_context() {
  return _impl_.tracing_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestHeader::mutable_tracing_context() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.RequestHeader.tracing_context)
  return _internal_mutable_tracing_context();
}

// string timezone = 6;
inline void RequestHeader::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& RequestHeader::timezone() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.timezone)
}
inline std::string* RequestHeader::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.timezone)
  return _s;
}
inline const std::string& RequestHeader::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void RequestHeader::_internal_set_timezone(const std::string& value) {
  
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_timezone() {
  
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_timezone() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.timezone)
  return _impl_.timezone_.Release();
}
inline void RequestHeader::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.timezone)
}

// -------------------------------------------------------------------

// ResponseHeader

// .greptime.v1.Status status = 1;
inline bool ResponseHeader::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ResponseHeader::has_status() const {
  return _internal_has_status();
}
inline void ResponseHeader::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::greptime::v1::Status& ResponseHeader::_internal_status() const {
  const ::greptime::v1::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Status&>(
      ::greptime::v1::_Status_default_instance_);
}
inline const ::greptime::v1::Status& ResponseHeader::status() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ResponseHeader.status)
  return _internal_status();
}
inline void ResponseHeader::unsafe_arena_set_allocated_status(
    ::greptime::v1::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ResponseHeader.status)
}
inline ::greptime::v1::Status* ResponseHeader::release_status() {
  
  ::greptime::v1::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Status* ResponseHeader::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:greptime.v1.ResponseHeader.status)
  
  ::greptime::v1::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::greptime::v1::Status* ResponseHeader::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::greptime::v1::Status* ResponseHeader::mutable_status() {
  ::greptime::v1::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ResponseHeader.status)
  return _msg;
}
inline void ResponseHeader::set_allocated_status(::greptime::v1::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ResponseHeader.status)
}

// -------------------------------------------------------------------

// Status

// uint32 status_code = 1;
inline void Status::clear_status_code() {
  _impl_.status_code_ = 0u;
}
inline uint32_t Status::_internal_status_code() const {
  return _impl_.status_code_;
}
inline uint32_t Status::status_code() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Status.status_code)
  return _internal_status_code();
}
inline void Status::_internal_set_status_code(uint32_t value) {
  
  _impl_.status_code_ = value;
}
inline void Status::set_status_code(uint32_t value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:greptime.v1.Status.status_code)
}

// string err_msg = 2;
inline void Status::clear_err_msg() {
  _impl_.err_msg_.ClearToEmpty();
}
inline const std::string& Status::err_msg() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Status.err_msg)
  return _internal_err_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_err_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.err_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Status.err_msg)
}
inline std::string* Status::mutable_err_msg() {
  std::string* _s = _internal_mutable_err_msg();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Status.err_msg)
  return _s;
}
inline const std::string& Status::_internal_err_msg() const {
  return _impl_.err_msg_.Get();
}
inline void Status::_internal_set_err_msg(const std::string& value) {
  
  _impl_.err_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_err_msg() {
  
  return _impl_.err_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_err_msg() {
  // @@protoc_insertion_point(field_release:greptime.v1.Status.err_msg)
  return _impl_.err_msg_.Release();
}
inline void Status::set_allocated_err_msg(std::string* err_msg) {
  if (err_msg != nullptr) {
    
  } else {
    
  }
  _impl_.err_msg_.SetAllocated(err_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_msg_.IsDefault()) {
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Status.err_msg)
}

// -------------------------------------------------------------------

// AuthHeader

// .greptime.v1.Basic basic = 1;
inline bool AuthHeader::_internal_has_basic() const {
  return auth_scheme_case() == kBasic;
}
inline bool AuthHeader::has_basic() const {
  return _internal_has_basic();
}
inline void AuthHeader::set_has_basic() {
  _impl_._oneof_case_[0] = kBasic;
}
inline void AuthHeader::clear_basic() {
  if (_internal_has_basic()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.auth_scheme_.basic_;
    }
    clear_has_auth_scheme();
  }
}
inline ::greptime::v1::Basic* AuthHeader::release_basic() {
  // @@protoc_insertion_point(field_release:greptime.v1.AuthHeader.basic)
  if (_internal_has_basic()) {
    clear_has_auth_scheme();
    ::greptime::v1::Basic* temp = _impl_.auth_scheme_.basic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.auth_scheme_.basic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::Basic& AuthHeader::_internal_basic() const {
  return _internal_has_basic()
      ? *_impl_.auth_scheme_.basic_
      : reinterpret_cast< ::greptime::v1::Basic&>(::greptime::v1::_Basic_default_instance_);
}
inline const ::greptime::v1::Basic& AuthHeader::basic() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AuthHeader.basic)
  return _internal_basic();
}
inline ::greptime::v1::Basic* AuthHeader::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AuthHeader.basic)
  if (_internal_has_basic()) {
    clear_has_auth_scheme();
    ::greptime::v1::Basic* temp = _impl_.auth_scheme_.basic_;
    _impl_.auth_scheme_.basic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthHeader::unsafe_arena_set_allocated_basic(::greptime::v1::Basic* basic) {
  clear_auth_scheme();
  if (basic) {
    set_has_basic();
    _impl_.auth_scheme_.basic_ = basic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AuthHeader.basic)
}
inline ::greptime::v1::Basic* AuthHeader::_internal_mutable_basic() {
  if (!_internal_has_basic()) {
    clear_auth_scheme();
    set_has_basic();
    _impl_.auth_scheme_.basic_ = CreateMaybeMessage< ::greptime::v1::Basic >(GetArenaForAllocation());
  }
  return _impl_.auth_scheme_.basic_;
}
inline ::greptime::v1::Basic* AuthHeader::mutable_basic() {
  ::greptime::v1::Basic* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AuthHeader.basic)
  return _msg;
}

// .greptime.v1.Token token = 2;
inline bool AuthHeader::_internal_has_token() const {
  return auth_scheme_case() == kToken;
}
inline bool AuthHeader::has_token() const {
  return _internal_has_token();
}
inline void AuthHeader::set_has_token() {
  _impl_._oneof_case_[0] = kToken;
}
inline void AuthHeader::clear_token() {
  if (_internal_has_token()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.auth_scheme_.token_;
    }
    clear_has_auth_scheme();
  }
}
inline ::greptime::v1::Token* AuthHeader::release_token() {
  // @@protoc_insertion_point(field_release:greptime.v1.AuthHeader.token)
  if (_internal_has_token()) {
    clear_has_auth_scheme();
    ::greptime::v1::Token* temp = _impl_.auth_scheme_.token_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.auth_scheme_.token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::Token& AuthHeader::_internal_token() const {
  return _internal_has_token()
      ? *_impl_.auth_scheme_.token_
      : reinterpret_cast< ::greptime::v1::Token&>(::greptime::v1::_Token_default_instance_);
}
inline const ::greptime::v1::Token& AuthHeader::token() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AuthHeader.token)
  return _internal_token();
}
inline ::greptime::v1::Token* AuthHeader::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AuthHeader.token)
  if (_internal_has_token()) {
    clear_has_auth_scheme();
    ::greptime::v1::Token* temp = _impl_.auth_scheme_.token_;
    _impl_.auth_scheme_.token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthHeader::unsafe_arena_set_allocated_token(::greptime::v1::Token* token) {
  clear_auth_scheme();
  if (token) {
    set_has_token();
    _impl_.auth_scheme_.token_ = token;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AuthHeader.token)
}
inline ::greptime::v1::Token* AuthHeader::_internal_mutable_token() {
  if (!_internal_has_token()) {
    clear_auth_scheme();
    set_has_token();
    _impl_.auth_scheme_.token_ = CreateMaybeMessage< ::greptime::v1::Token >(GetArenaForAllocation());
  }
  return _impl_.auth_scheme_.token_;
}
inline ::greptime::v1::Token* AuthHeader::mutable_token() {
  ::greptime::v1::Token* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AuthHeader.token)
  return _msg;
}

inline bool AuthHeader::has_auth_scheme() const {
  return auth_scheme_case() != AUTH_SCHEME_NOT_SET;
}
inline void AuthHeader::clear_has_auth_scheme() {
  _impl_._oneof_case_[0] = AUTH_SCHEME_NOT_SET;
}
inline AuthHeader::AuthSchemeCase AuthHeader::auth_scheme_case() const {
  return AuthHeader::AuthSchemeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Basic

// string username = 1;
inline void Basic::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Basic::username() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Basic.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Basic::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Basic.username)
}
inline std::string* Basic::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Basic.username)
  return _s;
}
inline const std::string& Basic::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Basic::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Basic::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Basic::release_username() {
  // @@protoc_insertion_point(field_release:greptime.v1.Basic.username)
  return _impl_.username_.Release();
}
inline void Basic::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Basic.username)
}

// string password = 2;
inline void Basic::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Basic::password() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Basic.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Basic::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Basic.password)
}
inline std::string* Basic::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Basic.password)
  return _s;
}
inline const std::string& Basic::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Basic::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Basic::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Basic::release_password() {
  // @@protoc_insertion_point(field_release:greptime.v1.Basic.password)
  return _impl_.password_.Release();
}
inline void Basic::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Basic.password)
}

// -------------------------------------------------------------------

// Token

// string token = 1;
inline void Token::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& Token::token() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Token.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Token.token)
}
inline std::string* Token::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Token.token)
  return _s;
}
inline const std::string& Token::_internal_token() const {
  return _impl_.token_.Get();
}
inline void Token::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_token() {
  // @@protoc_insertion_point(field_release:greptime.v1.Token.token)
  return _impl_.token_.Release();
}
inline void Token::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Token.token)
}

// -------------------------------------------------------------------

// TableName

// string catalog_name = 1;
inline void TableName::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& TableName::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableName.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TableName.catalog_name)
}
inline std::string* TableName::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TableName.catalog_name)
  return _s;
}
inline const std::string& TableName::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void TableName::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableName::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TableName.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void TableName::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TableName.catalog_name)
}

// string schema_name = 2;
inline void TableName::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& TableName::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableName.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TableName.schema_name)
}
inline std::string* TableName::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TableName.schema_name)
  return _s;
}
inline const std::string& TableName::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TableName::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableName::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TableName.schema_name)
  return _impl_.schema_name_.Release();
}
inline void TableName::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TableName.schema_name)
}

// string table_name = 3;
inline void TableName::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& TableName::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableName.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TableName.table_name)
}
inline std::string* TableName::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TableName.table_name)
  return _s;
}
inline const std::string& TableName::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TableName::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableName::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TableName.table_name)
  return _impl_.table_name_.Release();
}
inline void TableName::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TableName.table_name)
}

// -------------------------------------------------------------------

// AffectedRows

// uint32 value = 1;
inline void AffectedRows::clear_value() {
  _impl_.value_ = 0u;
}
inline uint32_t AffectedRows::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t AffectedRows::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AffectedRows.value)
  return _internal_value();
}
inline void AffectedRows::_internal_set_value(uint32_t value) {
  
  _impl_.value_ = value;
}
inline void AffectedRows::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:greptime.v1.AffectedRows.value)
}

// -------------------------------------------------------------------

// Metrics

// bytes metrics = 1;
inline void Metrics::clear_metrics() {
  _impl_.metrics_.ClearToEmpty();
}
inline const std::string& Metrics::metrics() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Metrics.metrics)
  return _internal_metrics();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metrics::set_metrics(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metrics_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Metrics.metrics)
}
inline std::string* Metrics::mutable_metrics() {
  std::string* _s = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Metrics.metrics)
  return _s;
}
inline const std::string& Metrics::_internal_metrics() const {
  return _impl_.metrics_.Get();
}
inline void Metrics::_internal_set_metrics(const std::string& value) {
  
  _impl_.metrics_.Set(value, GetArenaForAllocation());
}
inline std::string* Metrics::_internal_mutable_metrics() {
  
  return _impl_.metrics_.Mutable(GetArenaForAllocation());
}
inline std::string* Metrics::release_metrics() {
  // @@protoc_insertion_point(field_release:greptime.v1.Metrics.metrics)
  return _impl_.metrics_.Release();
}
inline void Metrics::set_allocated_metrics(std::string* metrics) {
  if (metrics != nullptr) {
    
  } else {
    
  }
  _impl_.metrics_.SetAllocated(metrics, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metrics_.IsDefault()) {
    _impl_.metrics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Metrics.metrics)
}

// -------------------------------------------------------------------

// ExpireAfter

// int64 value = 1;
inline void ExpireAfter::clear_value() {
  _impl_.value_ = int64_t{0};
}
inline int64_t ExpireAfter::_internal_value() const {
  return _impl_.value_;
}
inline int64_t ExpireAfter::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ExpireAfter.value)
  return _internal_value();
}
inline void ExpireAfter::_internal_set_value(int64_t value) {
  
  _impl_.value_ = value;
}
inline void ExpireAfter::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ExpireAfter.value)
}

// -------------------------------------------------------------------

// FlightMetadata

// .greptime.v1.AffectedRows affected_rows = 1;
inline bool FlightMetadata::_internal_has_affected_rows() const {
  return this != internal_default_instance() && _impl_.affected_rows_ != nullptr;
}
inline bool FlightMetadata::has_affected_rows() const {
  return _internal_has_affected_rows();
}
inline void FlightMetadata::clear_affected_rows() {
  if (GetArenaForAllocation() == nullptr && _impl_.affected_rows_ != nullptr) {
    delete _impl_.affected_rows_;
  }
  _impl_.affected_rows_ = nullptr;
}
inline const ::greptime::v1::AffectedRows& FlightMetadata::_internal_affected_rows() const {
  const ::greptime::v1::AffectedRows* p = _impl_.affected_rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AffectedRows&>(
      ::greptime::v1::_AffectedRows_default_instance_);
}
inline const ::greptime::v1::AffectedRows& FlightMetadata::affected_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.FlightMetadata.affected_rows)
  return _internal_affected_rows();
}
inline void FlightMetadata::unsafe_arena_set_allocated_affected_rows(
    ::greptime::v1::AffectedRows* affected_rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.affected_rows_);
  }
  _impl_.affected_rows_ = affected_rows;
  if (affected_rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.FlightMetadata.affected_rows)
}
inline ::greptime::v1::AffectedRows* FlightMetadata::release_affected_rows() {
  
  ::greptime::v1::AffectedRows* temp = _impl_.affected_rows_;
  _impl_.affected_rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AffectedRows* FlightMetadata::unsafe_arena_release_affected_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.FlightMetadata.affected_rows)
  
  ::greptime::v1::AffectedRows* temp = _impl_.affected_rows_;
  _impl_.affected_rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::AffectedRows* FlightMetadata::_internal_mutable_affected_rows() {
  
  if (_impl_.affected_rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AffectedRows>(GetArenaForAllocation());
    _impl_.affected_rows_ = p;
  }
  return _impl_.affected_rows_;
}
inline ::greptime::v1::AffectedRows* FlightMetadata::mutable_affected_rows() {
  ::greptime::v1::AffectedRows* _msg = _internal_mutable_affected_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.FlightMetadata.affected_rows)
  return _msg;
}
inline void FlightMetadata::set_allocated_affected_rows(::greptime::v1::AffectedRows* affected_rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.affected_rows_;
  }
  if (affected_rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(affected_rows);
    if (message_arena != submessage_arena) {
      affected_rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affected_rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.affected_rows_ = affected_rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.FlightMetadata.affected_rows)
}

// .greptime.v1.Metrics metrics = 2;
inline bool FlightMetadata::_internal_has_metrics() const {
  return this != internal_default_instance() && _impl_.metrics_ != nullptr;
}
inline bool FlightMetadata::has_metrics() const {
  return _internal_has_metrics();
}
inline void FlightMetadata::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
}
inline const ::greptime::v1::Metrics& FlightMetadata::_internal_metrics() const {
  const ::greptime::v1::Metrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Metrics&>(
      ::greptime::v1::_Metrics_default_instance_);
}
inline const ::greptime::v1::Metrics& FlightMetadata::metrics() const {
  // @@protoc_insertion_point(field_get:greptime.v1.FlightMetadata.metrics)
  return _internal_metrics();
}
inline void FlightMetadata::unsafe_arena_set_allocated_metrics(
    ::greptime::v1::Metrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.FlightMetadata.metrics)
}
inline ::greptime::v1::Metrics* FlightMetadata::release_metrics() {
  
  ::greptime::v1::Metrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Metrics* FlightMetadata::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:greptime.v1.FlightMetadata.metrics)
  
  ::greptime::v1::Metrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::greptime::v1::Metrics* FlightMetadata::_internal_mutable_metrics() {
  
  if (_impl_.metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Metrics>(GetArenaForAllocation());
    _impl_.metrics_ = p;
  }
  return _impl_.metrics_;
}
inline ::greptime::v1::Metrics* FlightMetadata::mutable_metrics() {
  ::greptime::v1::Metrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:greptime.v1.FlightMetadata.metrics)
  return _msg;
}
inline void FlightMetadata::set_allocated_metrics(::greptime::v1::Metrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.FlightMetadata.metrics)
}

// -------------------------------------------------------------------

// IntervalMonthDayNano

// int32 months = 1;
inline void IntervalMonthDayNano::clear_months() {
  _impl_.months_ = 0;
}
inline int32_t IntervalMonthDayNano::_internal_months() const {
  return _impl_.months_;
}
inline int32_t IntervalMonthDayNano::months() const {
  // @@protoc_insertion_point(field_get:greptime.v1.IntervalMonthDayNano.months)
  return _internal_months();
}
inline void IntervalMonthDayNano::_internal_set_months(int32_t value) {
  
  _impl_.months_ = value;
}
inline void IntervalMonthDayNano::set_months(int32_t value) {
  _internal_set_months(value);
  // @@protoc_insertion_point(field_set:greptime.v1.IntervalMonthDayNano.months)
}

// int32 days = 2;
inline void IntervalMonthDayNano::clear_days() {
  _impl_.days_ = 0;
}
inline int32_t IntervalMonthDayNano::_internal_days() const {
  return _impl_.days_;
}
inline int32_t IntervalMonthDayNano::days() const {
  // @@protoc_insertion_point(field_get:greptime.v1.IntervalMonthDayNano.days)
  return _internal_days();
}
inline void IntervalMonthDayNano::_internal_set_days(int32_t value) {
  
  _impl_.days_ = value;
}
inline void IntervalMonthDayNano::set_days(int32_t value) {
  _internal_set_days(value);
  // @@protoc_insertion_point(field_set:greptime.v1.IntervalMonthDayNano.days)
}

// int64 nanoseconds = 3;
inline void IntervalMonthDayNano::clear_nanoseconds() {
  _impl_.nanoseconds_ = int64_t{0};
}
inline int64_t IntervalMonthDayNano::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline int64_t IntervalMonthDayNano::nanoseconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.IntervalMonthDayNano.nanoseconds)
  return _internal_nanoseconds();
}
inline void IntervalMonthDayNano::_internal_set_nanoseconds(int64_t value) {
  
  _impl_.nanoseconds_ = value;
}
inline void IntervalMonthDayNano::set_nanoseconds(int64_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.IntervalMonthDayNano.nanoseconds)
}

// -------------------------------------------------------------------

// Decimal128

// int64 hi = 1;
inline void Decimal128::clear_hi() {
  _impl_.hi_ = int64_t{0};
}
inline int64_t Decimal128::_internal_hi() const {
  return _impl_.hi_;
}
inline int64_t Decimal128::hi() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Decimal128.hi)
  return _internal_hi();
}
inline void Decimal128::_internal_set_hi(int64_t value) {
  
  _impl_.hi_ = value;
}
inline void Decimal128::set_hi(int64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:greptime.v1.Decimal128.hi)
}

// int64 lo = 2;
inline void Decimal128::clear_lo() {
  _impl_.lo_ = int64_t{0};
}
inline int64_t Decimal128::_internal_lo() const {
  return _impl_.lo_;
}
inline int64_t Decimal128::lo() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Decimal128.lo)
  return _internal_lo();
}
inline void Decimal128::_internal_set_lo(int64_t value) {
  
  _impl_.lo_ = value;
}
inline void Decimal128::set_lo(int64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:greptime.v1.Decimal128.lo)
}

// -------------------------------------------------------------------

// ColumnDataTypeExtension

// .greptime.v1.DecimalTypeExtension decimal_type = 1;
inline bool ColumnDataTypeExtension::_internal_has_decimal_type() const {
  return type_ext_case() == kDecimalType;
}
inline bool ColumnDataTypeExtension::has_decimal_type() const {
  return _internal_has_decimal_type();
}
inline void ColumnDataTypeExtension::set_has_decimal_type() {
  _impl_._oneof_case_[0] = kDecimalType;
}
inline void ColumnDataTypeExtension::clear_decimal_type() {
  if (_internal_has_decimal_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_ext_.decimal_type_;
    }
    clear_has_type_ext();
  }
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::release_decimal_type() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDataTypeExtension.decimal_type)
  if (_internal_has_decimal_type()) {
    clear_has_type_ext();
    ::greptime::v1::DecimalTypeExtension* temp = _impl_.type_ext_.decimal_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_ext_.decimal_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DecimalTypeExtension& ColumnDataTypeExtension::_internal_decimal_type() const {
  return _internal_has_decimal_type()
      ? *_impl_.type_ext_.decimal_type_
      : reinterpret_cast< ::greptime::v1::DecimalTypeExtension&>(::greptime::v1::_DecimalTypeExtension_default_instance_);
}
inline const ::greptime::v1::DecimalTypeExtension& ColumnDataTypeExtension::decimal_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.decimal_type)
  return _internal_decimal_type();
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::unsafe_arena_release_decimal_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.ColumnDataTypeExtension.decimal_type)
  if (_internal_has_decimal_type()) {
    clear_has_type_ext();
    ::greptime::v1::DecimalTypeExtension* temp = _impl_.type_ext_.decimal_type_;
    _impl_.type_ext_.decimal_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ColumnDataTypeExtension::unsafe_arena_set_allocated_decimal_type(::greptime::v1::DecimalTypeExtension* decimal_type) {
  clear_type_ext();
  if (decimal_type) {
    set_has_decimal_type();
    _impl_.type_ext_.decimal_type_ = decimal_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDataTypeExtension.decimal_type)
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::_internal_mutable_decimal_type() {
  if (!_internal_has_decimal_type()) {
    clear_type_ext();
    set_has_decimal_type();
    _impl_.type_ext_.decimal_type_ = CreateMaybeMessage< ::greptime::v1::DecimalTypeExtension >(GetArenaForAllocation());
  }
  return _impl_.type_ext_.decimal_type_;
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::mutable_decimal_type() {
  ::greptime::v1::DecimalTypeExtension* _msg = _internal_mutable_decimal_type();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDataTypeExtension.decimal_type)
  return _msg;
}

// .greptime.v1.JsonTypeExtension json_type = 2;
inline bool ColumnDataTypeExtension::_internal_has_json_type() const {
  return type_ext_case() == kJsonType;
}
inline bool ColumnDataTypeExtension::has_json_type() const {
  return _internal_has_json_type();
}
inline void ColumnDataTypeExtension::set_has_json_type() {
  _impl_._oneof_case_[0] = kJsonType;
}
inline void ColumnDataTypeExtension::clear_json_type() {
  if (_internal_has_json_type()) {
    _impl_.type_ext_.json_type_ = 0;
    clear_has_type_ext();
  }
}
inline ::greptime::v1::JsonTypeExtension ColumnDataTypeExtension::_internal_json_type() const {
  if (_internal_has_json_type()) {
    return static_cast< ::greptime::v1::JsonTypeExtension >(_impl_.type_ext_.json_type_);
  }
  return static_cast< ::greptime::v1::JsonTypeExtension >(0);
}
inline ::greptime::v1::JsonTypeExtension ColumnDataTypeExtension::json_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.json_type)
  return _internal_json_type();
}
inline void ColumnDataTypeExtension::_internal_set_json_type(::greptime::v1::JsonTypeExtension value) {
  if (!_internal_has_json_type()) {
    clear_type_ext();
    set_has_json_type();
  }
  _impl_.type_ext_.json_type_ = value;
}
inline void ColumnDataTypeExtension::set_json_type(::greptime::v1::JsonTypeExtension value) {
  _internal_set_json_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDataTypeExtension.json_type)
}

inline bool ColumnDataTypeExtension::has_type_ext() const {
  return type_ext_case() != TYPE_EXT_NOT_SET;
}
inline void ColumnDataTypeExtension::clear_has_type_ext() {
  _impl_._oneof_case_[0] = TYPE_EXT_NOT_SET;
}
inline ColumnDataTypeExtension::TypeExtCase ColumnDataTypeExtension::type_ext_case() const {
  return ColumnDataTypeExtension::TypeExtCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DecimalTypeExtension

// int32 precision = 1;
inline void DecimalTypeExtension::clear_precision() {
  _impl_.precision_ = 0;
}
inline int32_t DecimalTypeExtension::_internal_precision() const {
  return _impl_.precision_;
}
inline int32_t DecimalTypeExtension::precision() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DecimalTypeExtension.precision)
  return _internal_precision();
}
inline void DecimalTypeExtension::_internal_set_precision(int32_t value) {
  
  _impl_.precision_ = value;
}
inline void DecimalTypeExtension::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DecimalTypeExtension.precision)
}

// int32 scale = 2;
inline void DecimalTypeExtension::clear_scale() {
  _impl_.scale_ = 0;
}
inline int32_t DecimalTypeExtension::_internal_scale() const {
  return _impl_.scale_;
}
inline int32_t DecimalTypeExtension::scale() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DecimalTypeExtension.scale)
  return _internal_scale();
}
inline void DecimalTypeExtension::_internal_set_scale(int32_t value) {
  
  _impl_.scale_ = value;
}
inline void DecimalTypeExtension::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DecimalTypeExtension.scale)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ColumnOptions

// map<string, string> options = 1;
inline int ColumnOptions::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int ColumnOptions::options_size() const {
  return _internal_options_size();
}
inline void ColumnOptions::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ColumnOptions::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ColumnOptions::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.ColumnOptions.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ColumnOptions::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ColumnOptions::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.ColumnOptions.options)
  return _internal_mutable_options();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::SemanticType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::SemanticType>() {
  return ::greptime::v1::SemanticType_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::ColumnDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::ColumnDataType>() {
  return ::greptime::v1::ColumnDataType_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::JsonTypeExtension> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::JsonTypeExtension>() {
  return ::greptime::v1::JsonTypeExtension_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fcommon_2eproto
