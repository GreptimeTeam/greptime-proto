// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: greptime/v1/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_greptime_2fv1_2fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_greptime_2fv1_2fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_greptime_2fv1_2fcommon_2eproto;
namespace greptime {
namespace v1 {
class AffectedRows;
struct AffectedRowsDefaultTypeInternal;
extern AffectedRowsDefaultTypeInternal _AffectedRows_default_instance_;
class ArrowIpc;
struct ArrowIpcDefaultTypeInternal;
extern ArrowIpcDefaultTypeInternal _ArrowIpc_default_instance_;
class AuthHeader;
struct AuthHeaderDefaultTypeInternal;
extern AuthHeaderDefaultTypeInternal _AuthHeader_default_instance_;
class Basic;
struct BasicDefaultTypeInternal;
extern BasicDefaultTypeInternal _Basic_default_instance_;
class ColumnDataTypeExtension;
struct ColumnDataTypeExtensionDefaultTypeInternal;
extern ColumnDataTypeExtensionDefaultTypeInternal _ColumnDataTypeExtension_default_instance_;
class ColumnOptions;
struct ColumnOptionsDefaultTypeInternal;
extern ColumnOptionsDefaultTypeInternal _ColumnOptions_default_instance_;
class ColumnOptions_OptionsEntry_DoNotUse;
struct ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal;
extern ColumnOptions_OptionsEntry_DoNotUseDefaultTypeInternal _ColumnOptions_OptionsEntry_DoNotUse_default_instance_;
class Decimal128;
struct Decimal128DefaultTypeInternal;
extern Decimal128DefaultTypeInternal _Decimal128_default_instance_;
class DecimalTypeExtension;
struct DecimalTypeExtensionDefaultTypeInternal;
extern DecimalTypeExtensionDefaultTypeInternal _DecimalTypeExtension_default_instance_;
class EvalInterval;
struct EvalIntervalDefaultTypeInternal;
extern EvalIntervalDefaultTypeInternal _EvalInterval_default_instance_;
class ExpireAfter;
struct ExpireAfterDefaultTypeInternal;
extern ExpireAfterDefaultTypeInternal _ExpireAfter_default_instance_;
class ExplainOptions;
struct ExplainOptionsDefaultTypeInternal;
extern ExplainOptionsDefaultTypeInternal _ExplainOptions_default_instance_;
class FlightMetadata;
struct FlightMetadataDefaultTypeInternal;
extern FlightMetadataDefaultTypeInternal _FlightMetadata_default_instance_;
class IntervalMonthDayNano;
struct IntervalMonthDayNanoDefaultTypeInternal;
extern IntervalMonthDayNanoDefaultTypeInternal _IntervalMonthDayNano_default_instance_;
class ListTypeExtension;
struct ListTypeExtensionDefaultTypeInternal;
extern ListTypeExtensionDefaultTypeInternal _ListTypeExtension_default_instance_;
class Metrics;
struct MetricsDefaultTypeInternal;
extern MetricsDefaultTypeInternal _Metrics_default_instance_;
class QueryContext;
struct QueryContextDefaultTypeInternal;
extern QueryContextDefaultTypeInternal _QueryContext_default_instance_;
class QueryContext_ExtensionsEntry_DoNotUse;
struct QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal;
extern QueryContext_ExtensionsEntry_DoNotUseDefaultTypeInternal _QueryContext_ExtensionsEntry_DoNotUse_default_instance_;
class RequestHeader;
struct RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class RequestHeader_TracingContextEntry_DoNotUse;
struct RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal;
extern RequestHeader_TracingContextEntry_DoNotUseDefaultTypeInternal _RequestHeader_TracingContextEntry_DoNotUse_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class SnapshotSequences;
struct SnapshotSequencesDefaultTypeInternal;
extern SnapshotSequencesDefaultTypeInternal _SnapshotSequences_default_instance_;
class SnapshotSequences_SnapshotSeqsEntry_DoNotUse;
struct SnapshotSequences_SnapshotSeqsEntry_DoNotUseDefaultTypeInternal;
extern SnapshotSequences_SnapshotSeqsEntry_DoNotUseDefaultTypeInternal _SnapshotSequences_SnapshotSeqsEntry_DoNotUse_default_instance_;
class SnapshotSequences_SstMinSequencesEntry_DoNotUse;
struct SnapshotSequences_SstMinSequencesEntry_DoNotUseDefaultTypeInternal;
extern SnapshotSequences_SstMinSequencesEntry_DoNotUseDefaultTypeInternal _SnapshotSequences_SstMinSequencesEntry_DoNotUse_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StructField;
struct StructFieldDefaultTypeInternal;
extern StructFieldDefaultTypeInternal _StructField_default_instance_;
class StructTypeExtension;
struct StructTypeExtensionDefaultTypeInternal;
extern StructTypeExtensionDefaultTypeInternal _StructTypeExtension_default_instance_;
class TableName;
struct TableNameDefaultTypeInternal;
extern TableNameDefaultTypeInternal _TableName_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TimeRanges;
struct TimeRangesDefaultTypeInternal;
extern TimeRangesDefaultTypeInternal _TimeRanges_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class VectorTypeExtension;
struct VectorTypeExtensionDefaultTypeInternal;
extern VectorTypeExtensionDefaultTypeInternal _VectorTypeExtension_default_instance_;
}  // namespace v1
}  // namespace greptime
PROTOBUF_NAMESPACE_OPEN
template<> ::greptime::v1::AffectedRows* Arena::CreateMaybeMessage<::greptime::v1::AffectedRows>(Arena*);
template<> ::greptime::v1::ArrowIpc* Arena::CreateMaybeMessage<::greptime::v1::ArrowIpc>(Arena*);
template<> ::greptime::v1::AuthHeader* Arena::CreateMaybeMessage<::greptime::v1::AuthHeader>(Arena*);
template<> ::greptime::v1::Basic* Arena::CreateMaybeMessage<::greptime::v1::Basic>(Arena*);
template<> ::greptime::v1::ColumnDataTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(Arena*);
template<> ::greptime::v1::ColumnOptions* Arena::CreateMaybeMessage<::greptime::v1::ColumnOptions>(Arena*);
template<> ::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::ColumnOptions_OptionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::Decimal128* Arena::CreateMaybeMessage<::greptime::v1::Decimal128>(Arena*);
template<> ::greptime::v1::DecimalTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::DecimalTypeExtension>(Arena*);
template<> ::greptime::v1::EvalInterval* Arena::CreateMaybeMessage<::greptime::v1::EvalInterval>(Arena*);
template<> ::greptime::v1::ExpireAfter* Arena::CreateMaybeMessage<::greptime::v1::ExpireAfter>(Arena*);
template<> ::greptime::v1::ExplainOptions* Arena::CreateMaybeMessage<::greptime::v1::ExplainOptions>(Arena*);
template<> ::greptime::v1::FlightMetadata* Arena::CreateMaybeMessage<::greptime::v1::FlightMetadata>(Arena*);
template<> ::greptime::v1::IntervalMonthDayNano* Arena::CreateMaybeMessage<::greptime::v1::IntervalMonthDayNano>(Arena*);
template<> ::greptime::v1::ListTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::ListTypeExtension>(Arena*);
template<> ::greptime::v1::Metrics* Arena::CreateMaybeMessage<::greptime::v1::Metrics>(Arena*);
template<> ::greptime::v1::QueryContext* Arena::CreateMaybeMessage<::greptime::v1::QueryContext>(Arena*);
template<> ::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::QueryContext_ExtensionsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::RequestHeader* Arena::CreateMaybeMessage<::greptime::v1::RequestHeader>(Arena*);
template<> ::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::RequestHeader_TracingContextEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::ResponseHeader* Arena::CreateMaybeMessage<::greptime::v1::ResponseHeader>(Arena*);
template<> ::greptime::v1::SnapshotSequences* Arena::CreateMaybeMessage<::greptime::v1::SnapshotSequences>(Arena*);
template<> ::greptime::v1::SnapshotSequences_SnapshotSeqsEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::SnapshotSequences_SnapshotSeqsEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::SnapshotSequences_SstMinSequencesEntry_DoNotUse* Arena::CreateMaybeMessage<::greptime::v1::SnapshotSequences_SstMinSequencesEntry_DoNotUse>(Arena*);
template<> ::greptime::v1::Status* Arena::CreateMaybeMessage<::greptime::v1::Status>(Arena*);
template<> ::greptime::v1::StructField* Arena::CreateMaybeMessage<::greptime::v1::StructField>(Arena*);
template<> ::greptime::v1::StructTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::StructTypeExtension>(Arena*);
template<> ::greptime::v1::TableName* Arena::CreateMaybeMessage<::greptime::v1::TableName>(Arena*);
template<> ::greptime::v1::TimeRange* Arena::CreateMaybeMessage<::greptime::v1::TimeRange>(Arena*);
template<> ::greptime::v1::TimeRanges* Arena::CreateMaybeMessage<::greptime::v1::TimeRanges>(Arena*);
template<> ::greptime::v1::Token* Arena::CreateMaybeMessage<::greptime::v1::Token>(Arena*);
template<> ::greptime::v1::VectorTypeExtension* Arena::CreateMaybeMessage<::greptime::v1::VectorTypeExtension>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace greptime {
namespace v1 {

enum SemanticType : int {
  TAG = 0,
  FIELD = 1,
  TIMESTAMP = 2,
  SemanticType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SemanticType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SemanticType_IsValid(int value);
constexpr SemanticType SemanticType_MIN = TAG;
constexpr SemanticType SemanticType_MAX = TIMESTAMP;
constexpr int SemanticType_ARRAYSIZE = SemanticType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SemanticType_descriptor();
template<typename T>
inline const std::string& SemanticType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SemanticType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SemanticType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SemanticType_descriptor(), enum_t_value);
}
inline bool SemanticType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SemanticType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SemanticType>(
    SemanticType_descriptor(), name, value);
}
enum ColumnDataType : int {
  BOOLEAN = 0,
  INT8 = 1,
  INT16 = 2,
  INT32 = 3,
  INT64 = 4,
  UINT8 = 5,
  UINT16 = 6,
  UINT32 = 7,
  UINT64 = 8,
  FLOAT32 = 9,
  FLOAT64 = 10,
  BINARY = 11,
  STRING = 12,
  DATE = 13,
  DATETIME = 14,
  TIMESTAMP_SECOND = 15,
  TIMESTAMP_MILLISECOND = 16,
  TIMESTAMP_MICROSECOND = 17,
  TIMESTAMP_NANOSECOND = 18,
  TIME_SECOND = 19,
  TIME_MILLISECOND = 20,
  TIME_MICROSECOND = 21,
  TIME_NANOSECOND = 22,
  INTERVAL_YEAR_MONTH = 23,
  INTERVAL_DAY_TIME = 24,
  INTERVAL_MONTH_DAY_NANO = 25,
  DECIMAL128 = 30,
  JSON = 31,
  VECTOR = 32,
  LIST = 40,
  STRUCT = 41,
  ColumnDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ColumnDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ColumnDataType_IsValid(int value);
constexpr ColumnDataType ColumnDataType_MIN = BOOLEAN;
constexpr ColumnDataType ColumnDataType_MAX = STRUCT;
constexpr int ColumnDataType_ARRAYSIZE = ColumnDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnDataType_descriptor();
template<typename T>
inline const std::string& ColumnDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColumnDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColumnDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColumnDataType_descriptor(), enum_t_value);
}
inline bool ColumnDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnDataType>(
    ColumnDataType_descriptor(), name, value);
}
enum TimeUnit : int {
  MILLISECOND = 0,
  SECOND = 1,
  MICROSECOND = 2,
  NANOSECOND = 3,
  TimeUnit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimeUnit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimeUnit_IsValid(int value);
constexpr TimeUnit TimeUnit_MIN = MILLISECOND;
constexpr TimeUnit TimeUnit_MAX = NANOSECOND;
constexpr int TimeUnit_ARRAYSIZE = TimeUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeUnit_descriptor();
template<typename T>
inline const std::string& TimeUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeUnit_descriptor(), enum_t_value);
}
inline bool TimeUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeUnit>(
    TimeUnit_descriptor(), name, value);
}
enum JsonTypeExtension : int {
  JSON_BINARY = 0,
  JsonTypeExtension_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JsonTypeExtension_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JsonTypeExtension_IsValid(int value);
constexpr JsonTypeExtension JsonTypeExtension_MIN = JSON_BINARY;
constexpr JsonTypeExtension JsonTypeExtension_MAX = JSON_BINARY;
constexpr int JsonTypeExtension_ARRAYSIZE = JsonTypeExtension_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JsonTypeExtension_descriptor();
template<typename T>
inline const std::string& JsonTypeExtension_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JsonTypeExtension>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JsonTypeExtension_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JsonTypeExtension_descriptor(), enum_t_value);
}
inline bool JsonTypeExtension_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JsonTypeExtension* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JsonTypeExtension>(
    JsonTypeExtension_descriptor(), name, value);
}
// ===================================================================

class QueryContext_ExtensionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryContext_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueryContext_ExtensionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  QueryContext_ExtensionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR QueryContext_ExtensionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueryContext_ExtensionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueryContext_ExtensionsEntry_DoNotUse& other);
  static const QueryContext_ExtensionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryContext_ExtensionsEntry_DoNotUse*>(&_QueryContext_ExtensionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.QueryContext.ExtensionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.QueryContext.ExtensionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class QueryContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.QueryContext) */ {
 public:
  inline QueryContext() : QueryContext(nullptr) {}
  ~QueryContext() override;
  explicit PROTOBUF_CONSTEXPR QueryContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryContext(const QueryContext& from);
  QueryContext(QueryContext&& from) noexcept
    : QueryContext() {
    *this = ::std::move(from);
  }

  inline QueryContext& operator=(const QueryContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryContext& operator=(QueryContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryContext* internal_default_instance() {
    return reinterpret_cast<const QueryContext*>(
               &_QueryContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryContext& a, QueryContext& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryContext& from) {
    QueryContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.QueryContext";
  }
  protected:
  explicit QueryContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kExtensionsFieldNumber = 5,
    kCurrentCatalogFieldNumber = 1,
    kCurrentSchemaFieldNumber = 2,
    kTimezoneFieldNumber = 4,
    kSnapshotSeqsFieldNumber = 7,
    kExplainFieldNumber = 8,
    kChannelFieldNumber = 6,
  };
  // map<string, string> extensions = 5;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_extensions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      extensions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_extensions();

  // string current_catalog = 1;
  void clear_current_catalog();
  const std::string& current_catalog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_catalog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_catalog();
  PROTOBUF_NODISCARD std::string* release_current_catalog();
  void set_allocated_current_catalog(std::string* current_catalog);
  private:
  const std::string& _internal_current_catalog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_catalog(const std::string& value);
  std::string* _internal_mutable_current_catalog();
  public:

  // string current_schema = 2;
  void clear_current_schema();
  const std::string& current_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_schema();
  PROTOBUF_NODISCARD std::string* release_current_schema();
  void set_allocated_current_schema(std::string* current_schema);
  private:
  const std::string& _internal_current_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_schema(const std::string& value);
  std::string* _internal_mutable_current_schema();
  public:

  // string timezone = 4;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // .greptime.v1.SnapshotSequences snapshot_seqs = 7;
  bool has_snapshot_seqs() const;
  private:
  bool _internal_has_snapshot_seqs() const;
  public:
  void clear_snapshot_seqs();
  const ::greptime::v1::SnapshotSequences& snapshot_seqs() const;
  PROTOBUF_NODISCARD ::greptime::v1::SnapshotSequences* release_snapshot_seqs();
  ::greptime::v1::SnapshotSequences* mutable_snapshot_seqs();
  void set_allocated_snapshot_seqs(::greptime::v1::SnapshotSequences* snapshot_seqs);
  private:
  const ::greptime::v1::SnapshotSequences& _internal_snapshot_seqs() const;
  ::greptime::v1::SnapshotSequences* _internal_mutable_snapshot_seqs();
  public:
  void unsafe_arena_set_allocated_snapshot_seqs(
      ::greptime::v1::SnapshotSequences* snapshot_seqs);
  ::greptime::v1::SnapshotSequences* unsafe_arena_release_snapshot_seqs();

  // .greptime.v1.ExplainOptions explain = 8;
  bool has_explain() const;
  private:
  bool _internal_has_explain() const;
  public:
  void clear_explain();
  const ::greptime::v1::ExplainOptions& explain() const;
  PROTOBUF_NODISCARD ::greptime::v1::ExplainOptions* release_explain();
  ::greptime::v1::ExplainOptions* mutable_explain();
  void set_allocated_explain(::greptime::v1::ExplainOptions* explain);
  private:
  const ::greptime::v1::ExplainOptions& _internal_explain() const;
  ::greptime::v1::ExplainOptions* _internal_mutable_explain();
  public:
  void unsafe_arena_set_allocated_explain(
      ::greptime::v1::ExplainOptions* explain);
  ::greptime::v1::ExplainOptions* unsafe_arena_release_explain();

  // uint32 channel = 6;
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.QueryContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        QueryContext_ExtensionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_catalog_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    ::greptime::v1::SnapshotSequences* snapshot_seqs_;
    ::greptime::v1::ExplainOptions* explain_;
    uint32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class SnapshotSequences_SstMinSequencesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SnapshotSequences_SstMinSequencesEntry_DoNotUse, 
    uint64_t, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SnapshotSequences_SstMinSequencesEntry_DoNotUse, 
    uint64_t, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  SnapshotSequences_SstMinSequencesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SnapshotSequences_SstMinSequencesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SnapshotSequences_SstMinSequencesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SnapshotSequences_SstMinSequencesEntry_DoNotUse& other);
  static const SnapshotSequences_SstMinSequencesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SnapshotSequences_SstMinSequencesEntry_DoNotUse*>(&_SnapshotSequences_SstMinSequencesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class SnapshotSequences_SnapshotSeqsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SnapshotSequences_SnapshotSeqsEntry_DoNotUse, 
    uint64_t, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SnapshotSequences_SnapshotSeqsEntry_DoNotUse, 
    uint64_t, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  SnapshotSequences_SnapshotSeqsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SnapshotSequences_SnapshotSeqsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SnapshotSequences_SnapshotSeqsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SnapshotSequences_SnapshotSeqsEntry_DoNotUse& other);
  static const SnapshotSequences_SnapshotSeqsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SnapshotSequences_SnapshotSeqsEntry_DoNotUse*>(&_SnapshotSequences_SnapshotSeqsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class SnapshotSequences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.SnapshotSequences) */ {
 public:
  inline SnapshotSequences() : SnapshotSequences(nullptr) {}
  ~SnapshotSequences() override;
  explicit PROTOBUF_CONSTEXPR SnapshotSequences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotSequences(const SnapshotSequences& from);
  SnapshotSequences(SnapshotSequences&& from) noexcept
    : SnapshotSequences() {
    *this = ::std::move(from);
  }

  inline SnapshotSequences& operator=(const SnapshotSequences& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotSequences& operator=(SnapshotSequences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotSequences& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotSequences* internal_default_instance() {
    return reinterpret_cast<const SnapshotSequences*>(
               &_SnapshotSequences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SnapshotSequences& a, SnapshotSequences& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotSequences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotSequences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotSequences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotSequences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotSequences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotSequences& from) {
    SnapshotSequences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotSequences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.SnapshotSequences";
  }
  protected:
  explicit SnapshotSequences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSstMinSequencesFieldNumber = 1,
    kSnapshotSeqsFieldNumber = 7,
  };
  // map<uint64, uint64> sst_min_sequences = 1;
  int sst_min_sequences_size() const;
  private:
  int _internal_sst_min_sequences_size() const;
  public:
  void clear_sst_min_sequences();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
      _internal_sst_min_sequences() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
      _internal_mutable_sst_min_sequences();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
      sst_min_sequences() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
      mutable_sst_min_sequences();

  // map<uint64, uint64> snapshot_seqs = 7;
  int snapshot_seqs_size() const;
  private:
  int _internal_snapshot_seqs_size() const;
  public:
  void clear_snapshot_seqs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
      _internal_snapshot_seqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
      _internal_mutable_snapshot_seqs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
      snapshot_seqs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
      mutable_snapshot_seqs();

  // @@protoc_insertion_point(class_scope:greptime.v1.SnapshotSequences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SnapshotSequences_SstMinSequencesEntry_DoNotUse,
        uint64_t, uint64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> sst_min_sequences_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SnapshotSequences_SnapshotSeqsEntry_DoNotUse,
        uint64_t, uint64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> snapshot_seqs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ExplainOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ExplainOptions) */ {
 public:
  inline ExplainOptions() : ExplainOptions(nullptr) {}
  ~ExplainOptions() override;
  explicit PROTOBUF_CONSTEXPR ExplainOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExplainOptions(const ExplainOptions& from);
  ExplainOptions(ExplainOptions&& from) noexcept
    : ExplainOptions() {
    *this = ::std::move(from);
  }

  inline ExplainOptions& operator=(const ExplainOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExplainOptions& operator=(ExplainOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExplainOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExplainOptions* internal_default_instance() {
    return reinterpret_cast<const ExplainOptions*>(
               &_ExplainOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExplainOptions& a, ExplainOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ExplainOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExplainOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExplainOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExplainOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExplainOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExplainOptions& from) {
    ExplainOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExplainOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ExplainOptions";
  }
  protected:
  explicit ExplainOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerboseFieldNumber = 1,
  };
  // bool verbose = 1;
  void clear_verbose();
  bool verbose() const;
  void set_verbose(bool value);
  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ExplainOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool verbose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class RequestHeader_TracingContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RequestHeader_TracingContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RequestHeader_TracingContextEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RequestHeader_TracingContextEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RequestHeader_TracingContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RequestHeader_TracingContextEntry_DoNotUse& other);
  static const RequestHeader_TracingContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RequestHeader_TracingContextEntry_DoNotUse*>(&_RequestHeader_TracingContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.RequestHeader.TracingContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.RequestHeader.TracingContextEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class RequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  ~RequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestHeader& from) {
    RequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTracingContextFieldNumber = 5,
    kCatalogFieldNumber = 1,
    kSchemaFieldNumber = 2,
    kDbnameFieldNumber = 4,
    kTimezoneFieldNumber = 6,
    kAuthorizationFieldNumber = 3,
  };
  // map<string, string> tracing_context = 5;
  int tracing_context_size() const;
  private:
  int _internal_tracing_context_size() const;
  public:
  void clear_tracing_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tracing_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tracing_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tracing_context();

  // string catalog = 1;
  void clear_catalog();
  const std::string& catalog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog();
  PROTOBUF_NODISCARD std::string* release_catalog();
  void set_allocated_catalog(std::string* catalog);
  private:
  const std::string& _internal_catalog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog(const std::string& value);
  std::string* _internal_mutable_catalog();
  public:

  // string schema = 2;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // string dbname = 4;
  void clear_dbname();
  const std::string& dbname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbname();
  PROTOBUF_NODISCARD std::string* release_dbname();
  void set_allocated_dbname(std::string* dbname);
  private:
  const std::string& _internal_dbname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbname(const std::string& value);
  std::string* _internal_mutable_dbname();
  public:

  // string timezone = 6;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // .greptime.v1.AuthHeader authorization = 3;
  bool has_authorization() const;
  private:
  bool _internal_has_authorization() const;
  public:
  void clear_authorization();
  const ::greptime::v1::AuthHeader& authorization() const;
  PROTOBUF_NODISCARD ::greptime::v1::AuthHeader* release_authorization();
  ::greptime::v1::AuthHeader* mutable_authorization();
  void set_allocated_authorization(::greptime::v1::AuthHeader* authorization);
  private:
  const ::greptime::v1::AuthHeader& _internal_authorization() const;
  ::greptime::v1::AuthHeader* _internal_mutable_authorization();
  public:
  void unsafe_arena_set_allocated_authorization(
      ::greptime::v1::AuthHeader* authorization);
  ::greptime::v1::AuthHeader* unsafe_arena_release_authorization();

  // @@protoc_insertion_point(class_scope:greptime.v1.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RequestHeader_TracingContextEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tracing_context_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    ::greptime::v1::AuthHeader* authorization_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  ~ResponseHeader() override;
  explicit PROTOBUF_CONSTEXPR ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseHeader& from) {
    ResponseHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .greptime.v1.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::greptime::v1::Status& status() const;
  PROTOBUF_NODISCARD ::greptime::v1::Status* release_status();
  ::greptime::v1::Status* mutable_status();
  void set_allocated_status(::greptime::v1::Status* status);
  private:
  const ::greptime::v1::Status& _internal_status() const;
  ::greptime::v1::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::greptime::v1::Status* status);
  ::greptime::v1::Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:greptime.v1.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::Status* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string err_msg = 2;
  void clear_err_msg();
  const std::string& err_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_err_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_err_msg();
  PROTOBUF_NODISCARD std::string* release_err_msg();
  void set_allocated_err_msg(std::string* err_msg);
  private:
  const std::string& _internal_err_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_err_msg(const std::string& value);
  std::string* _internal_mutable_err_msg();
  public:

  // uint32 status_code = 1;
  void clear_status_code();
  uint32_t status_code() const;
  void set_status_code(uint32_t value);
  private:
  uint32_t _internal_status_code() const;
  void _internal_set_status_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_msg_;
    uint32_t status_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class AuthHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AuthHeader) */ {
 public:
  inline AuthHeader() : AuthHeader(nullptr) {}
  ~AuthHeader() override;
  explicit PROTOBUF_CONSTEXPR AuthHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthHeader(const AuthHeader& from);
  AuthHeader(AuthHeader&& from) noexcept
    : AuthHeader() {
    *this = ::std::move(from);
  }

  inline AuthHeader& operator=(const AuthHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthHeader& operator=(AuthHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthHeader& default_instance() {
    return *internal_default_instance();
  }
  enum AuthSchemeCase {
    kBasic = 1,
    kToken = 2,
    AUTH_SCHEME_NOT_SET = 0,
  };

  static inline const AuthHeader* internal_default_instance() {
    return reinterpret_cast<const AuthHeader*>(
               &_AuthHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AuthHeader& a, AuthHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthHeader& from) {
    AuthHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AuthHeader";
  }
  protected:
  explicit AuthHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // .greptime.v1.Basic basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::greptime::v1::Basic& basic() const;
  PROTOBUF_NODISCARD ::greptime::v1::Basic* release_basic();
  ::greptime::v1::Basic* mutable_basic();
  void set_allocated_basic(::greptime::v1::Basic* basic);
  private:
  const ::greptime::v1::Basic& _internal_basic() const;
  ::greptime::v1::Basic* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::greptime::v1::Basic* basic);
  ::greptime::v1::Basic* unsafe_arena_release_basic();

  // .greptime.v1.Token token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::greptime::v1::Token& token() const;
  PROTOBUF_NODISCARD ::greptime::v1::Token* release_token();
  ::greptime::v1::Token* mutable_token();
  void set_allocated_token(::greptime::v1::Token* token);
  private:
  const ::greptime::v1::Token& _internal_token() const;
  ::greptime::v1::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::greptime::v1::Token* token);
  ::greptime::v1::Token* unsafe_arena_release_token();

  void clear_auth_scheme();
  AuthSchemeCase auth_scheme_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.AuthHeader)
 private:
  class _Internal;
  void set_has_basic();
  void set_has_token();

  inline bool has_auth_scheme() const;
  inline void clear_has_auth_scheme();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union AuthSchemeUnion {
      constexpr AuthSchemeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::Basic* basic_;
      ::greptime::v1::Token* token_;
    } auth_scheme_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Basic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Basic) */ {
 public:
  inline Basic() : Basic(nullptr) {}
  ~Basic() override;
  explicit PROTOBUF_CONSTEXPR Basic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Basic(const Basic& from);
  Basic(Basic&& from) noexcept
    : Basic() {
    *this = ::std::move(from);
  }

  inline Basic& operator=(const Basic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Basic& operator=(Basic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Basic& default_instance() {
    return *internal_default_instance();
  }
  static inline const Basic* internal_default_instance() {
    return reinterpret_cast<const Basic*>(
               &_Basic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Basic& a, Basic& b) {
    a.Swap(&b);
  }
  inline void Swap(Basic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Basic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Basic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Basic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Basic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Basic& from) {
    Basic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Basic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Basic";
  }
  protected:
  explicit Basic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Basic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TableName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TableName) */ {
 public:
  inline TableName() : TableName(nullptr) {}
  ~TableName() override;
  explicit PROTOBUF_CONSTEXPR TableName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableName(const TableName& from);
  TableName(TableName&& from) noexcept
    : TableName() {
    *this = ::std::move(from);
  }

  inline TableName& operator=(const TableName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableName& operator=(TableName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableName& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableName* internal_default_instance() {
    return reinterpret_cast<const TableName*>(
               &_TableName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TableName& a, TableName& b) {
    a.Swap(&b);
  }
  inline void Swap(TableName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableName& from) {
    TableName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TableName";
  }
  protected:
  explicit TableName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
  };
  // string catalog_name = 1;
  void clear_catalog_name();
  const std::string& catalog_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_catalog_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* catalog_name);
  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(const std::string& value);
  std::string* _internal_mutable_catalog_name();
  public:

  // string schema_name = 2;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TableName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class AffectedRows final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.AffectedRows) */ {
 public:
  inline AffectedRows() : AffectedRows(nullptr) {}
  ~AffectedRows() override;
  explicit PROTOBUF_CONSTEXPR AffectedRows(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AffectedRows(const AffectedRows& from);
  AffectedRows(AffectedRows&& from) noexcept
    : AffectedRows() {
    *this = ::std::move(from);
  }

  inline AffectedRows& operator=(const AffectedRows& from) {
    CopyFrom(from);
    return *this;
  }
  inline AffectedRows& operator=(AffectedRows&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AffectedRows& default_instance() {
    return *internal_default_instance();
  }
  static inline const AffectedRows* internal_default_instance() {
    return reinterpret_cast<const AffectedRows*>(
               &_AffectedRows_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AffectedRows& a, AffectedRows& b) {
    a.Swap(&b);
  }
  inline void Swap(AffectedRows* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AffectedRows* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AffectedRows* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AffectedRows>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AffectedRows& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AffectedRows& from) {
    AffectedRows::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AffectedRows* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.AffectedRows";
  }
  protected:
  explicit AffectedRows(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.AffectedRows)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Metrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Metrics) */ {
 public:
  inline Metrics() : Metrics(nullptr) {}
  ~Metrics() override;
  explicit PROTOBUF_CONSTEXPR Metrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metrics(const Metrics& from);
  Metrics(Metrics&& from) noexcept
    : Metrics() {
    *this = ::std::move(from);
  }

  inline Metrics& operator=(const Metrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metrics& operator=(Metrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metrics* internal_default_instance() {
    return reinterpret_cast<const Metrics*>(
               &_Metrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Metrics& a, Metrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Metrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metrics& from) {
    Metrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Metrics";
  }
  protected:
  explicit Metrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 1,
  };
  // bytes metrics = 1;
  void clear_metrics();
  const std::string& metrics() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metrics(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metrics();
  PROTOBUF_NODISCARD std::string* release_metrics();
  void set_allocated_metrics(std::string* metrics);
  private:
  const std::string& _internal_metrics() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metrics(const std::string& value);
  std::string* _internal_mutable_metrics();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Metrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ExpireAfter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ExpireAfter) */ {
 public:
  inline ExpireAfter() : ExpireAfter(nullptr) {}
  ~ExpireAfter() override;
  explicit PROTOBUF_CONSTEXPR ExpireAfter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpireAfter(const ExpireAfter& from);
  ExpireAfter(ExpireAfter&& from) noexcept
    : ExpireAfter() {
    *this = ::std::move(from);
  }

  inline ExpireAfter& operator=(const ExpireAfter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpireAfter& operator=(ExpireAfter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpireAfter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpireAfter* internal_default_instance() {
    return reinterpret_cast<const ExpireAfter*>(
               &_ExpireAfter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ExpireAfter& a, ExpireAfter& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpireAfter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpireAfter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpireAfter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpireAfter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpireAfter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpireAfter& from) {
    ExpireAfter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpireAfter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ExpireAfter";
  }
  protected:
  explicit ExpireAfter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int64 value = 1;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ExpireAfter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class EvalInterval final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.EvalInterval) */ {
 public:
  inline EvalInterval() : EvalInterval(nullptr) {}
  ~EvalInterval() override;
  explicit PROTOBUF_CONSTEXPR EvalInterval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvalInterval(const EvalInterval& from);
  EvalInterval(EvalInterval&& from) noexcept
    : EvalInterval() {
    *this = ::std::move(from);
  }

  inline EvalInterval& operator=(const EvalInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalInterval& operator=(EvalInterval&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalInterval& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalInterval* internal_default_instance() {
    return reinterpret_cast<const EvalInterval*>(
               &_EvalInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EvalInterval& a, EvalInterval& b) {
    a.Swap(&b);
  }
  inline void Swap(EvalInterval* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalInterval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvalInterval>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvalInterval& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvalInterval& from) {
    EvalInterval::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvalInterval* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.EvalInterval";
  }
  protected:
  explicit EvalInterval(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
  };
  // int64 seconds = 1;
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.EvalInterval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class FlightMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.FlightMetadata) */ {
 public:
  inline FlightMetadata() : FlightMetadata(nullptr) {}
  ~FlightMetadata() override;
  explicit PROTOBUF_CONSTEXPR FlightMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightMetadata(const FlightMetadata& from);
  FlightMetadata(FlightMetadata&& from) noexcept
    : FlightMetadata() {
    *this = ::std::move(from);
  }

  inline FlightMetadata& operator=(const FlightMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightMetadata& operator=(FlightMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightMetadata* internal_default_instance() {
    return reinterpret_cast<const FlightMetadata*>(
               &_FlightMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FlightMetadata& a, FlightMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightMetadata& from) {
    FlightMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.FlightMetadata";
  }
  protected:
  explicit FlightMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedRowsFieldNumber = 1,
    kMetricsFieldNumber = 2,
  };
  // .greptime.v1.AffectedRows affected_rows = 1;
  bool has_affected_rows() const;
  private:
  bool _internal_has_affected_rows() const;
  public:
  void clear_affected_rows();
  const ::greptime::v1::AffectedRows& affected_rows() const;
  PROTOBUF_NODISCARD ::greptime::v1::AffectedRows* release_affected_rows();
  ::greptime::v1::AffectedRows* mutable_affected_rows();
  void set_allocated_affected_rows(::greptime::v1::AffectedRows* affected_rows);
  private:
  const ::greptime::v1::AffectedRows& _internal_affected_rows() const;
  ::greptime::v1::AffectedRows* _internal_mutable_affected_rows();
  public:
  void unsafe_arena_set_allocated_affected_rows(
      ::greptime::v1::AffectedRows* affected_rows);
  ::greptime::v1::AffectedRows* unsafe_arena_release_affected_rows();

  // .greptime.v1.Metrics metrics = 2;
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::greptime::v1::Metrics& metrics() const;
  PROTOBUF_NODISCARD ::greptime::v1::Metrics* release_metrics();
  ::greptime::v1::Metrics* mutable_metrics();
  void set_allocated_metrics(::greptime::v1::Metrics* metrics);
  private:
  const ::greptime::v1::Metrics& _internal_metrics() const;
  ::greptime::v1::Metrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::greptime::v1::Metrics* metrics);
  ::greptime::v1::Metrics* unsafe_arena_release_metrics();

  // @@protoc_insertion_point(class_scope:greptime.v1.FlightMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::AffectedRows* affected_rows_;
    ::greptime::v1::Metrics* metrics_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class IntervalMonthDayNano final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.IntervalMonthDayNano) */ {
 public:
  inline IntervalMonthDayNano() : IntervalMonthDayNano(nullptr) {}
  ~IntervalMonthDayNano() override;
  explicit PROTOBUF_CONSTEXPR IntervalMonthDayNano(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntervalMonthDayNano(const IntervalMonthDayNano& from);
  IntervalMonthDayNano(IntervalMonthDayNano&& from) noexcept
    : IntervalMonthDayNano() {
    *this = ::std::move(from);
  }

  inline IntervalMonthDayNano& operator=(const IntervalMonthDayNano& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntervalMonthDayNano& operator=(IntervalMonthDayNano&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntervalMonthDayNano& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntervalMonthDayNano* internal_default_instance() {
    return reinterpret_cast<const IntervalMonthDayNano*>(
               &_IntervalMonthDayNano_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IntervalMonthDayNano& a, IntervalMonthDayNano& b) {
    a.Swap(&b);
  }
  inline void Swap(IntervalMonthDayNano* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntervalMonthDayNano* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntervalMonthDayNano* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntervalMonthDayNano>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntervalMonthDayNano& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntervalMonthDayNano& from) {
    IntervalMonthDayNano::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntervalMonthDayNano* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.IntervalMonthDayNano";
  }
  protected:
  explicit IntervalMonthDayNano(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonthsFieldNumber = 1,
    kDaysFieldNumber = 2,
    kNanosecondsFieldNumber = 3,
  };
  // int32 months = 1;
  void clear_months();
  int32_t months() const;
  void set_months(int32_t value);
  private:
  int32_t _internal_months() const;
  void _internal_set_months(int32_t value);
  public:

  // int32 days = 2;
  void clear_days();
  int32_t days() const;
  void set_days(int32_t value);
  private:
  int32_t _internal_days() const;
  void _internal_set_days(int32_t value);
  public:

  // int64 nanoseconds = 3;
  void clear_nanoseconds();
  int64_t nanoseconds() const;
  void set_nanoseconds(int64_t value);
  private:
  int64_t _internal_nanoseconds() const;
  void _internal_set_nanoseconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.IntervalMonthDayNano)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t months_;
    int32_t days_;
    int64_t nanoseconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  explicit PROTOBUF_CONSTEXPR TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRange& from) {
    TimeRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int64 start = 1;
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 end = 2;
  void clear_end();
  int64_t end() const;
  void set_end(int64_t value);
  private:
  int64_t _internal_end() const;
  void _internal_set_end(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t start_;
    int64_t end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class TimeRanges final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.TimeRanges) */ {
 public:
  inline TimeRanges() : TimeRanges(nullptr) {}
  ~TimeRanges() override;
  explicit PROTOBUF_CONSTEXPR TimeRanges(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRanges(const TimeRanges& from);
  TimeRanges(TimeRanges&& from) noexcept
    : TimeRanges() {
    *this = ::std::move(from);
  }

  inline TimeRanges& operator=(const TimeRanges& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRanges& operator=(TimeRanges&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRanges& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRanges* internal_default_instance() {
    return reinterpret_cast<const TimeRanges*>(
               &_TimeRanges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TimeRanges& a, TimeRanges& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRanges* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRanges* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRanges* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRanges>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRanges& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeRanges& from) {
    TimeRanges::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRanges* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.TimeRanges";
  }
  protected:
  explicit TimeRanges(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeRangesFieldNumber = 2,
    kTimeUnitFieldNumber = 1,
  };
  // repeated .greptime.v1.TimeRange time_ranges = 2;
  int time_ranges_size() const;
  private:
  int _internal_time_ranges_size() const;
  public:
  void clear_time_ranges();
  ::greptime::v1::TimeRange* mutable_time_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TimeRange >*
      mutable_time_ranges();
  private:
  const ::greptime::v1::TimeRange& _internal_time_ranges(int index) const;
  ::greptime::v1::TimeRange* _internal_add_time_ranges();
  public:
  const ::greptime::v1::TimeRange& time_ranges(int index) const;
  ::greptime::v1::TimeRange* add_time_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TimeRange >&
      time_ranges() const;

  // .greptime.v1.TimeUnit time_unit = 1;
  void clear_time_unit();
  ::greptime::v1::TimeUnit time_unit() const;
  void set_time_unit(::greptime::v1::TimeUnit value);
  private:
  ::greptime::v1::TimeUnit _internal_time_unit() const;
  void _internal_set_time_unit(::greptime::v1::TimeUnit value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.TimeRanges)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TimeRange > time_ranges_;
    int time_unit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class Decimal128 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.Decimal128) */ {
 public:
  inline Decimal128() : Decimal128(nullptr) {}
  ~Decimal128() override;
  explicit PROTOBUF_CONSTEXPR Decimal128(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Decimal128(const Decimal128& from);
  Decimal128(Decimal128&& from) noexcept
    : Decimal128() {
    *this = ::std::move(from);
  }

  inline Decimal128& operator=(const Decimal128& from) {
    CopyFrom(from);
    return *this;
  }
  inline Decimal128& operator=(Decimal128&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Decimal128& default_instance() {
    return *internal_default_instance();
  }
  static inline const Decimal128* internal_default_instance() {
    return reinterpret_cast<const Decimal128*>(
               &_Decimal128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Decimal128& a, Decimal128& b) {
    a.Swap(&b);
  }
  inline void Swap(Decimal128* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Decimal128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Decimal128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Decimal128>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Decimal128& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Decimal128& from) {
    Decimal128::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Decimal128* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.Decimal128";
  }
  protected:
  explicit Decimal128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHiFieldNumber = 1,
    kLoFieldNumber = 2,
  };
  // int64 hi = 1;
  void clear_hi();
  int64_t hi() const;
  void set_hi(int64_t value);
  private:
  int64_t _internal_hi() const;
  void _internal_set_hi(int64_t value);
  public:

  // int64 lo = 2;
  void clear_lo();
  int64_t lo() const;
  void set_lo(int64_t value);
  private:
  int64_t _internal_lo() const;
  void _internal_set_lo(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.Decimal128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t hi_;
    int64_t lo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class StructField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.StructField) */ {
 public:
  inline StructField() : StructField(nullptr) {}
  ~StructField() override;
  explicit PROTOBUF_CONSTEXPR StructField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructField(const StructField& from);
  StructField(StructField&& from) noexcept
    : StructField() {
    *this = ::std::move(from);
  }

  inline StructField& operator=(const StructField& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructField& operator=(StructField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructField& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructField* internal_default_instance() {
    return reinterpret_cast<const StructField*>(
               &_StructField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StructField& a, StructField& b) {
    a.Swap(&b);
  }
  inline void Swap(StructField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StructField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StructField& from) {
    StructField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.StructField";
  }
  protected:
  explicit StructField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDatatypeExtensionFieldNumber = 3,
    kDatatypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .greptime.v1.ColumnDataTypeExtension datatype_extension = 3;
  bool has_datatype_extension() const;
  private:
  bool _internal_has_datatype_extension() const;
  public:
  void clear_datatype_extension();
  const ::greptime::v1::ColumnDataTypeExtension& datatype_extension() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDataTypeExtension* release_datatype_extension();
  ::greptime::v1::ColumnDataTypeExtension* mutable_datatype_extension();
  void set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  private:
  const ::greptime::v1::ColumnDataTypeExtension& _internal_datatype_extension() const;
  ::greptime::v1::ColumnDataTypeExtension* _internal_mutable_datatype_extension();
  public:
  void unsafe_arena_set_allocated_datatype_extension(
      ::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  ::greptime::v1::ColumnDataTypeExtension* unsafe_arena_release_datatype_extension();

  // .greptime.v1.ColumnDataType datatype = 2;
  void clear_datatype();
  ::greptime::v1::ColumnDataType datatype() const;
  void set_datatype(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_datatype() const;
  void _internal_set_datatype(::greptime::v1::ColumnDataType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.StructField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension_;
    int datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColumnDataTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnDataTypeExtension) */ {
 public:
  inline ColumnDataTypeExtension() : ColumnDataTypeExtension(nullptr) {}
  ~ColumnDataTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR ColumnDataTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDataTypeExtension(const ColumnDataTypeExtension& from);
  ColumnDataTypeExtension(ColumnDataTypeExtension&& from) noexcept
    : ColumnDataTypeExtension() {
    *this = ::std::move(from);
  }

  inline ColumnDataTypeExtension& operator=(const ColumnDataTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDataTypeExtension& operator=(ColumnDataTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDataTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  enum TypeExtCase {
    kDecimalType = 1,
    kJsonType = 2,
    kVectorType = 3,
    kListType = 4,
    kStructType = 5,
    TYPE_EXT_NOT_SET = 0,
  };

  static inline const ColumnDataTypeExtension* internal_default_instance() {
    return reinterpret_cast<const ColumnDataTypeExtension*>(
               &_ColumnDataTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ColumnDataTypeExtension& a, ColumnDataTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDataTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDataTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDataTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDataTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDataTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDataTypeExtension& from) {
    ColumnDataTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDataTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnDataTypeExtension";
  }
  protected:
  explicit ColumnDataTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecimalTypeFieldNumber = 1,
    kJsonTypeFieldNumber = 2,
    kVectorTypeFieldNumber = 3,
    kListTypeFieldNumber = 4,
    kStructTypeFieldNumber = 5,
  };
  // .greptime.v1.DecimalTypeExtension decimal_type = 1;
  bool has_decimal_type() const;
  private:
  bool _internal_has_decimal_type() const;
  public:
  void clear_decimal_type();
  const ::greptime::v1::DecimalTypeExtension& decimal_type() const;
  PROTOBUF_NODISCARD ::greptime::v1::DecimalTypeExtension* release_decimal_type();
  ::greptime::v1::DecimalTypeExtension* mutable_decimal_type();
  void set_allocated_decimal_type(::greptime::v1::DecimalTypeExtension* decimal_type);
  private:
  const ::greptime::v1::DecimalTypeExtension& _internal_decimal_type() const;
  ::greptime::v1::DecimalTypeExtension* _internal_mutable_decimal_type();
  public:
  void unsafe_arena_set_allocated_decimal_type(
      ::greptime::v1::DecimalTypeExtension* decimal_type);
  ::greptime::v1::DecimalTypeExtension* unsafe_arena_release_decimal_type();

  // .greptime.v1.JsonTypeExtension json_type = 2;
  bool has_json_type() const;
  private:
  bool _internal_has_json_type() const;
  public:
  void clear_json_type();
  ::greptime::v1::JsonTypeExtension json_type() const;
  void set_json_type(::greptime::v1::JsonTypeExtension value);
  private:
  ::greptime::v1::JsonTypeExtension _internal_json_type() const;
  void _internal_set_json_type(::greptime::v1::JsonTypeExtension value);
  public:

  // .greptime.v1.VectorTypeExtension vector_type = 3;
  bool has_vector_type() const;
  private:
  bool _internal_has_vector_type() const;
  public:
  void clear_vector_type();
  const ::greptime::v1::VectorTypeExtension& vector_type() const;
  PROTOBUF_NODISCARD ::greptime::v1::VectorTypeExtension* release_vector_type();
  ::greptime::v1::VectorTypeExtension* mutable_vector_type();
  void set_allocated_vector_type(::greptime::v1::VectorTypeExtension* vector_type);
  private:
  const ::greptime::v1::VectorTypeExtension& _internal_vector_type() const;
  ::greptime::v1::VectorTypeExtension* _internal_mutable_vector_type();
  public:
  void unsafe_arena_set_allocated_vector_type(
      ::greptime::v1::VectorTypeExtension* vector_type);
  ::greptime::v1::VectorTypeExtension* unsafe_arena_release_vector_type();

  // .greptime.v1.ListTypeExtension list_type = 4;
  bool has_list_type() const;
  private:
  bool _internal_has_list_type() const;
  public:
  void clear_list_type();
  const ::greptime::v1::ListTypeExtension& list_type() const;
  PROTOBUF_NODISCARD ::greptime::v1::ListTypeExtension* release_list_type();
  ::greptime::v1::ListTypeExtension* mutable_list_type();
  void set_allocated_list_type(::greptime::v1::ListTypeExtension* list_type);
  private:
  const ::greptime::v1::ListTypeExtension& _internal_list_type() const;
  ::greptime::v1::ListTypeExtension* _internal_mutable_list_type();
  public:
  void unsafe_arena_set_allocated_list_type(
      ::greptime::v1::ListTypeExtension* list_type);
  ::greptime::v1::ListTypeExtension* unsafe_arena_release_list_type();

  // .greptime.v1.StructTypeExtension struct_type = 5;
  bool has_struct_type() const;
  private:
  bool _internal_has_struct_type() const;
  public:
  void clear_struct_type();
  const ::greptime::v1::StructTypeExtension& struct_type() const;
  PROTOBUF_NODISCARD ::greptime::v1::StructTypeExtension* release_struct_type();
  ::greptime::v1::StructTypeExtension* mutable_struct_type();
  void set_allocated_struct_type(::greptime::v1::StructTypeExtension* struct_type);
  private:
  const ::greptime::v1::StructTypeExtension& _internal_struct_type() const;
  ::greptime::v1::StructTypeExtension* _internal_mutable_struct_type();
  public:
  void unsafe_arena_set_allocated_struct_type(
      ::greptime::v1::StructTypeExtension* struct_type);
  ::greptime::v1::StructTypeExtension* unsafe_arena_release_struct_type();

  void clear_type_ext();
  TypeExtCase type_ext_case() const;
  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnDataTypeExtension)
 private:
  class _Internal;
  void set_has_decimal_type();
  void set_has_json_type();
  void set_has_vector_type();
  void set_has_list_type();
  void set_has_struct_type();

  inline bool has_type_ext() const;
  inline void clear_has_type_ext();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeExtUnion {
      constexpr TypeExtUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::greptime::v1::DecimalTypeExtension* decimal_type_;
      int json_type_;
      ::greptime::v1::VectorTypeExtension* vector_type_;
      ::greptime::v1::ListTypeExtension* list_type_;
      ::greptime::v1::StructTypeExtension* struct_type_;
    } type_ext_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class DecimalTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.DecimalTypeExtension) */ {
 public:
  inline DecimalTypeExtension() : DecimalTypeExtension(nullptr) {}
  ~DecimalTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR DecimalTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecimalTypeExtension(const DecimalTypeExtension& from);
  DecimalTypeExtension(DecimalTypeExtension&& from) noexcept
    : DecimalTypeExtension() {
    *this = ::std::move(from);
  }

  inline DecimalTypeExtension& operator=(const DecimalTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecimalTypeExtension& operator=(DecimalTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecimalTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecimalTypeExtension* internal_default_instance() {
    return reinterpret_cast<const DecimalTypeExtension*>(
               &_DecimalTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DecimalTypeExtension& a, DecimalTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(DecimalTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecimalTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecimalTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecimalTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecimalTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DecimalTypeExtension& from) {
    DecimalTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecimalTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.DecimalTypeExtension";
  }
  protected:
  explicit DecimalTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrecisionFieldNumber = 1,
    kScaleFieldNumber = 2,
  };
  // int32 precision = 1;
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // int32 scale = 2;
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.DecimalTypeExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t precision_;
    int32_t scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class VectorTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.VectorTypeExtension) */ {
 public:
  inline VectorTypeExtension() : VectorTypeExtension(nullptr) {}
  ~VectorTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR VectorTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorTypeExtension(const VectorTypeExtension& from);
  VectorTypeExtension(VectorTypeExtension&& from) noexcept
    : VectorTypeExtension() {
    *this = ::std::move(from);
  }

  inline VectorTypeExtension& operator=(const VectorTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorTypeExtension& operator=(VectorTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorTypeExtension* internal_default_instance() {
    return reinterpret_cast<const VectorTypeExtension*>(
               &_VectorTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(VectorTypeExtension& a, VectorTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VectorTypeExtension& from) {
    VectorTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.VectorTypeExtension";
  }
  protected:
  explicit VectorTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 1,
  };
  // uint32 dim = 1;
  void clear_dim();
  uint32_t dim() const;
  void set_dim(uint32_t value);
  private:
  uint32_t _internal_dim() const;
  void _internal_set_dim(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.VectorTypeExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ListTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ListTypeExtension) */ {
 public:
  inline ListTypeExtension() : ListTypeExtension(nullptr) {}
  ~ListTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR ListTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTypeExtension(const ListTypeExtension& from);
  ListTypeExtension(ListTypeExtension&& from) noexcept
    : ListTypeExtension() {
    *this = ::std::move(from);
  }

  inline ListTypeExtension& operator=(const ListTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTypeExtension& operator=(ListTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTypeExtension* internal_default_instance() {
    return reinterpret_cast<const ListTypeExtension*>(
               &_ListTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListTypeExtension& a, ListTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTypeExtension& from) {
    ListTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ListTypeExtension";
  }
  protected:
  explicit ListTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatatypeExtensionFieldNumber = 2,
    kDatatypeFieldNumber = 1,
  };
  // .greptime.v1.ColumnDataTypeExtension datatype_extension = 2;
  bool has_datatype_extension() const;
  private:
  bool _internal_has_datatype_extension() const;
  public:
  void clear_datatype_extension();
  const ::greptime::v1::ColumnDataTypeExtension& datatype_extension() const;
  PROTOBUF_NODISCARD ::greptime::v1::ColumnDataTypeExtension* release_datatype_extension();
  ::greptime::v1::ColumnDataTypeExtension* mutable_datatype_extension();
  void set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  private:
  const ::greptime::v1::ColumnDataTypeExtension& _internal_datatype_extension() const;
  ::greptime::v1::ColumnDataTypeExtension* _internal_mutable_datatype_extension();
  public:
  void unsafe_arena_set_allocated_datatype_extension(
      ::greptime::v1::ColumnDataTypeExtension* datatype_extension);
  ::greptime::v1::ColumnDataTypeExtension* unsafe_arena_release_datatype_extension();

  // .greptime.v1.ColumnDataType datatype = 1;
  void clear_datatype();
  ::greptime::v1::ColumnDataType datatype() const;
  void set_datatype(::greptime::v1::ColumnDataType value);
  private:
  ::greptime::v1::ColumnDataType _internal_datatype() const;
  void _internal_set_datatype(::greptime::v1::ColumnDataType value);
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ListTypeExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension_;
    int datatype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class StructTypeExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.StructTypeExtension) */ {
 public:
  inline StructTypeExtension() : StructTypeExtension(nullptr) {}
  ~StructTypeExtension() override;
  explicit PROTOBUF_CONSTEXPR StructTypeExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StructTypeExtension(const StructTypeExtension& from);
  StructTypeExtension(StructTypeExtension&& from) noexcept
    : StructTypeExtension() {
    *this = ::std::move(from);
  }

  inline StructTypeExtension& operator=(const StructTypeExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline StructTypeExtension& operator=(StructTypeExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StructTypeExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const StructTypeExtension* internal_default_instance() {
    return reinterpret_cast<const StructTypeExtension*>(
               &_StructTypeExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(StructTypeExtension& a, StructTypeExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(StructTypeExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StructTypeExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StructTypeExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StructTypeExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StructTypeExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StructTypeExtension& from) {
    StructTypeExtension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StructTypeExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.StructTypeExtension";
  }
  protected:
  explicit StructTypeExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .greptime.v1.StructField fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::greptime::v1::StructField* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::StructField >*
      mutable_fields();
  private:
  const ::greptime::v1::StructField& _internal_fields(int index) const;
  ::greptime::v1::StructField* _internal_add_fields();
  public:
  const ::greptime::v1::StructField& fields(int index) const;
  ::greptime::v1::StructField* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::StructField >&
      fields() const;

  // @@protoc_insertion_point(class_scope:greptime.v1.StructTypeExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::StructField > fields_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ColumnOptions_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ColumnOptions_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ColumnOptions_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ColumnOptions_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ColumnOptions_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ColumnOptions_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ColumnOptions_OptionsEntry_DoNotUse& other);
  static const ColumnOptions_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ColumnOptions_OptionsEntry_DoNotUse*>(&_ColumnOptions_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.ColumnOptions.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "greptime.v1.ColumnOptions.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};

// -------------------------------------------------------------------

class ColumnOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ColumnOptions) */ {
 public:
  inline ColumnOptions() : ColumnOptions(nullptr) {}
  ~ColumnOptions() override;
  explicit PROTOBUF_CONSTEXPR ColumnOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnOptions(const ColumnOptions& from);
  ColumnOptions(ColumnOptions&& from) noexcept
    : ColumnOptions() {
    *this = ::std::move(from);
  }

  inline ColumnOptions& operator=(const ColumnOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnOptions& operator=(ColumnOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnOptions* internal_default_instance() {
    return reinterpret_cast<const ColumnOptions*>(
               &_ColumnOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ColumnOptions& a, ColumnOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnOptions& from) {
    ColumnOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ColumnOptions";
  }
  protected:
  explicit ColumnOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
  };
  // map<string, string> options = 1;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // @@protoc_insertion_point(class_scope:greptime.v1.ColumnOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        ColumnOptions_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class ArrowIpc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:greptime.v1.ArrowIpc) */ {
 public:
  inline ArrowIpc() : ArrowIpc(nullptr) {}
  ~ArrowIpc() override;
  explicit PROTOBUF_CONSTEXPR ArrowIpc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrowIpc(const ArrowIpc& from);
  ArrowIpc(ArrowIpc&& from) noexcept
    : ArrowIpc() {
    *this = ::std::move(from);
  }

  inline ArrowIpc& operator=(const ArrowIpc& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrowIpc& operator=(ArrowIpc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArrowIpc& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrowIpc* internal_default_instance() {
    return reinterpret_cast<const ArrowIpc*>(
               &_ArrowIpc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ArrowIpc& a, ArrowIpc& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrowIpc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrowIpc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrowIpc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrowIpc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArrowIpc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArrowIpc& from) {
    ArrowIpc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrowIpc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "greptime.v1.ArrowIpc";
  }
  protected:
  explicit ArrowIpc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaFieldNumber = 1,
    kDataHeaderFieldNumber = 2,
    kPayloadFieldNumber = 3,
  };
  // bytes schema = 1;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // bytes data_header = 2;
  void clear_data_header();
  const std::string& data_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_header();
  PROTOBUF_NODISCARD std::string* release_data_header();
  void set_allocated_data_header(std::string* data_header);
  private:
  const std::string& _internal_data_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_header(const std::string& value);
  std::string* _internal_mutable_data_header();
  public:

  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:greptime.v1.ArrowIpc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_header_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_greptime_2fv1_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// QueryContext

// string current_catalog = 1;
inline void QueryContext::clear_current_catalog() {
  _impl_.current_catalog_.ClearToEmpty();
}
inline const std::string& QueryContext::current_catalog() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.current_catalog)
  return _internal_current_catalog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryContext::set_current_catalog(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_catalog_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.current_catalog)
}
inline std::string* QueryContext::mutable_current_catalog() {
  std::string* _s = _internal_mutable_current_catalog();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.current_catalog)
  return _s;
}
inline const std::string& QueryContext::_internal_current_catalog() const {
  return _impl_.current_catalog_.Get();
}
inline void QueryContext::_internal_set_current_catalog(const std::string& value) {
  
  _impl_.current_catalog_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContext::_internal_mutable_current_catalog() {
  
  return _impl_.current_catalog_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryContext::release_current_catalog() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.current_catalog)
  return _impl_.current_catalog_.Release();
}
inline void QueryContext::set_allocated_current_catalog(std::string* current_catalog) {
  if (current_catalog != nullptr) {
    
  } else {
    
  }
  _impl_.current_catalog_.SetAllocated(current_catalog, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_catalog_.IsDefault()) {
    _impl_.current_catalog_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.current_catalog)
}

// string current_schema = 2;
inline void QueryContext::clear_current_schema() {
  _impl_.current_schema_.ClearToEmpty();
}
inline const std::string& QueryContext::current_schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.current_schema)
  return _internal_current_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryContext::set_current_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.current_schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.current_schema)
}
inline std::string* QueryContext::mutable_current_schema() {
  std::string* _s = _internal_mutable_current_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.current_schema)
  return _s;
}
inline const std::string& QueryContext::_internal_current_schema() const {
  return _impl_.current_schema_.Get();
}
inline void QueryContext::_internal_set_current_schema(const std::string& value) {
  
  _impl_.current_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContext::_internal_mutable_current_schema() {
  
  return _impl_.current_schema_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryContext::release_current_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.current_schema)
  return _impl_.current_schema_.Release();
}
inline void QueryContext::set_allocated_current_schema(std::string* current_schema) {
  if (current_schema != nullptr) {
    
  } else {
    
  }
  _impl_.current_schema_.SetAllocated(current_schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.current_schema_.IsDefault()) {
    _impl_.current_schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.current_schema)
}

// string timezone = 4;
inline void QueryContext::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& QueryContext::timezone() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryContext::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.timezone)
}
inline std::string* QueryContext::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.timezone)
  return _s;
}
inline const std::string& QueryContext::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void QueryContext::_internal_set_timezone(const std::string& value) {
  
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContext::_internal_mutable_timezone() {
  
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryContext::release_timezone() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.timezone)
  return _impl_.timezone_.Release();
}
inline void QueryContext::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.timezone)
}

// map<string, string> extensions = 5;
inline int QueryContext::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int QueryContext::extensions_size() const {
  return _internal_extensions_size();
}
inline void QueryContext::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueryContext::_internal_extensions() const {
  return _impl_.extensions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueryContext::extensions() const {
  // @@protoc_insertion_point(field_map:greptime.v1.QueryContext.extensions)
  return _internal_extensions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueryContext::_internal_mutable_extensions() {
  return _impl_.extensions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueryContext::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.QueryContext.extensions)
  return _internal_mutable_extensions();
}

// uint32 channel = 6;
inline void QueryContext::clear_channel() {
  _impl_.channel_ = 0u;
}
inline uint32_t QueryContext::_internal_channel() const {
  return _impl_.channel_;
}
inline uint32_t QueryContext::channel() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.channel)
  return _internal_channel();
}
inline void QueryContext::_internal_set_channel(uint32_t value) {
  
  _impl_.channel_ = value;
}
inline void QueryContext::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:greptime.v1.QueryContext.channel)
}

// .greptime.v1.SnapshotSequences snapshot_seqs = 7;
inline bool QueryContext::_internal_has_snapshot_seqs() const {
  return this != internal_default_instance() && _impl_.snapshot_seqs_ != nullptr;
}
inline bool QueryContext::has_snapshot_seqs() const {
  return _internal_has_snapshot_seqs();
}
inline void QueryContext::clear_snapshot_seqs() {
  if (GetArenaForAllocation() == nullptr && _impl_.snapshot_seqs_ != nullptr) {
    delete _impl_.snapshot_seqs_;
  }
  _impl_.snapshot_seqs_ = nullptr;
}
inline const ::greptime::v1::SnapshotSequences& QueryContext::_internal_snapshot_seqs() const {
  const ::greptime::v1::SnapshotSequences* p = _impl_.snapshot_seqs_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::SnapshotSequences&>(
      ::greptime::v1::_SnapshotSequences_default_instance_);
}
inline const ::greptime::v1::SnapshotSequences& QueryContext::snapshot_seqs() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.snapshot_seqs)
  return _internal_snapshot_seqs();
}
inline void QueryContext::unsafe_arena_set_allocated_snapshot_seqs(
    ::greptime::v1::SnapshotSequences* snapshot_seqs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snapshot_seqs_);
  }
  _impl_.snapshot_seqs_ = snapshot_seqs;
  if (snapshot_seqs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.QueryContext.snapshot_seqs)
}
inline ::greptime::v1::SnapshotSequences* QueryContext::release_snapshot_seqs() {
  
  ::greptime::v1::SnapshotSequences* temp = _impl_.snapshot_seqs_;
  _impl_.snapshot_seqs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::SnapshotSequences* QueryContext::unsafe_arena_release_snapshot_seqs() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.snapshot_seqs)
  
  ::greptime::v1::SnapshotSequences* temp = _impl_.snapshot_seqs_;
  _impl_.snapshot_seqs_ = nullptr;
  return temp;
}
inline ::greptime::v1::SnapshotSequences* QueryContext::_internal_mutable_snapshot_seqs() {
  
  if (_impl_.snapshot_seqs_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::SnapshotSequences>(GetArenaForAllocation());
    _impl_.snapshot_seqs_ = p;
  }
  return _impl_.snapshot_seqs_;
}
inline ::greptime::v1::SnapshotSequences* QueryContext::mutable_snapshot_seqs() {
  ::greptime::v1::SnapshotSequences* _msg = _internal_mutable_snapshot_seqs();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.snapshot_seqs)
  return _msg;
}
inline void QueryContext::set_allocated_snapshot_seqs(::greptime::v1::SnapshotSequences* snapshot_seqs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snapshot_seqs_;
  }
  if (snapshot_seqs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_seqs);
    if (message_arena != submessage_arena) {
      snapshot_seqs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_seqs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.snapshot_seqs_ = snapshot_seqs;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.snapshot_seqs)
}

// .greptime.v1.ExplainOptions explain = 8;
inline bool QueryContext::_internal_has_explain() const {
  return this != internal_default_instance() && _impl_.explain_ != nullptr;
}
inline bool QueryContext::has_explain() const {
  return _internal_has_explain();
}
inline void QueryContext::clear_explain() {
  if (GetArenaForAllocation() == nullptr && _impl_.explain_ != nullptr) {
    delete _impl_.explain_;
  }
  _impl_.explain_ = nullptr;
}
inline const ::greptime::v1::ExplainOptions& QueryContext::_internal_explain() const {
  const ::greptime::v1::ExplainOptions* p = _impl_.explain_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ExplainOptions&>(
      ::greptime::v1::_ExplainOptions_default_instance_);
}
inline const ::greptime::v1::ExplainOptions& QueryContext::explain() const {
  // @@protoc_insertion_point(field_get:greptime.v1.QueryContext.explain)
  return _internal_explain();
}
inline void QueryContext::unsafe_arena_set_allocated_explain(
    ::greptime::v1::ExplainOptions* explain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.explain_);
  }
  _impl_.explain_ = explain;
  if (explain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.QueryContext.explain)
}
inline ::greptime::v1::ExplainOptions* QueryContext::release_explain() {
  
  ::greptime::v1::ExplainOptions* temp = _impl_.explain_;
  _impl_.explain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ExplainOptions* QueryContext::unsafe_arena_release_explain() {
  // @@protoc_insertion_point(field_release:greptime.v1.QueryContext.explain)
  
  ::greptime::v1::ExplainOptions* temp = _impl_.explain_;
  _impl_.explain_ = nullptr;
  return temp;
}
inline ::greptime::v1::ExplainOptions* QueryContext::_internal_mutable_explain() {
  
  if (_impl_.explain_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ExplainOptions>(GetArenaForAllocation());
    _impl_.explain_ = p;
  }
  return _impl_.explain_;
}
inline ::greptime::v1::ExplainOptions* QueryContext::mutable_explain() {
  ::greptime::v1::ExplainOptions* _msg = _internal_mutable_explain();
  // @@protoc_insertion_point(field_mutable:greptime.v1.QueryContext.explain)
  return _msg;
}
inline void QueryContext::set_allocated_explain(::greptime::v1::ExplainOptions* explain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.explain_;
  }
  if (explain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(explain);
    if (message_arena != submessage_arena) {
      explain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, explain, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.explain_ = explain;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.QueryContext.explain)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SnapshotSequences

// map<uint64, uint64> sst_min_sequences = 1;
inline int SnapshotSequences::_internal_sst_min_sequences_size() const {
  return _impl_.sst_min_sequences_.size();
}
inline int SnapshotSequences::sst_min_sequences_size() const {
  return _internal_sst_min_sequences_size();
}
inline void SnapshotSequences::clear_sst_min_sequences() {
  _impl_.sst_min_sequences_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
SnapshotSequences::_internal_sst_min_sequences() const {
  return _impl_.sst_min_sequences_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
SnapshotSequences::sst_min_sequences() const {
  // @@protoc_insertion_point(field_map:greptime.v1.SnapshotSequences.sst_min_sequences)
  return _internal_sst_min_sequences();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
SnapshotSequences::_internal_mutable_sst_min_sequences() {
  return _impl_.sst_min_sequences_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
SnapshotSequences::mutable_sst_min_sequences() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.SnapshotSequences.sst_min_sequences)
  return _internal_mutable_sst_min_sequences();
}

// map<uint64, uint64> snapshot_seqs = 7;
inline int SnapshotSequences::_internal_snapshot_seqs_size() const {
  return _impl_.snapshot_seqs_.size();
}
inline int SnapshotSequences::snapshot_seqs_size() const {
  return _internal_snapshot_seqs_size();
}
inline void SnapshotSequences::clear_snapshot_seqs() {
  _impl_.snapshot_seqs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
SnapshotSequences::_internal_snapshot_seqs() const {
  return _impl_.snapshot_seqs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >&
SnapshotSequences::snapshot_seqs() const {
  // @@protoc_insertion_point(field_map:greptime.v1.SnapshotSequences.snapshot_seqs)
  return _internal_snapshot_seqs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
SnapshotSequences::_internal_mutable_snapshot_seqs() {
  return _impl_.snapshot_seqs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, uint64_t >*
SnapshotSequences::mutable_snapshot_seqs() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.SnapshotSequences.snapshot_seqs)
  return _internal_mutable_snapshot_seqs();
}

// -------------------------------------------------------------------

// ExplainOptions

// bool verbose = 1;
inline void ExplainOptions::clear_verbose() {
  _impl_.verbose_ = false;
}
inline bool ExplainOptions::_internal_verbose() const {
  return _impl_.verbose_;
}
inline bool ExplainOptions::verbose() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ExplainOptions.verbose)
  return _internal_verbose();
}
inline void ExplainOptions::_internal_set_verbose(bool value) {
  
  _impl_.verbose_ = value;
}
inline void ExplainOptions::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ExplainOptions.verbose)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RequestHeader

// string catalog = 1;
inline void RequestHeader::clear_catalog() {
  _impl_.catalog_.ClearToEmpty();
}
inline const std::string& RequestHeader::catalog() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.catalog)
  return _internal_catalog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_catalog(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.catalog)
}
inline std::string* RequestHeader::mutable_catalog() {
  std::string* _s = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.catalog)
  return _s;
}
inline const std::string& RequestHeader::_internal_catalog() const {
  return _impl_.catalog_.Get();
}
inline void RequestHeader::_internal_set_catalog(const std::string& value) {
  
  _impl_.catalog_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_catalog() {
  
  return _impl_.catalog_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_catalog() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.catalog)
  return _impl_.catalog_.Release();
}
inline void RequestHeader::set_allocated_catalog(std::string* catalog) {
  if (catalog != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_.SetAllocated(catalog, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_.IsDefault()) {
    _impl_.catalog_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.catalog)
}

// string schema = 2;
inline void RequestHeader::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& RequestHeader::schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.schema)
}
inline std::string* RequestHeader::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.schema)
  return _s;
}
inline const std::string& RequestHeader::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void RequestHeader::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.schema)
  return _impl_.schema_.Release();
}
inline void RequestHeader::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.schema)
}

// .greptime.v1.AuthHeader authorization = 3;
inline bool RequestHeader::_internal_has_authorization() const {
  return this != internal_default_instance() && _impl_.authorization_ != nullptr;
}
inline bool RequestHeader::has_authorization() const {
  return _internal_has_authorization();
}
inline void RequestHeader::clear_authorization() {
  if (GetArenaForAllocation() == nullptr && _impl_.authorization_ != nullptr) {
    delete _impl_.authorization_;
  }
  _impl_.authorization_ = nullptr;
}
inline const ::greptime::v1::AuthHeader& RequestHeader::_internal_authorization() const {
  const ::greptime::v1::AuthHeader* p = _impl_.authorization_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AuthHeader&>(
      ::greptime::v1::_AuthHeader_default_instance_);
}
inline const ::greptime::v1::AuthHeader& RequestHeader::authorization() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.authorization)
  return _internal_authorization();
}
inline void RequestHeader::unsafe_arena_set_allocated_authorization(
    ::greptime::v1::AuthHeader* authorization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.authorization_);
  }
  _impl_.authorization_ = authorization;
  if (authorization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.RequestHeader.authorization)
}
inline ::greptime::v1::AuthHeader* RequestHeader::release_authorization() {
  
  ::greptime::v1::AuthHeader* temp = _impl_.authorization_;
  _impl_.authorization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AuthHeader* RequestHeader::unsafe_arena_release_authorization() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.authorization)
  
  ::greptime::v1::AuthHeader* temp = _impl_.authorization_;
  _impl_.authorization_ = nullptr;
  return temp;
}
inline ::greptime::v1::AuthHeader* RequestHeader::_internal_mutable_authorization() {
  
  if (_impl_.authorization_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AuthHeader>(GetArenaForAllocation());
    _impl_.authorization_ = p;
  }
  return _impl_.authorization_;
}
inline ::greptime::v1::AuthHeader* RequestHeader::mutable_authorization() {
  ::greptime::v1::AuthHeader* _msg = _internal_mutable_authorization();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.authorization)
  return _msg;
}
inline void RequestHeader::set_allocated_authorization(::greptime::v1::AuthHeader* authorization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.authorization_;
  }
  if (authorization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(authorization);
    if (message_arena != submessage_arena) {
      authorization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, authorization, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.authorization_ = authorization;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.authorization)
}

// string dbname = 4;
inline void RequestHeader::clear_dbname() {
  _impl_.dbname_.ClearToEmpty();
}
inline const std::string& RequestHeader::dbname() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.dbname)
  return _internal_dbname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_dbname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dbname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.dbname)
}
inline std::string* RequestHeader::mutable_dbname() {
  std::string* _s = _internal_mutable_dbname();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.dbname)
  return _s;
}
inline const std::string& RequestHeader::_internal_dbname() const {
  return _impl_.dbname_.Get();
}
inline void RequestHeader::_internal_set_dbname(const std::string& value) {
  
  _impl_.dbname_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_dbname() {
  
  return _impl_.dbname_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_dbname() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.dbname)
  return _impl_.dbname_.Release();
}
inline void RequestHeader::set_allocated_dbname(std::string* dbname) {
  if (dbname != nullptr) {
    
  } else {
    
  }
  _impl_.dbname_.SetAllocated(dbname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dbname_.IsDefault()) {
    _impl_.dbname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.dbname)
}

// map<string, string> tracing_context = 5;
inline int RequestHeader::_internal_tracing_context_size() const {
  return _impl_.tracing_context_.size();
}
inline int RequestHeader::tracing_context_size() const {
  return _internal_tracing_context_size();
}
inline void RequestHeader::clear_tracing_context() {
  _impl_.tracing_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestHeader::_internal_tracing_context() const {
  return _impl_.tracing_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RequestHeader::tracing_context() const {
  // @@protoc_insertion_point(field_map:greptime.v1.RequestHeader.tracing_context)
  return _internal_tracing_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestHeader::_internal_mutable_tracing_context() {
  return _impl_.tracing_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RequestHeader::mutable_tracing_context() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.RequestHeader.tracing_context)
  return _internal_mutable_tracing_context();
}

// string timezone = 6;
inline void RequestHeader::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& RequestHeader::timezone() const {
  // @@protoc_insertion_point(field_get:greptime.v1.RequestHeader.timezone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestHeader::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.RequestHeader.timezone)
}
inline std::string* RequestHeader::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:greptime.v1.RequestHeader.timezone)
  return _s;
}
inline const std::string& RequestHeader::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void RequestHeader::_internal_set_timezone(const std::string& value) {
  
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestHeader::_internal_mutable_timezone() {
  
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestHeader::release_timezone() {
  // @@protoc_insertion_point(field_release:greptime.v1.RequestHeader.timezone)
  return _impl_.timezone_.Release();
}
inline void RequestHeader::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.RequestHeader.timezone)
}

// -------------------------------------------------------------------

// ResponseHeader

// .greptime.v1.Status status = 1;
inline bool ResponseHeader::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool ResponseHeader::has_status() const {
  return _internal_has_status();
}
inline void ResponseHeader::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::greptime::v1::Status& ResponseHeader::_internal_status() const {
  const ::greptime::v1::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Status&>(
      ::greptime::v1::_Status_default_instance_);
}
inline const ::greptime::v1::Status& ResponseHeader::status() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ResponseHeader.status)
  return _internal_status();
}
inline void ResponseHeader::unsafe_arena_set_allocated_status(
    ::greptime::v1::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ResponseHeader.status)
}
inline ::greptime::v1::Status* ResponseHeader::release_status() {
  
  ::greptime::v1::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Status* ResponseHeader::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:greptime.v1.ResponseHeader.status)
  
  ::greptime::v1::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::greptime::v1::Status* ResponseHeader::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::greptime::v1::Status* ResponseHeader::mutable_status() {
  ::greptime::v1::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ResponseHeader.status)
  return _msg;
}
inline void ResponseHeader::set_allocated_status(::greptime::v1::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ResponseHeader.status)
}

// -------------------------------------------------------------------

// Status

// uint32 status_code = 1;
inline void Status::clear_status_code() {
  _impl_.status_code_ = 0u;
}
inline uint32_t Status::_internal_status_code() const {
  return _impl_.status_code_;
}
inline uint32_t Status::status_code() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Status.status_code)
  return _internal_status_code();
}
inline void Status::_internal_set_status_code(uint32_t value) {
  
  _impl_.status_code_ = value;
}
inline void Status::set_status_code(uint32_t value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:greptime.v1.Status.status_code)
}

// string err_msg = 2;
inline void Status::clear_err_msg() {
  _impl_.err_msg_.ClearToEmpty();
}
inline const std::string& Status::err_msg() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Status.err_msg)
  return _internal_err_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_err_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.err_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Status.err_msg)
}
inline std::string* Status::mutable_err_msg() {
  std::string* _s = _internal_mutable_err_msg();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Status.err_msg)
  return _s;
}
inline const std::string& Status::_internal_err_msg() const {
  return _impl_.err_msg_.Get();
}
inline void Status::_internal_set_err_msg(const std::string& value) {
  
  _impl_.err_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_err_msg() {
  
  return _impl_.err_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_err_msg() {
  // @@protoc_insertion_point(field_release:greptime.v1.Status.err_msg)
  return _impl_.err_msg_.Release();
}
inline void Status::set_allocated_err_msg(std::string* err_msg) {
  if (err_msg != nullptr) {
    
  } else {
    
  }
  _impl_.err_msg_.SetAllocated(err_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.err_msg_.IsDefault()) {
    _impl_.err_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Status.err_msg)
}

// -------------------------------------------------------------------

// AuthHeader

// .greptime.v1.Basic basic = 1;
inline bool AuthHeader::_internal_has_basic() const {
  return auth_scheme_case() == kBasic;
}
inline bool AuthHeader::has_basic() const {
  return _internal_has_basic();
}
inline void AuthHeader::set_has_basic() {
  _impl_._oneof_case_[0] = kBasic;
}
inline void AuthHeader::clear_basic() {
  if (_internal_has_basic()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.auth_scheme_.basic_;
    }
    clear_has_auth_scheme();
  }
}
inline ::greptime::v1::Basic* AuthHeader::release_basic() {
  // @@protoc_insertion_point(field_release:greptime.v1.AuthHeader.basic)
  if (_internal_has_basic()) {
    clear_has_auth_scheme();
    ::greptime::v1::Basic* temp = _impl_.auth_scheme_.basic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.auth_scheme_.basic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::Basic& AuthHeader::_internal_basic() const {
  return _internal_has_basic()
      ? *_impl_.auth_scheme_.basic_
      : reinterpret_cast< ::greptime::v1::Basic&>(::greptime::v1::_Basic_default_instance_);
}
inline const ::greptime::v1::Basic& AuthHeader::basic() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AuthHeader.basic)
  return _internal_basic();
}
inline ::greptime::v1::Basic* AuthHeader::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AuthHeader.basic)
  if (_internal_has_basic()) {
    clear_has_auth_scheme();
    ::greptime::v1::Basic* temp = _impl_.auth_scheme_.basic_;
    _impl_.auth_scheme_.basic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthHeader::unsafe_arena_set_allocated_basic(::greptime::v1::Basic* basic) {
  clear_auth_scheme();
  if (basic) {
    set_has_basic();
    _impl_.auth_scheme_.basic_ = basic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AuthHeader.basic)
}
inline ::greptime::v1::Basic* AuthHeader::_internal_mutable_basic() {
  if (!_internal_has_basic()) {
    clear_auth_scheme();
    set_has_basic();
    _impl_.auth_scheme_.basic_ = CreateMaybeMessage< ::greptime::v1::Basic >(GetArenaForAllocation());
  }
  return _impl_.auth_scheme_.basic_;
}
inline ::greptime::v1::Basic* AuthHeader::mutable_basic() {
  ::greptime::v1::Basic* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AuthHeader.basic)
  return _msg;
}

// .greptime.v1.Token token = 2;
inline bool AuthHeader::_internal_has_token() const {
  return auth_scheme_case() == kToken;
}
inline bool AuthHeader::has_token() const {
  return _internal_has_token();
}
inline void AuthHeader::set_has_token() {
  _impl_._oneof_case_[0] = kToken;
}
inline void AuthHeader::clear_token() {
  if (_internal_has_token()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.auth_scheme_.token_;
    }
    clear_has_auth_scheme();
  }
}
inline ::greptime::v1::Token* AuthHeader::release_token() {
  // @@protoc_insertion_point(field_release:greptime.v1.AuthHeader.token)
  if (_internal_has_token()) {
    clear_has_auth_scheme();
    ::greptime::v1::Token* temp = _impl_.auth_scheme_.token_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.auth_scheme_.token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::Token& AuthHeader::_internal_token() const {
  return _internal_has_token()
      ? *_impl_.auth_scheme_.token_
      : reinterpret_cast< ::greptime::v1::Token&>(::greptime::v1::_Token_default_instance_);
}
inline const ::greptime::v1::Token& AuthHeader::token() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AuthHeader.token)
  return _internal_token();
}
inline ::greptime::v1::Token* AuthHeader::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.AuthHeader.token)
  if (_internal_has_token()) {
    clear_has_auth_scheme();
    ::greptime::v1::Token* temp = _impl_.auth_scheme_.token_;
    _impl_.auth_scheme_.token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AuthHeader::unsafe_arena_set_allocated_token(::greptime::v1::Token* token) {
  clear_auth_scheme();
  if (token) {
    set_has_token();
    _impl_.auth_scheme_.token_ = token;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.AuthHeader.token)
}
inline ::greptime::v1::Token* AuthHeader::_internal_mutable_token() {
  if (!_internal_has_token()) {
    clear_auth_scheme();
    set_has_token();
    _impl_.auth_scheme_.token_ = CreateMaybeMessage< ::greptime::v1::Token >(GetArenaForAllocation());
  }
  return _impl_.auth_scheme_.token_;
}
inline ::greptime::v1::Token* AuthHeader::mutable_token() {
  ::greptime::v1::Token* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:greptime.v1.AuthHeader.token)
  return _msg;
}

inline bool AuthHeader::has_auth_scheme() const {
  return auth_scheme_case() != AUTH_SCHEME_NOT_SET;
}
inline void AuthHeader::clear_has_auth_scheme() {
  _impl_._oneof_case_[0] = AUTH_SCHEME_NOT_SET;
}
inline AuthHeader::AuthSchemeCase AuthHeader::auth_scheme_case() const {
  return AuthHeader::AuthSchemeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Basic

// string username = 1;
inline void Basic::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Basic::username() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Basic.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Basic::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Basic.username)
}
inline std::string* Basic::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Basic.username)
  return _s;
}
inline const std::string& Basic::_internal_username() const {
  return _impl_.username_.Get();
}
inline void Basic::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* Basic::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* Basic::release_username() {
  // @@protoc_insertion_point(field_release:greptime.v1.Basic.username)
  return _impl_.username_.Release();
}
inline void Basic::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Basic.username)
}

// string password = 2;
inline void Basic::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Basic::password() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Basic.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Basic::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Basic.password)
}
inline std::string* Basic::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Basic.password)
  return _s;
}
inline const std::string& Basic::_internal_password() const {
  return _impl_.password_.Get();
}
inline void Basic::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* Basic::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* Basic::release_password() {
  // @@protoc_insertion_point(field_release:greptime.v1.Basic.password)
  return _impl_.password_.Release();
}
inline void Basic::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Basic.password)
}

// -------------------------------------------------------------------

// Token

// string token = 1;
inline void Token::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& Token::token() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Token.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Token.token)
}
inline std::string* Token::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Token.token)
  return _s;
}
inline const std::string& Token::_internal_token() const {
  return _impl_.token_.Get();
}
inline void Token::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_token() {
  // @@protoc_insertion_point(field_release:greptime.v1.Token.token)
  return _impl_.token_.Release();
}
inline void Token::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Token.token)
}

// -------------------------------------------------------------------

// TableName

// string catalog_name = 1;
inline void TableName::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
}
inline const std::string& TableName::catalog_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableName.catalog_name)
  return _internal_catalog_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_catalog_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.catalog_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TableName.catalog_name)
}
inline std::string* TableName::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TableName.catalog_name)
  return _s;
}
inline const std::string& TableName::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void TableName::_internal_set_catalog_name(const std::string& value) {
  
  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_catalog_name() {
  
  return _impl_.catalog_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableName::release_catalog_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TableName.catalog_name)
  return _impl_.catalog_name_.Release();
}
inline void TableName::set_allocated_catalog_name(std::string* catalog_name) {
  if (catalog_name != nullptr) {
    
  } else {
    
  }
  _impl_.catalog_name_.SetAllocated(catalog_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.catalog_name_.IsDefault()) {
    _impl_.catalog_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TableName.catalog_name)
}

// string schema_name = 2;
inline void TableName::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& TableName::schema_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableName.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TableName.schema_name)
}
inline std::string* TableName::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TableName.schema_name)
  return _s;
}
inline const std::string& TableName::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TableName::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableName::release_schema_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TableName.schema_name)
  return _impl_.schema_name_.Release();
}
inline void TableName::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TableName.schema_name)
}

// string table_name = 3;
inline void TableName::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& TableName::table_name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TableName.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.TableName.table_name)
}
inline std::string* TableName::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.TableName.table_name)
  return _s;
}
inline const std::string& TableName::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TableName::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableName::release_table_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.TableName.table_name)
  return _impl_.table_name_.Release();
}
inline void TableName::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.TableName.table_name)
}

// -------------------------------------------------------------------

// AffectedRows

// uint32 value = 1;
inline void AffectedRows::clear_value() {
  _impl_.value_ = 0u;
}
inline uint32_t AffectedRows::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t AffectedRows::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.AffectedRows.value)
  return _internal_value();
}
inline void AffectedRows::_internal_set_value(uint32_t value) {
  
  _impl_.value_ = value;
}
inline void AffectedRows::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:greptime.v1.AffectedRows.value)
}

// -------------------------------------------------------------------

// Metrics

// bytes metrics = 1;
inline void Metrics::clear_metrics() {
  _impl_.metrics_.ClearToEmpty();
}
inline const std::string& Metrics::metrics() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Metrics.metrics)
  return _internal_metrics();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metrics::set_metrics(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metrics_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.Metrics.metrics)
}
inline std::string* Metrics::mutable_metrics() {
  std::string* _s = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:greptime.v1.Metrics.metrics)
  return _s;
}
inline const std::string& Metrics::_internal_metrics() const {
  return _impl_.metrics_.Get();
}
inline void Metrics::_internal_set_metrics(const std::string& value) {
  
  _impl_.metrics_.Set(value, GetArenaForAllocation());
}
inline std::string* Metrics::_internal_mutable_metrics() {
  
  return _impl_.metrics_.Mutable(GetArenaForAllocation());
}
inline std::string* Metrics::release_metrics() {
  // @@protoc_insertion_point(field_release:greptime.v1.Metrics.metrics)
  return _impl_.metrics_.Release();
}
inline void Metrics::set_allocated_metrics(std::string* metrics) {
  if (metrics != nullptr) {
    
  } else {
    
  }
  _impl_.metrics_.SetAllocated(metrics, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metrics_.IsDefault()) {
    _impl_.metrics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.Metrics.metrics)
}

// -------------------------------------------------------------------

// ExpireAfter

// int64 value = 1;
inline void ExpireAfter::clear_value() {
  _impl_.value_ = int64_t{0};
}
inline int64_t ExpireAfter::_internal_value() const {
  return _impl_.value_;
}
inline int64_t ExpireAfter::value() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ExpireAfter.value)
  return _internal_value();
}
inline void ExpireAfter::_internal_set_value(int64_t value) {
  
  _impl_.value_ = value;
}
inline void ExpireAfter::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ExpireAfter.value)
}

// -------------------------------------------------------------------

// EvalInterval

// int64 seconds = 1;
inline void EvalInterval::clear_seconds() {
  _impl_.seconds_ = int64_t{0};
}
inline int64_t EvalInterval::_internal_seconds() const {
  return _impl_.seconds_;
}
inline int64_t EvalInterval::seconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.EvalInterval.seconds)
  return _internal_seconds();
}
inline void EvalInterval::_internal_set_seconds(int64_t value) {
  
  _impl_.seconds_ = value;
}
inline void EvalInterval::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.EvalInterval.seconds)
}

// -------------------------------------------------------------------

// FlightMetadata

// .greptime.v1.AffectedRows affected_rows = 1;
inline bool FlightMetadata::_internal_has_affected_rows() const {
  return this != internal_default_instance() && _impl_.affected_rows_ != nullptr;
}
inline bool FlightMetadata::has_affected_rows() const {
  return _internal_has_affected_rows();
}
inline void FlightMetadata::clear_affected_rows() {
  if (GetArenaForAllocation() == nullptr && _impl_.affected_rows_ != nullptr) {
    delete _impl_.affected_rows_;
  }
  _impl_.affected_rows_ = nullptr;
}
inline const ::greptime::v1::AffectedRows& FlightMetadata::_internal_affected_rows() const {
  const ::greptime::v1::AffectedRows* p = _impl_.affected_rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::AffectedRows&>(
      ::greptime::v1::_AffectedRows_default_instance_);
}
inline const ::greptime::v1::AffectedRows& FlightMetadata::affected_rows() const {
  // @@protoc_insertion_point(field_get:greptime.v1.FlightMetadata.affected_rows)
  return _internal_affected_rows();
}
inline void FlightMetadata::unsafe_arena_set_allocated_affected_rows(
    ::greptime::v1::AffectedRows* affected_rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.affected_rows_);
  }
  _impl_.affected_rows_ = affected_rows;
  if (affected_rows) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.FlightMetadata.affected_rows)
}
inline ::greptime::v1::AffectedRows* FlightMetadata::release_affected_rows() {
  
  ::greptime::v1::AffectedRows* temp = _impl_.affected_rows_;
  _impl_.affected_rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::AffectedRows* FlightMetadata::unsafe_arena_release_affected_rows() {
  // @@protoc_insertion_point(field_release:greptime.v1.FlightMetadata.affected_rows)
  
  ::greptime::v1::AffectedRows* temp = _impl_.affected_rows_;
  _impl_.affected_rows_ = nullptr;
  return temp;
}
inline ::greptime::v1::AffectedRows* FlightMetadata::_internal_mutable_affected_rows() {
  
  if (_impl_.affected_rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::AffectedRows>(GetArenaForAllocation());
    _impl_.affected_rows_ = p;
  }
  return _impl_.affected_rows_;
}
inline ::greptime::v1::AffectedRows* FlightMetadata::mutable_affected_rows() {
  ::greptime::v1::AffectedRows* _msg = _internal_mutable_affected_rows();
  // @@protoc_insertion_point(field_mutable:greptime.v1.FlightMetadata.affected_rows)
  return _msg;
}
inline void FlightMetadata::set_allocated_affected_rows(::greptime::v1::AffectedRows* affected_rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.affected_rows_;
  }
  if (affected_rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(affected_rows);
    if (message_arena != submessage_arena) {
      affected_rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, affected_rows, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.affected_rows_ = affected_rows;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.FlightMetadata.affected_rows)
}

// .greptime.v1.Metrics metrics = 2;
inline bool FlightMetadata::_internal_has_metrics() const {
  return this != internal_default_instance() && _impl_.metrics_ != nullptr;
}
inline bool FlightMetadata::has_metrics() const {
  return _internal_has_metrics();
}
inline void FlightMetadata::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.metrics_ != nullptr) {
    delete _impl_.metrics_;
  }
  _impl_.metrics_ = nullptr;
}
inline const ::greptime::v1::Metrics& FlightMetadata::_internal_metrics() const {
  const ::greptime::v1::Metrics* p = _impl_.metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::Metrics&>(
      ::greptime::v1::_Metrics_default_instance_);
}
inline const ::greptime::v1::Metrics& FlightMetadata::metrics() const {
  // @@protoc_insertion_point(field_get:greptime.v1.FlightMetadata.metrics)
  return _internal_metrics();
}
inline void FlightMetadata::unsafe_arena_set_allocated_metrics(
    ::greptime::v1::Metrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metrics_);
  }
  _impl_.metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.FlightMetadata.metrics)
}
inline ::greptime::v1::Metrics* FlightMetadata::release_metrics() {
  
  ::greptime::v1::Metrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::Metrics* FlightMetadata::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:greptime.v1.FlightMetadata.metrics)
  
  ::greptime::v1::Metrics* temp = _impl_.metrics_;
  _impl_.metrics_ = nullptr;
  return temp;
}
inline ::greptime::v1::Metrics* FlightMetadata::_internal_mutable_metrics() {
  
  if (_impl_.metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::Metrics>(GetArenaForAllocation());
    _impl_.metrics_ = p;
  }
  return _impl_.metrics_;
}
inline ::greptime::v1::Metrics* FlightMetadata::mutable_metrics() {
  ::greptime::v1::Metrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:greptime.v1.FlightMetadata.metrics)
  return _msg;
}
inline void FlightMetadata::set_allocated_metrics(::greptime::v1::Metrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.FlightMetadata.metrics)
}

// -------------------------------------------------------------------

// IntervalMonthDayNano

// int32 months = 1;
inline void IntervalMonthDayNano::clear_months() {
  _impl_.months_ = 0;
}
inline int32_t IntervalMonthDayNano::_internal_months() const {
  return _impl_.months_;
}
inline int32_t IntervalMonthDayNano::months() const {
  // @@protoc_insertion_point(field_get:greptime.v1.IntervalMonthDayNano.months)
  return _internal_months();
}
inline void IntervalMonthDayNano::_internal_set_months(int32_t value) {
  
  _impl_.months_ = value;
}
inline void IntervalMonthDayNano::set_months(int32_t value) {
  _internal_set_months(value);
  // @@protoc_insertion_point(field_set:greptime.v1.IntervalMonthDayNano.months)
}

// int32 days = 2;
inline void IntervalMonthDayNano::clear_days() {
  _impl_.days_ = 0;
}
inline int32_t IntervalMonthDayNano::_internal_days() const {
  return _impl_.days_;
}
inline int32_t IntervalMonthDayNano::days() const {
  // @@protoc_insertion_point(field_get:greptime.v1.IntervalMonthDayNano.days)
  return _internal_days();
}
inline void IntervalMonthDayNano::_internal_set_days(int32_t value) {
  
  _impl_.days_ = value;
}
inline void IntervalMonthDayNano::set_days(int32_t value) {
  _internal_set_days(value);
  // @@protoc_insertion_point(field_set:greptime.v1.IntervalMonthDayNano.days)
}

// int64 nanoseconds = 3;
inline void IntervalMonthDayNano::clear_nanoseconds() {
  _impl_.nanoseconds_ = int64_t{0};
}
inline int64_t IntervalMonthDayNano::_internal_nanoseconds() const {
  return _impl_.nanoseconds_;
}
inline int64_t IntervalMonthDayNano::nanoseconds() const {
  // @@protoc_insertion_point(field_get:greptime.v1.IntervalMonthDayNano.nanoseconds)
  return _internal_nanoseconds();
}
inline void IntervalMonthDayNano::_internal_set_nanoseconds(int64_t value) {
  
  _impl_.nanoseconds_ = value;
}
inline void IntervalMonthDayNano::set_nanoseconds(int64_t value) {
  _internal_set_nanoseconds(value);
  // @@protoc_insertion_point(field_set:greptime.v1.IntervalMonthDayNano.nanoseconds)
}

// -------------------------------------------------------------------

// TimeRange

// int64 start = 1;
inline void TimeRange::clear_start() {
  _impl_.start_ = int64_t{0};
}
inline int64_t TimeRange::_internal_start() const {
  return _impl_.start_;
}
inline int64_t TimeRange::start() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TimeRange.start)
  return _internal_start();
}
inline void TimeRange::_internal_set_start(int64_t value) {
  
  _impl_.start_ = value;
}
inline void TimeRange::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:greptime.v1.TimeRange.start)
}

// int64 end = 2;
inline void TimeRange::clear_end() {
  _impl_.end_ = int64_t{0};
}
inline int64_t TimeRange::_internal_end() const {
  return _impl_.end_;
}
inline int64_t TimeRange::end() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TimeRange.end)
  return _internal_end();
}
inline void TimeRange::_internal_set_end(int64_t value) {
  
  _impl_.end_ = value;
}
inline void TimeRange::set_end(int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:greptime.v1.TimeRange.end)
}

// -------------------------------------------------------------------

// TimeRanges

// .greptime.v1.TimeUnit time_unit = 1;
inline void TimeRanges::clear_time_unit() {
  _impl_.time_unit_ = 0;
}
inline ::greptime::v1::TimeUnit TimeRanges::_internal_time_unit() const {
  return static_cast< ::greptime::v1::TimeUnit >(_impl_.time_unit_);
}
inline ::greptime::v1::TimeUnit TimeRanges::time_unit() const {
  // @@protoc_insertion_point(field_get:greptime.v1.TimeRanges.time_unit)
  return _internal_time_unit();
}
inline void TimeRanges::_internal_set_time_unit(::greptime::v1::TimeUnit value) {
  
  _impl_.time_unit_ = value;
}
inline void TimeRanges::set_time_unit(::greptime::v1::TimeUnit value) {
  _internal_set_time_unit(value);
  // @@protoc_insertion_point(field_set:greptime.v1.TimeRanges.time_unit)
}

// repeated .greptime.v1.TimeRange time_ranges = 2;
inline int TimeRanges::_internal_time_ranges_size() const {
  return _impl_.time_ranges_.size();
}
inline int TimeRanges::time_ranges_size() const {
  return _internal_time_ranges_size();
}
inline void TimeRanges::clear_time_ranges() {
  _impl_.time_ranges_.Clear();
}
inline ::greptime::v1::TimeRange* TimeRanges::mutable_time_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.TimeRanges.time_ranges)
  return _impl_.time_ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TimeRange >*
TimeRanges::mutable_time_ranges() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.TimeRanges.time_ranges)
  return &_impl_.time_ranges_;
}
inline const ::greptime::v1::TimeRange& TimeRanges::_internal_time_ranges(int index) const {
  return _impl_.time_ranges_.Get(index);
}
inline const ::greptime::v1::TimeRange& TimeRanges::time_ranges(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.TimeRanges.time_ranges)
  return _internal_time_ranges(index);
}
inline ::greptime::v1::TimeRange* TimeRanges::_internal_add_time_ranges() {
  return _impl_.time_ranges_.Add();
}
inline ::greptime::v1::TimeRange* TimeRanges::add_time_ranges() {
  ::greptime::v1::TimeRange* _add = _internal_add_time_ranges();
  // @@protoc_insertion_point(field_add:greptime.v1.TimeRanges.time_ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::TimeRange >&
TimeRanges::time_ranges() const {
  // @@protoc_insertion_point(field_list:greptime.v1.TimeRanges.time_ranges)
  return _impl_.time_ranges_;
}

// -------------------------------------------------------------------

// Decimal128

// int64 hi = 1;
inline void Decimal128::clear_hi() {
  _impl_.hi_ = int64_t{0};
}
inline int64_t Decimal128::_internal_hi() const {
  return _impl_.hi_;
}
inline int64_t Decimal128::hi() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Decimal128.hi)
  return _internal_hi();
}
inline void Decimal128::_internal_set_hi(int64_t value) {
  
  _impl_.hi_ = value;
}
inline void Decimal128::set_hi(int64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:greptime.v1.Decimal128.hi)
}

// int64 lo = 2;
inline void Decimal128::clear_lo() {
  _impl_.lo_ = int64_t{0};
}
inline int64_t Decimal128::_internal_lo() const {
  return _impl_.lo_;
}
inline int64_t Decimal128::lo() const {
  // @@protoc_insertion_point(field_get:greptime.v1.Decimal128.lo)
  return _internal_lo();
}
inline void Decimal128::_internal_set_lo(int64_t value) {
  
  _impl_.lo_ = value;
}
inline void Decimal128::set_lo(int64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:greptime.v1.Decimal128.lo)
}

// -------------------------------------------------------------------

// StructField

// string name = 1;
inline void StructField::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StructField::name() const {
  // @@protoc_insertion_point(field_get:greptime.v1.StructField.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StructField::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.StructField.name)
}
inline std::string* StructField::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:greptime.v1.StructField.name)
  return _s;
}
inline const std::string& StructField::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StructField::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StructField::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StructField::release_name() {
  // @@protoc_insertion_point(field_release:greptime.v1.StructField.name)
  return _impl_.name_.Release();
}
inline void StructField::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.StructField.name)
}

// .greptime.v1.ColumnDataType datatype = 2;
inline void StructField::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::greptime::v1::ColumnDataType StructField::_internal_datatype() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.datatype_);
}
inline ::greptime::v1::ColumnDataType StructField::datatype() const {
  // @@protoc_insertion_point(field_get:greptime.v1.StructField.datatype)
  return _internal_datatype();
}
inline void StructField::_internal_set_datatype(::greptime::v1::ColumnDataType value) {
  
  _impl_.datatype_ = value;
}
inline void StructField::set_datatype(::greptime::v1::ColumnDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:greptime.v1.StructField.datatype)
}

// .greptime.v1.ColumnDataTypeExtension datatype_extension = 3;
inline bool StructField::_internal_has_datatype_extension() const {
  return this != internal_default_instance() && _impl_.datatype_extension_ != nullptr;
}
inline bool StructField::has_datatype_extension() const {
  return _internal_has_datatype_extension();
}
inline void StructField::clear_datatype_extension() {
  if (GetArenaForAllocation() == nullptr && _impl_.datatype_extension_ != nullptr) {
    delete _impl_.datatype_extension_;
  }
  _impl_.datatype_extension_ = nullptr;
}
inline const ::greptime::v1::ColumnDataTypeExtension& StructField::_internal_datatype_extension() const {
  const ::greptime::v1::ColumnDataTypeExtension* p = _impl_.datatype_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDataTypeExtension&>(
      ::greptime::v1::_ColumnDataTypeExtension_default_instance_);
}
inline const ::greptime::v1::ColumnDataTypeExtension& StructField::datatype_extension() const {
  // @@protoc_insertion_point(field_get:greptime.v1.StructField.datatype_extension)
  return _internal_datatype_extension();
}
inline void StructField::unsafe_arena_set_allocated_datatype_extension(
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_extension_);
  }
  _impl_.datatype_extension_ = datatype_extension;
  if (datatype_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.StructField.datatype_extension)
}
inline ::greptime::v1::ColumnDataTypeExtension* StructField::release_datatype_extension() {
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* StructField::unsafe_arena_release_datatype_extension() {
  // @@protoc_insertion_point(field_release:greptime.v1.StructField.datatype_extension)
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* StructField::_internal_mutable_datatype_extension() {
  
  if (_impl_.datatype_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(GetArenaForAllocation());
    _impl_.datatype_extension_ = p;
  }
  return _impl_.datatype_extension_;
}
inline ::greptime::v1::ColumnDataTypeExtension* StructField::mutable_datatype_extension() {
  ::greptime::v1::ColumnDataTypeExtension* _msg = _internal_mutable_datatype_extension();
  // @@protoc_insertion_point(field_mutable:greptime.v1.StructField.datatype_extension)
  return _msg;
}
inline void StructField::set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.datatype_extension_;
  }
  if (datatype_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datatype_extension);
    if (message_arena != submessage_arena) {
      datatype_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datatype_extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datatype_extension_ = datatype_extension;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.StructField.datatype_extension)
}

// -------------------------------------------------------------------

// ColumnDataTypeExtension

// .greptime.v1.DecimalTypeExtension decimal_type = 1;
inline bool ColumnDataTypeExtension::_internal_has_decimal_type() const {
  return type_ext_case() == kDecimalType;
}
inline bool ColumnDataTypeExtension::has_decimal_type() const {
  return _internal_has_decimal_type();
}
inline void ColumnDataTypeExtension::set_has_decimal_type() {
  _impl_._oneof_case_[0] = kDecimalType;
}
inline void ColumnDataTypeExtension::clear_decimal_type() {
  if (_internal_has_decimal_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_ext_.decimal_type_;
    }
    clear_has_type_ext();
  }
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::release_decimal_type() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDataTypeExtension.decimal_type)
  if (_internal_has_decimal_type()) {
    clear_has_type_ext();
    ::greptime::v1::DecimalTypeExtension* temp = _impl_.type_ext_.decimal_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_ext_.decimal_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::DecimalTypeExtension& ColumnDataTypeExtension::_internal_decimal_type() const {
  return _internal_has_decimal_type()
      ? *_impl_.type_ext_.decimal_type_
      : reinterpret_cast< ::greptime::v1::DecimalTypeExtension&>(::greptime::v1::_DecimalTypeExtension_default_instance_);
}
inline const ::greptime::v1::DecimalTypeExtension& ColumnDataTypeExtension::decimal_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.decimal_type)
  return _internal_decimal_type();
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::unsafe_arena_release_decimal_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.ColumnDataTypeExtension.decimal_type)
  if (_internal_has_decimal_type()) {
    clear_has_type_ext();
    ::greptime::v1::DecimalTypeExtension* temp = _impl_.type_ext_.decimal_type_;
    _impl_.type_ext_.decimal_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ColumnDataTypeExtension::unsafe_arena_set_allocated_decimal_type(::greptime::v1::DecimalTypeExtension* decimal_type) {
  clear_type_ext();
  if (decimal_type) {
    set_has_decimal_type();
    _impl_.type_ext_.decimal_type_ = decimal_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDataTypeExtension.decimal_type)
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::_internal_mutable_decimal_type() {
  if (!_internal_has_decimal_type()) {
    clear_type_ext();
    set_has_decimal_type();
    _impl_.type_ext_.decimal_type_ = CreateMaybeMessage< ::greptime::v1::DecimalTypeExtension >(GetArenaForAllocation());
  }
  return _impl_.type_ext_.decimal_type_;
}
inline ::greptime::v1::DecimalTypeExtension* ColumnDataTypeExtension::mutable_decimal_type() {
  ::greptime::v1::DecimalTypeExtension* _msg = _internal_mutable_decimal_type();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDataTypeExtension.decimal_type)
  return _msg;
}

// .greptime.v1.JsonTypeExtension json_type = 2;
inline bool ColumnDataTypeExtension::_internal_has_json_type() const {
  return type_ext_case() == kJsonType;
}
inline bool ColumnDataTypeExtension::has_json_type() const {
  return _internal_has_json_type();
}
inline void ColumnDataTypeExtension::set_has_json_type() {
  _impl_._oneof_case_[0] = kJsonType;
}
inline void ColumnDataTypeExtension::clear_json_type() {
  if (_internal_has_json_type()) {
    _impl_.type_ext_.json_type_ = 0;
    clear_has_type_ext();
  }
}
inline ::greptime::v1::JsonTypeExtension ColumnDataTypeExtension::_internal_json_type() const {
  if (_internal_has_json_type()) {
    return static_cast< ::greptime::v1::JsonTypeExtension >(_impl_.type_ext_.json_type_);
  }
  return static_cast< ::greptime::v1::JsonTypeExtension >(0);
}
inline ::greptime::v1::JsonTypeExtension ColumnDataTypeExtension::json_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.json_type)
  return _internal_json_type();
}
inline void ColumnDataTypeExtension::_internal_set_json_type(::greptime::v1::JsonTypeExtension value) {
  if (!_internal_has_json_type()) {
    clear_type_ext();
    set_has_json_type();
  }
  _impl_.type_ext_.json_type_ = value;
}
inline void ColumnDataTypeExtension::set_json_type(::greptime::v1::JsonTypeExtension value) {
  _internal_set_json_type(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ColumnDataTypeExtension.json_type)
}

// .greptime.v1.VectorTypeExtension vector_type = 3;
inline bool ColumnDataTypeExtension::_internal_has_vector_type() const {
  return type_ext_case() == kVectorType;
}
inline bool ColumnDataTypeExtension::has_vector_type() const {
  return _internal_has_vector_type();
}
inline void ColumnDataTypeExtension::set_has_vector_type() {
  _impl_._oneof_case_[0] = kVectorType;
}
inline void ColumnDataTypeExtension::clear_vector_type() {
  if (_internal_has_vector_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_ext_.vector_type_;
    }
    clear_has_type_ext();
  }
}
inline ::greptime::v1::VectorTypeExtension* ColumnDataTypeExtension::release_vector_type() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDataTypeExtension.vector_type)
  if (_internal_has_vector_type()) {
    clear_has_type_ext();
    ::greptime::v1::VectorTypeExtension* temp = _impl_.type_ext_.vector_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_ext_.vector_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::VectorTypeExtension& ColumnDataTypeExtension::_internal_vector_type() const {
  return _internal_has_vector_type()
      ? *_impl_.type_ext_.vector_type_
      : reinterpret_cast< ::greptime::v1::VectorTypeExtension&>(::greptime::v1::_VectorTypeExtension_default_instance_);
}
inline const ::greptime::v1::VectorTypeExtension& ColumnDataTypeExtension::vector_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.vector_type)
  return _internal_vector_type();
}
inline ::greptime::v1::VectorTypeExtension* ColumnDataTypeExtension::unsafe_arena_release_vector_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.ColumnDataTypeExtension.vector_type)
  if (_internal_has_vector_type()) {
    clear_has_type_ext();
    ::greptime::v1::VectorTypeExtension* temp = _impl_.type_ext_.vector_type_;
    _impl_.type_ext_.vector_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ColumnDataTypeExtension::unsafe_arena_set_allocated_vector_type(::greptime::v1::VectorTypeExtension* vector_type) {
  clear_type_ext();
  if (vector_type) {
    set_has_vector_type();
    _impl_.type_ext_.vector_type_ = vector_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDataTypeExtension.vector_type)
}
inline ::greptime::v1::VectorTypeExtension* ColumnDataTypeExtension::_internal_mutable_vector_type() {
  if (!_internal_has_vector_type()) {
    clear_type_ext();
    set_has_vector_type();
    _impl_.type_ext_.vector_type_ = CreateMaybeMessage< ::greptime::v1::VectorTypeExtension >(GetArenaForAllocation());
  }
  return _impl_.type_ext_.vector_type_;
}
inline ::greptime::v1::VectorTypeExtension* ColumnDataTypeExtension::mutable_vector_type() {
  ::greptime::v1::VectorTypeExtension* _msg = _internal_mutable_vector_type();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDataTypeExtension.vector_type)
  return _msg;
}

// .greptime.v1.ListTypeExtension list_type = 4;
inline bool ColumnDataTypeExtension::_internal_has_list_type() const {
  return type_ext_case() == kListType;
}
inline bool ColumnDataTypeExtension::has_list_type() const {
  return _internal_has_list_type();
}
inline void ColumnDataTypeExtension::set_has_list_type() {
  _impl_._oneof_case_[0] = kListType;
}
inline void ColumnDataTypeExtension::clear_list_type() {
  if (_internal_has_list_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_ext_.list_type_;
    }
    clear_has_type_ext();
  }
}
inline ::greptime::v1::ListTypeExtension* ColumnDataTypeExtension::release_list_type() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDataTypeExtension.list_type)
  if (_internal_has_list_type()) {
    clear_has_type_ext();
    ::greptime::v1::ListTypeExtension* temp = _impl_.type_ext_.list_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_ext_.list_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::ListTypeExtension& ColumnDataTypeExtension::_internal_list_type() const {
  return _internal_has_list_type()
      ? *_impl_.type_ext_.list_type_
      : reinterpret_cast< ::greptime::v1::ListTypeExtension&>(::greptime::v1::_ListTypeExtension_default_instance_);
}
inline const ::greptime::v1::ListTypeExtension& ColumnDataTypeExtension::list_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.list_type)
  return _internal_list_type();
}
inline ::greptime::v1::ListTypeExtension* ColumnDataTypeExtension::unsafe_arena_release_list_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.ColumnDataTypeExtension.list_type)
  if (_internal_has_list_type()) {
    clear_has_type_ext();
    ::greptime::v1::ListTypeExtension* temp = _impl_.type_ext_.list_type_;
    _impl_.type_ext_.list_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ColumnDataTypeExtension::unsafe_arena_set_allocated_list_type(::greptime::v1::ListTypeExtension* list_type) {
  clear_type_ext();
  if (list_type) {
    set_has_list_type();
    _impl_.type_ext_.list_type_ = list_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDataTypeExtension.list_type)
}
inline ::greptime::v1::ListTypeExtension* ColumnDataTypeExtension::_internal_mutable_list_type() {
  if (!_internal_has_list_type()) {
    clear_type_ext();
    set_has_list_type();
    _impl_.type_ext_.list_type_ = CreateMaybeMessage< ::greptime::v1::ListTypeExtension >(GetArenaForAllocation());
  }
  return _impl_.type_ext_.list_type_;
}
inline ::greptime::v1::ListTypeExtension* ColumnDataTypeExtension::mutable_list_type() {
  ::greptime::v1::ListTypeExtension* _msg = _internal_mutable_list_type();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDataTypeExtension.list_type)
  return _msg;
}

// .greptime.v1.StructTypeExtension struct_type = 5;
inline bool ColumnDataTypeExtension::_internal_has_struct_type() const {
  return type_ext_case() == kStructType;
}
inline bool ColumnDataTypeExtension::has_struct_type() const {
  return _internal_has_struct_type();
}
inline void ColumnDataTypeExtension::set_has_struct_type() {
  _impl_._oneof_case_[0] = kStructType;
}
inline void ColumnDataTypeExtension::clear_struct_type() {
  if (_internal_has_struct_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_ext_.struct_type_;
    }
    clear_has_type_ext();
  }
}
inline ::greptime::v1::StructTypeExtension* ColumnDataTypeExtension::release_struct_type() {
  // @@protoc_insertion_point(field_release:greptime.v1.ColumnDataTypeExtension.struct_type)
  if (_internal_has_struct_type()) {
    clear_has_type_ext();
    ::greptime::v1::StructTypeExtension* temp = _impl_.type_ext_.struct_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_ext_.struct_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::greptime::v1::StructTypeExtension& ColumnDataTypeExtension::_internal_struct_type() const {
  return _internal_has_struct_type()
      ? *_impl_.type_ext_.struct_type_
      : reinterpret_cast< ::greptime::v1::StructTypeExtension&>(::greptime::v1::_StructTypeExtension_default_instance_);
}
inline const ::greptime::v1::StructTypeExtension& ColumnDataTypeExtension::struct_type() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ColumnDataTypeExtension.struct_type)
  return _internal_struct_type();
}
inline ::greptime::v1::StructTypeExtension* ColumnDataTypeExtension::unsafe_arena_release_struct_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:greptime.v1.ColumnDataTypeExtension.struct_type)
  if (_internal_has_struct_type()) {
    clear_has_type_ext();
    ::greptime::v1::StructTypeExtension* temp = _impl_.type_ext_.struct_type_;
    _impl_.type_ext_.struct_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ColumnDataTypeExtension::unsafe_arena_set_allocated_struct_type(::greptime::v1::StructTypeExtension* struct_type) {
  clear_type_ext();
  if (struct_type) {
    set_has_struct_type();
    _impl_.type_ext_.struct_type_ = struct_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ColumnDataTypeExtension.struct_type)
}
inline ::greptime::v1::StructTypeExtension* ColumnDataTypeExtension::_internal_mutable_struct_type() {
  if (!_internal_has_struct_type()) {
    clear_type_ext();
    set_has_struct_type();
    _impl_.type_ext_.struct_type_ = CreateMaybeMessage< ::greptime::v1::StructTypeExtension >(GetArenaForAllocation());
  }
  return _impl_.type_ext_.struct_type_;
}
inline ::greptime::v1::StructTypeExtension* ColumnDataTypeExtension::mutable_struct_type() {
  ::greptime::v1::StructTypeExtension* _msg = _internal_mutable_struct_type();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ColumnDataTypeExtension.struct_type)
  return _msg;
}

inline bool ColumnDataTypeExtension::has_type_ext() const {
  return type_ext_case() != TYPE_EXT_NOT_SET;
}
inline void ColumnDataTypeExtension::clear_has_type_ext() {
  _impl_._oneof_case_[0] = TYPE_EXT_NOT_SET;
}
inline ColumnDataTypeExtension::TypeExtCase ColumnDataTypeExtension::type_ext_case() const {
  return ColumnDataTypeExtension::TypeExtCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DecimalTypeExtension

// int32 precision = 1;
inline void DecimalTypeExtension::clear_precision() {
  _impl_.precision_ = 0;
}
inline int32_t DecimalTypeExtension::_internal_precision() const {
  return _impl_.precision_;
}
inline int32_t DecimalTypeExtension::precision() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DecimalTypeExtension.precision)
  return _internal_precision();
}
inline void DecimalTypeExtension::_internal_set_precision(int32_t value) {
  
  _impl_.precision_ = value;
}
inline void DecimalTypeExtension::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DecimalTypeExtension.precision)
}

// int32 scale = 2;
inline void DecimalTypeExtension::clear_scale() {
  _impl_.scale_ = 0;
}
inline int32_t DecimalTypeExtension::_internal_scale() const {
  return _impl_.scale_;
}
inline int32_t DecimalTypeExtension::scale() const {
  // @@protoc_insertion_point(field_get:greptime.v1.DecimalTypeExtension.scale)
  return _internal_scale();
}
inline void DecimalTypeExtension::_internal_set_scale(int32_t value) {
  
  _impl_.scale_ = value;
}
inline void DecimalTypeExtension::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:greptime.v1.DecimalTypeExtension.scale)
}

// -------------------------------------------------------------------

// VectorTypeExtension

// uint32 dim = 1;
inline void VectorTypeExtension::clear_dim() {
  _impl_.dim_ = 0u;
}
inline uint32_t VectorTypeExtension::_internal_dim() const {
  return _impl_.dim_;
}
inline uint32_t VectorTypeExtension::dim() const {
  // @@protoc_insertion_point(field_get:greptime.v1.VectorTypeExtension.dim)
  return _internal_dim();
}
inline void VectorTypeExtension::_internal_set_dim(uint32_t value) {
  
  _impl_.dim_ = value;
}
inline void VectorTypeExtension::set_dim(uint32_t value) {
  _internal_set_dim(value);
  // @@protoc_insertion_point(field_set:greptime.v1.VectorTypeExtension.dim)
}

// -------------------------------------------------------------------

// ListTypeExtension

// .greptime.v1.ColumnDataType datatype = 1;
inline void ListTypeExtension::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::greptime::v1::ColumnDataType ListTypeExtension::_internal_datatype() const {
  return static_cast< ::greptime::v1::ColumnDataType >(_impl_.datatype_);
}
inline ::greptime::v1::ColumnDataType ListTypeExtension::datatype() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ListTypeExtension.datatype)
  return _internal_datatype();
}
inline void ListTypeExtension::_internal_set_datatype(::greptime::v1::ColumnDataType value) {
  
  _impl_.datatype_ = value;
}
inline void ListTypeExtension::set_datatype(::greptime::v1::ColumnDataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:greptime.v1.ListTypeExtension.datatype)
}

// .greptime.v1.ColumnDataTypeExtension datatype_extension = 2;
inline bool ListTypeExtension::_internal_has_datatype_extension() const {
  return this != internal_default_instance() && _impl_.datatype_extension_ != nullptr;
}
inline bool ListTypeExtension::has_datatype_extension() const {
  return _internal_has_datatype_extension();
}
inline void ListTypeExtension::clear_datatype_extension() {
  if (GetArenaForAllocation() == nullptr && _impl_.datatype_extension_ != nullptr) {
    delete _impl_.datatype_extension_;
  }
  _impl_.datatype_extension_ = nullptr;
}
inline const ::greptime::v1::ColumnDataTypeExtension& ListTypeExtension::_internal_datatype_extension() const {
  const ::greptime::v1::ColumnDataTypeExtension* p = _impl_.datatype_extension_;
  return p != nullptr ? *p : reinterpret_cast<const ::greptime::v1::ColumnDataTypeExtension&>(
      ::greptime::v1::_ColumnDataTypeExtension_default_instance_);
}
inline const ::greptime::v1::ColumnDataTypeExtension& ListTypeExtension::datatype_extension() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ListTypeExtension.datatype_extension)
  return _internal_datatype_extension();
}
inline void ListTypeExtension::unsafe_arena_set_allocated_datatype_extension(
    ::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_extension_);
  }
  _impl_.datatype_extension_ = datatype_extension;
  if (datatype_extension) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:greptime.v1.ListTypeExtension.datatype_extension)
}
inline ::greptime::v1::ColumnDataTypeExtension* ListTypeExtension::release_datatype_extension() {
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ListTypeExtension::unsafe_arena_release_datatype_extension() {
  // @@protoc_insertion_point(field_release:greptime.v1.ListTypeExtension.datatype_extension)
  
  ::greptime::v1::ColumnDataTypeExtension* temp = _impl_.datatype_extension_;
  _impl_.datatype_extension_ = nullptr;
  return temp;
}
inline ::greptime::v1::ColumnDataTypeExtension* ListTypeExtension::_internal_mutable_datatype_extension() {
  
  if (_impl_.datatype_extension_ == nullptr) {
    auto* p = CreateMaybeMessage<::greptime::v1::ColumnDataTypeExtension>(GetArenaForAllocation());
    _impl_.datatype_extension_ = p;
  }
  return _impl_.datatype_extension_;
}
inline ::greptime::v1::ColumnDataTypeExtension* ListTypeExtension::mutable_datatype_extension() {
  ::greptime::v1::ColumnDataTypeExtension* _msg = _internal_mutable_datatype_extension();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ListTypeExtension.datatype_extension)
  return _msg;
}
inline void ListTypeExtension::set_allocated_datatype_extension(::greptime::v1::ColumnDataTypeExtension* datatype_extension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.datatype_extension_;
  }
  if (datatype_extension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datatype_extension);
    if (message_arena != submessage_arena) {
      datatype_extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datatype_extension, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.datatype_extension_ = datatype_extension;
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ListTypeExtension.datatype_extension)
}

// -------------------------------------------------------------------

// StructTypeExtension

// repeated .greptime.v1.StructField fields = 1;
inline int StructTypeExtension::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int StructTypeExtension::fields_size() const {
  return _internal_fields_size();
}
inline void StructTypeExtension::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::greptime::v1::StructField* StructTypeExtension::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:greptime.v1.StructTypeExtension.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::StructField >*
StructTypeExtension::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:greptime.v1.StructTypeExtension.fields)
  return &_impl_.fields_;
}
inline const ::greptime::v1::StructField& StructTypeExtension::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::greptime::v1::StructField& StructTypeExtension::fields(int index) const {
  // @@protoc_insertion_point(field_get:greptime.v1.StructTypeExtension.fields)
  return _internal_fields(index);
}
inline ::greptime::v1::StructField* StructTypeExtension::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::greptime::v1::StructField* StructTypeExtension::add_fields() {
  ::greptime::v1::StructField* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:greptime.v1.StructTypeExtension.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::greptime::v1::StructField >&
StructTypeExtension::fields() const {
  // @@protoc_insertion_point(field_list:greptime.v1.StructTypeExtension.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ColumnOptions

// map<string, string> options = 1;
inline int ColumnOptions::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int ColumnOptions::options_size() const {
  return _internal_options_size();
}
inline void ColumnOptions::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ColumnOptions::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ColumnOptions::options() const {
  // @@protoc_insertion_point(field_map:greptime.v1.ColumnOptions.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ColumnOptions::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ColumnOptions::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:greptime.v1.ColumnOptions.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// ArrowIpc

// bytes schema = 1;
inline void ArrowIpc::clear_schema() {
  _impl_.schema_.ClearToEmpty();
}
inline const std::string& ArrowIpc::schema() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ArrowIpc.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArrowIpc::set_schema(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ArrowIpc.schema)
}
inline std::string* ArrowIpc::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ArrowIpc.schema)
  return _s;
}
inline const std::string& ArrowIpc::_internal_schema() const {
  return _impl_.schema_.Get();
}
inline void ArrowIpc::_internal_set_schema(const std::string& value) {
  
  _impl_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* ArrowIpc::_internal_mutable_schema() {
  
  return _impl_.schema_.Mutable(GetArenaForAllocation());
}
inline std::string* ArrowIpc::release_schema() {
  // @@protoc_insertion_point(field_release:greptime.v1.ArrowIpc.schema)
  return _impl_.schema_.Release();
}
inline void ArrowIpc::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  _impl_.schema_.SetAllocated(schema, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_.IsDefault()) {
    _impl_.schema_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ArrowIpc.schema)
}

// bytes data_header = 2;
inline void ArrowIpc::clear_data_header() {
  _impl_.data_header_.ClearToEmpty();
}
inline const std::string& ArrowIpc::data_header() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ArrowIpc.data_header)
  return _internal_data_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArrowIpc::set_data_header(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_header_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ArrowIpc.data_header)
}
inline std::string* ArrowIpc::mutable_data_header() {
  std::string* _s = _internal_mutable_data_header();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ArrowIpc.data_header)
  return _s;
}
inline const std::string& ArrowIpc::_internal_data_header() const {
  return _impl_.data_header_.Get();
}
inline void ArrowIpc::_internal_set_data_header(const std::string& value) {
  
  _impl_.data_header_.Set(value, GetArenaForAllocation());
}
inline std::string* ArrowIpc::_internal_mutable_data_header() {
  
  return _impl_.data_header_.Mutable(GetArenaForAllocation());
}
inline std::string* ArrowIpc::release_data_header() {
  // @@protoc_insertion_point(field_release:greptime.v1.ArrowIpc.data_header)
  return _impl_.data_header_.Release();
}
inline void ArrowIpc::set_allocated_data_header(std::string* data_header) {
  if (data_header != nullptr) {
    
  } else {
    
  }
  _impl_.data_header_.SetAllocated(data_header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_header_.IsDefault()) {
    _impl_.data_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ArrowIpc.data_header)
}

// bytes payload = 3;
inline void ArrowIpc::clear_payload() {
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& ArrowIpc::payload() const {
  // @@protoc_insertion_point(field_get:greptime.v1.ArrowIpc.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArrowIpc::set_payload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:greptime.v1.ArrowIpc.payload)
}
inline std::string* ArrowIpc::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:greptime.v1.ArrowIpc.payload)
  return _s;
}
inline const std::string& ArrowIpc::_internal_payload() const {
  return _impl_.payload_.Get();
}
inline void ArrowIpc::_internal_set_payload(const std::string& value) {
  
  _impl_.payload_.Set(value, GetArenaForAllocation());
}
inline std::string* ArrowIpc::_internal_mutable_payload() {
  
  return _impl_.payload_.Mutable(GetArenaForAllocation());
}
inline std::string* ArrowIpc::release_payload() {
  // @@protoc_insertion_point(field_release:greptime.v1.ArrowIpc.payload)
  return _impl_.payload_.Release();
}
inline void ArrowIpc::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  _impl_.payload_.SetAllocated(payload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_.IsDefault()) {
    _impl_.payload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:greptime.v1.ArrowIpc.payload)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace greptime

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::greptime::v1::SemanticType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::SemanticType>() {
  return ::greptime::v1::SemanticType_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::ColumnDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::ColumnDataType>() {
  return ::greptime::v1::ColumnDataType_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::TimeUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::TimeUnit>() {
  return ::greptime::v1::TimeUnit_descriptor();
}
template <> struct is_proto_enum< ::greptime::v1::JsonTypeExtension> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::greptime::v1::JsonTypeExtension>() {
  return ::greptime::v1::JsonTypeExtension_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_greptime_2fv1_2fcommon_2eproto
